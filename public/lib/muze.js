var Fc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fw(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Iw = "Expected a function", um = NaN, dF = "[object Symbol]", uF = /^\s+|\s+$/g, fF = /^[-+]0x[0-9a-f]+$/i, IF = /^0b[01]+$/i, CF = /^0o[0-7]+$/i, EF = parseInt, BF = typeof Fc == "object" && Fc && Fc.Object === Object && Fc, mF = typeof self == "object" && self && self.Object === Object && self, pF = BF || mF || Function("return this")(), QF = Object.prototype, yF = QF.toString, wF = Math.max, DF = Math.min, Ru = function() {
  return pF.Date.now();
};
function xF(e, t, i) {
  var n, s, A, o, a, r, l = 0, c = !1, g = !1, h = !0;
  if (typeof e != "function")
    throw new TypeError(Iw);
  t = fm(t) || 0, Xg(i) && (c = !!i.leading, g = "maxWait" in i, A = g ? wF(fm(i.maxWait) || 0, t) : A, h = "trailing" in i ? !!i.trailing : h);
  function d(w) {
    var Q = n, y = s;
    return n = s = void 0, l = w, o = e.apply(y, Q), o;
  }
  function u(w) {
    return l = w, a = setTimeout(I, t), c ? d(w) : o;
  }
  function f(w) {
    var Q = w - r, y = w - l, D = t - Q;
    return g ? DF(D, A - y) : D;
  }
  function C(w) {
    var Q = w - r, y = w - l;
    return r === void 0 || Q >= t || Q < 0 || g && y >= A;
  }
  function I() {
    var w = Ru();
    if (C(w))
      return E(w);
    a = setTimeout(I, f(w));
  }
  function E(w) {
    return a = void 0, h && n ? d(w) : (n = s = void 0, o);
  }
  function B() {
    a !== void 0 && clearTimeout(a), l = 0, n = r = s = a = void 0;
  }
  function m() {
    return a === void 0 ? o : E(Ru());
  }
  function p() {
    var w = Ru(), Q = C(w);
    if (n = arguments, s = this, r = w, Q) {
      if (a === void 0)
        return u(r);
      if (g)
        return a = setTimeout(I, t), d(r);
    }
    return a === void 0 && (a = setTimeout(I, t)), o;
  }
  return p.cancel = B, p.flush = m, p;
}
function SF(e, t, i) {
  var n = !0, s = !0;
  if (typeof e != "function")
    throw new TypeError(Iw);
  return Xg(i) && (n = "leading" in i ? !!i.leading : n, s = "trailing" in i ? !!i.trailing : s), xF(e, t, {
    leading: n,
    maxWait: t,
    trailing: s
  });
}
function Xg(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function _F(e) {
  return !!e && typeof e == "object";
}
function bF(e) {
  return typeof e == "symbol" || _F(e) && yF.call(e) == dF;
}
function fm(e) {
  if (typeof e == "number")
    return e;
  if (bF(e))
    return um;
  if (Xg(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Xg(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(uF, "");
  var i = IF.test(e);
  return i || CF.test(e) ? EF(e.slice(2), i ? 2 : 8) : fF.test(e) ? um : +e;
}
var MF = SF;
const Gf = /* @__PURE__ */ fw(MF);
var Xn;
(function(e) {
  e.FLAT_JSON = "FlatJSON", e.DSV_STR = "DSVStr", e.DSV_ARR = "DSVArr", e.AUTO = "Auto";
})(Xn || (Xn = {}));
function He(e) {
  return e instanceof Date ? e : new Date(e);
}
function Rc(e) {
  return e < 10 ? `0${e}` : e;
}
RegExp.escape = function(e) {
  return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
};
function Nt(e) {
  this.format = e, this.dtParams = void 0, this.nativeDate = void 0;
}
Nt.TOKEN_PREFIX = "%";
Nt.DATETIME_PARAM_SEQUENCE = {
  YEAR: 0,
  MONTH: 1,
  DAY: 2,
  HOUR: 3,
  MINUTE: 4,
  SECOND: 5,
  MILLISECOND: 6
};
Nt.defaultNumberParser = function(e) {
  return function(t) {
    let i;
    return isFinite(i = parseInt(t, 10)) ? i : e;
  };
};
Nt.defaultRangeParser = function(e, t) {
  return (i) => {
    let n, s;
    if (!i)
      return t;
    const A = i.toLowerCase();
    for (n = 0, s = e.length; n < s; n++)
      if (e[n].toLowerCase() === A)
        return n;
    return n === void 0 ? t : null;
  };
};
Nt.getTokenDefinitions = function() {
  const e = {
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  }, t = {
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    long: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  return {
    H: {
      // 24 hours format
      name: "H",
      index: 3,
      extract() {
        return "(\\d+)";
      },
      parser: Nt.defaultNumberParser(),
      formatter(n, s) {
        const A = He(n);
        return s ? A.getUTCHours().toString() : A.getHours().toString();
      }
    },
    l: {
      // 12 hours format
      name: "l",
      index: 3,
      extract() {
        return "(\\d+)";
      },
      parser: Nt.defaultNumberParser(),
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCHours() % 12 : A.getHours() % 12;
        return (o === 0 ? 12 : o).toString();
      }
    },
    p: {
      // AM or PM
      name: "p",
      index: 3,
      extract() {
        return "(AM|PM)";
      },
      parser: (n) => n ? n.toLowerCase() : null,
      formatter: (n, s) => {
        const A = He(n);
        return (s ? A.getUTCHours() : A.getHours()) < 12 ? "AM" : "PM";
      }
    },
    P: {
      // am or pm
      name: "P",
      index: 3,
      extract() {
        return "(am|pm)";
      },
      parser: (n) => n ? n.toLowerCase() : null,
      formatter: (n, s) => {
        const A = He(n);
        return (s ? A.getUTCHours() : A.getHours()) < 12 ? "am" : "pm";
      }
    },
    M: {
      // Two digit minutes 00 - 59
      name: "M",
      index: 4,
      extract() {
        return "(\\d+)";
      },
      parser: Nt.defaultNumberParser(),
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCMinutes() : A.getMinutes();
        return Rc(o);
      }
    },
    S: {
      // Two digit seconds 00 - 59
      name: "S",
      index: 5,
      extract() {
        return "(\\d+)";
      },
      parser: Nt.defaultNumberParser(),
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCSeconds() : A.getSeconds();
        return Rc(o);
      }
    },
    K: {
      // Milliseconds
      name: "K",
      index: 6,
      extract() {
        return "(\\d+)";
      },
      parser: Nt.defaultNumberParser(),
      formatter(n) {
        return He(n).getMilliseconds().toString();
      }
    },
    a: {
      // Short name of day, like Mon
      name: "a",
      index: 2,
      extract() {
        return `(${e.short.join("|")})`;
      },
      parser: Nt.defaultRangeParser(e.short),
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCDay() : A.getDay();
        return e.short[o].toString();
      }
    },
    A: {
      // Long name of day, like Monday
      name: "A",
      index: 2,
      extract() {
        return `(${e.long.join("|")})`;
      },
      parser: Nt.defaultRangeParser(e.long),
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCDay() : A.getDay();
        return e.long[o].toString();
      }
    },
    e: {
      // 8 of March, 11 of November
      name: "e",
      index: 2,
      extract() {
        return `(\\d+) of (${t.long.join("|")})`;
      },
      parser: Nt.defaultNumberParser(),
      formatter(n, s) {
        const A = He(n);
        return (s ? A.getUTCDate() : A.getDate()).toString();
      }
    },
    d: {
      // 08 of March, 11 of November, 8 of March
      name: "d",
      index: 2,
      extract() {
        return "(\\d+)";
      },
      parser: Nt.defaultNumberParser(),
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCDate() : A.getDate();
        return Rc(o);
      }
    },
    b: {
      // Short month, like Jan
      name: "b",
      index: 1,
      extract() {
        return `(${t.short.join("|")})`;
      },
      parser: Nt.defaultRangeParser(t.short),
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCMonth() : A.getMonth();
        return t.short[o].toString();
      }
    },
    B: {
      // Long month, like January
      name: "B",
      index: 1,
      extract() {
        return `(${t.long.join("|")})`;
      },
      parser: Nt.defaultRangeParser(t.long),
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCMonth() : A.getMonth();
        return t.long[o].toString();
      }
    },
    m: {
      // Two digit month of year like 01 for January
      name: "m",
      index: 1,
      extract() {
        return "(\\d+)";
      },
      parser(n) {
        return Nt.defaultNumberParser()(n) - 1;
      },
      formatter(n, s) {
        const A = He(n), o = s ? A.getUTCMonth() : A.getMonth();
        return Rc(o + 1);
      }
    },
    y: {
      // Short year like 90 for 1990
      name: "y",
      index: 0,
      extract() {
        return "(\\d{2})";
      },
      parser(n) {
        let s;
        if (n) {
          const r = n.length;
          n = n.substring(r - 2, r);
        }
        const A = Nt.defaultNumberParser()(n), o = /* @__PURE__ */ new Date(), a = Math.trunc(o.getFullYear() / 100);
        return s = `${a}${A}`, He(s).getFullYear() > o.getFullYear() && (s = `${a - 1}${A}`), He(s).getFullYear();
      },
      formatter(n, s) {
        const A = He(n);
        let o = s ? A.getUTCFullYear().toString() : A.getFullYear().toString(), a;
        return o && (a = o.length, o = o.substring(a - 2, a)), o;
      }
    },
    Y: {
      // Long year like 1990
      name: "Y",
      index: 0,
      extract() {
        return "(\\d{4})";
      },
      parser: Nt.defaultNumberParser(),
      formatter(n, s) {
        const A = He(n);
        return s ? A.getUTCFullYear().toString() : A.getFullYear().toString();
      }
    }
  };
};
Nt.getTokenFormalNames = function() {
  const e = Nt.getTokenDefinitions();
  return {
    HOUR: e.H,
    HOUR_12: e.l,
    AMPM_UPPERCASE: e.p,
    AMPM_LOWERCASE: e.P,
    MINUTE: e.M,
    SECOND: e.S,
    SHORT_DAY: e.a,
    LONG_DAY: e.A,
    DAY_OF_MONTH: e.e,
    DAY_OF_MONTH_CONSTANT_WIDTH: e.d,
    SHORT_MONTH: e.b,
    LONG_MONTH: e.B,
    MONTH_OF_YEAR: e.m,
    SHORT_YEAR: e.y,
    LONG_YEAR: e.Y
  };
};
Nt.tokenResolver = function() {
  const e = Nt.getTokenDefinitions(), t = (...i) => {
    let n = 0, s, A;
    const o = i.length;
    for (; n < o; n++)
      s = i[n], i[n] && (A = s);
    return A ? A[0].parser(A[1]) : null;
  };
  return {
    YEAR: [e.y, e.Y, t],
    MONTH: [e.b, e.B, e.m, t],
    DAY: [e.a, e.A, e.d, t],
    HOUR: [
      e.H,
      e.l,
      e.p,
      e.P,
      function(i, n, s, A) {
        let o, a, r, l;
        return n && (a = s || A) ? (a[0].parser(a[1]) === "pm" && (r = !0), o = n) : n ? o = n : o = i, o ? (l = o[0].parser(o[1]), r && (l += 12), l) : null;
      }
    ],
    MINUTE: [e.M, t],
    SECOND: [e.S, t],
    MILLISECOND: [e.K, t]
  };
};
Nt.findTokens = function(e) {
  const t = Nt.TOKEN_PREFIX, i = Nt.getTokenDefinitions(), n = Object.keys(i), s = [];
  let A, o;
  for (; (A = e.indexOf(t, A + 1)) >= 0; )
    o = e[A + 1], n.indexOf(o) !== -1 && s.push({
      index: A,
      token: o
    });
  return s;
};
Nt.formatAs = function(e, t, i = {}) {
  const n = He(e), s = Nt.findTokens(t), A = Nt.getTokenDefinitions();
  let o = String(t);
  const a = Nt.TOKEN_PREFIX;
  let r, l, c, g;
  for (c = 0, g = s.length; c < g; c++)
    r = s[c].token, l = A[r].formatter(n, i.useUTC), o = o.replace(new RegExp(a + r, "g"), l);
  return o;
};
Nt.prototype.parse = function(e, t) {
  const i = Nt.tokenResolver(), n = this.extractTokenValue(e), s = Nt.DATETIME_PARAM_SEQUENCE, A = t && t.noBreak, o = [], a = [];
  let r, l, c, g, h, d, u, f;
  const C = [];
  for (r in i)
    if ({}.hasOwnProperty.call(i, r)) {
      for (a.length = 0, l = i[r], c = l.splice(l.length - 1, 1)[0], h = 0, f = l.length; h < f; h++)
        d = l[h], g = n[d.name], g === void 0 ? a.push(null) : a.push([d, g]);
      if (u = c.apply(this, a), u == null && !A)
        break;
      o[s[r]] = u;
    }
  return o.length && this.checkIfOnlyYear(o.length) ? C.unshift(o[0], 0, 1) : C.unshift(...o), C;
};
Nt.prototype.extractTokenValue = function(e) {
  const t = this.format, i = Nt.getTokenDefinitions(), n = Nt.TOKEN_PREFIX, s = Nt.findTokens(t), A = {};
  let o, a, r, l, c, g, h;
  c = String(t);
  const d = s.map((C) => C.token), u = s.length;
  for (h = u - 1; h >= 0; h--) {
    if (r = s[h].index, r + 1 === c.length - 1) {
      o = r;
      continue;
    }
    o === void 0 && (o = c.length), l = c.substring(r + 2, o), c = c.substring(0, r + 2) + RegExp.escape(l) + c.substring(o, c.length), o = r;
  }
  for (h = 0; h < u; h++)
    a = s[h], c = c.replace(n + a.token, i[a.token].extract());
  const f = e?.match(new RegExp(c)) || [];
  for (f.shift(), h = 0, g = d.length; h < g; h++)
    A[d[h]] = f[h];
  return A;
};
Nt.prototype.getNativeDate = function(e) {
  let t = null, i = !this.format || typeof this.format != "string";
  if (Number.isFinite(e) && i)
    t = new Date(e);
  else if (i)
    t = new Date(e);
  else {
    const n = this.dtParams = this.parse(e);
    n.length && (this.nativeDate = new Date(...n), t = this.nativeDate);
  }
  return t;
};
Nt.prototype.checkIfOnlyYear = function(e) {
  return e === 1 && this.format.match(/y|Y/g).length;
};
const Cw = (e) => {
  let t = 0;
  return (...i) => {
    i.forEach((n, s) => {
      e[s] instanceof Array || (e[s] = Array.from({ length: t })), e[s].push(n);
    }), t++;
  };
};
function ku(e) {
  return Array.isArray(e);
}
function NF(e) {
  return e === Object(e);
}
function FF(e) {
  return typeof e == "string";
}
const RF = (e) => FF(e) ? Xn.DSV_STR : ku(e) && ku(e[0]) ? Xn.DSV_ARR : ku(e) && (e.length === 0 || NF(e[0])) ? Xn.FLAT_JSON : null;
var cA = /* @__PURE__ */ new Map(), kF = function(e) {
  if (e == null || e === "")
    throw new Error("Please give a promise id");
  if (cA.has(e))
    throw new Error("A promise with " + e + " id already exists, please destroy or resolve or reject it first");
  return new Promise(function(t, i) {
    cA.set(e, {
      doResolve: t,
      doReject: i
    });
  });
}, vF = function(e, t) {
  if (cA.has(e)) {
    var i = cA.get(e), n = i.doResolve, s = i.doReject;
    cA.delete(e), Promise.resolve(t).then(function(A) {
      n(A);
    }).catch(function(A) {
      s(A);
    });
  }
}, TF = function(e, t) {
  if (cA.has(e)) {
    var i = cA.get(e).doReject;
    cA.delete(e), i(t);
  }
};
let kc;
const GF = new Uint8Array(16);
function LF() {
  if (!kc && (kc = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !kc))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return kc(GF);
}
const si = [];
for (let e = 0; e < 256; ++e)
  si.push((e + 256).toString(16).slice(1));
function UF(e, t = 0) {
  return si[e[t + 0]] + si[e[t + 1]] + si[e[t + 2]] + si[e[t + 3]] + "-" + si[e[t + 4]] + si[e[t + 5]] + "-" + si[e[t + 6]] + si[e[t + 7]] + "-" + si[e[t + 8]] + si[e[t + 9]] + "-" + si[e[t + 10]] + si[e[t + 11]] + si[e[t + 12]] + si[e[t + 13]] + si[e[t + 14]] + si[e[t + 15]];
}
const HF = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Im = {
  randomUUID: HF
};
function OF(e, t, i) {
  if (Im.randomUUID && !e)
    return Im.randomUUID();
  e = e || {};
  const n = e.random || (e.rng || LF)();
  return n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, UF(n);
}
const PF = 64, YF = (e) => e.isFree, JF = (e) => {
  const t = () => e.find(YF), i = () => {
    const s = t();
    return new Promise((A) => {
      if (s == null) {
        const o = setInterval(() => {
          const a = t();
          a != null && (a.isFree = !1, clearInterval(o), A(a));
        }, PF);
      } else
        s.isFree = !1, A(s);
    });
  };
  return (s) => {
    const A = OF(), o = kF(A);
    return i().then((a) => {
      const { worker: r } = a;
      r.addEventListener("message", (l) => {
        const { reqId: c, data: g } = l.data;
        a.isFree = !0, g.error ? TF(c, new Error(g.error)) : vF(c, g.data);
      }), r.postMessage({
        data: s,
        reqId: A,
        type: "transform-data"
      });
    }), o;
  };
}, KF = (e, t) => JF(t)(e);
var Cm = {}, vu = {}, Tu = 34, mr = 10, Gu = 13;
function Ew(e) {
  return new Function("d", "return {" + e.map(function(t, i) {
    return JSON.stringify(t) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function VF(e, t) {
  var i = Ew(e);
  return function(n, s) {
    return t(i(n), s, e);
  };
}
function Em(e) {
  var t = /* @__PURE__ */ Object.create(null), i = [];
  return e.forEach(function(n) {
    for (var s in n)
      s in t || i.push(t[s] = s);
  }), i;
}
function Ti(e, t) {
  var i = e + "", n = i.length;
  return n < t ? new Array(t - n + 1).join(0) + i : i;
}
function WF(e) {
  return e < 0 ? "-" + Ti(-e, 6) : e > 9999 ? "+" + Ti(e, 6) : Ti(e, 4);
}
function qF(e) {
  var t = e.getUTCHours(), i = e.getUTCMinutes(), n = e.getUTCSeconds(), s = e.getUTCMilliseconds();
  return isNaN(e) ? "Invalid Date" : WF(e.getUTCFullYear()) + "-" + Ti(e.getUTCMonth() + 1, 2) + "-" + Ti(e.getUTCDate(), 2) + (s ? "T" + Ti(t, 2) + ":" + Ti(i, 2) + ":" + Ti(n, 2) + "." + Ti(s, 3) + "Z" : n ? "T" + Ti(t, 2) + ":" + Ti(i, 2) + ":" + Ti(n, 2) + "Z" : i || t ? "T" + Ti(t, 2) + ":" + Ti(i, 2) + "Z" : "");
}
function jF(e) {
  var t = new RegExp('["' + e + `
\r]`), i = e.charCodeAt(0);
  function n(g, h) {
    var d, u, f = s(g, function(C, I) {
      if (d) return d(C, I - 1);
      u = C, d = h ? VF(C, h) : Ew(C);
    });
    return f.columns = u || [], f;
  }
  function s(g, h) {
    var d = [], u = g.length, f = 0, C = 0, I, E = u <= 0, B = !1;
    g.charCodeAt(u - 1) === mr && --u, g.charCodeAt(u - 1) === Gu && --u;
    function m() {
      if (E) return vu;
      if (B) return B = !1, Cm;
      var w, Q = f, y;
      if (g.charCodeAt(Q) === Tu) {
        for (; f++ < u && g.charCodeAt(f) !== Tu || g.charCodeAt(++f) === Tu; ) ;
        return (w = f) >= u ? E = !0 : (y = g.charCodeAt(f++)) === mr ? B = !0 : y === Gu && (B = !0, g.charCodeAt(f) === mr && ++f), g.slice(Q + 1, w - 1).replace(/""/g, '"');
      }
      for (; f < u; ) {
        if ((y = g.charCodeAt(w = f++)) === mr) B = !0;
        else if (y === Gu)
          B = !0, g.charCodeAt(f) === mr && ++f;
        else if (y !== i) continue;
        return g.slice(Q, w);
      }
      return E = !0, g.slice(Q, u);
    }
    for (; (I = m()) !== vu; ) {
      for (var p = []; I !== Cm && I !== vu; ) p.push(I), I = m();
      h && (p = h(p, C++)) == null || d.push(p);
    }
    return d;
  }
  function A(g, h) {
    return g.map(function(d) {
      return h.map(function(u) {
        return c(d[u]);
      }).join(e);
    });
  }
  function o(g, h) {
    return h == null && (h = Em(g)), [h.map(c).join(e)].concat(A(g, h)).join(`
`);
  }
  function a(g, h) {
    return h == null && (h = Em(g)), A(g, h).join(`
`);
  }
  function r(g) {
    return g.map(l).join(`
`);
  }
  function l(g) {
    return g.map(c).join(e);
  }
  function c(g) {
    return g == null ? "" : g instanceof Date ? qF(g) : t.test(g += "") ? '"' + g.replace(/"/g, '""') + '"' : g;
  }
  return {
    parse: n,
    parseRows: s,
    format: o,
    formatBody: a,
    formatRows: r,
    formatRow: l,
    formatValue: c
  };
}
var Ct;
(function(e) {
  e.MEASURE = "measure", e.DIMENSION = "dimension";
})(Ct || (Ct = {}));
var ot;
(function(e) {
  e.CATEGORICAL = "categorical", e.TEMPORAL = "temporal", e.BINNED = "binned", e.CONTINUOUS = "continuous", e.ROWID = "__id";
})(ot || (ot = {}));
const Lf = "__id__", zF = (e) => e === Ct.MEASURE ? 1 : 0, $F = {
  categorical: 0,
  continuous: 1,
  temporal: 2,
  __id: 3,
  binned: 4
}, XF = (e) => $F[e], ZF = (e) => e === Ct.MEASURE ? ot.CONTINUOUS : ot.CATEGORICAL;
class tR {
  constructor() {
    this._type = ot.CATEGORICAL;
  }
  get type() {
    return this._type;
  }
  /**
   * Parses a single value to string if not already in string format
   *
   * @public
   * @param {string|number} val - The value of the field.
   * @return {string} Returns the string representation of the value.
   */
  parse(t) {
    return typeof t == "number" ? String(t) : t;
  }
}
const Bw = (e) => !e && e !== 0 ? NaN : (typeof e == "string" && e.includes(",") && (e = e.replace(/,/g, "")), Number(e));
class eR {
  constructor() {
    this._type = ot.CONTINUOUS;
  }
  get type() {
    return this._type;
  }
  /*
   * Parses a single value to number if not already in number format
   *
   * @public
   * @param {string|number} val - The value of the field.
   * @return {number} Returns the number representation of the value.
   */
  parse(t) {
    return Bw(t);
  }
}
var ne;
(function(e) {
  e.SELECT = "select", e.GROUPBY = "groupBy", e.PROJECT = "project", e.SPLIT = "split", e.SORT = "sort", e.CALCULATE = "calculate_variable";
})(ne || (ne = {}));
const iR = "default", nR = "b29153703d1b02bf5f662b2a10f00c2af68d728fa52fd3af777cd6f7c3b59b7e";
class sR {
  constructor() {
    this._type = ot.TEMPORAL;
  }
  get type() {
    return this._type;
  }
  /**
   * Parses a single value of a field and returns the millisecond value.
   *
   * @public
   * @param {string|number} val - The value of the field.
   * @return {number} Returns the millisecond value.
   */
  parse(t, i) {
    let n = iR;
    if (this._dtf = {}, !t && typeof t != "number")
      return NaN;
    let s = t;
    i && typeof i == "string" ? (s = String(t), n = i, (!this._dtf || !this._dtf[n]) && (this._dtf[n] = new Nt(n))) : (s = Number(t), (!this._dtf || !this._dtf.default) && (this._dtf.default = new Nt()));
    const A = this._dtf[n].getNativeDate(s);
    return A ? A.getTime() : NaN;
  }
}
class AR {
  constructor() {
    this._type = ot.BINNED;
  }
  get type() {
    return this._type;
  }
  /*
   * Parses a single value to number if not already in number format
   *
   * @public
   * @param {string|number} val - The value of the field.
   * @return {number} Returns the number representation of the value.
   */
  parse(t) {
    return Bw(t);
  }
}
class oR {
  constructor() {
    this.store = /* @__PURE__ */ new Map(), this.parsers(this._getDefaultParsers());
  }
  _getDefaultParsers() {
    return [new tR(), new eR(), new sR(), new AR()];
  }
  /**
   * Sets the given parsers in the store and returns the store
   * @param  {Array<FieldContract>} parsers : contains array of parsers instance
   * @return {Map<string, FieldContract>}
   */
  parsers(t) {
    return t.forEach((i) => this.register(i)), this.store;
  }
  /**
   * Registers a parsers
   * @param {DataConverter} parser : parser Instance
   */
  register(t) {
    return this.store.set(t._type, t), this;
  }
  /**
   * Removes a parser from store
   * @param {FieldContract} parser : parser Instance
   */
  unregister(t) {
    return this.store.delete(t._type), this;
  }
  get(t) {
    return t && this.store.has(t) ? this.store.get(t) : null;
  }
}
const oa = (() => {
  let e = null;
  function t() {
    return e = new oR(), e;
  }
  return e || t();
})();
function QC(e, t, i) {
  if (!Array.isArray(t))
    throw new Error("Schema missing or is in an unsupported format");
  const n = {
    firstRowHeader: !0
  }, s = t.map((l) => l.name);
  i = Object.assign({}, n, i);
  const A = [[]], o = Cw(A);
  let a = s;
  i.firstRowHeader && (a = e.splice(0, 1)[0]);
  const r = a.reduce((l, c, g) => (Object.assign(l, { [c]: g }), l), {});
  return e.forEach((l) => {
    const c = [];
    return t.forEach((g) => {
      const { name: h, type: d, format: u = (B) => B } = g;
      let { subtype: f = ot.CATEGORICAL } = g;
      d === Ct.MEASURE && (f = ot.CONTINUOUS);
      const C = oa.get(f), I = r[h], E = C ? C.parse(l[I], u) : l[I];
      c.push(E);
    }), o(...c);
  }), {
    data: A,
    schema: t
  };
}
function mw(e, t, i) {
  if (i = Object.assign({}, {
    firstRowHeader: !0,
    fieldSeparator: ","
  }, i), i.fieldSeparator) {
    const s = jF(i.fieldSeparator);
    return QC(s.parseRows(e), t, i);
  }
  return { schema: [], data: [] };
}
class aR {
  constructor() {
    this._type = Xn.DSV_STR;
  }
  get type() {
    return this._type;
  }
  convert(t, i, n) {
    return mw(t, i, n);
  }
}
function pw(e, t) {
  if (!Array.isArray(t))
    throw new Error("Schema missing or is in an unsupported format");
  const i = {};
  let n = 0, s;
  const A = [[]], o = Cw(A);
  return e.forEach((a) => {
    const r = [];
    t.forEach((l) => {
      const { name: c, type: g, format: h = (C) => C } = l;
      let { subtype: d = ot.CATEGORICAL } = l;
      g === Ct.MEASURE && (d = ot.CONTINUOUS);
      const u = oa.get(d);
      c in i ? s = i[c] : (i[c] = n++, s = n - 1);
      const f = u ? u.parse(a[c], h) : a[c];
      r[s] = f;
    }), o(...r);
  }), {
    data: A,
    schema: t
  };
}
class rR {
  constructor() {
    this._type = Xn.FLAT_JSON;
  }
  get type() {
    return this._type;
  }
  convert(t, i) {
    return pw(t, i);
  }
}
class lR {
  constructor() {
    this._type = Xn.DSV_ARR;
  }
  get type() {
    return this._type;
  }
  convert(t, i, n) {
    return QC(t, i, n);
  }
}
function cR(e, t, i) {
  const n = { FlatJSON: pw, DSVStr: mw, DSVArr: QC }, s = RF(e);
  if (!s)
    throw new Error("Could not detect the data format");
  return n[s](e, t, i);
}
class gR {
  constructor() {
    this._type = Xn.AUTO;
  }
  get type() {
    return this._type;
  }
  convert(t, i, n) {
    return cR(t, i, n);
  }
}
class hR {
  constructor() {
    this.store = /* @__PURE__ */ new Map(), this.converters(this._getDefaultConverters());
  }
  _getDefaultConverters() {
    return [new aR(), new lR(), new rR(), new gR()];
  }
  /**
   * Sets the given converters in the store and returns the store
   * @param  {Array<DataConverter>} converters : contains array of converter instance
   * @return { Map<String,DataConverter> }
   */
  converters(t) {
    return t.forEach((i) => this.store.set(i._type, i)), this.store;
  }
  /**
   * Registers a Converter of type DataConverter
   * @param {DataConverter} converter : converter Instance
   * @returns self
   */
  register(t) {
    return this.store.set(t._type, t), this;
  }
  /**
   * Removes a converter from store
   * @param {DataConverter} converter : converter Instance
   * @returns self
   */
  unregister(t) {
    return this.store.delete(t._type), this;
  }
  get(t) {
    return t && this.store.has(t) ? this.store.get(t) : null;
  }
}
const dR = (() => {
  let e = null;
  function t() {
    return e = new hR(), e;
  }
  return e || t();
})(), Qw = (e) => {
  const { data: t, schema: i, options: n } = e, s = dR.get(n.dataFormat);
  return s ? s.convert(t, i, n) : { data: [], schema: i };
}, uR = (e, t) => {
  const { options: i } = e;
  return t && i.useWorker !== !1 ? KF(e, t) : new Promise((n, s) => {
    setTimeout(() => {
      try {
        n(Qw(e));
      } catch (A) {
        s(A);
      }
    }, 0);
  });
}, fR = async (e, t, i, n) => {
  const s = {
    dataFormat: Xn.AUTO
  };
  return i = Object.assign(Object.assign({}, s), i), await uR({ data: e, schema: t, options: i }, n);
}, Bm = async (e, t) => {
  const { data: i, schema: n, options: s } = e;
  return await fR(i, n, s, t);
}, IR = (e, t, i = {}) => {
  const n = [], s = t.map((a) => {
    n.push({ ...a });
    const r = { ...a }, { format: l } = r;
    return l && typeof l == "function" && delete r.format, r;
  }), A = {
    dataFormat: Xn.AUTO
  };
  i = Object.assign(Object.assign({}, A), i);
  const o = Qw({ data: e, schema: s, options: i });
  return o.schema = n, o;
};
class qt {
  // static _defaults: Record<InvalidAwareType, Function>;
  /**
   * Initialize a new instance.
   *
   * @public
   * @param {string} value - The value of the invalid data type.
   */
  constructor(t) {
    this._value = t;
  }
  /**
   * Returns the current value of the instance.
   *
   * @public
   * @return {string} Returns the value of the invalid data type.
   */
  value() {
    return this._value;
  }
  /**
   * Returns the current value of the instance in string format.
   *
   * @public
   * @return {string} Returns the value of the invalid data type.
   */
  toString() {
    return String(this._value);
  }
}
var Ts;
(function(e) {
  e.ASC = "asc", e.DESC = "desc", e.NO_ORDER = "";
})(Ts || (Ts = {}));
const yw = (e) => e === Ts.DESC ? 1 : e === Ts.NO_ORDER ? 3 : 0;
var Bi;
(function(e) {
  e.NORMAL = "normal", e.INVERSE = "inverse", e.ALL = "all";
})(Bi || (Bi = {}));
const mm = (e) => ({
  normal: 1,
  inverse: 2,
  all: 3
})[e];
var Zg;
(function(e) {
  e.SUM = "sum", e.AVG = "avg", e.MIN = "min", e.MAX = "max", e.FIRST = "first", e.LAST = "last", e.COUNT = "count", e.STD = "std";
})(Zg || (Zg = {}));
const ww = (e) => ({
  sum: 0,
  avg: 1,
  count: 3,
  min: 4,
  max: 5,
  std: 6
})[e];
var Ui;
(function(e) {
  e.EQUAL = "eq", e.NOT_EQUAL = "neq", e.GREATER_THAN = "gt", e.LESS_THAN = "lt", e.GREATER_THAN_EQUAL = "gte", e.LESS_THAN_EQUAL = "lte", e.IN = "in", e.NIN = "nin", e.EQUAL_TO = "eq", e.NOT_EQUAL_TO = "neq";
})(Ui || (Ui = {}));
var Ns;
(function(e) {
  e.AND = "and", e.OR = "or";
})(Ns || (Ns = {}));
const pm = (e) => {
  const i = {
    eq: 1,
    neq: 2,
    gt: 3,
    lt: 4,
    gte: 5,
    lte: 6,
    in: 9,
    nin: 10,
    and: 7,
    or: 8
  }[e];
  return i !== void 0 ? i : -1;
}, CR = 1;
function ER() {
  var e, t;
  if (typeof window < "u") {
    const i = Math.min((t = (e = window.navigator) === null || e === void 0 ? void 0 : e.hardwareConcurrency) !== null && t !== void 0 ? t : CR, 4);
    return window.Worker != null ? Array.from({ length: i }).map(() => ({
      isFree: !0,
      worker: new Worker(new URL(
        /* @vite-ignore */
        "/assets/transform-data-worker-CGZDqNWC.js",
        self.location
      ), {
        type: "module"
      })
    })) : void 0;
  }
}
const BR = "data:application/wasm;base64,AGFzbQEAAAABkQImYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gAX8AYAN/f38AYAR/f39/AGACf38BfGAFf39/f38Bf2AFf39/f38AYAAAYAR/f39/AX9gBX9/f35/AGAGf39/f39/AGAGf39/f39/AX9gA39+fgBgAAF/YAJ8fAF8YAJ/fwF+YAF/AX5gCX9/f39/f35+fgBgB39/f39/f38Bf2AGfn9/f39/AX5gA35/fwF/YA1/f39/f39/f39/f39/AX9gBH9/f34AYAJ+fwBgA39/fwF8YAJ/fAF/YAR/fn5/AGABfwF8YAF+AX9gBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgBX9/fH9/AGAEf3x/fwACgwEDES4vZGF0YW1vZGVsX2JnLmpzGl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmAAQRLi9kYXRhbW9kZWxfYmcuanMZX193YmluZGdlbl9qc29uX3NlcmlhbGl6ZQABES4vZGF0YW1vZGVsX2JnLmpzEF9fd2JpbmRnZW5fdGhyb3cAAQP/Av0CAwUFEhMBAAUCAAIBBQgFDgEEAQICBAIBAAIBAgUDAAwFAQ8CDAUUAA0BBgEVAxYAFwUAAQEBAQEAAQEADAAAAQABBQEDBAYEGBkCAQEGAgQGDQMABhoFBQUCBgYBAQYAAwMDAQQABQEDAQUCAAICAgcHAQECBQEEAQcCAQEJAQQPBAEEBRsBAQEBAAQAAAAFBQUFBQUBAQQBAQEBAxwCAgECAAcHBwAAAwMDAwMBAR0AAAMDAwMBAwQBAwMDBAMDAwMEAwEEBAMDBAMABAQDAAEDAwMBAQAFAQEBAQUHAAAAAAAHBwEFBAQEAwMDAwMDDR4EBAUBBAIEAgECBQYGBgYDAAQAAggAAwEBCgEDAwAEAAEACwQDAQEEAQEDAQMDBQQBAB8EAwQBAhAQDgAECQggIiQACwQGBAAEAgEREQAAAgUEBQsFAAACAAkAAAUAAQABAAABAQEAAAAEAAADAAAAAAEKCgAABQAAAAABAAICAgIFAAAAAAAAAwQKBAUBcAFcXAUDAQARBgkBfwFBgIDAAAsH7hZcBm1lbW9yeQIAGV9fd2JnX2lkZmllbGR3cmFwcGVyX2ZyZWUAqAIXaWRmaWVsZHdyYXBwZXJfZ2V0X25hbWUAigEbaWRmaWVsZHdyYXBwZXJfZ2V0X2RhdGFfcHRyALoBH2lkZmllbGR3cmFwcGVyX2dldF9kYXRhX2luZGljZXMAwQEcaWRmaWVsZHdyYXBwZXJfZ2V0X2RhdGFfaW5mbwDtAR1pZGZpZWxkd3JhcHBlcl9nZXRfcm93c19jb3VudACrASFpZGZpZWxkd3JhcHBlcl9nZXRfdmFsdWVfYXRfaW5kZXgAqgEgX193YmdfY2F0ZWdvcmljYWxkb21haW5tZXRhX2ZyZWUAsQIoX193YmdfZ2V0X2NhdGVnb3JpY2FsZG9tYWlubWV0YV9kYXRhX3B0cgCpAihfX3diZ19zZXRfY2F0ZWdvcmljYWxkb21haW5tZXRhX2RhdGFfcHRyAKACKF9fd2JnX2dldF9jYXRlZ29yaWNhbGRvbWFpbm1ldGFfZGF0YV9sZW4AoQIoX193Ymdfc2V0X2NhdGVnb3JpY2FsZG9tYWlubWV0YV9kYXRhX2xlbgCaAiFfX3diZ19jb250aW51b3VzZmllbGR3cmFwcGVyX2ZyZWUAqAIfY29udGludW91c2ZpZWxkd3JhcHBlcl9nZXRfbmFtZQCKASNjb250aW51b3VzZmllbGR3cmFwcGVyX2dldF9kYXRhX3B0cgC1ASdjb250aW51b3VzZmllbGR3cmFwcGVyX2dldF9kYXRhX2luZGljZXMAwgEkY29udGludW91c2ZpZWxkd3JhcHBlcl9nZXRfZGF0YV9pbmZvAO4BJWNvbnRpbnVvdXNmaWVsZHdyYXBwZXJfZ2V0X3Jvd3NfY291bnQArAEpY29udGludW91c2ZpZWxkd3JhcHBlcl9nZXRfdmFsdWVfYXRfaW5kZXgA4AEhY29udGludW91c2ZpZWxkd3JhcHBlcl9nZXRfZG9tYWluAJIBGV9fd2JnX3NwbGl0ZGF0YW1vZGVsX2ZyZWUA+wEVc3BsaXRkYXRhbW9kZWxfZ2V0X2RtAMoBGHNwbGl0ZGF0YW1vZGVsX2dldF9jb3VudACiAgdtYWluX2pzAP8CGF9fd2JnX2RhdGFtb2RlbG1ldGFfZnJlZQCxAhxfX3diZ19nZXRfZGF0YW1vZGVsbWV0YV9yb3dzAKkCHF9fd2JnX3NldF9kYXRhbW9kZWxtZXRhX3Jvd3MAoAIfX193YmdfZ2V0X2RhdGFtb2RlbG1ldGFfY29sdW1ucwChAh9fX3diZ19zZXRfZGF0YW1vZGVsbWV0YV9jb2x1bW5zAJoCEWRhdGFtb2RlbG1ldGFfbmV3APoCFF9fd2JnX2RhdGFtb2RlbF9mcmVlAM8BDWRhdGFtb2RlbF9uZXcAiwIPZGF0YW1vZGVsX2Nsb25lAMsBE2RhdGFtb2RlbF9hZGRfZmllbGQAiAIfZGF0YW1vZGVsX2dldF9jYXRlZ29yaWNhbF9maWVsZADhARpkYXRhbW9kZWxfZ2V0X2Jpbm5lZF9maWVsZADiAR5kYXRhbW9kZWxfZ2V0X2NvbnRpbnVvdXNfZmllbGQA4wEcZGF0YW1vZGVsX2dldF90ZW1wb3JhbF9maWVsZADkARZkYXRhbW9kZWxfZ2V0X2lkX2ZpZWxkAOUBEGRhdGFtb2RlbF9zZWxlY3QAoQEOZGF0YW1vZGVsX3NvcnQAjwERZGF0YW1vZGVsX3Byb2plY3QAkAESZGF0YW1vZGVsX2dyb3VwX2J5AKIBFmRhdGFtb2RlbF9zcGxpdF9ieV9yb3cApQERZGF0YW1vZGVsX2Rpc3Bvc2UA+AETZGF0YW1vZGVsX3Jvd19jb3VudAC9ARZkYXRhbW9kZWxfY29sdW1uX2NvdW50AKICG2RhdGFtb2RlbF9nZXRfZWxpZ2libGVfcm93cwCjASJkYXRhbW9kZWxfZ2V0X3BhcnRpYWxfY29sdW1uX2NvdW50AL4BH2RhdGFtb2RlbF9nZXRfcGFydGlhbF9yb3dfY291bnQAvwEaZGF0YW1vZGVsX2dldF9tYXRjaGluZ19pZHMAbR9fX3diZ190ZW1wb3JhbGZpZWxkd3JhcHBlcl9mcmVlAKgCHXRlbXBvcmFsZmllbGR3cmFwcGVyX2dldF9uYW1lAIoBIXRlbXBvcmFsZmllbGR3cmFwcGVyX2dldF9kYXRhX3B0cgC2ASV0ZW1wb3JhbGZpZWxkd3JhcHBlcl9nZXRfZGF0YV9pbmRpY2VzAMMBInRlbXBvcmFsZmllbGR3cmFwcGVyX2dldF9kYXRhX2luZm8A7wEjdGVtcG9yYWxmaWVsZHdyYXBwZXJfZ2V0X3Jvd3NfY291bnQArQEndGVtcG9yYWxmaWVsZHdyYXBwZXJfZ2V0X3ZhbHVlX2F0X2luZGV4AOYBKXRlbXBvcmFsZmllbGR3cmFwcGVyX21pbl9jb25zZWN1dGl2ZV9kaWZmAPQBH3RlbXBvcmFsZmllbGR3cmFwcGVyX2dldF9kb21haW4AkwEUX193Ymdfc3RhY2tkYXRhX2ZyZWUAvQIRc3RhY2tkYXRhX2dldF95XzAA1AERc3RhY2tkYXRhX2dldF95XzEAzQEQc3RhY2tkYXRhX2dldF9pZADRARNzdGFja2RhdGFfZnJlZV9kYXRhAGcIc3RhY2tfYnkASx1fX3diZ19iaW5uZWRmaWVsZHdyYXBwZXJfZnJlZQCoAhtiaW5uZWRmaWVsZHdyYXBwZXJfZ2V0X25hbWUAigEfYmlubmVkZmllbGR3cmFwcGVyX2dldF9kYXRhX3B0cgC3ASNiaW5uZWRmaWVsZHdyYXBwZXJfZ2V0X2RhdGFfaW5kaWNlcwDEASBiaW5uZWRmaWVsZHdyYXBwZXJfZ2V0X2RhdGFfaW5mbwDwASFiaW5uZWRmaWVsZHdyYXBwZXJfZ2V0X3Jvd3NfY291bnQArgElYmlubmVkZmllbGR3cmFwcGVyX2dldF92YWx1ZV9hdF9pbmRleADnAR1iaW5uZWRmaWVsZHdyYXBwZXJfZ2V0X2RvbWFpbgCbAR5iaW5uZWRmaWVsZHdyYXBwZXJfZ2V0X3VuaXF1ZXMAnAEbX193YmdfcHJvamVjdGRhdGFtb2RlbF9mcmVlAJgCIHByb2plY3RkYXRhbW9kZWxfZ2V0X2ZpbHRlcmVkX2RtAGQicHJvamVjdGRhdGFtb2RlbF9nZXRfdW5maWx0ZXJlZF9kbQBlIl9fd2JnX2NhdGVnb3JpY2FsZmllbGR3cmFwcGVyX2ZyZWUAqgIgY2F0ZWdvcmljYWxmaWVsZHdyYXBwZXJfZ2V0X25hbWUAjAEoY2F0ZWdvcmljYWxmaWVsZHdyYXBwZXJfZ2V0X2RhdGFfaW5kaWNlcwDGASVjYXRlZ29yaWNhbGZpZWxkd3JhcHBlcl9nZXRfZGF0YV9pbmZvAPEBJmNhdGVnb3JpY2FsZmllbGR3cmFwcGVyX2dldF9yb3dzX2NvdW50AK8BKmNhdGVnb3JpY2FsZmllbGR3cmFwcGVyX2dldF92YWx1ZV9hdF9pbmRleADZASJjYXRlZ29yaWNhbGZpZWxkd3JhcHBlcl9nZXRfZG9tYWluAI0BLGNhdGVnb3Jp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IAEgA0EBajYCCCABQRRqKAIAIgMgAk0NFyABQRBqKAIAIAJBA3RqIgIoAgANFCACKAIEIgIgAigCAEEBaiIDNgIAIAMNBAwWCyAAKAIQIgMoAggNCiADQX82AgggBEEcaiICIAFBNBD1AhogA0EMakEBIAIQdyECIAMgAygCCEEBajYCCCAAKAIQIgEoAggiA0H/////B08NCyABIANBAWo2AgggAUEUaigCACIDIAJNDRYgAUEQaigCACACQQN0aiICKAIADQRBkIfAAEELQZyHwAAQowIACyAAKAIQIgMoAggNCyADQX82AgggBEEcaiICIAFBNBD1AhogA0EMakEBIAIQdyECIAMgAygCCEEBajYCCCAAKAIQIgEoAggiA0H/////B08NDCABIANBAWo2AgggAUEUaigCACIDIAJNDRUgAUEQaigCACACQQN0aiICKAIADQRBkIfAAEELQcyHwAAQowIACyAAKAIQIgMoAggNDCADQX82AgggBEEcaiICIAFBNBD1AhogA0EMakEBIAIQdyECIAMgAygCCEEBajYCCCAAKAIQIgEoAggiA0H/////B08NDSABIANBAWo2AgggAUEUaigCACIDIAJNDRQgAUEQaigCACACQQN0aiICKAIADQRBkIfAAEELQfyHwAAQowIACyAAKAIQIgMoAggNDSADQX82AgggBEEcaiICIAFBNBD1AhogA0EMakEBIAIQdyECIAMgAygCCEEBajYCCCAAKAIQIgEoAggiA0H/////B08NDiABIANBAWo2AgggAUEUaigCACIDIAJNDRMgAUEQaigCACACQQN0aiICKAIADQRBkIfAAEELQayIwAAQowIACyAAKAIMIgMgAygCAEEBaiIFNgIAIAVFDREgAigCCA0OIAFBCGohASAEIAM2AiAgBCACNgIcIAQgAkEMaigCADYCJCAEQRxqEIQCIQNBACECDBALIAIoAgQiAyADKAIAQQFqIgI2AgAgAkUNECAAKAIMIgUgBSgCAEEBaiICNgIAIAJFDRAgAUEIaiEBQQEhAiADIAUQlgIhAwwPCyACKAIEIgMgAygCAEEBaiICNgIAIAJFDQ8gACgCDCIFIAUoAgBBAWoiAjYCACACRQ0PIAFBCGohAUECIQIgAyAFEJYCIQMMDgsgAigCBCIDIAMoAgBBAWoiAjYCACAC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DQIgBEGABkYNAyAAIAFqIg1BpApqLQAAIgcgAy0AACIFRgRAIAxB43VGIANB6czBAEZyDQUgBEEBciAGRg0DIAMtAAEhBSAEQQJqIQQgAUECaiEBIANBAmohAyANQaUKai0AACIHIAVGDQELCyACIAUgB0trIQIMAwsgAUGcCkH8zMEAEJQBAAsgAkEBayECDAELQYAGQYAGQezMwQAQlQEACyAGQQFrIQEgAEEHaiIDIAJqIQQgCK0hEQNAAkACQCABQQFqQYEGSQRAIAEgA2pBAWoxAAAgEYYgEHwiDiAOQgqAIhBCdn58IQ8gASACakGABkkNASAPUA0CIABBAToAiAYMAgsgAUGABkH8wMEAEJUBAAsgASAEakEBaiAPPAAACyABQQFrIgFBf0cNAAsgDkIKWgRAIAJBB2ohAQNAIBAiDiAOQgqAIhBCdn58IQ8CQCABQQhrQYAGTwRAIA9QDQEgAEEBOgCIBgwBCyAAIAFqIA88AAALIAFBAWshASAOQgpaDQALCyAAIAAoAgQgAmo2AgQgAEGABiAAKAIAIAJqIgEgAUGABk8bIgE2AgAgAUUNACABQQdqIQEDQCAAIAFqLQAADQEgACABQQhrNgIAIAFBAWsiAUEHRw0ACwsLlgUBC38jAEEwayIDJAAgA0EkaiABNgIAIANBAzoALCADQSA2AhwgA0EANgIoIAMgADYCICADQQA2AhQgA0EANgIMAn8CQAJAAkAgAigCECILRQRAIAJBDGooAgAiAEUNASACKAIIIgEgAEEDdGohBCAAQQFrQf////8BcUEBaiEIIAIoAgAhAANAIABBBGooAgAiBgRAIAMoAiAgACgCACAGIAMoAiQoAgwRAgANBAsgASgCACADQQxqIAFBBGooAgARAAANAyAFQQFqIQUgAEEIaiEAIAFBCGoiASAERw0ACwwBCyACQRRqKAIAIgBFDQAgAEEFdCEMIABBAWtB////P3FBAWohCCACKAIIIQYgAigCACEAA0AgAEEEaigCACIBBEAgAygCICAAKAIAIAEgAygCJCgCDBECAA0DCyADIAUgC2oiAUEQaigCADYCHCADIAFBHGotAAA6ACwgAyABQRhqKAIANgIoIAFBDGooAgAhB0EAIQpBACEEAkACQAJAIAFBCGooAgBBAWsOAgACAQsgB0EDdCAGaiINKAIE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NgIYIAIgAkEIajYCKCABIAJBEGoQywIMEQsgAiAAKQMINwMIIAJBHGpCATcCACACQQI2AhQgAkHUscEANgIQIAJBLDYCLCACIAJBKGo2AhggAiACQQhqNgIoIAEgAkEQahDLAgwQCyACIAApAwg3AwggAkEcakIBNwIAIAJBAjYCFCACQdSxwQA2AhAgAkEtNgIsIAIgAkEoajYCGCACIAJBCGo2AiggASACQRBqEMsCDA8LIAArAwghFCACQRxqQgE3AgAgAkECNgIUIAJB9LHBADYCECACQS42AgwgAiAUOQMoIAIgAkEIajYCGCACIAJBKGo2AgggASACQRBqEMsCDA4LIAIgACgCBDYCCCACQRxqQgE3AgAgAkECNgIUIAJBkLLBADYCECACQS82AiwgAiACQShqNgIYIAIgAkEIajYCKCABIAJBEGoQywIMDQsgAiAAKQIENwIIIAJBHGpCATcCACACQQE2AhQgAkGossEANgIQIAJBMDYCLCACIAJBKGo2AhggAiACQQhqNgIoIAEgAkEQahDLAgwMCyABQbCywQBBChDEAgwLCyABQbqywQBBChDEAgwKCyABQcSywQBBDBDEAgwJCyABQdCywQBBDhDEAgwICyABQd6ywQBBCBDEAgwHCyABQeaywQBBAxDEAgwGCyABQemywQBBBBDEAgwFCyABQe2ywQBBDBDEAgwECyABQfmywQBBDxDEAgwDCyABQYizwQBBDRDEAgwCCyABQZWzwQBBDhDEAgwBCyABIAAoAgQgAEEIaigCABDEAgsgAkEwaiQADAILIAZBCGohDCAGQThqIQIgACsDCCEUIwBBEGsiCyQAAn8gFL1CgICAgICAgPj/AINCgICAgICAgPj/AFIEQCMAQRBrIgokACAUvSINQv////////8HgyEPIA1CAFMEQCACQS06AABBASEHCwJAAn8CfwJAAkAgDUI0iKdB/w9xIgBFIA9QcUUEQCAAQQJJIA9CAFJyIQQgD0KAgICAgICACIQgDyAAGyINQgKGIQ4gDUIBgyESIABBtQhrQcx3IAAbIgVBAEgEQCANQeiGwQAgBSAFQYWiU2xBFHYgBUF/R2siAGoiCEEEdGsgACAIQbHZtX9sQRN2a0H8AGogCiAKQQhqIAQQMSEQIAopAwghDSAKKQMAIQ8gAEECTwRAIA5CfyAA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NgIAIAFBIGokACACKAIEQYCAgIB4RwRAIAAgAikCBDcCACAAQQhqIAJBDGooAgA2AgAMAgsgACACKAIINgIEIABBgYCAgHg2AgAMAQsgACACKAIINgIEIABBgYCAgHg2AgALIAJBEGokAAvcBQEGfyMAQTBrIgMkAAJ/IAFFBEAgACgCDCEGIwBBIGsiASQAIAJBIGohBSACKAIwIQQCQCACKAIQQQJGBEAgBEUEQCABQQA2AhggAUKAgICAwAA3AhAgAUEQahCEAiEECyABQRBqIAZBABCHASABQQMQuQEgASgCACEGIAEoAgQiAkGApMAALwAAOwAAIAJBAmpBgqTAAC0AADoAACADIAQ2AiwgA0EoakEDNgIAIANBJGogAjYCACADIAY2AiAgAyAFKQIANwIQIANBGGogBUEIaikCADcCACADIAEpAhA3AgAgA0EIaiABQRhqKQIANwIADAELIARFBEAgAUEANgIYIAFCgICAgMAANwIQIAFBEGoQhAIhBAsgAUEIakEDELkBIAEoAgghByABKAIMIgZBgKTAAC8AADsAACAGQQJqQYKkwAAtAAA6AAAgAyAENgIsIANBKGpBAzYCACADQSRqIAY2AgAgAyAHNgIgIAMgBSkCADcCECADQRhqIAVBCGopAgA3AgAgAyACQRBqIgIpAgA3AgAgA0EIaiACQQhqKQIANwIACyABQSBqJAAgAxCRAgwBCyAAKAIMIQUjAEEQayIBJAAgAkEgaiEEAkAgAigCAEECRgRAIAMgBCkCADcCICADQShqIARBCGopAgA3AgAgASAFIAJBLWotAABBA0cQhwEgAyAFQQAQhwEgA0EYaiABQQhqKQIANwIAIAMgASkCADcCEAwBCyADIAQpAgA3AiAgA0EoaiAEQQhqKQIANwIAIAMgBUEAEIcBIANBGGogAkEIaikCADcCACADIAIpAgA3AhALIAIoAjAEQCACQTBqELsBCyABQRBqJABBASEIIAMQkQILIQEgACgCCCICIAAoAgBGBEAgACACENsBIAAoAgghAgsgACgCBCACQQN0aiICIAE2AgQgAiAINgIAIAAgACgCCCIAQQFqNgIIIANBMGokACAAC4kBAQN/IAAoAgAhBQJAIAAoAggiAyAAKAIERwRAIAUhBAwBCyAAIANBAXQ2AgRBtdjCAC0AABogA0EE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mcAAQTNB6JnAABCjAgALIg0gDWJxRQRAQbXYwgAtAAAaQRBBCBDQAiICRQ0DIAIgDTkDCCACIA45AwAgBkECNgIIIAYgAjYCBCAGQQI2AgAMBAsgBkEANgIIIAZCgICAgIABNwIADAMLQfiZwAAQ6gEACyMAQSBrIgIkACACQQhqIAhBBGoiBCgCCCIDEJ0BIAJBADYCHCACIAIpAwg3AhQgAwRAIAQoAgQiBSADQQJ0aiEMA0ACQAJAAkACQCAKRSAHIAUoAgAQpgEiDSANYnFFBEAgAigCHCIDQQN0IQQgAigCGCEJA0AgBEUNAiAEQQhrIQQgCSsDACEOIAlBCGohCSANIA5iDQALDAQLQQEhCiACKAIcIgMgAigCFEYNAQwCCyADIAIoAhRHDQELIAJBFGogAxDeASACKAIcIQMLIAIoAhggA0EDdGogDTkDACACIAIoAhxBAWo2AhwLIAVBBGoiBSAMRw0ACwsgBiACKQIUNwIAIAZBCGogAkEcaigCADYCACACQSBqJAAMAQtBCEEQEPACAAsgCCgCBARAIAgoAggQFAsgCEEQaiQAIAEgASgCAEEBazYCACAGEMkBIAAgCykCCDcDACALQRBqJAAPCxDnAgALEOgCAAttAQF/IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0EUakICNwIAIANBLGpBAzYCACADQQI2AgwgA0H47sEANgIIIANBAzYCJCADIANBIGo2AhAgAyADQQRqNgIoIAMgAzYCICADQQhqIAIQjwIAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRRqQgI3AgAgA0EsakEDNgIAIANBAjYCDCADQYzqwQA2AgggA0EDNgIkIAMgA0EgajYCECADIAM2AiggAyADQQRqNgIgIANBCGogAhCPAgALbQEBfyMAQTBrIgMkACADIAA2AgAgAyABNgIEIANBFGpCAjcCACADQSxqQQM2AgAgA0ECNgIMIANBmO/BADYCCCADQQM2AiQgAyADQSBqNgIQIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEI8CAAttAQF/IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0EUakICNwIAIANBLGpBAzYCACADQQI2AgwgA0HM78EANgIIIANBAzYCJCADIANBIGo2AhAgAyADQQRqNgIo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ASgCmAMhASADQQFrIgMNAAsLIABCADcCCCAAIAE2AgQgAEEBNgIAIAILbgIBfAF/AkACQCAAKwMAIgIgAmIEQCABIAFhDQFBAA8LIAEgAWENAQtBAw8LQQIhAAJAAkACQEEAQX8gASACZSIDG0EBQQIgAxsgASACZhsiA0H/AXEOAwEBAAILQfSFwAAQ3gIACyADIQALIAAL/BEBEX8jAEEwayIQJAACQCAABEAgACgCACIMQX9GDQEgACAMQQFqNgIAIBBBCGohESAAQQRqIQkjAEGwAWsiBCQAIAQgASIMNgIMIARBQGsgBEEMahCLAQJAAkAgBC0AQEEGRwRAIARBIGogBEHQAGopAwA3AwAgBEEYaiAEQcgAaikDADcDACAEIAQpA0A3AxAgCSgCBCEBIAkoAgghByAEQShqIgogBEEQagJ/A0BBfyAFIAdGDQEaIAVBAWohBSABKAIAIAFBCGohAUEERw0ACyAFQQFrCxAKIARBgICAgHg2AlQgBEGAgICAeDYCQCMAQaABayIDJAAgA0EANgI4IANCgICAgMAANwIwIANBADYCRCADQoCAgIDAADcCPAJAIAkoAgwiDSgCCEUEQCANQX82AgggCigCACEBIANBKGogDUEMaiILEEIgAygCKEEBRgRAIANBxABqIQ8gA0FAayEFIANBOGohEiADQTRqIQcgAygCLCEIIAFBBkchEwNAAn8CQAJAIBNFBEAgCSAIIAoQXA0BDAILIAkgCCAKECZFDQELIAMoAjgiBiADKAIwRgRAIANBMGogBhDcASADKAI4IQYLIAchASASDAELIAMoAkQiBiADKAI8RgRAIANBPGogBhDcASADKAJEIQYLIAUhASAPCyEOIAEoAgAgBkECdGogCDYCACAOIA4oAgBBAWo2AgAgA0EgaiALEEIgAygCJCEIIAMoAiBBAUYNAAsLAn8CQAJAAkAgAkH/AXFBAmsOAgECAAsgA0H8AGoiAkF/NgIAIANB9ABqIgVCgICAgHA3AgAgA0HsAGoiB0IANwIAIANCgICAgMAANwJkIAMoAjQhBiADIAMoAjgiARCZASADKAIAIQggAygCBCAGIAFBAnQQ9QIhBiADIAE2AogBIAMgBjYChAEgAyAINgKAASADQeQAaiADQYABaiIBENgBIANBnAFqIAIoAgA2AgAgA0GUAWogBSkCADcCACADQYwBaiAHKQIANwIAIAMgAykCZDcChAEgA0EANgKAASABELgBIQZBAAwCCyADQfwAaiICQX82AgAgA0H0AGoiBUKAgICAcDcCACADQewAaiIHQgA3AgAgA0KAgICAwAA3AmQgAygCQCEIQQAhBiADQQhqIAMoAkQiARCZASADKAIIIQogAygCDCAIIAFBAnQQ9QIhCCADIAE2AogBIAMgCDYChAEgAyAKNgKAASADQeQAaiADQYABaiIBENgBIANBnAFqIAIoAgA2AgAgA0GUAWogBSkCADcCACADQYwBaiAHKQIANwIAIAMgAykCZDcChAEgA0EANgKAASABELgBDAELIANB4ABqIgVBfzYCACADQdgAaiIHQoCAgIBwNwIAIANB0ABqIgZCADcCACADQoCAgIDAADcCSCADKAI0IQIgA0EYaiADKAI4IgEQmQEgAygCGCEIIAMoAhwgAiABQQJ0EPUCIQIgAyABNgKIASADIAI2AoQBIAMgCDYCgAEgA0HIAGogA0GAAWoiARDYASADQfwAaiIIQX82AgAgA0H0AGoiCkKAgICAcDcCACADQewAaiIOQgA3AgAgA0KAgICAwAA3AmQgAygCQCELIANBEGogAygCRCICEJkBIAMoAhAhDyADKAIUIAsgAkECdBD1AiELIAMgAjYCiAEgAyALNgKEASADIA82AoABIANB5ABqIAEQ2AEgA0GcAWoiAiAFKAIANgIAIANBlAFqIgUgBykCADcCACADQYwBaiIHIAYpAgA3AgAgAyADKQJINwKEASADQQA2AoABIAEQuAEhBiACIAgoAgA2AgAgBSAKKQIANwIAIAcgDikCADcCACADIAMpAmQ3AoQBIANBADYCgAEgARC4AQshASANIA0oAghBAWo2AgggAygCPARAIAMoAkAQFAsgAygCMARAIAMoAjQQFAsgBCABNgIEIAQgBjYCACADQaABaiQADAELQeSbwAAQ6gEACyAEKAIEIQEgBCgCACIHBEAgBEGkAWogCRA5IAkoAgwiAiACKAIAQQFqIgU2AgAgBUUNAiAJKAIQIgUgBSgCAEEBaiIDNgIAIANFDQIgBEGYAWoiAyAEQawBaigCADYCACAEIAQpAqQBNwOQASAEIAU2AqABIAQgAjYCnAEgBEGQAWoiAhDWASEFIAQgBzYCeCAE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KALUAiAEQQJ0aiANNgIAIAMgAygC2AJBAWoiBDYC2AIgAUEMaiEBIAJBDGsiAg0ACwsgA0GQAmogCygCBCgCCCIBQRhqELABIANB4AFqIANBmAJqKAIAIgI2AgAgAyADKQKQAiIkNwPYASABQSZqLQAAIQQgAUEkai8BACEBIBtBCGogAjYCACAbICQ3AgAgAyAGNgKgASADQQI2AoABIANBAjYCcCADIAE7AZwBIANCgIKAmMCggQMgBEEDdK1C+AGDiDwAngEgA0HEAGogA0HwAGoQCSICIAMoAkwiAU8NFAJAIAMoAkggAkEDdGoiASgCAA0AIAEoAgQoAggiASgCCA0KIAMoAtgCIgJFDQAgAUEMaigCACEBIAMoAtQCIQQgAkECdCECA0AgASAEKAIANgIAIAFBBGohASAEQQRqIQQgAkEEayICDQALCyADKALQAkUNAyADKALUAhAUDAMLIAooAghBAnQhASAKKAIEIQIDQCABRQ0DIAFBBGshASACKAIAIAJBBGohAiANRw0ACyADQShqIAwQnQEgA0EANgLMAiADIAMpAyg3AsQCIANBIGogDBCZASADQQA2AtgCIAMgAykDIDcC0AIgDARAIAghAiAFIQEDQCABQQRqKAIARQ0PIAsoAgRBCGogASgCACgCABCmASEjIAMoAswCIgQgAygCxAJGBEAgA0HEAmogBBDeASADKALMAiEECyADKALIAiAEQQN0aiAjOQMAIAMgAygCzAJBAWo2AswCIAMoAtgCIgQgAygC0AJGBEAgA0HQAmogBBDcASADKALYAiEECyADKALUAiAEQQJ0akF/QQEgIyAjYhs2AgAgAyADKALYAkEBajYC2AIgAUEMaiEBIAJBDGsiAg0ACwsgA0GQAmogCygCBCgCCCIBQShqELABIANB4AFqIANBmAJqKAIAIgI2AgAgAyADKQKQAiIkNwPYASABQTZqLQAAIQQgAUE0ai8BACEBIBxBCGogAjYCACAcICQ3AgAgA0EANgKMAyADQQI2AuwCIANBAjYC3AIgAyABOwGIAyADQoCCgJjAoIEDIARBA3StQvgBg4g8AIoDIANBxABqIANB3AJqEAkiAiADKAJMIgFPDRMCQCADKAJIIAJBA3RqIgYoAgBBAkcNACAGKAIEKAIIIgFBGGooAgBFDQ8gAygCzAIiAgRAIAFBHGooAgAhASADKALIAiEEIAJBA3QhAgNAIAEgBCsDADkDACABQQhqIQEgBEEIaiEEIAJBCGsiAg0ACyAGKAIEKAIIIQELIAEoAggNECADKALYAiICRQ0AIAFBDGooAgAhASADKALUAiEEIAJBAnQhAgNAIAEgBCgCADYCACABQQRqIQEgBEEEaiEEIAJBBGsiAg0ACwsgAygC0AIEQCADKALUAhAUCyADKALEAkUNAiADKALIAhAUDAILIAooAghBAnQhASAKKAIEIQIDQCABRQ0CIAFBBGshASACKAIAIAJBBGohAiANRw0ACyADQThqIAwQnQEgA0EANgLMAiADIAMpAzg3AsQCIANBMGogDBCZASADQQA2AtgCIAMgAykDMDcC0AIgDARAIAghAiAFIQEDQCABQQRqKAIARQ0RIAsoAgRBCGogASgCACgCABCnASEjIAMoAswCIgQgAygCxAJGBEAgA0HEAmogBBDeASADKALMAiEECyADKALIAiAEQQN0aiAjOQMAIAMgAygCzAJBAWo2AswCIAMoAtgCIgQgAygC0AJGBEAgA0HQAmogBBDcASADKALYAiEECyADKALUAiAEQQJ0akF/QQEgIyAjYhs2AgAgAyADKALYAkEBajYC2AIgAUEMaiEBIAJBDGsiAg0ACwsgA0GQAmogCygCBCgCCCIBQShqELABIANB4AFqIANBmAJqKAIAIgI2AgAgAyADKQKQAiIkNwPYASABQTZqLQAAIQQgAUE0ai8BACEBIB1BCGogAjYCACAdICQ3AgAgA0EANgLUASADQQI2ArQBIANBAjYCpAEgAyABOwHQASADQoCCgJjAoIEDIARBA3StQvgBg4g8ANIBIANBxABqIANBpAFqEAkiAiADKAJMIgFPDRICQCADKAJIIAJBA3RqIgYoAgBBA0cNACAGKAIEKAIIIgFBGGooAgBFDREgAygCzAIiAgRAIAFBHGooAgAhASADKALIAiEEIAJBA3QhAgNAIAEgBCsDADkDACABQQhqIQEgBEEIaiEEIAJBCGsiAg0ACyAGKAIEKAIIIQELIAEoAggNEiADKALYAiICRQ0AIAFBDGooAgAhASADKALUAiEEIAJBAnQhAgNAIAEgBCgCADYCACABQQRqIQEgBEEEaiEEIAJBBGsiAg0ACwsgAygC0AIEQCADKALUAhAUCyADKALEAkUNASADKALIAhAUDAELIANBkAJqIAsoAgQoAggiAUEoahCwASADQdgCaiADQZgCaigCACIENgIAIAMgAykCkAIiJDcD0AIgAUE2ai0AACEGIAFBNGotAAAhAiABQTVqLQAAIQEgFkEIaiAENgIAIBYgJDcCACADQQA2AogCIANBAjYC6AEgA0ECNgLYASADIAE6AIUCIAMgAjoAhAIgA0KAgoCYwKCBAyAGQQN0rUL4AYOIPACGAgJAIAJFBEAgCigCCEECdCEBIAooAgQhAgNAIAFFDQIgAUEEayEBIAIoAgAgAkEEaiECIA1HDQALCyADQZACaiIBIANB2AFqQTQQ9QIaIANBxABqIAEQCSEXIANBGGogDBCdASADQQA2AtgCIAMgAykDGDcC0AIgA0EQaiAMEJkBIANBADYCmAIgAyADKQMQNwKQAiAKKAIIQQJ0IQEgCigCBCECAkACQANAIAFFDQEgAUEEayEBIAIoAgAgAkEEaiECIA1HDQALIAxFDQEgCCECIAUhAQNAIAFBBGooAgBFDQsgCygCBEEIaiABKAIAKAIAEKgBISMgAygC2AIiBCADKALQAkYEQCADQdACaiAEEN4BIAMoAtgCIQQLIAMoAtQCIARBA3RqICM5AwAgAyADKALYAkEBajYC2AIgAygCmAIiBCADKAKQAkYEQCADQZACaiAEENwBIAMoApgCIQQLIAMoApQCIARBAnRqQX9BASAjICNiGzYCACADIAMoApgCQQFqNgKYAiABQQxqIQEgAkEMayICDQALDAELIAxFDQAgCSEEA0BBByEQAkAgIA0AQQAhAiAOIQYgDyEBA0AgDSABKAIARwRAIAJBAWohAiABQQhqIQEgBkEIayIGDQEMAgsLQoCCgJjAoIEDIAFBBGotAABBA3StQvgBg4inIRALIAsoAgRBCGogBCAQEIgBISMgAygC2AIiASADKALQAkYEQCADQdACaiABEN4BIAMoAtgCIQELIAMoAtQCIAFBA3RqICM5AwAgAyADKALYAkEBajYC2AIgAygCmAIiASADKAKQAkYEQCADQZACaiABENwBIAMoApgCIQELIAMoApQCIAFBAnRqQX9BASAjICNiGzYCACADIAMoApgCQQFqNgKYAiAEQQxqIgQgH0cNAAsLIAMoAkwiASAXTQ0JAkAg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AkGs6MEANgIIIAJBqMDBADYCEEEBIAEoAhQgAUEYaigCACACQQhqEBYNABogAEEEaiABEDULIAJBIGokAAtoAQJ/AkACQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIAAoAgQoAggiA0EYaigCAA0CIANBHGooAgAgAUECdGooAgAgACACNgIADwsQ5wIACxDoAgALQbyiwABBM0HwosAAEKMCAAtlAQF/AkACQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgRBDGooAgAiASgCCA0CIAFBADYCCCABQRhqKAIAIAAgACgCAEEBazYCAA8LEOcCAAsQ6AIAC0GsosAAEOoBAAtlAQF/AkACQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgRBDGooAgAiASgCCA0CIAFBADYCCCABQRhqKAIAIAAgACgCAEEBazYCAA8LEOcCAAsQ6AIAC0HQpcAAEOoBAAtlAQF/AkACQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgRBDGooAgAiASgCCA0CIAFBADYCCCABQRhqKAIAIAAgACgCAEEBazYCAA8LEOcCAAsQ6AIAC0GkmcAAEOoBAAtlAQF/AkACQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgRBDGooAgAiASgCCA0CIAFBADYCCCABQRhqKAIAIAAgACgCAEEBazYCAA8LEOcCAAsQ6AIAC0Hcn8AAEOoBAAtlAQF/AkACQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgRBDGooAgAiASgCCA0CIAFBADYCCCABQRhqKAIAIAAgACgCAEEBazYCAA8LEOcCAAsQ6AIAC0GAjsAAEOoBAAtuAQJ/IAEoAgQhAwJAAkACQCABKAIIIgFFBEBBASECDAELIAFBAEgNAUG12MIALQAAGiABQQEQ0AIiAkUNAgsgAiADIAEQ9QIhAiAAIAE2AgggACACNgIEIAAgATYCAA8LEI4CAAtBASABEPACAAtoACMAQTBrIgAkAEG02MIALQAABEAgAEEYakIBNwIAIABBAjYCECAAQby6wQA2AgwgAEEDNgIoIAAgATYCLCAAIABBJGo2AhQgACAAQSxqNgIkIABBDGpB5LrBABCPAgALIABBMGokAAtWAQF+AkAg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AgQgA0EMaiABQQxqKQIANwIAIABBADYCACADENUBIARBIGokAA8LEOcCAAsQ6AIAC/QBAQZ/IwBBIGsiBCQAAkAgAARAIAAoAgANASAAQX82AgAgBEEMaiEFIwBBQGoiASQAIAFBNGogAEEEaiICEDkgAigCDCIGIAYoAgBBAWoiAzYCAAJAAkAgA0UNACACKAIQIgIgAigCAEEBaiIDNgIAIANFDQAgAUEoaiABQTxqKAIANgIAIAEgASkCNDcDICABIAI2AjAgASAGNgIsIAFBIGoQ1gEhAiABQQA2AhwgASACNgIYIAFBgICAgHg2AgwgBSABQQxqEIUBIAFBQGskAAwBCwALIABBADYCACAFENUBIARBIGokAA8LEOcCAAsQ6AIAC4oCAQZ/IwBBEGsiBCQAAkACQCAAKAIIIgIgACgCAE8NACAEQQhqIQUjAEEgayIBJAACQCACIAAoAgAiA00EQAJ/QYGAgIB4IANFDQAaIAAoAgQhBgJAIAJFBEBBASEDIAYQFAwBC0EBIAYgA0EBIAIQyAIiA0UNARoLIAAgAjYCACAAIAM2AgRBgYCAgHgLIQAgBSACNgIEIAUgADYCACABQSBqJAAMAQsgAUEUakIANwIAIAFBATYCDCABQZTbwAA2AgggAUHw2sAANgIQIAFBCGpB6NvAABCPAgALIAQoAggiAEGBgICAeEYNACAARQ0BIAAgBCgCDBDwAgALIARBEGokAA8LEI4CAAtYAQF/AkACQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIABBFGooAgBFDQIgACABNgIAIABBGGooAgAPCxDnAgALEOgCAAtBuJ7AAEEsQYCfwAAQowIAC0wBAn8jAEEQayICJAAgAkEIaiAAQQxqIABBEGooAgAiAyAAQRRqKAIAQQFqIgAgACADSxsQIyABIAIoAgggAigCDBD6ASACQRBqJAALygEBA38jAEEgayICJAAgAkEMaiEDIwBBIGsiASQAAkACQCAABEAgACgCAA0BIABBADYCACABQRBqIABBCGopAgA3AwAgAUEYaiAAQRBqKQIANwMAIAEgACkCADcDCCADIAEpAgw3AgAgA0EIaiABQRRqKQIANwIAIANBEGogAUEcaigCADYCACAAEBQgAUEgaiQADAILEOcCAAsQ6AIACyADEJoBIAIoAgwE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IAFBKEHE/8EAEJYBAAsPCyABIwBBgAFrIhkkACA7vSECAkAgOyA7YgRAQQIhAAwBCyACQv////////8HgyIGQoCAgICAgIAIhCACQgGGQv7///////8PgyACQjSIp0H/D3EiARsiBEIBgyEFQQMhAAJAAkACQEEBQQJBBCACQoCAgICAgID4/wCDIgdQIhobIAdCgICAgICAgPj/AFEbQQNBBCAaGyAGUBtBAmsOAwABAgMLQQQhAAwCCyABQbMIayElIAVQIQBCASEDDAELQoCAgICAgIAgIARCAYYgBEKAgICAgICACFEiABshBEICQgEgABshA0HLd0HMdyAAGyABaiElIAVQIQALIBkgJTsBeCAZIAM3A3AgGUIBNwNoIBkgBDcDYCAZIAA6AHoCfwJAAkBBAyAAQQJrQf8BcSIAIABBA08bIgEEQEHn58EAQejnwQAgAkIAUyIAG0Hn58EAQajAwQAgABsgGBshJUEBIQAgAkI/iKcgGHIhMgJAIAFBAmsOAgMAAgsgGUEgaiEbIBlBD2oiIyEeIwBBMGsiGiQAAkACQAJ/AkACQAJAAkACQAJAAkACQCAZQeAAaiIhIgApAwAiAlBFBEAgACkDCCIEUA0BIAApAxAiA1ANAiACIAN8IgMgAlQNAyACIARUDQQgA0KAgICAgICAgCBaDQUgGiAALwEYIgA7AQggGiACIAR9IgQ3AwAgACAAQSBrIAAgA0KAgICAEFQiARsiGEEQayAYIANCIIYgAyABGyIDQoCAgICAgMAAVCIBGyIYQQhrIBggA0IQhiADIAEbIgNCgICAgICAgIABVCIBGyIYQQRrIBggA0IIhiADIAEbIgNCgICAgICAgIAQVCIBGyIYQQJrIBggA0IEhiADIAEbIgNCgICAgICAgIDAAFQiARsgA0IChiADIAEbIghCAFkiGGsiAWvBIiJBAEgNBiAaIAQgIq0iA4YiBSADiCIGNwMQIAQgBlINCiAaIAA7AQggGiACNwMAIBogAiADQj+DIgSGIgMgBIgiBDcDECACIARSDQpBoH8gAWvBQdAAbEGwpwVqQc4QbSIAQdEATw0HIABBBHQiAEGQ2MEAaikDACIEQv////8PgyICIANCIIgiEn4iB0IgiCIWIARCIIgiBiASfnwgBiADQv////8PgyIDfiIEQiCIIhd8IQsgB0L/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QRhsagsgA0EQaiQABUEACwsmAQF/QbXYwgAtAAAaQZgDQQgQ0AIiAARAIAAPC0EIQZgDEPACAAsmAQF/QbXYwgAtAAAaQcgDQQgQ0AIiAARAIAAPC0EIQcgDEPACAAslACAARQRAQcirwABBMhDmAgALIAAgAiADIAQgBSABKAIQEQgACx8BAn4gACkDACICIAJCP4ciA4UgA30gAkIAWSABEDMLHgEBfyMAQRBrIgEkACABQQhqIAAQlQIgAUEQaiQACyMAIABFBEBByKvAAEEyEOYCAAsgACACIAMgBCABKAIQEQYACyMAIABFBEBByKvAAEEyEOYCAAsgACACIAMgBCABKAIQEQsACyMAIABFBEBByKvAAEEyEOYCAAsgACACIAMgBCABKAIQESEACyMAIABFBEBByKvAAEEyEOYCAAsgACACIAMgBCABKAIQESMACyMAIABFBEBByKvAAEEyEOYCAAsgACACIAMgBCABKAIQESUACy8AIAAgAUEuRiAALQAEQQBHcjoABCAAKAIAIgAoAhQgASAAQRhqKAIAKAIQEQAACxkBAX8gASADRgR/IAAgAiABEPQCRQUgBAsLHwAgACgCAEGAgICAeHJBgICAgHhHBEAgACgCBBAUCwshACAARQRAQcirwABBMhDmAgALIAAgAiADIAEoAhARBQALEQAgACgCAARAIAAoAgQQFAsLIgAgAC0AAEUEQCABQZjuwQBBBRALDwsgAUGd7sEAQQQQCwtlAQJ/IwBBMGsiAiQAIwBBQGoiASQAAkACQCAABEAgACgCAA0BIABBADYCACABQQxqIABBNBD1AhogAiABQRBqQTAQ9QIaIAAQFCABQUBrJAAMAgsQ5wIACxDoAgALIAJBMGokAAsfACAARQRAQcirwABBMhDmAgALIAAgAiABKAIQEQAACx0AIAEoAgBFBEAACyAAQcSzwQA2AgQgACABNgIACxQAIAEgASAAIAAgAWMbIAAgAGIbCxQAIAAgACABIAAgAWMbIAEgAWIbCxwAIAEoAhRBxOjBAEELIAFBGGooAgAoAgwRAgALHAAgASgCFEHP6MEAQQ4gAUEYaigCACgCDBECAAsZACAAKAIUIAEgAiAAQRhqKAIAKAIMEQIACxcAIAAgAjYCCCAAIAE2AgQgACACNgIACxQAIABBFGoiACAAKAIAQQFq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DgAAAA0AAAAAAAAAAQAAAA8AAAANAAAAAAAAAAEAAAAPAAAADQAAAAAAAAABAAAADwAAAA0AAAAAAAAAAQAAABAAAAANAAAAAAAAAAEAAAARAAAAc3JjL2RhdGFtb2RlbC91dGlscy9hbGxvY2F0ZS5yc0ludmFsaWQgcG9pbnRlciB0eXBlIHJlcXVlc3RlZAAAAOALEAAfAAAAPwAAAA0AAABzdHJ1Y3QgUHJvamVjdFBhcmFtcyB3aXRoIDIgZWxlbWVudHMwDBAAJAAAABIAAAAIAAAABAAAABMAAABjb2x1bW5zbW9kZXNyYy9kYXRhbW9kZWwvZmllbGRfc3RvcmUvZmllbGRzL3RlbXBvcmFsLnJzAHcMEAAsAAAANgAAACwAAABJbnZhbGlkIHBvaW50ZXIgcmVjZWl2ZWQgZm9yIGdldF9kYXRhLCBleHBlY3RlZCBmNjQAdwwQACwAAAA+AAAAEgAAAHcMEAAsAAAATwAAACgAAABJbnZhbGlkIHBvaW50ZXIgc2V0IGZvciBpbmRpY2VzLCBleHBlY3RlZCBpMzIAAAB3DBAALAAAAHUAAAASAAAAdwwQACwAAAB8AAAAEgAAAHcMEAAsAAAAgQAAADAAAABJbnZhbGlkIHBvaW50ZXIgdHlwZSByZWNlaXZlZCBmcm9tIGFsbG9jYXRlX21lbW9yeSwgZXhwZWN0ZWQgZjY0dwwQACwAAACGAAAAEgAAAHNyYy9kYXRhbW9kZWwvb3BlcmF0aW9ucy9zZWxlY3Rpb24vc2VsZWN0LnJzuA0QACwAAACjAAAAMAAAAHNyYy9kYXRhbW9kZWwvZmllbGRfc3RvcmUvZmllbGRzL3dyYXBwZXJzL3RlbXBvcmFsLnJzAAAA9A0QADUAAAAnAAAAPAAAAPQNEAA1AAAAKQAAAEYAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93TA4QABwAAAAvVXNlcnMvbmFrc2hhdHJhLm0vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9oYXNoYnJvd24tMC4xNC41L3NyYy9yYXcvbW9kLnJzAHAOEABnAAAAVgAAACgAAABzcmMvZGF0YW1vZGVsL2ZpZWxkX3N0b3JlL3BhcnRpYWxfZmllbGRzL3BhcnRpYWxfZmllbGRfc3BhY2UucnMA6A4QAD8AAAA4AAAAIAAAAEludmFsaWQgcG9pbnRlciBzZXQgaW4gaW5kaWNlcywgZXhwZWN0ZWQgZjY0c3JjL3dyYW5nbGVycy9zdGFja19ieS5ycwAAAGQPEAAZAAAA5gAAAA4AAABkDxAAGQAAAO0AAAAOAAAAZA8QABkAAAD+AAAAMQAAAHNyYy9kYXRhbW9kZWwvZmllbGRfc3RvcmUvZmllbGRzL2Jpbm5lZC5ycwAAsA8QACoAAAA0AAAALAAAAEludmFsaWQgcG9pbnRlciByZWNlaXZlZCBmb3IgZ2V0X2RhdGEsIGV4cGVjdGVkIGY2NACwDxAAKgAAADwAAAASAAAAsA8QACoAAABNAAAAKAAAALAPEAAqAAAAWAAAACgAAABJbnZhbGlkIHBvaW50ZXIgc2V0IGZvciBpbmRpY2VzLCBleHBlY3RlZCBpMzIAAACwDxAAKgAAAF8AAAASAAAAsA8QACoAAABmAAAAEgAAALAPEAAqAAAAcwAAADAAAABJbnZhbGlkIHBvaW50ZXIgdHlwZSByZWNlaXZlZCBmcm9tIGFsbG9jYXRlX21lbW9yeSwgZXhwZWN0ZWQgZjY0sA8QACoAAAB4AAAAEgAAAHNyYy9kYXRhbW9kZWwvZmllbGRfc3RvcmUvZmllbGRzL3Jvd19pZC5ycwAAABEQACoAAAA0AAAALAAAAEludmFsaWQgcG9pbnRlciByZWNlaXZlZCBmb3IgZ2V0X2RhdGEsIGV4cGVjdGVkIGkzMgAAERAAKgAAADwAAAASAAAAABEQACoAAABLAAAAEgAAAAAREAAqAAAAUgAAABIAAAAAERAAKgAAAF8AAAAwAAAASW52YWxpZCBwb2ludGVyIHR5cGUgcmVjZWl2ZWQgZnJvbSBhbGxvY2F0ZV9tZW1vcnksIGV4cGVjdGVkIGkzMgAREAAqAAAAZAAAABIAAABfIy1zcmMvZGF0YW1vZGVsL2ZpZWxkX3N0b3JlL3BhcnRpYWxfZmllbGRzL2RpbWVuc2lvbl9wYXJ0aWFsX2ZpZWxkLnJzAAADEhAAQwAAADQAAAASAAAASW52YWxpZCBwb2ludGVyIEFkZGVyZXNzAxIQAEMAAABLAAAAEgAAAGNvbHVtbnNtb2Rlc3RydWN0IFByb2plY3RQYXJhbXN1bGxzcmMvZGF0YW1vZGVsL2ZpZWxkX3N0b3JlL2ZpZWxkcy9jb250aW51b3VzLnJzohIQAC4AAAA0AAAALAAAAEludmFsaWQgcG9pbnRlciByZWNlaXZlZCBmb3IgZ2V0X2RhdGEsIGV4cGVjdGVkIGY2NACiEhAALgAAADwAAAASAAAAohIQAC4AAABNAAAAKAAAAEludmFsaWQgcG9pbnRlciBzZXQgZm9yIGluZGljZXMsIGV4cGVjdGVkIGkzMgAAAKISEAAuAAAAXgAAABIAAACiEhAALgAAAGUAAAASAAAAohIQAC4AAAByAAAAMAAAAEludmFsaWQgcG9pbnRlciB0eXBlIHJlY2VpdmVkIGZyb20gYWxsb2NhdGVfbWVtb3J5LCBleHBlY3RlZCBmNjSiEhAALgAAAHcAAAASAAAASW52YWxpZCBwb2ludGVyIEFkZGVyZXNzc3JjL2RhdGFtb2RlbC9maWVsZF9zdG9yZS9wYXJ0aWFsX2ZpZWxkcy9tZWFzdXJlX3BhcnRpYWxfZmllbGQucnMAAAD8ExAAQQAAADwAAAASAAAAdHlwZXNyYy9kYXRhbW9kZWwvZmllbGRfc3RvcmUvc2NoZW1hL2ZpZWxkX3NjaGVtYV9vcGVyYXRpb25zLnJzc3VidHlwZWFnZ3JlZ2F0aW9uX2Z1bmN0aW9ubmFtZU5hbWUgbm90IGZvdW5kVBQQADsAAAAsAAAAEQAAAEFnZ3JlZ2F0aW9uIEZ1bmN0aW9uIG5vdCBmb3VuZAAAVBQQADsAAAAnAAAADgAAAFN1YnR5cGUgbm90IGZvdW5kAAAAVBQQADsAAAAeAAAADgAAAFR5cGUgbm90IGZvdW5kAABUFBAAOwAAABUAAAAOAAAAVHJpZWQgdG8gc2hyaW5rIHRvIGEgbGFyZ2VyIGNhcGFjaXR5QBUQACQAAAAvcnVzdGMvYWVkZDE3M2EyYzA4NmU1NThjMmI2NmQzNzQzYjM0NGY5Nzc2MjFhNy9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzbBUQAEwAAADPAQAACQAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdCIAAAAMAAAABAAAACMAAAAkAAAAJQAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAJgAAAAAAAAABAAAAJwAAAC9ydXN0Yy9hZWRkMTczYTJjMDg2ZTU1OGMyYjY2ZDM3NDNiMzQ0Zjk3NzYyMWE3L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwDEFhAASwAAADMKAAAOAAAAL3J1c3RjL2FlZGQxNzNhMmMwODZlNTU4YzJiNjZkMzc0M2IzNDRmOTc3NjIxYTcvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwAgFxAATwAAAA4GAAAUAAAAIBcQAE8AAAAOBgAAIQAAACAXEABPAAAAAgYAABQAAAAgFxAATwAAAAIGAAAhAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikAAADEFhAASwAAAHQFAAANAAAAIBcQAE8AAACPBAAAJAAAAEVPRiB3aGlsZSBwYXJzaW5nIGEgbGlzdEVPRiB3aGlsZSBwYXJzaW5nIGFuIG9iamVjdEVPRiB3aGlsZSBwYXJzaW5nIGEgc3RyaW5nRU9GIHdoaWxlIHBhcnNpbmcgYSB2YWx1ZWV4cGVjdGVkIGA6YGV4cGVjdGVkIGAsYCBvciBgXWBleHBlY3RlZCBgLGAgb3IgYH1gZXhwZWN0ZWQgaWRlbnRleHBlY3RlZCB2YWx1ZWV4cGVjdGVkIGAiYGludmFsaWQgZXNjYXBlaW52YWxpZCBudW1iZXJudW1iZXIgb3V0IG9mIHJhbmdlaW52YWxpZCB1bmljb2RlIGNvZGUgcG9pbnRjb250cm9sIGNoYXJhY3RlciAoXHUwMDAwLVx1MDAxRikgZm91bmQgd2hpbGUgcGFyc2luZyBhIHN0cmluZ2tleSBtdXN0IGJlIGEgc3RyaW5naW52YWxpZCB2YWx1ZTogZXhwZWN0ZWQga2V5IHRvIGJlIGEgbnVtYmVyIGluIHF1b3Rlc2Zsb2F0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VANfdyYyvZwUYpN3sH7sw5k6yHdcnuc0QEn+d/nCECHI7TJ4uPNUKTqpZ3ilMKqziJOdeGdeSnA1fNJ4AfZczEIbB3mCM3R/E+I8eTGgqC9MDXJ5PciSO5+QpnlNencKxzTceXCsimb8oBF6jFctgDsJRnpvrThgiot7emVsI3w2N7F6f0csGwSF5XpeWfchReYae9uXOjXrz1B70j2JAuYDhXtGjSuD30S6e0w4+7ELa/B7XwZ6ns6FJHz2hxhGQqdZfPpUz2uJCJB8OCrDxqsKxHzH9HO4Vg35fPjxkGasUC99O5cawGuSY30KPSGwBneYfUyMKVzIlM59sPeZOf0cA36cdQCIPOQ3fgOTAKpL3W1+4ltASk+qon7actAc41TXfpCPBOQbKg1/utmCblE6Qn8pkCPK5ch2fzN0rDwfe6x/oMjrhfPM4X91bGxydWVhbHNlL1VzZXJzL25ha3NoYXRyYS5tLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvc2VyZGVfanNvbi0xLjAuMTMzL3NyYy9yZWFkLnJzgiUQAGYAAACgAQAARQAAAIIlEABmAAAApQEAAD0AAACCJRAAZgAAAK0BAAAaAAAAgiUQAGYAAAD6AQAAEwAAAIIlEABmAAAAAwIAAD4AAACCJRAAZgAAAP8BAAAzAAAAgiUQAGYAAAAJAgAAOgAAAIIlEABmAAAAVgIAABMAAACCJRAAZgAAAGgCAAAZAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAABAAIAAwAEAAUABgAHAAgACQD//////////////////woACwAMAA0ADgAPAP////////////////////////////////////////////////////////////////////8KAAsADAANAA4ADwD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AABAAIAAwAEAAUABgAHAAgACQAP//////////////////oACwAMAA0ADgAPAA/////////////////////////////////////////////////////////////////////6AAsADAANAA4ADwAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////y9ydXN0Yy9hZWRkMTczYTJjMDg2ZTU1OGMyYjY2ZDM3NDNiMzQ0Zjk3NzYyMWE3L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL21hcC9lbnRyeS5yc3gqEABgAAAAcAEAADYAAABhc3NlcnRpb24gZmFpbGVkOiBpZHggPCBDQVBBQ0lUWS9ydXN0Yy9hZWRkMTczYTJjMDg2ZTU1OGMyYjY2ZDM3NDNiMzQ0Zjk3NzYyMWE3L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25vZGUucnNhc3NlcnRpb24gZmFpbGVkOiBlZGdlLmhlaWdodCA9PSBzZWxmLmhlaWdodCAtIDEACCsQAFsAAACvAgAACQAAAAgrEABbAAAAswIAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBzcmMubGVuKCkgPT0gZHN0LmxlbigpCCsQAFsAAAAvBwAABQAAAAgrEABbAAAArwQAACMAAAAIKxAAWwAAAO8EAAAkAAAAYXNzZXJ0aW9uIGZhaWxlZDogZWRnZS5oZWlnaHQgPT0gc2VsZi5ub2RlLmhlaWdodCAtIDEAAAAIKxAAWwAAAPADAAAJAAAAL3J1c3RjL2FlZGQxNzNhMmMwODZlNTU4YzJiNjZkMzc0M2IzNDRmOTc3NjIxYTcvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnMAVCwQAF8AAABZAgAAMAAAAC9ydXN0Yy9hZWRkMTczYTJjMDg2ZTU1OGMyYjY2ZDM3NDNiMzQ0Zjk3NzYyMWE3L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25hdmlnYXRlLnJzAMQsEABfAAAAxwAAACcAAADELBAAXwAAABcCAAAvAAAAxCwQAF8AAACiAAAAJABB8NrAAAuZAVRyaWVkIHRvIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0eXAtEAAkAAAAL3J1c3RjL2FlZGQxNzNhMmMwODZlNTU4YzJiNjZkMzc0M2IzNDRmOTc3NjIxYTcvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc5wtEABMAAAAzwEAAAkAAABpbmYtaW5mTmFOAAAAAAAAAQBBl9zAAAvRKiCamZmZmZmZmZmZmZmZmZkZFa5H4XoUrkfhehSuR+F6FN4kBoGVQ4ts5/up8dJNYhCW1AloImx4eqUsQxzr4jYaq0Nuhhvw+WGE8GjjiLX4FCI2WDhJ88e0No3ttaD3xhBqI43ADlKmh1dIr7ya8tcaiE/XZqVBuJ/fOYww4o55FQemEh9RAS3mspTWJugLLhGkCVHLgWiu1re6vdfZ33wb6jqnojTt8d5flWR54X/9FbvIhej28Cd/GRHq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dHNlcXVlbmNlbWFwZW51bXVuaXQgdmFyaWFudG5ld3R5cGUgdmFyaWFudHR1cGxlIHZhcmlhbnRzdHJ1Y3QgdmFyaWFudACUWBAAAAAAAC4wAAA1AAAACAAAAAQAAAA2AAAANwAAADUAAAAIAAAABAAAADgAAABhIHN0cmluZ3U4dXNpemUAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAA5FkQAAAAAABlbnRpdHkgbm90IGZvdW5kcGVybWlzc2lvbiBkZW5pZWRjb25uZWN0aW9uIHJlZnVzZWRjb25uZWN0aW9uIHJlc2V0aG9zdCB1bnJlYWNoYWJsZW5ldHdvcmsgdW5yZWFjaGFibGVjb25uZWN0aW9uIGFib3J0ZWRub3QgY29ubmVjdGVkYWRkcmVzcyBpbiB1c2VhZGRyZXNzIG5vdCBhdmFpbGFibGVuZXR3b3JrIGRvd25icm9rZW4gcGlwZWVudGl0eSBhbHJlYWR5IGV4aXN0c29wZXJhdGlvbiB3b3VsZCBibG9ja25vdCBhIGRpcmVjdG9yeWlzIGEgZGlyZWN0b3J5ZGlyZWN0b3J5IG5vdCBlbXB0eXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZmlsZXN5c3RlbSBsb29wIG9yIGluZGlyZWN0aW9uIGxpbWl0IChlLmcuIHN5bWxpbmsgbG9vcClzdGFsZSBuZXR3b3JrIGZpbGUgaGFuZGxlaW52YWxpZCBpbnB1dCBwYXJhbWV0ZXJpbnZhbGlkIGRhdGF0aW1lZCBvdXR3cml0ZSB6ZXJvbm8gc3RvcmFnZSBzcGFjZXNlZWsgb24gdW5zZWVrYWJsZSBmaWxlZmlsZXN5c3RlbSBxdW90YSBleGNlZWRlZGZpbGUgdG9vIGxhcmdlcmVzb3VyY2UgYnVzeWV4ZWN1dGFibGUgZmlsZSBidXN5ZGVhZGxvY2tjcm9zcy1kZXZpY2UgbGluayBvciByZW5hbWV0b28gbWFueSBsaW5rc2ludmFsaWQgZmlsZW5hbWVhcmd1bWVudCBsaXN0IHRvbyBsb25nb3BlcmF0aW9uIGludGVycnVwdGVkdW5zdXBwb3J0ZWR1bmV4cGVjdGVkIGVuZCBvZiBmaWxlb3V0IG9mIG1lbW9yeW90aGVyIGVycm9ydW5j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bXQvbnVtLnJzANB1EAAbAAAAaQAAABcAAAAweDAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAKGAQABsAAADyBQAAHwAAAGZhbHNldHJ1ZQAAAChgEAAbAAAANQkAABoAAAAoYBAAGwAAAC4JAAAiAAAAcmFuZ2Ugc3RhcnQgaW5kZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIER3EAASAAAAVncQACIAAAByYW5nZSBlbmQgaW5kZXggiHcQABAAAABWdxAAIgAAAHNsaWNlIGluZGV4IHN0YXJ0cyBhdCAgYnV0IGVuZHMgYXQgAKh3EAAWAAAAvncQAA0AAABsaWJyYXJ5L2NvcmUvc3JjL3N0ci9wYXR0ZXJuLnJzANx3EAAfAAAARgUAABIAAADcdxAAHwAAAEYFAAAoAAAA3HcQAB8AAAA5BgAAFQAAANx3EAAfAAAAZwYAABUAAADcdxAAHwAAAGgGAAAVAAAAWy4uLl1iZWdpbiA8PSBlbmQgKCA8PSApIHdoZW4gc2xpY2luZyBgYFF4EAAOAAAAX3gQAAQAAABjeBAAEAAAAHN4EAABAAAAYnl0ZSBpbmRleCAgaXMgbm90IGEgY2hhciBib3VuZGFyeTsgaXQgaXMgaW5zaWRlICAoYnl0ZXMgKSBvZiBgAJR4EAALAAAAn3gQACYAAADFeBAACAAAAM14EAAGAAAAc3gQAAEAAAAgaXMgb3V0IG9mIGJvdW5kcyBvZiBgAACUeBAACwAAAPx4EAAWAAAAc3gQAAEAAABsaWJyYXJ5L2NvcmUvc3JjL3N0ci9tb2QucnMALHkQABsAAAAMAQAALAAAAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS9wcmludGFibGUucnMAAABYeRAAJQAAABoAAAA2AAAAWHkQACUAAAAKAAAAKwAAAAAGAQEDAQQCBQcHAggICQIKBQsCDgQQARECEgUTERQBFQIXAhkNHAUdCB8BJAFqBGsCrwOxArwCzwLRAtQM1QnWAtcC2gHgBeEC5wToAu4g8AT4AvoD+wEMJzs+Tk+Pnp6fe4uTlqKyuoaxBgcJNj0+VvPQ0QQUGDY3Vld/qq6vvTXgEoeJjp4EDQ4REikxNDpFRklKTk9kZVy2txscBwgKCxQXNjk6qKnY2Qk3kJGoBwo7PmZpj5IRb1+/7u9aYvT8/1NUmpsuLycoVZ2goaOkp6iturzEBgsMFR06P0VRpqfMzaAHGRoiJT4/5+zv/8XGBCAjJSYoMzg6SEpMUFNVVlhaXF5gY2Vma3N4fX+KpKqvsMDQrq9ub76TXiJ7BQMELQNmAwEvLoCCHQMxDxwEJAkeBSsFRAQOKoCqBiQEJAQoCDQLTkOBNwkWCggYO0U5A2MICTAWBSEDGwUBQDgESwUvBAoHCQdAICcEDAk2AzoFGgcEDAdQSTczDTMHLggKgSZSSysIKhYaJhwUFwlOBCQJRA0ZBwoGSAgnCXULQj4qBjsFCgZRBgEFEAMFgItiHkgICoCmXiJFCwoGDRM6Bgo2LAQXgLk8ZFMMSAkKRkUbSAhTDUkHCoD2RgodA0dJNwMOCAoGOQcKgTYZBzsDHFYBDzINg5tmdQuAxIpMYw2EMBAWj6qCR6G5gjkHKgRcBiYKRgooBROCsFtlSwQ5BxFABQsCDpf4CITWKgmi54EzDwEdBg4ECIGMiQRrBQ0DCQcQkmBHCXQ8gPYKcwhwFUZ6FAwUDFcJGYCHgUcDhUIPFYRQHwYGgNUrBT4hAXAtAxoEAoFAHxE6BQGB0CqC5oD3KUwECgQCgxFETD2AwjwGAQRVBRs0AoEOLARkDFYKgK44HQ0sBAkHAg4GgJqD2AQRAw0DdwRfBgwEAQ8MBDgICgYoCCJOgVQMHQMJBzYIDgQJBwkHgMslCoQGAAEDBQUGBgIHBggHCREKHAsZDBoNEA4MDwQQAxISEwkWARcEGAEZAxoHGwEcAh8WIAMrAy0LLgEwAzECMgGnAqkCqgSrCPoC+wX9Av4D/wmteHmLjaIwV1iLjJAc3Q4PS0z7/C4vP1xdX+KEjY6RkqmxurvFxsnK3uTl/wAEERIpMTQ3Ojs9SUpdhI6SqbG0urvGys7P5OUABA0OERIpMTQ6O0VGSUpeZGWEkZudyc7PDREpOjtFSVdbXF5fZGWNkam0urvFyd/k5fANEUVJZGWAhLK8vr/V1/Dxg4WLpKa+v8XHz9rbSJi9zcbOz0lOT1dZXl+Jjo+xtre/wcbH1xEWF1tc9vf+/4Btcd7fDh9ubxwdX31+rq9/u7wWFx4fRkdOT1haXF5+f7XF1NXc8PH1cnOPdHWWJi4vp6+3v8fP19+aQJeYMI8f0tTO/05PWlsHCA8QJy/u725vNz0/QkWQkVNndcjJ0NHY2ef+/wAgXyKC3wSCRAgbBAYRgawOgKsFHwmBGwMZCAEELwQ0BAcDAQcGBxEKUA8SB1UHAwQcCgkDCAMHAwIDAwMMBAUDCwYBDhUFTgcbB1cHAgYXDFAEQwMtAwEEEQYPDDoEHSVfIG0EaiWAyAWCsAMaBoL9A1kHFgkYCRQMFAxqBgoGGgZZBysFRgosBAwEAQMxCywEGgYLA4CsBgoGLzFNA4CkCDwDDwM8BzgIKwWC/xEYCC8RLQMhDyEPgIwEgpcZCxWIlAUvBTsHAg4YCYC+InQMgNYaDAWA/wWA3wzynQM3CYFcFIC4CIDLBQoYOwMKBjgIRggMBnQLHgNaBFkJgIMYHAoWCUwEgIoGq6QMFwQxoQSB2iYHDAUFgKYQgfUHASAqBkwEgI0EgL4DGwMPDWxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnMcfxAAKAAAAFAAAAAoAAAAHH8QACgAAABcAAAAFgAAAGxpYnJhcnkvY29yZS9zcmMvZXNjYXBlLnJzXHV7AAAAZH8QABoAAAA4AAAACwAAAGR/EAAaAAAAZgAAACMAAABsaWJyYXJ5L2NvcmUvc3JjL251bS9iaWdudW0ucnMAAKR/EAAeAAAArAEAAAEAAABhc3NlcnRpb24gZmFpbGVkOiBub2JvcnJvd2Fzc2VydGlvbiBmYWlsZWQ6IGRpZ2l0cyA8IDQwYXNzZXJ0aW9uIGZhaWxlZDogb3RoZXIgPiAwAABa1juS1lP07j87oQYpqj8R+GVlG2a0WJUHxSSkWcrHSna/PqJ/4a66SfYtDfC8eV1Tb86K35la6dxzeRAsLNj0lAXBtiug2JFp6EuKmxsHeflGcaQ2yE62hOLebILiSJe3mI1NRHri4yWbFggjGxv9cn94sGqMbY73IA7l9fAw/k+fllyF7wiyNalRXjMtvb0jR7yzZiuL3oIT5jWAeCytdqxVMCD7FosxzK8hUMs7TJMXazzoudytPb8bKiS+St943YVLYuhT2Q2vojStbR3Xa6ozbz1x1IdoreVAjGRyhgaVAMuMjcmpwhgfUa/9DmhIusD97/A71PLeZiUbvRICbXSY/pV2pYRXS2D3MLZLAYiRPn471M6lLV44Nb2jnkHqNc5dSolCz7l1hoKsTAZSsuGges6ViYGTCZTR6+9Dcx8aSRlC++uh+Av5xebrFBCmYJufEvpmyvZOd3fgJhrU0DiCR5e4AP20IlWVmLAgiYJjsYxecyCesDVVXV9utFVivN0vNpCoxR2DqjT3iSHreyvVu0O0EvfkI9UBdezppS07ZVWqsGuabjYlIckzskf4ib7q1JwGwQqEbmm7wJ6ZdixuJQpESPENJcpD6nAGwMrbZFeGKs2WKFdeapIGBDi8Ej7tJ3WAvPLs9QQ3CAXGa5eN6HGSoOsuaDPGREqG96N+WDGHW0STHSHg+2rus3pMnq79aHIVuGQp2LoF6mBZ30UaPQPPGua9M44phyS5b6trMAZiwdCPVuD4edS206WWhryHuvHEs2wYd5iJpEiPPKirKSkutuCH3pT+q80aMyVJC7rZ3HGMFAsdf4vA8J9vG44oEFSOr9lN5F6u8OwHSqKxMhTpcdtQYZ322SzoyW4Fr5+sMSeJ0lwiOggcMb7KxprHF/5wqwb0qkgKY71tfXiBuZ09TdYIsdXazLssCU7r8JOCRvCFpY7FCGD1uyUhJu04I1hsp07y9gq48iqvqm8oByxuR9HhrrQNZq/1GspFeYTbpMyCTe2QyJ+N2VA8l5dlEs5/o6AotboH8Q/lDH39/pbBX8zIcmKpSe1THk/cvL78sXf/eg+7E5zo6CWxCTb3Pc+qn6zpVIxhkbF3HYwDdQ2DlccXJGrvufWd1SVvRNLQ43r5Ha1EayhzBUt3xWqDYs7smzLsCkP5Z+NO1XZFJPsB6MI/p82T90GcIorUVu15AqLzDxHBeHVSQ2vWRFY0jEFFmKmqeGuJEwqDDNZrQe+RVr5T1VbGa5jMI4/LxhFrNuztqIrst4a+vyw5PxzrAqKzlKnW8zIU1/d7B0/jpYOK4LlTzLA/2cz12skiXI8krVjoaP+cjw9As9G+lZnZNmw3kaEfwrkJCBAjLfv/j0RHhbWKpzIoDArUq/n5/7MVmebibFE/Mo8MyRY7/H+QrR/QjeOSZ3/Zpz2uSvuf9JgnRLGcd0HfzxHNmR36xzF/MZXdg9UR10NWQEBS/Bx/7z59inIla2bqNShIZjvkXquOHK3P7gUAZUMy2kBKnTZWsmPYgmoHQD7UvpBoTiLidU8+h5GiBOimRHdaAuKqWlPjDak2ywWi0BUVcYOaVTEoXFHTAz6HykRbWg2RgNUemdkShMKGlP4KeVjotuCKZv+PF6VyqDm+TZduYuOYLUD/c13OjxLILSE9CvuOfxyIf2j6gJkLnbw0ZuZ8cp8jap8COaGATsTrwf8fHE6HrERHQ4fJIGK1ZrL/J6MiqdcVGRTp+6i6YgCf//FLtcmmrY+scZ2ptD1gwz93byJ8EJmzF87E0yFNOLQPVcsrm1R/oJ0B9khqYEahUyp+++CUT4QCwZltQvzLRHTaLjkZemMlQzHACFP7/lURkfqIn1i87pM98Monun6rVTV5tWO3NXV8JpbeWDQvi1XBS6I8JYOSG7C7Fm8B++2qsZ7Li+4jdyKc6tzKwXmpFV5GXxd1doqVoZLJHhnsic36CzZdEhTt+km3e2YfZ+yA+c6E9BZZqHkc5RpA54An4beC0liuNwnMMY8QiJCwuOyy0QfvmYULP/6yFaq03OanH4bJagBnzs6935rU4ZPgkadnvUJgAEGh1ovgJG1cLLvI4G1TeECRScyuGG6Ic/fp+lhIaJaQ9Vt/2p6JalB1pDmvLQFeenmZj4gDlkJSyQaEbXiB9djXf7OqgzvTpnsI5cjW4TLPzV9g1WQKiJCaSh77Js1/oeA7XIV/BlWaoO7yXG/A38nYSrOmHkjqwEiqL/SLsFf8jh1g0CbaJPHalDvxV862XXkSPIJYCLfWCD3Fdu2BJLUXF8uibspkDEuMdlRoom2i3dx9ywn9fc9dL5SpAgsJCxVUXf5MfF1DNTv50+Gm5SaNVPqer20aSgHFe8SaEJ9wsOm4xhsJoZxBtpo1wNTGjBwkZ/hiS8kD0mMBw/hE/NeRdkCbHc9dQmPe4Hk2VvtNNpQQwuRC9RL8FVmYxCt64UO5lPKdk7IXe1tvPlpb7GzK85yXQpzP7iyZBacxcicIvTCEvVODgyp4/8ZQvU4xSuw85ewoZCQ1Vr/4pDbRXq4TRg+Umb424ZV3G4eEhfaZmBcTuT9uhFl7VeIo5SZ0wH7dV+fPieUv2uoaM0+YSDhv6paQIXbvXcjS8D9jvloGC6W8tKlTa3V6B+0P+23xx03O6+GUKMYSWUno073k9pzwYDONXNm7q9ctcWTsnTTELDmAsLPPqpZNeY29Z8VB9XdHoNygg1X8oNfw7GAbSfmqLOSJRHK1ncSGFvQ5Ypu31TddrNXOIsV1KBwxxzqCJcuFdNeLgms2kzJjfbxkcfee06iGlzEDApz/Xa7rvU21hghTqPz9gwKDf/XZZi2hYqjKZ9J7/STDY99y0GC8pD2p3oCDbR73WZ7LR0J46w2NUxZhpAjmdPCFvtlSVmZRcOhbec2LH5JsJy6QZ/bfMkZx2WuAtlPbo9gcugDzl7+Xzc+GoKQo0swOpOiA8H2v/cCDqMjNsgaAEs0iYWxdGz2xpNL6gV8IIFeAa3ljGjHG7qbDnLA7BXQ2MOPL/GC9d6qQ9MOcigYRRPzbvju5rBXVtPH0RC1IFVX7ku7F84stBREXmUocTS0V3Rt1tvDueEbVXL9dY6B4WtRi0uSsKheYCjTvNHzIFnGJ+4YOrHoOn4aAlaBNPa7mNV3UElcZ0kao4LoJocxZYIN0idesn4ZY0pjpS8k/cDik0SsGzCNUd4P/kc/dJ0ajBmN7CL8sKVVkf7ZC1bEXTMg7Gsrud3NqPR/kk0qeHV+6yiA+9SqIYoaTjpzugnJ7tH5UjbI1KvtnOLJDqiNPmmGe6TEfw/T5gcbe1JTs4gD6BWR+8/k4PBE8iwTd041AvIPeXnA4R4sVC65F1EixUKsklnaMBhnu2o3ZVwmb3STWrTvJF6TP1Kj4h9blgArXpUzlvB2NAwrT9qlMHyHNTM+fXitlcITMh3TUH2dpACDDR3Y7P8bS39TIhHPgQQD02ewpCc93xxcK+6WQWFIAcRBo9MzCVbmdzHnPtO5mQI0UgnG/mdWT4h+sgTBVQEjYTPHGLwDLONsnF6J8alBaDqCtuDvA/QbS8ZzKHIXk8BEI2aZKML2IRi5E/WOmHW0WSo+QLj52FeycSp7+hzIETo5ZmrrN0xonRN3F/Sk/heHx70AowYjhMJVU93z0juZZ7ivRuXj1jD7dlJrOWBkw+HS7gufWMjCOFDrBAa8fPDZSauOhjD+8sZmI8cGaJ8vD5kTc5benFQ9g9Za5wPheOhCrKd6lEdsSuLK85/C29kjUFXRWD9aRF2bf6yGtZDRbSRsRlcklu86fa5M07L4A2Q2xyvs772nCh0a4QqfuQE9RXT36CmsEsylY5hJRKhGjpbQM3ObC4g8a94+rcrrqhefwR5Ogc9uT4PSzVg9pZWch7Vm4iFDSuBjy4CxTwz7BaWgwc1Vyg3NPl4z7EzrHGEJBHs/qTmRQI72v+pgI+Z6S0eWDpWJ9JGys2zm/SrdG90XfcqddzpbDS4mDt44yjLqLa08R9YF8tJ6rZGUyPy+pbgaiVXKim2GG1r3+/g57UwrIhXWHRQH9E4Y2X1/pLHQGvedS6ZZB/JinBDe3IzgRSCygp6P8UTt/0cUEpSyGFVr3xEjmPROF74L7Iufbc02YmvXaXw1YZqujuuvg0tBgPsGz0bcQ7j+WzKgmmQcF+Y0xH8bllOnPu/9ScH9JRnfx/dObD/3xYdWfM6bv7Yvqtv7IglN8brrKx8CPa+kupWT+e2NoGwppvfmwc8ajes79PS0+IVGmYRacTghcpgyhvga4jWnlD/obw2IK889PSW5IJvHD3pP44vP6zO/Do9uJWrd2Omtc222YHOB1WkYplvhlFAmGM1KJviNYE/GXs7v2f1mLZ8CmK+4sLljtfaBqdO8Xt0A4SNuU3BxXtE6kwqjr3eRQRhoSuhPkbGFiTfOSZhUe5deglugXHcj5uiCwd2DNMu+GJF6RLhId3HQUzgq4gP+qqK21tbpWJBOSmYEN5mC/1RIZI+NpbO2X9v/hEI+cl8Wr7/WNwWP0Hvo/jcqzg/22lmtzsbJ8sab4jzC9oOS8ZHxG0N3e213Q9rN8rOQO9r4NLKKKa6k6QnrwzWudkrMuEbdKrcZTydKYbMGGRHdgetVkndi3qHsHv8dx6ItKfGwFX2KHckmtZNccRxEtXZvHxvY6qc+b2D0N5JjVeTSCeXi0idPDwk6NEB3/Sstg8UvLEDaEujlRWCpy387+uO0e/pRDpSiIZe60TpfCPieppj16lM4y6v4pYiI9c4e4KYhmzByBX1I/Wn01BgioJjQqgP9jofcmz7DcwgfKUjDBNGD/vMm18ALdk7OJ/Gd88UE4Pyz84qxD1HggrLvA7TYpg6ebnQ1MqoRLlEvVMamE82ORAsUR39RlXnmeCn3TZfC8NUP21RZK/7UXRk0upD8WlgHqmUVOjr/RzktQOY3Pm/uBZMDW4XEvhsJe5Ihww4J6on3wTFpOuydzdl1VJrqRjIVOlm/4ENX4B2o66q8otu8m4ruLNlUK94kEieXbsqOrsNrqLoTqzHSsRStvyU9Ga67Ikp2SEgDJiws7y7vjFwbaerdENxdAu27OCb2q3J2HkFnlFQUdEGoKQsy26qnCVPpXjy0jEkqCRqmfZGVU8+n4LbP5q5bcIpiTR71+KXAkd/nf91a8kyt+eFk27xnGdur7i1q2VTzbTutXA2ugdxTl+q7xI2sLkiLm7cSFiJVZnrna7exFjjarX+mbU3X99wK0iBS06xgCy9sRgajS/LUD4aoZoSafwr1S1qJSB3yjRJnVX0nwRjNt50ulk4Qt5sp/hdstVgxApHBvjrjluJ+936ZSuWsPUM1My7ImH6cHrZfQp6dGE6QAIH4veHPIJMxegsgoDIxmANSOO1aQ+i1/9qL6Mg8vgACJcsprNHn5HrTLuf/SOqBAK0+8hoHXtyah/qi/h0nIEPbiNvSw5jK4JJ/J1/QtfcrZDUMxXaA/5u3Guw1yeRw9UJGUfXSIz1+p+CqRzpdjTKR1fM5IteHbaZu6GuE+vq+GyRsCmyLaUkTCaGGZzq1b6PuiwkGrkGfV8sO5P0KZcuL6pRkJa7pgxZca1GfJn4fN3A9gywXpuLa9IMnBu4fpAFQTOD5HI2ck7Wg7sqrpIwEpC+OGDHbANpQhZa8Kcrag+c6bqI+TcES5aT5bjQ7kCPjCwpJzuIyV5wQOsjASHQu2ubk7SPN3vZDCSG9eK/LGsSioShrw1ey08xoLNrauOB4yUt0gbAso4rDhjcNj2sYlX1OKlCMHWY0OrThafkicVzforHnsSK+wUdjG8J1agy1EIhiYJxvb3GWO+GxFMeT4axUPv/jwCIr/WBtky56OG8Xa0u42LYusPy8iPX5GcuJ3kYeqhPit1w+7aswd2A5b6rqU6lK7zIbptMKfEkfpmKXpOaUn6n+oJGKzR9eYIz8OZIiOseSf0q06oBkNf+yOiT4V+e7uo4OsJAQwaM9TGSuOWreq6oyk1y0FPELDqF+2MTFlVSWwzU15BssS9JI3Eb8+X1UXjoDQC+S+i9i74tZuDrcqnbGgxA6drq7OaluLCtJkdQTeyHVSRFpagkXyLo0GvpKFFfsSZ9Xw8OLW7j0YxLZ7c+2ca2CFltZNRlVMHnWkWtAoxIa4JjxM4Zeq32WSTXEEM/WoZjBLn9k91at/e9DG4j+ZKUD+jgOoRuWWX5qEeNuPvzPQvXIEUpjefPfApVbSc+9ARG2PhWY+lq2amCd2Y6iVqEqkeRMA591ZwX6xU3wSu1JdDVgYwGBVr3HenWgb1+mmtBBuHvC4qg0Hq2IhcSaS6HDKBBOWs8rRyFW7aQ2wtiIN/cWXe2A9BTsrKsQQXORqUHy3fZq4jOMEW5p6irmOQrKtko5g83ccxvFAGe1nstMeWTeyOPBVozcukV/oAd+IZi/F3kZsa8bivLo7MWGLFaA9O0usIyN3G2ypin05rhoIDQpel+yrVSLHU+3cx9khSpCMNb3nlnV1XFQU6hyIVC7ad0HWUH7SknNpmSQkqum50NXRC+Xdh3fQw78trdRk6ERLxk5elbRKYtqXPOyEPhEL7zvxWr1h3frQvUsnpo7VzeqKrbHsupQ5Ra0esc/ySoGl7RjeZ/T8Q0sss86B185wh5TP6oAx/BRe919Coo0CTal5gyWhPjuaNfX30sowQ6ATWORuCQ3KAIPytYf9/FOIGG6dyotIfuCRt9F0nn40Vc9kol532p1YdiUGEsaegSoD/ko2lVHF7tOuh5b3BSL1g73dgzpSO3VEzRS+mkM1eXKWapLEJ4qSlQCabcGUghcPPAW3dbEs97qAAMnxOWPdEovGJFPue9p0UKAdlwReyusW/PbT6hoRkmQI5byF9bymHLv0iKVhlbZ9Sh7s5jJs0OPpMSsHXR2Sju6Sk9CfQ2IuMv86SbSkNjKqd7jDh9T6uf6+CVvhTcS+lJXmtKmJeWi+LkzZrLA693wdkBEK9ksBN50PD9hcCTXcJLSVjPOewYSEUxMOtEtCEy7hum+wBvKlZSjLiFBvCcy8jNRFLkS3hz/5/qokywv/669J1zkVpWmP977V7b3O/ubbHE2IWg5Ec7WXpbQ2QV9wiTEwlfiICmgx/M5hhBF3zKs+fLo2Kw3C/bxCeuXVlL/WTRtpBHaQMj21aWyvBb03hhCxwcJJmj+mI4RHG0esxadUHXIz3IDPDytlGeJYF7fRqaROQBNhw9M730+Nl24Sg+omMQisHFpkCtejcD0K16OkcD0K16NwPczMzMzMzMzMzczMzMzMzMwAAAAAAAAAgABBn6vCAAsBoABBr6vCAAsByABBv6vCAAsB+gBBzqvCAAsCQJwAQd6rwgALAlDDAEHuq8IACwIk9ABB/avCAAsDgJaYAEGNrMIACwMgvL4AQZ2swgALAyhr7gBBrazCAAsD+QKVAEG8rMIACwRAt0O6AEHMrMIACwQQpdToAEHcrMIACwQq54SRAEHrrMIACwWA9CDmtQBB+6zCAAsFoDGpX+MAQYutwgALBQS/yRuOAEGbrcIACwXFLryisQBBqq3CAAsGQHY6awveAEG6rcIACwboiQQjx4oAQcqtwgALBmKsxet4rQBB2a3CAAsHgHoXtybX2ABB6a3CAAsHkKxuMniGhwBB+a3CAAsHtFcKPxZoqQBBia7CAAupKqHtzM4bwtMAAAAAAAAAAKCEFEBhUVmEAAAAAAAAAADIpRmQuaVvpQAAAAAAAAAAOg8g9CePy84AAAAAAAAAAIQJlPh4OT+BAAAAAAAAAEDlC7k21wePoQAAAAAAAABQ3k5nBM3J8skAAAAAAAAApJYigUVAfG/8AAAAAAAAAE2dtXArqK3FnQAAAAAAACDwBeNMNhIZN8UAAAAAAAAobMYb4MNW34T2AAAAAAAAMsdcEWw6lgsTmgAAAAAAQH88sxUHyXvOl8AAAAAAABCfSyDbSLsawr3wAAAAAADUhh70iA21UJl2lgAAAACARBQTMetQ4qQ/FLwAAAAAoFXZF/0l5RqOTxnrAAAAAAirz12+N8/QuNHvkgAAAADlyqFarQUDBSfGq7cAAABAnj1K8RnHQ8awt5blAAAA0AXNnG1vXOp7zjJ+jwAAAKIjAILki/PkGoK/XbMAAICKLICi3W4wnqFiLzXgAAAgrTcgC9VF3gKlnT0hjAAANMwi9CZF1pVDDgWNKa8AAEF/K7Fwlkx71FFG8PPaAEARX3bdDDwPzSTzK3bYiADIavtpCoilUwDu77aTDqsAekV6BA3qjmiA6aukONLVgNjWmEWQpHJB8HHrZmOjhVBHhn8r2qZHUWxOpkA8DKck2WdftpCQmWUH4s9QS8/Qbc9B9+O09P+fRO2BEo+BgqQhiXoO8fi/x5VoItfyIaMNaisZUi33rzm7AuuMb+rLkER2n6b49JsIasMlcAvl/rTVU0fQNvICRSKaFyYnT5+QZZQsQmLXAdaqgJ3v8CLH9X65t9I6TUKL1eCEK63r+LLep2WHieDSd4UMMztMk5sv64if9FXMY9Wmz/9JH3jC+yVrx3FrvzyKkMN/HCcW83rvRTlORu+LVjraz3HY7Zestcvj8It1l+zI0EOOTum9F6O+HO3uUj0n+8TUMaJj7d1L7mOoqqdM+Bz7JF9FXpRq73Q+qcrojzbkOe621nW5RCsSjlP94rNEXcipZEzT5xa2lnGovNtgSjod6r4P5JDNMf5G6VWJvN2IpKSuEx21Qb69mGOrq2sUq81Nmlhk4tEt7X48lpbG7IqgcGC3fo2iPFTP5R0e/KityIw4Zd6wy0spQ1+lJTsS2fqvhv4V3b6e8xO3Du9Jq8f8LRS/LYo3Q3hsMmk1bpb5eznZLrmsBFSWB3/Dwkn799qHj3rn1wbpe8ledDPc/drotJms8Iajce09uyigabwRIyLA16yoDM5oDeoyCMQr1qsqsA3Y0pABw5CkPwr122WrGo4Ix4P64HnaxmcmeVI/VqGxyrikOFkYkbgBcFcmz6sJXv3mzYZvXrUmAkzteGELxlpesIC0BVsxWIFPVNY5jnfxddygIcexPa5hY2lMyHHVbZMTyek4Hs0ZOrwDXzrOSkl4WPsjx2VAoEirBHvkwM4tSxeddpw/KGQN62KaHXFC+R1dxJSDTzK90KU7AGUNk3dldPV5ZON+7ESPyiBf6Ltqv2iZyx5OzxOLmX7oduJqRe/Cv36mIcPY7T+eohSbxRars+8eEOrzTunPxeXsgDvuStCVEkpyWNHxobsfKGHKqV1Eu5fcjq5FbooqJnL5PBR1Feq9kzIa1wkt9VjnG6YsaU2SVpxfcCYmPFku4aLPd8PgtmyDdwywL4tvepmLw1X0mORHZJUPnPttC+w/N5q1mN+OrF69iUG9JEfnD8UA436Xsle2LOyR7O1Y4VP2wJtePd/t4zdntmcpL2z0mVghW4aLdO6CANLgeb2HccCu6fFnrhGqo4AGWdjs6Y1wGmTuAdqVlMwgSG8O6LJYhpD+NEGI3dx/FI0FCTHe7qc0PoJRqhXUn1nwRku9lurRwc3i5dQayQdwrBiebJ4yI5nArQ+FsN0ExmvP4gNF/2u/MJlTphwVhrdGg9uEFv9G73x/6M9jmmdlGGQS5m5fjBWuT/GBfsBgP49+y09Jd++amaNtop3wOA8zXr7jHFWrAYAMCcvFLAfTv/WtXGMqFgKgT8v99vfIxy9z2XN+2k0BxBGfnvqa3dz952coHVGhATXWRsa4ARVU/eGBsmWlCULCi9j3JkIaqXxaIh9fB0ZpWVfnmlhpsOmNeHUzN4mXwy8tocGugxxksdZSAIRrfbR7eAnymqQjvV2MZ8AyY85QTetFl+BGNpa6t0D4//sBpSBmF72Y2MM7qeVQtv96Qs6oP13svs60ihMf5aPfjOmAyUe6kzcBsTZsM2/GF/Aj4bvZqLiEQV1ERwALuB3sbNkqENPm5ZF0FVnADaaSE+THGupDkC/baK03mMiHdxjdeaHkVLT7EcOYRb66KZReVNjJHWrhetbz/tZtKfQduzQnnlLijAxmWF+m5JkY5OkBsUXnGrCPfy73z13AXl1kQh0XoSHccx/69EN1cHa6fklyrgSViahTHHlKSQZqad7bDtpF+quSaGMXnduHBAPWkpJQ1/jWtkI8XYTSqUXCxZtbkoZbhrKpRbqSI4oLMreC8jZo8qceFNdod6xsjv9kI69EAu/RJtkMQ5XXBzIfH3btamE1g7gH6Em95kR/56bTqMW5AqSmCWKcbCAWX6GQCBM3aAPND4x6w4eo2zZkWuVrIiEigImXLNpUSUnC/bDeBmupKqBsvbcQqpvb8j1dlsjFUzXIx6zllJSCkm+M9Ls6t6hC+vkXH7o5I3fL13i1hHKpaZz7blMUBHYq/w3X4iXPE4TDukpoGYUT9f7RjFvvwhhl9Gldwl9mWLJ+AjiZ1Xkvv5hhetn7P3cv7wOG/0pY++6++tjP+g9V+6qEZ79dLrqq7jjPg/lTKrqVsqCX+ly0KpWDYfJ7dFqU3d+IPTl0YXW65PnumhFx+ZQX64xH0bkS6V24qgFWzTd67hK4zCK0q5E6swrBVeBirKoX5n8roRa2CWBNMWuYe1eUnd9fdkmc4wu4oP2FflrtfcLr++mtQY4Hc4S+E49YFByz5npkGdKxyI8lrtiyblnjX6CZvZ9G3rvzrtmOX8pv7jsEgNYj7IpUWA1IuXveJelKBSDMLKetaq4QmqcaVq+knQYo//cQ2QTalIBRoSsbhiIEef+aqodCCF3w0kT7kCgrRVe/QZWpU0p0rAcWOjXydRYtL5L60+hckZeJm4hCtwkufF2bfIQR2rr+NWGVaSWMOds0wpullZBpfoO5+kMu7wcSwrICz7v0A17kZ/mUffVES7mvYYH1eMK67uAbHdwyFp6nG7qhMhdzaSrZYmSTv5uFkaIoyv7czwN1j3t9eK8C5zXLsvw+1MNEUnPaXKutYbABv++dp2T6ahOICDoWGXocwq5rxdD9uEUYqooIW5+Yo3KaxvZFPSdXnlStipljP6aHIDyaS4Z49uJUrDZ/PM+PqSjLwN2nFrQbaleEnwvD89Py/fDVURyhokRtZUPnWXjEt56WJbOxpOVKZJ8UYXCWtWVGvO4f3g2fXT2HWXkM/CL/V+vqp1XRBrUMqdjLh911/xaT8ojVQiTxpwnOvulUU7/cty/rilNt7REMgS4kKijv0+X6pW2oyGgWjxCdVhp5daSPvIdEaX0BbvlVROxg15KNs6yplcPcgck3alUnOY33cOAXFHv0U+K7hWKVuEO4mkaMjuzMeHRtlZO7uqZUZkFYr7InAJfRyHo4amnQ6b9RLtueMcD8BXuZBuJBIvIX8/yIAx/4vePsH0Ra0qru3S88q8Mmdq0c6CfV8YZVatU7C9Z0sNPYI+JxilZ0dWJlBceFSU6EZ1Yth/Zs0RK7vsY4p9thZQGs+Ci0x4XXaW74BtFSur4B1zYz4ZyzJgJFW6SCczQXYUYCwOyEYLBCFnJNo5ABXfnXAvAnpXhc05vOIMz0QbT3jQPsMc6WM8hCAin/cVKhdXEEZ35BPiC9aaF5n4bThOnGYgAP0U1oLMQJWMdoCOajeHvAUkVhgjc1DC75gorfzFaacKfLfLFCoce8m5G2C0B2YKaI/ttdk4n5q8I1pA7Qk/jPav5SNfjr91bzQ00SxLj2gwXeUyF781oWmEpwi3ozenLD1qjpWbDxG75cTC5ZwBhPdAwTZHAc7qLtc995b/DeYhHniz7G0dSFlKgrrEVWy92K4S7ONwZKp7mSNhfXKz6VbZm6wcWHHBHoNwTdzLaN+sigFJnb1LEKkaIiCkCSmJwdyFl/EkpeTbVLqwzQtr4DJTowH5fctaDiHdYPhGSuRC4kfnPeqXGkjdLlidL+7OpcrV0QVhSODbFHXyyHPqgldBh1lGuZ8VDdGXf3KE4SL9EvyTzj/5ZSim+qmtlwa72Ce/sL3L8856wLVQEQTcZsY1r6DtPvCyHYTqoBVOD3Rzx4XOnjdacUh3EKgTTs+qxllrPjXFPR2agNTaFBpzkYf3ygHDSoRRDTUKAJEhFI3h5N5JEgiSvqgzIERqsK7UqTYF22aGu25KQ/hRdWTagd+Ln040IG5B3Ojmadq2ASJTbzeM7pg67SgBlgQmt8K9fBMBdC5CRaB6Ef+BKGW/ZMsvycUh2uMEnJJ7aXZ/Iz4N48RKek2Xyb+7GjfQHvQJgWpYroBgguQZ1Ohu5glSgfjk6togiKeZHE4icqubrypvGiWMuK7Ne19duxdGdprxCuZRe/1vOmkZkp76jgoW3KrD/dbsywEPa/8yrTWAoJ/ReOlIr/3JTz77D1B+9MS/zd2Zy2Hwo9+JWO+WQVEK+9Sg9EpKdMTHa78Te+GtQabZ0TVY3RX99T6u3FbSGJYciELFX44ptrdJK0m+S09Tz9MndqttuChhG3ocIdIjOMvD8VBaSSI+jV5Eozpeo/r6sPLYOmOxaxBY8OQKfyh03LKfgjkMpbHceyEhBR7+kgPnT2LDS9suR43xZUJWskqU2RGpxAtu+Oq4uOVPfCtonQGiDD0KOrcpausSm1cySshKHo88SMVg882h50opAt1+XJcRj7F5aJZYiSiGV6fKYvfo3e+Z37636qt+r+mBuQu90xVniF+qYe1WWlPn8idCpV3jVrk1woM4VfJ4ePlYg61VYDRrhz8n+mN/Fo87oqiYoshFemEO8f0IUtQ7BpdSstm7L2Z2r1E4Jz/CkOYik7nEJf9AHF8piij3u0kbrzSYMTd3FCdi8/y3OaITapcBwk19QN01P7Dv4QAaqD04wj7Qal6GMUXcmeqkBKMgQ4NvRIzuJ8WbR7xtXQ3D4FxkOx2oEb3G+hGvgKBZSOhreU3SgxkenlpBCbJoMcGbTyfMpyffVjH87UwfCjYx9hLxz9z9zyPKcBSvLsjDxnOTtjvAHKF4YIQW6XE9iF4AMFvtWCvJ2nStFJvRhOp9hEhi1LoiuFUZ1FnOyeIdEO1uf43UU781KCq+GTA7VCyeWQu8oXCrDnYhbauENikzsfdWo9nQycofubEOfUOngKZxLFDOKHAUV9YWqQxSSLZoAr+yfa6UGW3PmEtPbtLYBg9vmxUWTSu1M4puFzaTmg+HN4XrJ+Y1U04weN6OEjZHtIC9tfXrxqAdxJsGLaLD2aGs6R93VrxQFTXNz7EHjMQKFBdropYxvhs7mJnQrLf8gE6akp9Dti2SAorETNvZ/6RWNUM/HKug8pMteVQK1HeRd8qcDWvtSpWX+GXUjMzKuO7UlwjO5JFDAfqHRa/79W8mhcjC9qXBn8JtIRMf9v7C6Dc7ddwtmPXViDq37/xVP9Mcgl9TLQ83QupFVef7eofD66b7I/xDASOs3rNV/l0hvOKIXPp3peS0SAs4Fbz2PRgHlmw1EZNl5VoB9iMsO8BeHXQDSmn8O1asin+v7zK0fZjVDBj4c0Y4X6Ubn+8PaYT7HS2LnUAF6TnNMzn1aav9FuB0/oCYE1uMPIAEfsgC+GCshiYkzhQqb0+sBYJ2G7J829fb3PzOnnmJx4l7gc1TiALN2sA0DkIb/DVr3mYwpH4HgUmARQXerudKxs4PzMWBjLDN8CUnpSlcjrQwwegDcP/c+Wg+YYp7q65lSPJWAF0/2DfCQg31DpaSAq8y64xkd+0s0WdIvSkUFU+lcdM9xMHUeBHFEuR7ZS6fit5D8T4OWYoWPl+djjpiN32d0PGFiP/0ReL5xnjkh26qfqCQ9XAAMAAIMEIACRBWAAXROgABIXIB8MIGAf7yygKyowICxvpuAsAqhgLR77YC4A/iA2nv9gNv0B4TYBCiE3JA3hN6sOYTkvGKE5MBxhSPMeoUxANGFQ8GqhUU9vIVKdvKFSAM9hU2XRoVMA2iFUAODhVa7iYVfs5CFZ0OihWSAA7lnwAX9aAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDPAgqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgECAQMBBQIHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwADHQIeAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwHzEEMAcBAQUBKAkMAiAEAgIBAzgBAQIDAQEDOggCApgDAQ0BBwQBBgEDAsZAAAHDIQADjQFgIAAGaQIABAEKIAJQAgABAwEEARkCBQGXAhoSDQEmCBkLLgMwAQIEAgInAUMGAgICAgwBCAEvATMBAQMCAgUCAQEqAggB7gECAQQBAAEAEBAQAAIAAeIBlQUAAwECBQQoAwQBpQIABAACUANGCzEEewE2DykBAgIKAzEEAgIHAT0DJAUBCD4BDAI0CQoEAgFfAwIBAQIGAQIBnQEDCBUCOQIBAQEBFgEOBwMFwwgCAwEBFwFRAQIGAQECAQECAQLrAQIEBgIBAhsCVQgCAQECagEBAQIGAQFlAwIEAQUACQEC9QEKAgEBBAGQBAICBAEgCigGAgQIAQkGAgMuDQECAAcBBgEBUhYCBwECAQJ6BgMBAQIBBwEBSAIDAQEBAAILAjQFBQEBAQABBg8ABTsHAAE/BFEBAAIALgIXAAEBAwQFCAgCBx4ElAMANwQyCAEOARYFAQ8ABwERAgcBAgEFZAGgBwABPQQABAAHbQcAYIDwAG8JcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjc3LjAgKGFlZGQxNzNhMiAyMDI0LTAzLTE3KQZ3YWxydXMGMC4xOS4wDHdhc20tYmluZGdlbgYwLjIuODcALA90YXJnZXRfZmVhdHVyZXMCKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0", mR = async (e = {}, t) => {
  let i;
  if (t.startsWith("data:")) {
    const n = t.replace(/^data:.*?base64,/, "");
    let s;
    if (typeof Buffer == "function" && typeof Buffer.from == "function")
      s = Buffer.from(n, "base64");
    else if (typeof atob == "function") {
      const A = atob(n);
      s = new Uint8Array(A.length);
      for (let o = 0; o < A.length; o++)
        s[o] = A.charCodeAt(o);
    } else
      throw new Error("Cannot decode base64-encoded data URL");
    i = await WebAssembly.instantiate(s, e);
  } else {
    const n = await fetch(t), s = n.headers.get("Content-Type") || "";
    if ("instantiateStreaming" in WebAssembly && s.startsWith("application/wasm"))
      i = await WebAssembly.instantiateStreaming(n, e);
    else {
      const A = await n.arrayBuffer();
      i = await WebAssembly.instantiate(A, e);
    }
  }
  return i.instance.exports;
};
let it;
function pR(e) {
  it = e;
}
const Fn = new Array(128).fill(void 0);
Fn.push(void 0, null, !0, !1);
function Dw(e) {
  return Fn[e];
}
let Al = Fn.length;
function QR(e) {
  e < 132 || (Fn[e] = Al, Al = e);
}
function yR(e) {
  const t = Dw(e);
  return QR(e), t;
}
let Ra = 0, vc = null;
function xg() {
  return (vc === null || vc.byteLength === 0) && (vc = new Uint8Array(it.memory.buffer)), vc;
}
const wR = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
let Sg = new wR("utf-8");
const DR = typeof Sg.encodeInto == "function" ? function(e, t) {
  return Sg.encodeInto(e, t);
} : function(e, t) {
  const i = Sg.encode(e);
  return t.set(i), {
    read: e.length,
    written: i.length
  };
};
function xR(e, t, i) {
  if (i === void 0) {
    const a = Sg.encode(e), r = t(a.length, 1) >>> 0;
    return xg().subarray(r, r + a.length).set(a), Ra = a.length, r;
  }
  let n = e.length, s = t(n, 1) >>> 0;
  const A = xg();
  let o = 0;
  for (; o < n; o++) {
    const a = e.charCodeAt(o);
    if (a > 127) break;
    A[s + o] = a;
  }
  if (o !== n) {
    o !== 0 && (e = e.slice(o)), s = i(s, n, n = o + e.length * 3, 1) >>> 0;
    const a = xg().subarray(s + o, s + n), r = DR(e, a);
    o += r.written;
  }
  return Ra = o, s;
}
let Tc = null;
function Ce() {
  return (Tc === null || Tc.byteLength === 0) && (Tc = new Int32Array(it.memory.buffer)), Tc;
}
const SR = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
let xw = new SR("utf-8", { ignoreBOM: !0, fatal: !0 });
xw.decode();
function Ar(e, t) {
  return e = e >>> 0, xw.decode(xg().subarray(e, e + t));
}
let Gc = null;
function Sw() {
  return (Gc === null || Gc.byteLength === 0) && (Gc = new Float64Array(it.memory.buffer)), Gc;
}
function th(e, t) {
  return e = e >>> 0, Sw().subarray(e / 8, e / 8 + t);
}
function Uf(e, t) {
  if (!(e instanceof t))
    throw new Error(`expected instance of ${t.name}`);
  return e.ptr;
}
function SA(e) {
  Al === Fn.length && Fn.push(Fn.length + 1);
  const t = Al;
  return Al = Fn[t], Fn[t] = e, t;
}
let ol = 128;
function Qm(e) {
  if (ol == 1) throw new Error("out of js stack");
  return Fn[--ol] = e, ol;
}
function _R(e, t) {
  return e = e >>> 0, Ce().subarray(e / 4, e / 4 + t);
}
let Lc = null;
function bR() {
  return (Lc === null || Lc.byteLength === 0) && (Lc = new Uint32Array(it.memory.buffer)), Lc;
}
function MR(e, t) {
  return e = e >>> 0, bR().subarray(e / 4, e / 4 + t);
}
function ym(e, t) {
  const i = t(e.length * 8, 8) >>> 0;
  return Sw().set(e, i / 8), Ra = e.length, i;
}
function Uc(e) {
  return e == null;
}
function NR(e, t, i, n, s, A, o, a, r) {
  Uf(e, El);
  const l = ym(A, it.__wbindgen_malloc), c = Ra, g = ym(a, it.__wbindgen_malloc), h = Ra, d = it.stack_by(
    e.__wbg_ptr,
    t,
    i,
    n,
    s,
    l,
    c,
    !Uc(o),
    Uc(o) ? 0 : o,
    g,
    h,
    !Uc(r),
    Uc(r) ? 0 : r
  );
  return bC.__wrap(d);
}
const wm = new FinalizationRegistry((e) => it.__wbg_binnedfieldwrapper_free(e >>> 0));
class yC {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(yC.prototype);
    return i.__wbg_ptr = t, wm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, wm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_binnedfieldwrapper_free(t);
  }
  /**
   * @returns {string}
   */
  get_name() {
    let t, i;
    try {
      const A = it.__wbindgen_add_to_stack_pointer(-16);
      it.binnedfieldwrapper_get_name(A, this.__wbg_ptr);
      var n = Ce()[A / 4 + 0], s = Ce()[A / 4 + 1];
      return t = n, i = s, Ar(n, s);
    } finally {
      it.__wbindgen_add_to_stack_pointer(16), it.__wbindgen_free(t, i, 1);
    }
  }
  /**
   * @returns {number}
   */
  get_data_ptr() {
    return it.binnedfieldwrapper_get_data_ptr(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_indices() {
    return it.binnedfieldwrapper_get_data_indices(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_info() {
    return it.binnedfieldwrapper_get_data_info(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_rows_count() {
    return it.binnedfieldwrapper_get_rows_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} row_index
   * @returns {number}
   */
  get_value_at_index(t) {
    return it.binnedfieldwrapper_get_value_at_index(this.__wbg_ptr, t);
  }
  /**
   * @returns {Float64Array}
   */
  get_domain() {
    try {
      const s = it.__wbindgen_add_to_stack_pointer(-16);
      it.binnedfieldwrapper_get_domain(s, this.__wbg_ptr);
      var t = Ce()[s / 4 + 0], i = Ce()[s / 4 + 1], n = th(t, i).slice();
      return it.__wbindgen_free(t, i * 8), n;
    } finally {
      it.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Float64Array}
   */
  get_uniques() {
    try {
      const s = it.__wbindgen_add_to_stack_pointer(-16);
      it.binnedfieldwrapper_get_uniques(s, this.__wbg_ptr);
      var t = Ce()[s / 4 + 0], i = Ce()[s / 4 + 1], n = th(t, i).slice();
      return it.__wbindgen_free(t, i * 8), n;
    } finally {
      it.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
const Dm = new FinalizationRegistry(
  (e) => it.__wbg_categoricaldomainmeta_free(e >>> 0)
);
class wC {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(wC.prototype);
    return i.__wbg_ptr = t, Dm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Dm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_categoricaldomainmeta_free(t);
  }
  /**
   * @returns {number}
   */
  get data_ptr() {
    return it.__wbg_get_categoricaldomainmeta_data_ptr(this.__wbg_ptr);
  }
  /**
   * @param {number} arg0
   */
  set data_ptr(t) {
    it.__wbg_set_categoricaldomainmeta_data_ptr(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  get data_len() {
    return it.__wbg_get_categoricaldomainmeta_data_len(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} arg0
   */
  set data_len(t) {
    it.__wbg_set_categoricaldomainmeta_data_len(this.__wbg_ptr, t);
  }
}
const xm = new FinalizationRegistry(
  (e) => it.__wbg_categoricalfieldwrapper_free(e >>> 0)
);
class DC {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(DC.prototype);
    return i.__wbg_ptr = t, xm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, xm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_categoricalfieldwrapper_free(t);
  }
  /**
   * @returns {string}
   */
  get_name() {
    let t, i;
    try {
      const A = it.__wbindgen_add_to_stack_pointer(-16);
      it.categoricalfieldwrapper_get_name(A, this.__wbg_ptr);
      var n = Ce()[A / 4 + 0], s = Ce()[A / 4 + 1];
      return t = n, i = s, Ar(n, s);
    } finally {
      it.__wbindgen_add_to_stack_pointer(16), it.__wbindgen_free(t, i, 1);
    }
  }
  /**
   * @returns {number}
   */
  get_data_indices() {
    return it.categoricalfieldwrapper_get_data_indices(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_info() {
    return it.categoricalfieldwrapper_get_data_info(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_rows_count() {
    return it.categoricalfieldwrapper_get_rows_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} row_index
   * @returns {number}
   */
  get_value_at_index(t) {
    return it.categoricalfieldwrapper_get_value_at_index(this.__wbg_ptr, t);
  }
  /**
   * @param {number} min_max_domain
   * @returns {CategoricalDomainMeta}
   */
  get_domain(t) {
    const i = it.categoricalfieldwrapper_get_domain(this.__wbg_ptr, t);
    return wC.__wrap(i);
  }
  /**
   * @returns {boolean}
   */
  is_naturally_numeric() {
    return it.categoricalfieldwrapper_is_naturally_numeric(this.__wbg_ptr) !== 0;
  }
}
const Sm = new FinalizationRegistry(
  (e) => it.__wbg_continuousfieldwrapper_free(e >>> 0)
);
class xC {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(xC.prototype);
    return i.__wbg_ptr = t, Sm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Sm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_continuousfieldwrapper_free(t);
  }
  /**
   * @returns {string}
   */
  get_name() {
    let t, i;
    try {
      const A = it.__wbindgen_add_to_stack_pointer(-16);
      it.continuousfieldwrapper_get_name(A, this.__wbg_ptr);
      var n = Ce()[A / 4 + 0], s = Ce()[A / 4 + 1];
      return t = n, i = s, Ar(n, s);
    } finally {
      it.__wbindgen_add_to_stack_pointer(16), it.__wbindgen_free(t, i, 1);
    }
  }
  /**
   * @returns {number}
   */
  get_data_ptr() {
    return it.continuousfieldwrapper_get_data_ptr(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_indices() {
    return it.continuousfieldwrapper_get_data_indices(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_info() {
    return it.continuousfieldwrapper_get_data_info(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_rows_count() {
    return it.continuousfieldwrapper_get_rows_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} row_index
   * @returns {number}
   */
  get_value_at_index(t) {
    return it.continuousfieldwrapper_get_value_at_index(this.__wbg_ptr, t);
  }
  /**
   * @param {number} unique
   * @returns {Float64Array}
   */
  get_domain(t) {
    try {
      const A = it.__wbindgen_add_to_stack_pointer(-16);
      it.continuousfieldwrapper_get_domain(A, this.__wbg_ptr, t);
      var i = Ce()[A / 4 + 0], n = Ce()[A / 4 + 1], s = th(i, n).slice();
      return it.__wbindgen_free(i, n * 8), s;
    } finally {
      it.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
const _m = new FinalizationRegistry((e) => it.__wbg_datamodel_free(e >>> 0));
let El = class RA {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(RA.prototype);
    return i.__wbg_ptr = t, _m.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, _m.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_datamodel_free(t);
  }
  /**
   * Public API to create new DataModel Instance
   * @param {DataModelMeta} meta
   */
  constructor(t) {
    Uf(t, Bl);
    var i = t.__destroy_into_raw();
    const n = it.datamodel_new(i);
    return RA.__wrap(n);
  }
  /**
   * @returns {DataModel}
   */
  clone() {
    const t = it.datamodel_clone(this.__wbg_ptr);
    return RA.__wrap(t);
  }
  /**
   * @param {any} schema
   * @param {any} data
   * @returns {number}
   */
  add_field(t, i) {
    return it.datamodel_add_field(this.__wbg_ptr, SA(t), SA(i)) >>> 0;
  }
  /**
   * @param {number} index
   * @returns {CategoricalFieldWrapper}
   */
  get_categorical_field(t) {
    const i = it.datamodel_get_categorical_field(this.__wbg_ptr, t);
    return DC.__wrap(i);
  }
  /**
   * @param {number} index
   * @returns {BinnedFieldWrapper}
   */
  get_binned_field(t) {
    const i = it.datamodel_get_binned_field(this.__wbg_ptr, t);
    return yC.__wrap(i);
  }
  /**
   * @param {number} index
   * @returns {ContinuousFieldWrapper}
   */
  get_continuous_field(t) {
    const i = it.datamodel_get_continuous_field(this.__wbg_ptr, t);
    return xC.__wrap(i);
  }
  /**
   * @param {number} index
   * @returns {TemporalFieldWrapper}
   */
  get_temporal_field(t) {
    const i = it.datamodel_get_temporal_field(this.__wbg_ptr, t);
    return MC.__wrap(i);
  }
  /**
   * @param {number} index
   * @returns {IdFieldWrapper}
   */
  get_id_field(t) {
    const i = it.datamodel_get_id_field(this.__wbg_ptr, t);
    return SC.__wrap(i);
  }
  /**
   * @param {any} obj
   * @param {number} mode
   * @returns {ProjectDataModel}
   */
  select(t, i) {
    const n = it.datamodel_select(this.__wbg_ptr, SA(t), i);
    return eh.__wrap(n);
  }
  /**
   * @param {any} details
   * @returns {DataModel}
   */
  sort(t) {
    try {
      const i = it.datamodel_sort(this.__wbg_ptr, Qm(t));
      return RA.__wrap(i);
    } finally {
      Fn[ol++] = void 0;
    }
  }
  /**
   * @param {any} details
   * @returns {ProjectDataModel}
   */
  project(t) {
    try {
      const i = it.datamodel_project(this.__wbg_ptr, Qm(t));
      return eh.__wrap(i);
    } finally {
      Fn[ol++] = void 0;
    }
  }
  /**
   * @param {any} details
   * @param {any} options
   * @returns {DataModel}
   */
  group_by(t, i) {
    const n = it.datamodel_group_by(this.__wbg_ptr, SA(t), SA(i));
    return RA.__wrap(n);
  }
  /**
   * @param {any} options
   * @returns {SplitDataModel}
   */
  split_by_row(t) {
    const i = it.datamodel_split_by_row(this.__wbg_ptr, SA(t));
    return _C.__wrap(i);
  }
  /**
   * @param {any} fields
   */
  dispose(t) {
    it.datamodel_dispose(this.__wbg_ptr, SA(t));
  }
  /**
   * @returns {number}
   */
  row_count() {
    return it.datamodel_row_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {number}
   */
  column_count() {
    return it.datamodel_column_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {Int32Array}
   */
  get_eligible_rows() {
    try {
      const s = it.__wbindgen_add_to_stack_pointer(-16);
      it.datamodel_get_eligible_rows(s, this.__wbg_ptr);
      var t = Ce()[s / 4 + 0], i = Ce()[s / 4 + 1], n = _R(t, i).slice();
      return it.__wbindgen_free(t, i * 4), n;
    } finally {
      it.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  get_partial_column_count() {
    return it.datamodel_get_partial_column_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @returns {number}
   */
  get_partial_row_count() {
    return it.datamodel_get_partial_row_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {DataModel} dm2
   * @returns {Uint32Array}
   */
  get_matching_ids(t) {
    try {
      const A = it.__wbindgen_add_to_stack_pointer(-16);
      Uf(t, RA), it.datamodel_get_matching_ids(A, this.__wbg_ptr, t.__wbg_ptr);
      var i = Ce()[A / 4 + 0], n = Ce()[A / 4 + 1], s = MR(i, n).slice();
      return it.__wbindgen_free(i, n * 4), s;
    } finally {
      it.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
const bm = new FinalizationRegistry((e) => it.__wbg_datamodelmeta_free(e >>> 0));
class Bl {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(Bl.prototype);
    return i.__wbg_ptr = t, bm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, bm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_datamodelmeta_free(t);
  }
  /**
   * @returns {number}
   */
  get rows() {
    return it.__wbg_get_datamodelmeta_rows(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} arg0
   */
  set rows(t) {
    it.__wbg_set_datamodelmeta_rows(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  get columns() {
    return it.__wbg_get_datamodelmeta_columns(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} arg0
   */
  set columns(t) {
    it.__wbg_set_datamodelmeta_columns(this.__wbg_ptr, t);
  }
  /**
   * @param {number} rows
   * @param {number} columns
   */
  constructor(t, i) {
    const n = it.datamodelmeta_new(t, i);
    return Bl.__wrap(n);
  }
}
const Mm = new FinalizationRegistry((e) => it.__wbg_idfieldwrapper_free(e >>> 0));
class SC {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(SC.prototype);
    return i.__wbg_ptr = t, Mm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Mm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_idfieldwrapper_free(t);
  }
  /**
   * @returns {string}
   */
  get_name() {
    let t, i;
    try {
      const A = it.__wbindgen_add_to_stack_pointer(-16);
      it.idfieldwrapper_get_name(A, this.__wbg_ptr);
      var n = Ce()[A / 4 + 0], s = Ce()[A / 4 + 1];
      return t = n, i = s, Ar(n, s);
    } finally {
      it.__wbindgen_add_to_stack_pointer(16), it.__wbindgen_free(t, i, 1);
    }
  }
  /**
   * @returns {number}
   */
  get_data_ptr() {
    return it.idfieldwrapper_get_data_ptr(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_indices() {
    return it.idfieldwrapper_get_data_indices(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_info() {
    return it.idfieldwrapper_get_data_info(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_rows_count() {
    return it.idfieldwrapper_get_rows_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} row_index
   * @returns {number}
   */
  get_value_at_index(t) {
    return it.idfieldwrapper_get_value_at_index(this.__wbg_ptr, t);
  }
}
const Nm = new FinalizationRegistry((e) => it.__wbg_projectdatamodel_free(e >>> 0));
class eh {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(eh.prototype);
    return i.__wbg_ptr = t, Nm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Nm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_projectdatamodel_free(t);
  }
  /**
   * @returns {DataModel | undefined}
   */
  get_filtered_dm() {
    const t = it.projectdatamodel_get_filtered_dm(this.__wbg_ptr);
    return t === 0 ? void 0 : El.__wrap(t);
  }
  /**
   * @returns {DataModel | undefined}
   */
  get_unfiltered_dm() {
    const t = it.projectdatamodel_get_unfiltered_dm(this.__wbg_ptr);
    return t === 0 ? void 0 : El.__wrap(t);
  }
}
const Fm = new FinalizationRegistry((e) => it.__wbg_splitdatamodel_free(e >>> 0));
class _C {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(_C.prototype);
    return i.__wbg_ptr = t, Fm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Fm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_splitdatamodel_free(t);
  }
  /**
   * @returns {DataModel}
   */
  get_dm() {
    const t = it.splitdatamodel_get_dm(this.__wbg_ptr);
    return El.__wrap(t);
  }
  /**
   * @returns {number}
   */
  get_count() {
    return it.splitdatamodel_get_count(this.__wbg_ptr) >>> 0;
  }
}
const Rm = new FinalizationRegistry((e) => it.__wbg_stackdata_free(e >>> 0));
class bC {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(bC.prototype);
    return i.__wbg_ptr = t, Rm.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, Rm.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_stackdata_free(t);
  }
  /**
   * @returns {number}
   */
  get_y_0() {
    return it.stackdata_get_y_0(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_y_1() {
    return it.stackdata_get_y_1(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_id() {
    return it.stackdata_get_id(this.__wbg_ptr);
  }
  /**
   */
  free_data() {
    it.stackdata_free_data(this.__wbg_ptr);
  }
}
const km = new FinalizationRegistry(
  (e) => it.__wbg_temporalfieldwrapper_free(e >>> 0)
);
class MC {
  static __wrap(t) {
    t = t >>> 0;
    const i = Object.create(MC.prototype);
    return i.__wbg_ptr = t, km.register(i, i.__wbg_ptr, i), i;
  }
  __destroy_into_raw() {
    const t = this.__wbg_ptr;
    return this.__wbg_ptr = 0, km.unregister(this), t;
  }
  free() {
    const t = this.__destroy_into_raw();
    it.__wbg_temporalfieldwrapper_free(t);
  }
  /**
   * @returns {string}
   */
  get_name() {
    let t, i;
    try {
      const A = it.__wbindgen_add_to_stack_pointer(-16);
      it.temporalfieldwrapper_get_name(A, this.__wbg_ptr);
      var n = Ce()[A / 4 + 0], s = Ce()[A / 4 + 1];
      return t = n, i = s, Ar(n, s);
    } finally {
      it.__wbindgen_add_to_stack_pointer(16), it.__wbindgen_free(t, i, 1);
    }
  }
  /**
   * @returns {number}
   */
  get_data_ptr() {
    return it.temporalfieldwrapper_get_data_ptr(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_indices() {
    return it.temporalfieldwrapper_get_data_indices(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_data_info() {
    return it.temporalfieldwrapper_get_data_info(this.__wbg_ptr);
  }
  /**
   * @returns {number}
   */
  get_rows_count() {
    return it.temporalfieldwrapper_get_rows_count(this.__wbg_ptr) >>> 0;
  }
  /**
   * @param {number} row_index
   * @returns {number}
   */
  get_value_at_index(t) {
    return it.temporalfieldwrapper_get_value_at_index(this.__wbg_ptr, t);
  }
  /**
   * @returns {number}
   */
  min_consecutive_diff() {
    return it.temporalfieldwrapper_min_consecutive_diff(this.__wbg_ptr);
  }
  /**
   * @param {number} unique
   * @returns {Float64Array}
   */
  get_domain(t) {
    try {
      const A = it.__wbindgen_add_to_stack_pointer(-16);
      it.temporalfieldwrapper_get_domain(A, this.__wbg_ptr, t);
      var i = Ce()[A / 4 + 0], n = Ce()[A / 4 + 1], s = th(i, n).slice();
      return it.__wbindgen_free(i, n * 8), s;
    } finally {
      it.__wbindgen_add_to_stack_pointer(16);
    }
  }
}
function FR(e) {
  yR(e);
}
function RR(e, t) {
  const i = Dw(t), n = JSON.stringify(i === void 0 ? null : i), s = xR(n, it.__wbindgen_malloc, it.__wbindgen_realloc), A = Ra;
  Ce()[e / 4 + 1] = A, Ce()[e / 4 + 0] = s;
}
function kR(e, t) {
  throw new Error(Ar(e, t));
}
URL = globalThis.URL;
const ct = await mR({ "./datamodel_bg.js": {
  __wbindgen_object_drop_ref: FR,
  __wbindgen_json_serialize: RR,
  __wbindgen_throw: kR
} }, BR), jl = ct.memory, vR = ct.__wbg_idfieldwrapper_free, TR = ct.idfieldwrapper_get_name, GR = ct.idfieldwrapper_get_data_ptr, LR = ct.idfieldwrapper_get_data_indices, UR = ct.idfieldwrapper_get_data_info, HR = ct.idfieldwrapper_get_rows_count, OR = ct.idfieldwrapper_get_value_at_index, PR = ct.__wbg_categoricaldomainmeta_free, YR = ct.__wbg_get_categoricaldomainmeta_data_ptr, JR = ct.__wbg_set_categoricaldomainmeta_data_ptr, KR = ct.__wbg_get_categoricaldomainmeta_data_len, VR = ct.__wbg_set_categoricaldomainmeta_data_len, WR = ct.__wbg_continuousfieldwrapper_free, qR = ct.continuousfieldwrapper_get_name, jR = ct.continuousfieldwrapper_get_data_ptr, zR = ct.continuousfieldwrapper_get_data_indices, $R = ct.continuousfieldwrapper_get_data_info, XR = ct.continuousfieldwrapper_get_rows_count, ZR = ct.continuousfieldwrapper_get_value_at_index, t2 = ct.continuousfieldwrapper_get_domain, e2 = ct.__wbg_splitdatamodel_free, i2 = ct.splitdatamodel_get_dm, n2 = ct.splitdatamodel_get_count, s2 = ct.main_js, A2 = ct.__wbg_datamodelmeta_free, o2 = ct.__wbg_get_datamodelmeta_rows, a2 = ct.__wbg_set_datamodelmeta_rows, r2 = ct.__wbg_get_datamodelmeta_columns, l2 = ct.__wbg_set_datamodelmeta_columns, c2 = ct.datamodelmeta_new, g2 = ct.__wbg_datamodel_free, h2 = ct.datamodel_new, d2 = ct.datamodel_clone, u2 = ct.datamodel_add_field, f2 = ct.datamodel_get_categorical_field, I2 = ct.datamodel_get_binned_field, C2 = ct.datamodel_get_continuous_field, E2 = ct.datamodel_get_temporal_field, B2 = ct.datamodel_get_id_field, m2 = ct.datamodel_select, p2 = ct.datamodel_sort, Q2 = ct.datamodel_project, y2 = ct.datamodel_group_by, w2 = ct.datamodel_split_by_row, D2 = ct.datamodel_dispose, x2 = ct.datamodel_row_count, S2 = ct.datamodel_column_count, _2 = ct.datamodel_get_eligible_rows, b2 = ct.datamodel_get_partial_column_count, M2 = ct.datamodel_get_partial_row_count, N2 = ct.datamodel_get_matching_ids, F2 = ct.__wbg_temporalfieldwrapper_free, R2 = ct.temporalfieldwrapper_get_name, k2 = ct.temporalfieldwrapper_get_data_ptr, v2 = ct.temporalfieldwrapper_get_data_indices, T2 = ct.temporalfieldwrapper_get_data_info, G2 = ct.temporalfieldwrapper_get_rows_count, L2 = ct.temporalfieldwrapper_get_value_at_index, U2 = ct.temporalfieldwrapper_min_consecutive_diff, H2 = ct.temporalfieldwrapper_get_domain, O2 = ct.__wbg_stackdata_free, P2 = ct.stackdata_get_y_0, Y2 = ct.stackdata_get_y_1, J2 = ct.stackdata_get_id, K2 = ct.stackdata_free_data, V2 = ct.stack_by, W2 = ct.__wbg_binnedfieldwrapper_free, q2 = ct.binnedfieldwrapper_get_name, j2 = ct.binnedfieldwrapper_get_data_ptr, z2 = ct.binnedfieldwrapper_get_data_indices, $2 = ct.binnedfieldwrapper_get_data_info, X2 = ct.binnedfieldwrapper_get_rows_count, Z2 = ct.binnedfieldwrapper_get_value_at_index, tk = ct.binnedfieldwrapper_get_domain, ek = ct.binnedfieldwrapper_get_uniques, ik = ct.__wbg_projectdatamodel_free, nk = ct.projectdatamodel_get_filtered_dm, sk = ct.projectdatamodel_get_unfiltered_dm, Ak = ct.__wbg_categoricalfieldwrapper_free, ok = ct.categoricalfieldwrapper_get_name, ak = ct.categoricalfieldwrapper_get_data_indices, rk = ct.categoricalfieldwrapper_get_data_info, lk = ct.categoricalfieldwrapper_get_rows_count, ck = ct.categoricalfieldwrapper_get_value_at_index, gk = ct.categoricalfieldwrapper_get_domain, hk = ct.categoricalfieldwrapper_is_naturally_numeric, dk = ct.__wbindgen_malloc, uk = ct.__wbindgen_realloc, fk = ct.__wbindgen_add_to_stack_pointer, Ik = ct.__wbindgen_free, _w = ct.__wbindgen_start, Ck = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __wbg_binnedfieldwrapper_free: W2,
  __wbg_categoricaldomainmeta_free: PR,
  __wbg_categoricalfieldwrapper_free: Ak,
  __wbg_continuousfieldwrapper_free: WR,
  __wbg_datamodel_free: g2,
  __wbg_datamodelmeta_free: A2,
  __wbg_get_categoricaldomainmeta_data_len: KR,
  __wbg_get_categoricaldomainmeta_data_ptr: YR,
  __wbg_get_datamodelmeta_columns: r2,
  __wbg_get_datamodelmeta_rows: o2,
  __wbg_idfieldwrapper_free: vR,
  __wbg_projectdatamodel_free: ik,
  __wbg_set_categoricaldomainmeta_data_len: VR,
  __wbg_set_categoricaldomainmeta_data_ptr: JR,
  __wbg_set_datamodelmeta_columns: l2,
  __wbg_set_datamodelmeta_rows: a2,
  __wbg_splitdatamodel_free: e2,
  __wbg_stackdata_free: O2,
  __wbg_temporalfieldwrapper_free: F2,
  __wbindgen_add_to_stack_pointer: fk,
  __wbindgen_free: Ik,
  __wbindgen_malloc: dk,
  __wbindgen_realloc: uk,
  __wbindgen_start: _w,
  binnedfieldwrapper_get_data_indices: z2,
  binnedfieldwrapper_get_data_info: $2,
  binnedfieldwrapper_get_data_ptr: j2,
  binnedfieldwrapper_get_domain: tk,
  binnedfieldwrapper_get_name: q2,
  binnedfieldwrapper_get_rows_count: X2,
  binnedfieldwrapper_get_uniques: ek,
  binnedfieldwrapper_get_value_at_index: Z2,
  categoricalfieldwrapper_get_data_indices: ak,
  categoricalfieldwrapper_get_data_info: rk,
  categoricalfieldwrapper_get_domain: gk,
  categoricalfieldwrapper_get_name: ok,
  categoricalfieldwrapper_get_rows_count: lk,
  categoricalfieldwrapper_get_value_at_index: ck,
  categoricalfieldwrapper_is_naturally_numeric: hk,
  continuousfieldwrapper_get_data_indices: zR,
  continuousfieldwrapper_get_data_info: $R,
  continuousfieldwrapper_get_data_ptr: jR,
  continuousfieldwrapper_get_domain: t2,
  continuousfieldwrapper_get_name: qR,
  continuousfieldwrapper_get_rows_count: XR,
  continuousfieldwrapper_get_value_at_index: ZR,
  datamodel_add_field: u2,
  datamodel_clone: d2,
  datamodel_column_count: S2,
  datamodel_dispose: D2,
  datamodel_get_binned_field: I2,
  datamodel_get_categorical_field: f2,
  datamodel_get_continuous_field: C2,
  datamodel_get_eligible_rows: _2,
  datamodel_get_id_field: B2,
  datamodel_get_matching_ids: N2,
  datamodel_get_partial_column_count: b2,
  datamodel_get_partial_row_count: M2,
  datamodel_get_temporal_field: E2,
  datamodel_group_by: y2,
  datamodel_new: h2,
  datamodel_project: Q2,
  datamodel_row_count: x2,
  datamodel_select: m2,
  datamodel_sort: p2,
  datamodel_split_by_row: w2,
  datamodelmeta_new: c2,
  idfieldwrapper_get_data_indices: LR,
  idfieldwrapper_get_data_info: UR,
  idfieldwrapper_get_data_ptr: GR,
  idfieldwrapper_get_name: TR,
  idfieldwrapper_get_rows_count: HR,
  idfieldwrapper_get_value_at_index: OR,
  main_js: s2,
  memory: jl,
  projectdatamodel_get_filtered_dm: nk,
  projectdatamodel_get_unfiltered_dm: sk,
  splitdatamodel_get_count: n2,
  splitdatamodel_get_dm: i2,
  stack_by: V2,
  stackdata_free_data: K2,
  stackdata_get_id: J2,
  stackdata_get_y_0: P2,
  stackdata_get_y_1: Y2,
  temporalfieldwrapper_get_data_indices: v2,
  temporalfieldwrapper_get_data_info: T2,
  temporalfieldwrapper_get_data_ptr: k2,
  temporalfieldwrapper_get_domain: H2,
  temporalfieldwrapper_get_name: R2,
  temporalfieldwrapper_get_rows_count: G2,
  temporalfieldwrapper_get_value_at_index: L2,
  temporalfieldwrapper_min_consecutive_diff: U2
}, Symbol.toStringTag, { value: "Module" }));
pR(Ck);
_w();
var ho;
(function(e) {
  e.WASM = "wasm";
})(ho || (ho = {}));
var vm;
(function(e) {
  e.UNDEFINED = "";
})(vm || (vm = {}));
var ih;
(function(e) {
  e.NULL = "null", e.UNDEFINED = "undefined", e.NAN = "NaN", e.NIL = "nil", e.NA = "na", e.EMPTY_STRING = "", e.INVALID = "_invalid";
})(ih || (ih = {}));
const Ek = String(ih.INVALID), Bk = "_#-", mk = {
  [ot.TEMPORAL]: (e, t) => {
    let i = e;
    if (typeof e != "number") {
      const n = oa.get(ot.TEMPORAL);
      i = n ? n.parse(e, t) : e;
    }
    return i;
  },
  [ot.CATEGORICAL]: (e, t) => {
    const i = oa.get(ot.CATEGORICAL), n = i ? i.parse(e, t) : e;
    return Tw(n) ? n : Bk;
  },
  [ot.BINNED]: (e, t) => {
    const i = oa.get(ot.CONTINUOUS);
    return i?.parse(e, t);
  },
  [ot.CONTINUOUS]: (e, t) => {
    const i = oa.get(ot.CONTINUOUS);
    return i?.parse(e, t);
  }
}, bw = (e, t, i) => {
  const n = mk[e];
  return n ? n(t, i) : t;
}, Mw = (e, t, i = {}) => {
  const n = e.conditions, { operator: s } = e;
  if (n && s && n.length > 0) {
    i.conditions = [];
    for (let A = 0; A < n.length; A++) {
      let o = i.conditions[A] = {};
      const a = Mw(n[A], t, o);
      a.operator ? o = a : i.conditions.pop();
    }
    if (i.operator = pm(s), i.operator === -1)
      i = {};
    else if (i.conditions.length === 1)
      i.conditions[0] ? i = i.conditions[0] : i = {};
    else {
      const A = [];
      for (const o in i.conditions)
        i.conditions[o] && A.push(i.conditions[o]);
      i.conditions = A, i.conditions.length === 1 && (i = i.conditions[0]);
    }
  } else if (e.field) {
    const { field: A, value: o } = e, a = t.get(A || {});
    if (a && a.index != null) {
      const { index: r, field: l } = a;
      i.field = r;
      const { subtype: c = ot.CATEGORICAL, format: g = (d) => d } = l.schema(), h = bw(c, o, g);
      i.value = h, i.operator = pm(s), i.operator == -1 && (i = {});
    }
  }
  return i;
};
const {
  entries: Nw,
  setPrototypeOf: Tm,
  isFrozen: pk,
  getPrototypeOf: Qk,
  getOwnPropertyDescriptor: yk
} = Object;
let {
  freeze: Ni,
  seal: Tn,
  create: Fw
} = Object, {
  apply: Hf,
  construct: Of
} = typeof Reflect < "u" && Reflect;
Ni || (Ni = function(t) {
  return t;
});
Tn || (Tn = function(t) {
  return t;
});
Hf || (Hf = function(t, i, n) {
  return t.apply(i, n);
});
Of || (Of = function(t, i) {
  return new t(...i);
});
const Hc = Fi(Array.prototype.forEach), wk = Fi(Array.prototype.lastIndexOf), Gm = Fi(Array.prototype.pop), pr = Fi(Array.prototype.push), Dk = Fi(Array.prototype.splice), _g = Fi(String.prototype.toLowerCase), Lu = Fi(String.prototype.toString), Lm = Fi(String.prototype.match), Qr = Fi(String.prototype.replace), xk = Fi(String.prototype.indexOf), Sk = Fi(String.prototype.trim), Yn = Fi(Object.prototype.hasOwnProperty), wi = Fi(RegExp.prototype.test), yr = _k(TypeError);
function Fi(e) {
  return function(t) {
    for (var i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++)
      n[s - 1] = arguments[s];
    return Hf(e, t, n);
  };
}
function _k(e) {
  return function() {
    for (var t = arguments.length, i = new Array(t), n = 0; n < t; n++)
      i[n] = arguments[n];
    return Of(e, i);
  };
}
function Yt(e, t) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _g;
  Tm && Tm(e, null);
  let n = t.length;
  for (; n--; ) {
    let s = t[n];
    if (typeof s == "string") {
      const A = i(s);
      A !== s && (pk(t) || (t[n] = A), s = A);
    }
    e[s] = !0;
  }
  return e;
}
function bk(e) {
  for (let t = 0; t < e.length; t++)
    Yn(e, t) || (e[t] = null);
  return e;
}
function kA(e) {
  const t = Fw(null);
  for (const [i, n] of Nw(e))
    Yn(e, i) && (Array.isArray(n) ? t[i] = bk(n) : n && typeof n == "object" && n.constructor === Object ? t[i] = kA(n) : t[i] = n);
  return t;
}
function wr(e, t) {
  for (; e !== null; ) {
    const n = yk(e, t);
    if (n) {
      if (n.get)
        return Fi(n.get);
      if (typeof n.value == "function")
        return Fi(n.value);
    }
    e = Qk(e);
  }
  function i() {
    return null;
  }
  return i;
}
const Um = Ni(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Uu = Ni(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Hu = Ni(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Mk = Ni(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Ou = Ni(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Nk = Ni(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), Hm = Ni(["#text"]), Om = Ni(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), Pu = Ni(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Pm = Ni(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Oc = Ni(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Fk = Tn(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Rk = Tn(/<%[\w\W]*|[\w\W]*%>/gm), kk = Tn(/\$\{[\w\W]*/gm), vk = Tn(/^data-[\-\w.\u00B7-\uFFFF]+$/), Tk = Tn(/^aria-[\-\w]+$/), Rw = Tn(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), Gk = Tn(/^(?:\w+script|data):/i), Lk = Tn(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), kw = Tn(/^html$/i), Uk = Tn(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Ym = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: Tk,
  ATTR_WHITESPACE: Lk,
  CUSTOM_ELEMENT: Uk,
  DATA_ATTR: vk,
  DOCTYPE_NAME: kw,
  ERB_EXPR: Rk,
  IS_ALLOWED_URI: Rw,
  IS_SCRIPT_OR_DATA: Gk,
  MUSTACHE_EXPR: Fk,
  TMPLIT_EXPR: kk
});
const Dr = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, Hk = function() {
  return typeof window > "u" ? null : window;
}, Ok = function(t, i) {
  if (typeof t != "object" || typeof t.createPolicy != "function")
    return null;
  let n = null;
  const s = "data-tt-policy-suffix";
  i && i.hasAttribute(s) && (n = i.getAttribute(s));
  const A = "dompurify" + (n ? "#" + n : "");
  try {
    return t.createPolicy(A, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + A + " could not be created."), null;
  }
}, Jm = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function vw() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Hk();
  const t = (Et) => vw(Et);
  if (t.version = "3.2.4", t.removed = [], !e || !e.document || e.document.nodeType !== Dr.document || !e.Element)
    return t.isSupported = !1, t;
  let {
    document: i
  } = e;
  const n = i, s = n.currentScript, {
    DocumentFragment: A,
    HTMLTemplateElement: o,
    Node: a,
    Element: r,
    NodeFilter: l,
    NamedNodeMap: c = e.NamedNodeMap || e.MozNamedAttrMap,
    HTMLFormElement: g,
    DOMParser: h,
    trustedTypes: d
  } = e, u = r.prototype, f = wr(u, "cloneNode"), C = wr(u, "remove"), I = wr(u, "nextSibling"), E = wr(u, "childNodes"), B = wr(u, "parentNode");
  if (typeof o == "function") {
    const Et = i.createElement("template");
    Et.content && Et.content.ownerDocument && (i = Et.content.ownerDocument);
  }
  let m, p = "";
  const {
    implementation: w,
    createNodeIterator: Q,
    createDocumentFragment: y,
    getElementsByTagName: D
  } = i, {
    importNode: _
  } = n;
  let x = Jm();
  t.isSupported = typeof Nw == "function" && typeof B == "function" && w && w.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: S,
    ERB_EXPR: b,
    TMPLIT_EXPR: R,
    DATA_ATTR: G,
    ARIA_ATTR: T,
    IS_SCRIPT_OR_DATA: v,
    ATTR_WHITESPACE: H,
    CUSTOM_ELEMENT: N
  } = Ym;
  let {
    IS_ALLOWED_URI: M
  } = Ym, F = null;
  const k = Yt({}, [...Um, ...Uu, ...Hu, ...Ou, ...Hm]);
  let O = null;
  const P = Yt({}, [...Om, ...Pu, ...Pm, ...Oc]);
  let L = Object.seal(Fw(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), q = null, $ = null, W = !0, U = !0, J = !1, V = !0, Y = !1, nt = !0, tt = !1, st = !1, lt = !1, at = !1, Dt = !1, Qt = !1, St = !0, At = !1;
  const Vt = "user-content-";
  let _t = !0, zt = !1, te = {}, ei = null;
  const ki = Yt({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let ue = null;
  const It = Yt({}, ["audio", "video", "img", "source", "image", "track"]);
  let dt = null;
  const Jt = Yt({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), gt = "http://www.w3.org/1998/Math/MathML", xt = "http://www.w3.org/2000/svg", Ft = "http://www.w3.org/1999/xhtml";
  let se = Ft, Te = !1, Ge = null;
  const Lt = Yt({}, [gt, xt, Ft], Lu);
  let Pt = Yt({}, ["mi", "mo", "mn", "ms", "mtext"]), An = Yt({}, ["annotation-xml"]);
  const yn = Yt({}, ["title", "style", "font", "a", "script"]);
  let fe = null;
  const Me = ["application/xhtml+xml", "text/html"], on = "text/html";
  let $t = null, ut = null;
  const Rt = i.createElement("form"), Mt = function(j) {
    return j instanceof RegExp || j instanceof Function;
  }, Ut = function() {
    let j = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(ut && ut === j)) {
      if ((!j || typeof j != "object") && (j = {}), j = kA(j), fe = // eslint-disable-next-line unicorn/prefer-includes
      Me.indexOf(j.PARSER_MEDIA_TYPE) === -1 ? on : j.PARSER_MEDIA_TYPE, $t = fe === "application/xhtml+xml" ? Lu : _g, F = Yn(j, "ALLOWED_TAGS") ? Yt({}, j.ALLOWED_TAGS, $t) : k, O = Yn(j, "ALLOWED_ATTR") ? Yt({}, j.ALLOWED_ATTR, $t) : P, Ge = Yn(j, "ALLOWED_NAMESPACES") ? Yt({}, j.ALLOWED_NAMESPACES, Lu) : Lt, dt = Yn(j, "ADD_URI_SAFE_ATTR") ? Yt(kA(Jt), j.ADD_URI_SAFE_ATTR, $t) : Jt, ue = Yn(j, "ADD_DATA_URI_TAGS") ? Yt(kA(It), j.ADD_DATA_URI_TAGS, $t) : It, ei = Yn(j, "FORBID_CONTENTS") ? Yt({}, j.FORBID_CONTENTS, $t) : ki, q = Yn(j, "FORBID_TAGS") ? Yt({}, j.FORBID_TAGS, $t) : {}, $ = Yn(j, "FORBID_ATTR") ? Yt({}, j.FORBID_ATTR, $t) : {}, te = Yn(j, "USE_PROFILES") ? j.USE_PROFILES : !1, W = j.ALLOW_ARIA_ATTR !== !1, U = j.ALLOW_DATA_ATTR !== !1, J = j.ALLOW_UNKNOWN_PROTOCOLS || !1, V = j.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Y = j.SAFE_FOR_TEMPLATES || !1, nt = j.SAFE_FOR_XML !== !1, tt = j.WHOLE_DOCUMENT || !1, at = j.RETURN_DOM || !1, Dt = j.RETURN_DOM_FRAGMENT || !1, Qt = j.RETURN_TRUSTED_TYPE || !1, lt = j.FORCE_BODY || !1, St = j.SANITIZE_DOM !== !1, At = j.SANITIZE_NAMED_PROPS || !1, _t = j.KEEP_CONTENT !== !1, zt = j.IN_PLACE || !1, M = j.ALLOWED_URI_REGEXP || Rw, se = j.NAMESPACE || Ft, Pt = j.MATHML_TEXT_INTEGRATION_POINTS || Pt, An = j.HTML_INTEGRATION_POINTS || An, L = j.CUSTOM_ELEMENT_HANDLING || {}, j.CUSTOM_ELEMENT_HANDLING && Mt(j.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (L.tagNameCheck = j.CUSTOM_ELEMENT_HANDLING.tagNameCheck), j.CUSTOM_ELEMENT_HANDLING && Mt(j.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (L.attributeNameCheck = j.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), j.CUSTOM_ELEMENT_HANDLING && typeof j.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (L.allowCustomizedBuiltInElements = j.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Y && (U = !1), Dt && (at = !0), te && (F = Yt({}, Hm), O = [], te.html === !0 && (Yt(F, Um), Yt(O, Om)), te.svg === !0 && (Yt(F, Uu), Yt(O, Pu), Yt(O, Oc)), te.svgFilters === !0 && (Yt(F, Hu), Yt(O, Pu), Yt(O, Oc)), te.mathMl === !0 && (Yt(F, Ou), Yt(O, Pm), Yt(O, Oc))), j.ADD_TAGS && (F === k && (F = kA(F)), Yt(F, j.ADD_TAGS, $t)), j.ADD_ATTR && (O === P && (O = kA(O)), Yt(O, j.ADD_ATTR, $t)), j.ADD_URI_SAFE_ATTR && Yt(dt, j.ADD_URI_SAFE_ATTR, $t), j.FORBID_CONTENTS && (ei === ki && (ei = kA(ei)), Yt(ei, j.FORBID_CONTENTS, $t)), _t && (F["#text"] = !0), tt && Yt(F, ["html", "head", "body"]), F.table && (Yt(F, ["tbody"]), delete q.tbody), j.TRUSTED_TYPES_POLICY) {
        if (typeof j.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw yr('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof j.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw yr('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        m = j.TRUSTED_TYPES_POLICY, p = m.createHTML("");
      } else
        m === void 0 && (m = Ok(d, s)), m !== null && typeof p == "string" && (p = m.createHTML(""));
      Ni && Ni(j), ut = j;
    }
  }, Ne = Yt({}, [...Uu, ...Hu, ...Mk]), ii = Yt({}, [...Ou, ...Nk]), Le = function(j) {
    let rt = B(j);
    (!rt || !rt.tagName) && (rt = {
      namespaceURI: se,
      tagName: "template"
    });
    const Bt = _g(j.tagName), he = _g(rt.tagName);
    return Ge[j.namespaceURI] ? j.namespaceURI === xt ? rt.namespaceURI === Ft ? Bt === "svg" : rt.namespaceURI === gt ? Bt === "svg" && (he === "annotation-xml" || Pt[he]) : !!Ne[Bt] : j.namespaceURI === gt ? rt.namespaceURI === Ft ? Bt === "math" : rt.namespaceURI === xt ? Bt === "math" && An[he] : !!ii[Bt] : j.namespaceURI === Ft ? rt.namespaceURI === xt && !An[he] || rt.namespaceURI === gt && !Pt[he] ? !1 : !ii[Bt] && (yn[Bt] || !Ne[Bt]) : !!(fe === "application/xhtml+xml" && Ge[j.namespaceURI]) : !1;
  }, Ue = function(j) {
    pr(t.removed, {
      element: j
    });
    try {
      B(j).removeChild(j);
    } catch {
      C(j);
    }
  }, We = function(j, rt) {
    try {
      pr(t.removed, {
        attribute: rt.getAttributeNode(j),
        from: rt
      });
    } catch {
      pr(t.removed, {
        attribute: null,
        from: rt
      });
    }
    if (rt.removeAttribute(j), j === "is")
      if (at || Dt)
        try {
          Ue(rt);
        } catch {
        }
      else
        try {
          rt.setAttribute(j, "");
        } catch {
        }
  }, ge = function(j) {
    let rt = null, Bt = null;
    if (lt)
      j = "<remove></remove>" + j;
    else {
      const ni = Lm(j, /^[\r\n\t ]+/);
      Bt = ni && ni[0];
    }
    fe === "application/xhtml+xml" && se === Ft && (j = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + j + "</body></html>");
    const he = m ? m.createHTML(j) : j;
    if (se === Ft)
      try {
        rt = new h().parseFromString(he, fe);
      } catch {
      }
    if (!rt || !rt.documentElement) {
      rt = w.createDocument(se, "template", null);
      try {
        rt.documentElement.innerHTML = Te ? p : he;
      } catch {
      }
    }
    const gi = rt.body || rt.documentElement;
    return j && Bt && gi.insertBefore(i.createTextNode(Bt), gi.childNodes[0] || null), se === Ft ? D.call(rt, tt ? "html" : "body")[0] : tt ? rt.documentElement : gi;
  }, kt = function(j) {
    return Q.call(
      j.ownerDocument || j,
      j,
      // eslint-disable-next-line no-bitwise
      l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT | l.SHOW_PROCESSING_INSTRUCTION | l.SHOW_CDATA_SECTION,
      null
    );
  }, Ie = function(j) {
    return j instanceof g && (typeof j.nodeName != "string" || typeof j.textContent != "string" || typeof j.removeChild != "function" || !(j.attributes instanceof c) || typeof j.removeAttribute != "function" || typeof j.setAttribute != "function" || typeof j.namespaceURI != "string" || typeof j.insertBefore != "function" || typeof j.hasChildNodes != "function");
  }, os = function(j) {
    return typeof a == "function" && j instanceof a;
  };
  function ee(Et, j, rt) {
    Hc(Et, (Bt) => {
      Bt.call(t, j, rt, ut);
    });
  }
  const Fe = function(j) {
    let rt = null;
    if (ee(x.beforeSanitizeElements, j, null), Ie(j))
      return Ue(j), !0;
    const Bt = $t(j.nodeName);
    if (ee(x.uponSanitizeElement, j, {
      tagName: Bt,
      allowedTags: F
    }), j.hasChildNodes() && !os(j.firstElementChild) && wi(/<[/\w]/g, j.innerHTML) && wi(/<[/\w]/g, j.textContent) || j.nodeType === Dr.progressingInstruction || nt && j.nodeType === Dr.comment && wi(/<[/\w]/g, j.data))
      return Ue(j), !0;
    if (!F[Bt] || q[Bt]) {
      if (!q[Bt] && qe(Bt) && (L.tagNameCheck instanceof RegExp && wi(L.tagNameCheck, Bt) || L.tagNameCheck instanceof Function && L.tagNameCheck(Bt)))
        return !1;
      if (_t && !ei[Bt]) {
        const he = B(j) || j.parentNode, gi = E(j) || j.childNodes;
        if (gi && he) {
          const ni = gi.length;
          for (let vi = ni - 1; vi >= 0; --vi) {
            const as = f(gi[vi], !0);
            as.__removalCount = (j.__removalCount || 0) + 1, he.insertBefore(as, I(j));
          }
        }
      }
      return Ue(j), !0;
    }
    return j instanceof r && !Le(j) || (Bt === "noscript" || Bt === "noembed" || Bt === "noframes") && wi(/<\/no(script|embed|frames)/i, j.innerHTML) ? (Ue(j), !0) : (Y && j.nodeType === Dr.text && (rt = j.textContent, Hc([S, b, R], (he) => {
      rt = Qr(rt, he, " ");
    }), j.textContent !== rt && (pr(t.removed, {
      element: j.cloneNode()
    }), j.textContent = rt)), ee(x.afterSanitizeElements, j, null), !1);
  }, an = function(j, rt, Bt) {
    if (St && (rt === "id" || rt === "name") && (Bt in i || Bt in Rt))
      return !1;
    if (!(U && !$[rt] && wi(G, rt))) {
      if (!(W && wi(T, rt))) {
        if (!O[rt] || $[rt]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(qe(j) && (L.tagNameCheck instanceof RegExp && wi(L.tagNameCheck, j) || L.tagNameCheck instanceof Function && L.tagNameCheck(j)) && (L.attributeNameCheck instanceof RegExp && wi(L.attributeNameCheck, rt) || L.attributeNameCheck instanceof Function && L.attributeNameCheck(rt)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            rt === "is" && L.allowCustomizedBuiltInElements && (L.tagNameCheck instanceof RegExp && wi(L.tagNameCheck, Bt) || L.tagNameCheck instanceof Function && L.tagNameCheck(Bt)))
          ) return !1;
        } else if (!dt[rt]) {
          if (!wi(M, Qr(Bt, H, ""))) {
            if (!((rt === "src" || rt === "xlink:href" || rt === "href") && j !== "script" && xk(Bt, "data:") === 0 && ue[j])) {
              if (!(J && !wi(v, Qr(Bt, H, "")))) {
                if (Bt)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, qe = function(j) {
    return j !== "annotation-xml" && Lm(j, N);
  }, wn = function(j) {
    ee(x.beforeSanitizeAttributes, j, null);
    const {
      attributes: rt
    } = j;
    if (!rt || Ie(j))
      return;
    const Bt = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: O,
      forceKeepAttr: void 0
    };
    let he = rt.length;
    for (; he--; ) {
      const gi = rt[he], {
        name: ni,
        namespaceURI: vi,
        value: as
      } = gi, Br = $t(ni);
      let yi = ni === "value" ? as : Sk(as);
      if (Bt.attrName = Br, Bt.attrValue = yi, Bt.keepAttr = !0, Bt.forceKeepAttr = void 0, ee(x.uponSanitizeAttribute, j, Bt), yi = Bt.attrValue, At && (Br === "id" || Br === "name") && (We(ni, j), yi = Vt + yi), nt && wi(/((--!?|])>)|<\/(style|title)/i, yi)) {
        We(ni, j);
        continue;
      }
      if (Bt.forceKeepAttr || (We(ni, j), !Bt.keepAttr))
        continue;
      if (!V && wi(/\/>/i, yi)) {
        We(ni, j);
        continue;
      }
      Y && Hc([S, b, R], (dm) => {
        yi = Qr(yi, dm, " ");
      });
      const hm = $t(j.nodeName);
      if (an(hm, Br, yi)) {
        if (m && typeof d == "object" && typeof d.getAttributeType == "function" && !vi)
          switch (d.getAttributeType(hm, Br)) {
            case "TrustedHTML": {
              yi = m.createHTML(yi);
              break;
            }
            case "TrustedScriptURL": {
              yi = m.createScriptURL(yi);
              break;
            }
          }
        try {
          vi ? j.setAttributeNS(vi, ni, yi) : j.setAttribute(ni, yi), Ie(j) ? Ue(j) : Gm(t.removed);
        } catch {
        }
      }
    }
    ee(x.afterSanitizeAttributes, j, null);
  }, je = function Et(j) {
    let rt = null;
    const Bt = kt(j);
    for (ee(x.beforeSanitizeShadowDOM, j, null); rt = Bt.nextNode(); )
      ee(x.uponSanitizeShadowNode, rt, null), Fe(rt), wn(rt), rt.content instanceof A && Et(rt.content);
    ee(x.afterSanitizeShadowDOM, j, null);
  };
  return t.sanitize = function(Et) {
    let j = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rt = null, Bt = null, he = null, gi = null;
    if (Te = !Et, Te && (Et = "<!-->"), typeof Et != "string" && !os(Et))
      if (typeof Et.toString == "function") {
        if (Et = Et.toString(), typeof Et != "string")
          throw yr("dirty is not a string, aborting");
      } else
        throw yr("toString is not a function");
    if (!t.isSupported)
      return Et;
    if (st || Ut(j), t.removed = [], typeof Et == "string" && (zt = !1), zt) {
      if (Et.nodeName) {
        const as = $t(Et.nodeName);
        if (!F[as] || q[as])
          throw yr("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Et instanceof a)
      rt = ge("<!---->"), Bt = rt.ownerDocument.importNode(Et, !0), Bt.nodeType === Dr.element && Bt.nodeName === "BODY" || Bt.nodeName === "HTML" ? rt = Bt : rt.appendChild(Bt);
    else {
      if (!at && !Y && !tt && // eslint-disable-next-line unicorn/prefer-includes
      Et.indexOf("<") === -1)
        return m && Qt ? m.createHTML(Et) : Et;
      if (rt = ge(Et), !rt)
        return at ? null : Qt ? p : "";
    }
    rt && lt && Ue(rt.firstChild);
    const ni = kt(zt ? Et : rt);
    for (; he = ni.nextNode(); )
      Fe(he), wn(he), he.content instanceof A && je(he.content);
    if (zt)
      return Et;
    if (at) {
      if (Dt)
        for (gi = y.call(rt.ownerDocument); rt.firstChild; )
          gi.appendChild(rt.firstChild);
      else
        gi = rt;
      return (O.shadowroot || O.shadowrootmode) && (gi = _.call(n, gi, !0)), gi;
    }
    let vi = tt ? rt.outerHTML : rt.innerHTML;
    return tt && F["!doctype"] && rt.ownerDocument && rt.ownerDocument.doctype && rt.ownerDocument.doctype.name && wi(kw, rt.ownerDocument.doctype.name) && (vi = "<!DOCTYPE " + rt.ownerDocument.doctype.name + `>
` + vi), Y && Hc([S, b, R], (as) => {
      vi = Qr(vi, as, " ");
    }), m && Qt ? m.createHTML(vi) : vi;
  }, t.setConfig = function() {
    let Et = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Ut(Et), st = !0;
  }, t.clearConfig = function() {
    ut = null, st = !1;
  }, t.isValidAttribute = function(Et, j, rt) {
    ut || Ut({});
    const Bt = $t(Et), he = $t(j);
    return an(Bt, he, rt);
  }, t.addHook = function(Et, j) {
    typeof j == "function" && pr(x[Et], j);
  }, t.removeHook = function(Et, j) {
    if (j !== void 0) {
      const rt = wk(x[Et], j);
      return rt === -1 ? void 0 : Dk(x[Et], rt, 1)[0];
    }
    return Gm(x[Et]);
  }, t.removeHooks = function(Et) {
    x[Et] = [];
  }, t.removeAllHooks = function() {
    x = Jm();
  }, t;
}
var Pk = vw();
const zl = (e, t) => {
  new Int32Array(jl.buffer, e, t.length).set(t);
}, NC = (e, t) => {
  new Float64Array(jl.buffer, e, t.length).set(t);
}, FC = (e = []) => {
  const t = [], i = [];
  return e.forEach((n) => {
    typeof n == "number" && Number.isFinite(n) ? (t.push(n), i.push(1)) : (t.push(NaN), i.push(-1));
  }), {
    indices: i,
    values: t
  };
}, Fs = (e, t) => {
  const i = new Int32Array(jl.buffer, e, t), n = new Array(t);
  for (let s = 0; s < i.length; s++)
    n[s] = i[s];
  return n;
}, Km = (e, t) => {
  const i = new Float64Array(jl.buffer, e, t), n = new Array(t);
  for (let s = 0; s < i.length; s++)
    n[s] = i[s];
  return n;
}, Tw = (e) => {
  let t = "";
  const i = Ae.defaults.getInvalidStore();
  if (e == null)
    return !1;
  if (typeof e == "number") {
    if (isNaN(e))
      return !1;
    t = String(e);
  } else
    t = e;
  return !i.isInvalid(t);
}, Yk = (e = []) => {
  const t = /* @__PURE__ */ new Map(), i = [], n = [];
  let s = 0;
  for (let A = 0; A < e.length; A++) {
    const o = Tw(e[A]);
    o && !t.has(e[A]) ? (t.set(e[A], s), i.push(s), s++, n.push(String(e[A]))) : i.push(o ? t.get(e[A]) : -1);
  }
  return {
    uniqueStrings: n,
    indices: i
  };
}, $l = (e) => ({
  name: e.name,
  type: zF(e.type),
  subtype: XF(e.subtype),
  aggregation_function: ww(e.defAggFn)
}), Gw = (e) => e.map((t) => Pk.sanitize(t));
function Dd(e) {
  return e instanceof qt ? parseFloat(String(e.value())) : e;
}
function xd(e) {
  return e instanceof qt ? String(e.value()) : e;
}
function Jk(e) {
  return e instanceof qt || e === null || e === void 0 || isNaN(e);
}
var Pf;
(function(e) {
  e.NORMALIZE = "normalize";
})(Pf || (Pf = {}));
const Kk = (e) => e === Pf.NORMALIZE ? 1 : 0, Vk = {
  stackBy: (e, t, i, n, s, A = [], o, a = [], r) => {
    const l = { y0: [], y1: [], id: [] }, c = e.context();
    switch (Ae._contextType) {
      case ho.WASM: {
        const g = c.context(), h = c.getSchema().findIndex((p) => t === p.name), d = c.getSchema().findIndex((p) => i === p.name), u = o ? c.getSchema().findIndex((p) => o === p.name) : void 0, f = c.getSchema().findIndex((p) => n === p.name), C = c.getField(i), I = o ? c.getField(o) : void 0;
        let E = Float64Array.from([]), B = Float64Array.from([]);
        C?.subtype() === ot.CATEGORICAL ? E = Float64Array.from(A.map((p) => p instanceof qt ? -1 : C._getMeta().findIndex((w) => w === p))) : E = Float64Array.from(A.map((p) => p instanceof qt ? NaN : p)), I?.subtype() === ot.CATEGORICAL ? B = Float64Array.from(a.map((p) => p instanceof qt ? -1 : I._getMeta().findIndex((w) => w === p))) : B = Float64Array.from(a.map((p) => p instanceof qt ? NaN : p));
        const m = NR(g, h, d, f, yw(s), E, u, B, Kk(r));
        l.y0 = Km(m.get_y_0(), c.getDataMeta().rows), l.y1 = Km(m.get_y_1(), c.getDataMeta().rows), l.id = Fs(m.get_id(), c.getDataMeta().rows), m.free_data(), m.free();
      }
    }
    return l;
  }
};
class Qn {
  static loadData(t, i, n = {}) {
    const s = [], A = i.map((o) => {
      s.push({ ...o });
      const a = { ...o }, { format: r } = a;
      return r && typeof r == "function" && delete a.format, a;
    });
    return n.useWorker !== !1 ? Bm({ data: t, schema: A, options: n }, ER()).then((o) => (o.schema = s, o)) : Bm({ data: t, schema: A, options: n }).then((o) => (o.schema = s, o));
  }
}
Qn.AggregationFunctions = Zg;
Qn.ComparisonOperators = Ui;
Qn.FilteringModes = Bi;
Qn.LogicalOperators = Ns;
Qn.DateTimeFormatter = Nt;
Qn.FieldType = Ct;
Qn.FieldSubtype = ot;
Qn.DerivationOperations = ne;
Qn.SortOrder = Ts;
Qn.Invalid = qt;
Qn.DataWranglers = Vk;
Qn.loadDataSync = IR;
class Xl {
  constructor(t) {
    this._schema = t;
  }
  name() {
    return this._schema.name;
  }
  type() {
    return this._schema.type;
  }
  schema() {
    return this._schema;
  }
  displayName() {
    return this._schema.displayName || this._schema.name;
  }
  subtype() {
    return this._schema.subtype;
  }
}
class Lw extends Xl {
  constructor(t, i) {
    super(t), this._cachedStringDomain = [], this._cachedNumericDomain = [], this._cachedStringData = [], this._cachedNumericData = [], this._cachedFormattedData = [], this._isNaturallyNumeric = null, this._wasmField = i, this._uniqueStrings = [];
  }
  _setMeta(t) {
    this._uniqueStrings = t;
  }
  _getMeta() {
    return this._uniqueStrings;
  }
  uniques() {
    if (this._wasmField && this._cachedStringDomain.length === 0) {
      const t = this._wasmField.get_domain(0), i = Fs(t.data_ptr, t.data_len);
      t.free(), i.forEach((n) => {
        n !== -1 ? this._cachedStringDomain.push(this._uniqueStrings[n]) : this._cachedStringDomain.push(new qt(Ae.defaultInvalidValue()));
      });
    }
    return this._cachedStringDomain;
  }
  isNaturallyNumeric() {
    var t;
    return this._isNaturallyNumeric == null && (this._isNaturallyNumeric = !!(!((t = this._wasmField) === null || t === void 0) && t.is_naturally_numeric())), this._isNaturallyNumeric;
  }
  minMax() {
    if (this._wasmField && this._cachedNumericDomain.length === 0) {
      const t = this._wasmField.get_domain(1), i = Fs(t.data_ptr, t.data_len);
      t.free(), i.forEach((n) => {
        n !== -1 && this._cachedNumericDomain.push(parseFloat(this._uniqueStrings[n]));
      });
    }
    return this._cachedNumericDomain;
  }
  domain() {
    return this.uniques();
  }
  data(t, i) {
    if (t = t || "string", t == "string") {
      const n = (s, A) => Fs(s.get_data_info(), s.get_rows_count()).map((a) => {
        let r;
        const l = this._uniqueStrings[s.get_value_at_index(a)];
        return l === void 0 ? r = new qt(Ae.defaultInvalidValue()) : r = l, A && (r = xd(r)), r;
      });
      return i ? this._wasmField ? n(this._wasmField, !0) : [] : (this._wasmField && this._cachedStringData.length === 0 && (this._cachedStringData = n(this._wasmField, !1)), this._cachedStringData);
    } else {
      const n = (s, A) => Fs(s.get_data_info(), s.get_rows_count()).map((a) => {
        let r;
        const l = this._uniqueStrings[s.get_value_at_index(a)];
        return l === void 0 ? r = new qt(NaN) : r = isNaN(parseFloat(l)) ? new qt(NaN) : parseFloat(l), A && (r = Dd(r)), r;
      });
      return i ? this._wasmField ? n(this._wasmField, !0) : [] : (this._wasmField && this._cachedNumericData.length === 0 && (this._cachedNumericData = n(this._wasmField, !1)), this._cachedNumericData);
    }
  }
  formattedData(t) {
    if (t) {
      const i = this.data(), n = t || this._schema.format, s = [];
      return this._cachedFormattedData = i, n instanceof Function && (i.forEach((A) => {
        let o;
        A instanceof qt ? o = A : o = n(A), s.push(o);
      }), this._cachedFormattedData = s), this._cachedFormattedData;
    }
    return this.data();
  }
  getRowsCount() {
    return this._wasmField ? this._wasmField.get_rows_count() : 0;
  }
  dispose() {
    this._cachedStringData = [], this._cachedNumericData = [], this._cachedStringDomain = [], this._cachedNumericDomain = [], this._cachedFormattedData = [], this._wasmField && this._wasmField.free();
  }
}
const Wk = (e, t, i, n) => {
  const s = Yk(e), { indices: A } = s;
  let { uniqueStrings: o } = s;
  n?.sanitizeString && (o = Gw(o));
  let a;
  const r = Number.MAX_VALUE;
  if (i) {
    const c = i.add_field($l(t), o);
    a = i.get_categorical_field(c);
    const g = a.get_data_indices();
    zl(g, A);
  }
  const l = new Lw(t, a);
  return l._setMeta(o), { field: l, index: r };
};
class Yf extends Xl {
  constructor(t, i) {
    super(t), this._cachedStringDomain = [], this._uniques = [], this._cachedNumericDomain = [], this._cachedStringData = [], this._cachedNumericData = [], this._cachedFormattedData = [], this._wasmField = i, this._cachedFormattedData = [];
  }
  uniques() {
    return this._wasmField && this._uniques.length === 0 && this._wasmField.get_domain(1).forEach((i) => isNaN(i) ? this._uniques.push(new qt(NaN)) : this._uniques.push(i)), this._uniques;
  }
  minMax() {
    return this._wasmField && this._cachedNumericDomain.length === 0 && this._wasmField.get_domain(0).forEach((i) => this._cachedNumericDomain.push(i)), this._cachedNumericDomain;
  }
  domain() {
    return this.minMax();
  }
  getEligibleIndecies(t) {
    return Fs(t.get_data_info(), t.get_rows_count());
  }
  data(t, i) {
    if (t = t || "numeric", t == "numeric") {
      const n = (s, A) => this.getEligibleIndecies(s).map((o) => {
        const a = s.get_value_at_index(o);
        let r;
        return Number.isFinite(a) ? r = a : r = new qt(NaN), A && (r = Dd(r)), r;
      });
      return i ? this._wasmField ? n(this._wasmField, !0) : [] : (this._wasmField && this._cachedNumericData.length === 0 && (this._cachedNumericData = n(this._wasmField, !1)), this._cachedNumericData);
    } else {
      const n = (s, A) => this.getEligibleIndecies(s).map((o) => {
        const a = s.get_value_at_index(o);
        let r;
        return Number.isFinite(a) ? r = a + "" : r = new qt(Ae.defaultInvalidValue()), A && (r = xd(r)), r;
      });
      return i ? this._wasmField ? n(this._wasmField, !0) : [] : (this._wasmField && this._cachedStringData.length === 0 && (this._cachedStringData = n(this._wasmField, !1)), this._cachedStringData);
    }
  }
  formattedData(t) {
    if (this._cachedFormattedData.length === 0 || t) {
      const i = this.data(), n = t || this._schema.format, s = [];
      this._cachedFormattedData = i, n instanceof Function && (i.forEach((A) => {
        let o;
        A instanceof qt ? o = A : o = n(A), s.push(o);
      }), this._cachedFormattedData = s);
    }
    return this._cachedFormattedData;
  }
  getRowsCount() {
    return this._wasmField ? this._wasmField.get_rows_count() : 0;
  }
  dispose() {
    this._cachedStringData = [], this._cachedNumericData = [], this._cachedStringDomain = [], this._cachedNumericDomain = [], this._cachedFormattedData = [], this._wasmField && this._wasmField.free();
  }
}
const qk = (e, t, i) => {
  const { indices: n, values: s } = FC(e);
  let A, o = Number.MAX_VALUE;
  return i && (o = i.add_field($l(t), []), A = i.get_continuous_field(o), zl(A.get_data_indices(), n), NC(A.get_data_ptr(), s)), { field: new Yf(t, A), index: o };
};
class Uw extends Xl {
  constructor(t, i) {
    super(t), this._cachedStringDomain = [], this._uniques = [], this._cachedNumericDomain = [], this._cachedStringData = [], this._cachedNumericData = [], this._wasmField = i, this._cachedFormattedData = [];
  }
  uniques() {
    return this._wasmField && this._uniques.length === 0 && this._wasmField.get_domain(1).forEach((i) => isNaN(i) ? this._uniques.push(new qt(NaN)) : this._uniques.push(i)), this._uniques;
  }
  minMax() {
    return this._wasmField && this._cachedNumericDomain.length === 0 && this._wasmField.get_domain(0).forEach((i) => this._cachedNumericDomain.push(i)), this._cachedNumericDomain;
  }
  domain() {
    return this.minMax();
  }
  getEligibleIndecies(t) {
    return Fs(t.get_data_info(), t.get_rows_count());
  }
  data(t, i) {
    if (t = t || "numeric", t == "numeric") {
      const n = (s, A) => this.getEligibleIndecies(s).map((o) => {
        const a = s.get_value_at_index(o);
        let r;
        return Number.isFinite(a) ? r = a : r = new qt(NaN), A && (r = Dd(r)), r;
      });
      return i ? this._wasmField ? n(this._wasmField, !0) : [] : (this._wasmField && this._cachedNumericData.length === 0 && (this._cachedNumericData = n(this._wasmField, !1)), this._cachedNumericData);
    } else {
      const n = (s, A) => this.getEligibleIndecies(s).map((o) => {
        const a = s.get_value_at_index(o);
        let r;
        return Number.isFinite(a) ? r = Nt.formatAs(new Date(a), this._schema.format) : r = new qt(Ae.defaultInvalidValue()), A && (r = xd(r)), r;
      });
      return i ? this._wasmField ? n(this._wasmField, !0) : [] : (this._wasmField && this._cachedStringData.length === 0 && (this._cachedStringData = n(this._wasmField, !1)), this._cachedStringData);
    }
  }
  formattedData(t) {
    if (this._cachedFormattedData.length === 0 || t) {
      const i = this.data(), n = t || this._schema.format;
      if (this._cachedFormattedData = i, n instanceof Function) {
        const s = [];
        i.forEach((A) => {
          let o;
          A instanceof qt ? o = A : o = n(A), s.push(o);
        }), this._cachedFormattedData = s;
      } else if (typeof n == "string" || n instanceof String) {
        const s = [];
        i.forEach((A) => {
          let o;
          A instanceof qt ? o = A : o = Nt.formatAs(new Date(A), n), s.push(o);
        }), this._cachedFormattedData = s;
      }
    }
    return this._cachedFormattedData;
  }
  getRowsCount() {
    return this._wasmField ? this._wasmField.get_rows_count() : 0;
  }
  dispose() {
    this._cachedStringData = [], this._cachedNumericData = [], this._cachedStringDomain = [], this._cachedNumericDomain = [], this._cachedFormattedData = [], this._wasmField && this._wasmField.free();
  }
  minimumConsecutiveDifference() {
    const t = this._wasmField ? this._wasmField.min_consecutive_diff() : 1 / 0;
    return isFinite(t) ? t : NaN;
  }
}
const jk = (e, t, i) => {
  const { indices: n, values: s } = FC(e);
  let A = Number.MAX_VALUE, o;
  return i && (A = i.add_field($l(t), []), o = i.get_temporal_field(A), zl(o.get_data_indices(), n), NC(o.get_data_ptr(), s)), { field: new Uw(t, o), index: A };
};
class Hw extends Xl {
  constructor(t, i) {
    super(t), this._cachedStringDomain = [], this._cachedNumericDomain = [], this._cachedStringData = [], this._cachedNumericData = [], this._wasmField = i;
  }
  displayName() {
    return this._schema.name;
  }
  domain() {
    return [];
  }
  formattedData() {
    return [];
  }
  uniques() {
    return [];
  }
  minMax() {
    return [];
  }
  data() {
    if (this._cachedNumericData.length === 0 && this._wasmField) {
      const i = Fs(this._wasmField.get_data_info(), this._wasmField.get_rows_count()).map((n) => this._wasmField.get_value_at_index(n));
      this._cachedNumericData = i;
    }
    return this._cachedNumericData;
  }
  getRowsCount() {
    return this._wasmField ? this._wasmField.get_rows_count() : 0;
  }
  getValueAtIndex(t) {
    return this.data()[t];
  }
  dispose() {
    this._cachedStringData = [], this._cachedNumericData = [], this._cachedStringDomain = [], this._cachedNumericDomain = [], this._wasmField && this._wasmField.free();
  }
}
const zk = (e, t, i) => {
  let n, s = Number.MAX_VALUE;
  return i && (s = i.add_field($l(t), []), n = i.get_id_field(s), zl(n.get_data_ptr(), e)), { field: new Hw(t, n), index: s };
}, Yu = () => ({
  name: Lf,
  format: (e) => e,
  displayName: Lf,
  type: Ct.MEASURE,
  subtype: ot.ROWID,
  defAggFn: "sum"
});
class $k extends Xl {
  constructor(t) {
    super(t), this._schema = t;
  }
}
class Ow extends $k {
  constructor(t, i, n) {
    super(t), this._uniques = [], this._allBins = [], this._cachedNumericDomain = [], this._cachedStringData = [], this._cachedNumericData = [], this._cachedFormattedData = [], this._cachedStringDomain = [], this._wasmField = i, this._config = n;
  }
  _setMeta(t) {
    this._config = t;
  }
  _getMeta() {
    return this._config;
  }
  uniques() {
    return this._wasmField && this._uniques.length === 0 && this._wasmField.get_uniques().forEach((i) => isNaN(i) ? this._uniques.push(new qt(NaN)) : this._uniques.push(i)), this._uniques;
  }
  getAllBins() {
    var t;
    if (this._wasmField && this._allBins.length === 0) {
      const i = this.uniques(), [n, s] = i.reduce(([a, r], l) => (Jk(l) || !Number.isFinite(l) ? r.push(l) : a.push(l), [a, r]), [[], []]), A = this.getBinSize();
      let o = [];
      if (!((t = this._config) === null || t === void 0) && t.enableDomainCompletion)
        if (A !== void 0) {
          n.sort((r, l) => r - l);
          let a = null;
          for (let r = 0; r < n.length; r++) {
            const l = n[r];
            if (a === null) {
              o.push(l), a = l;
              continue;
            }
            const c = Math.abs(l - a), g = Math.max(Math.round(c / A) - 1, 0);
            for (let h = 0; h < g; h++) {
              const d = a + A;
              o.push(d), a = d;
            }
            o.push(l), a = l;
          }
          o.push(...s);
        } else
          o = i;
      else
        n.sort((a, r) => a - r), o = n, o.push(...s);
      this._allBins = o;
    }
    return this._allBins;
  }
  minMax() {
    if (this._wasmField && this._cachedNumericDomain.length === 0) {
      const t = this._wasmField.get_domain();
      Number.isFinite(t[0]) && Number.isFinite(t[1]) && (this._cachedNumericDomain[0] = t[0], this._cachedNumericDomain[1] = t[1] + (this.getBinSize() || 0));
    }
    return this._cachedNumericDomain;
  }
  domain() {
    return this.minMax();
  }
  data(t, i) {
    if (t = t || "numeric", t == "numeric") {
      const n = (s, A) => this.getEligibleIndecies(s).map((o) => {
        const a = s.get_value_at_index(o);
        let r;
        return Number.isFinite(a) ? r = a : r = new qt(NaN), A && (r = Dd(r)), r;
      });
      return i ? this._wasmField ? n(this._wasmField, !0) : [] : (this._wasmField && this._cachedNumericData.length === 0 && (this._cachedNumericData = n(this._wasmField, !1)), this._cachedNumericData);
    } else {
      const n = (s, A) => this.getEligibleIndecies(s).map((o) => {
        const a = s.get_value_at_index(o);
        let r;
        return Number.isFinite(a) ? r = a + "" : r = new qt(Ae.defaultInvalidValue()), A && (r = xd(r)), r;
      });
      return i ? this._wasmField ? n(this._wasmField, !0) : [] : (this._wasmField && this._cachedStringData.length === 0 && (this._cachedStringData = n(this._wasmField, !1)), this._cachedStringData);
    }
  }
  getEligibleIndecies(t) {
    return Fs(t.get_data_info(), t.get_rows_count());
  }
  formattedData(t) {
    if (t) {
      const i = this.data(), n = [];
      return t instanceof Function && (i.forEach((s) => {
        let A;
        s instanceof qt ? A = s : A = t(s), n.push(A);
      }), this._cachedFormattedData = n), this._cachedFormattedData;
    }
    return this.data();
  }
  getRowsCount() {
    return this._wasmField ? this._wasmField.get_rows_count() : 0;
  }
  dispose() {
    this._cachedStringData = [], this._cachedNumericData = [], this._cachedNumericDomain = [], this._cachedFormattedData = [], this._cachedStringDomain = [], this._wasmField && this._wasmField.free();
  }
  getBinSize() {
    return this._schema.binSize;
  }
}
const Xk = (e, t, i, n) => {
  const { indices: s, values: A } = FC(e);
  let o, a = Number.MAX_VALUE;
  return i && (a = i.add_field($l(t), []), o = i.get_binned_field(a), zl(o.get_data_indices(), s), NC(o.get_data_ptr(), A)), {
    field: new Ow(t, o, { enableDomainCompletion: n?.enableDomainCompletion }),
    index: a
  };
};
class nh {
  constructor(t, i, n) {
    if (this._contextName = ho.WASM, this._fieldOrder = [], this._fieldMap = /* @__PURE__ */ new Map(), this._dataMeta = { rows: 0, columns: 0 }, this._config = {
      sanitizeString: !1,
      enableDomainCompletion: !0
    }, n && (this._config = n), t instanceof nh)
      this._context = t._context, this._fieldOrder = t._fieldOrder, this._fieldMap = t._fieldMap;
    else {
      const { data: s, schema: A } = t, { rows: o, columns: a } = i;
      this._dataMeta = i, o && (this._context = new El(new Bl(o, a))), this.createFields(s, A);
    }
    this._partialFieldsDisposed = !1;
  }
  updateFieldMap({ field: t, index: i }) {
    const n = t.name(), s = i === Number.MAX_VALUE ? this._fieldMap.size : i;
    this._fieldMap.set(n, { field: t, index: s });
  }
  createFields(t, i) {
    i.forEach((n, s) => {
      this.createField(t[s], n);
    }), this.createField(new Array(t[0].length).fill(0).map((n, s) => s), Yu());
  }
  createField(t, i) {
    const { subtype: n } = i;
    switch (n) {
      case ot.CATEGORICAL:
        this.updateFieldMap(Wk(t, i, this._context, {
          sanitizeString: this._config.sanitizeString
        }));
        break;
      case ot.BINNED:
        this.updateFieldMap(Xk(t, i, this._context, {
          enableDomainCompletion: this._config.enableDomainCompletion
        }));
        break;
      case ot.CONTINUOUS:
        this.updateFieldMap(qk(t, i, this._context));
        break;
      case ot.TEMPORAL:
        this.updateFieldMap(jk(t, i, this._context));
        break;
      case ot.ROWID:
        this.updateFieldMap(zk(t, i, this._context));
        break;
    }
    this._fieldOrder.push(i.name);
  }
  updateFields(t) {
    this._fieldOrder.forEach((i) => {
      const { field: n, index: s } = t.get(i), A = n.schema();
      switch (A.subtype) {
        case ot.CATEGORICAL: {
          const o = new Lw(A, this._context.get_categorical_field(s));
          o._setMeta(n._getMeta()), this.updateFieldMap({
            field: o,
            index: s
          });
          break;
        }
        case ot.CONTINUOUS:
          this.updateFieldMap({
            index: s,
            field: new Yf(A, this._context.get_continuous_field(s))
          });
          break;
        case ot.BINNED: {
          const o = new Ow(A, this._context.get_binned_field(s));
          o._setMeta(n._getMeta()), this.updateFieldMap({
            index: s,
            field: o
          });
          break;
        }
        case ot.TEMPORAL:
          this.updateFieldMap({
            field: new Uw(A, this._context.get_temporal_field(s)),
            index: s
          });
          break;
        case ot.ROWID:
          this.updateFieldMap({
            field: new Hw(A, this._context.get_id_field(s)),
            index: s
          });
          break;
      }
    });
  }
  setContextInfo(t = this._context, i = [...this._fieldOrder], n = this._fieldMap) {
    this._context ? (this._context = t, this._dataMeta = {
      rows: t.row_count(),
      columns: t.column_count()
    }, this._fieldOrder = i, this._fieldMap = /* @__PURE__ */ new Map(), this.updateFields(n)) : (this._fieldOrder = i, this._fieldMap = n);
  }
  getClonedFieldMap(t, i) {
    const n = /* @__PURE__ */ new Map();
    return i.forEach((s, A) => {
      const { field: o } = t._fieldMap.get(s);
      n.set(s, { field: o, index: A });
    }), n;
  }
  getField(t) {
    const { field: i = void 0 } = this._fieldMap.get(t) || {};
    return i;
  }
  getData(t, i, n, s) {
    t = t || 0, n = n || [];
    let A = [];
    const o = [], a = this._fieldMap.get(this._fieldOrder[0]);
    if (a) {
      const { field: r } = a, l = r.getRowsCount(), c = i || l, g = this._fieldOrder.map((h) => {
        const { field: d } = this._fieldMap.get(h), u = n?.find((C) => C.name === d.name());
        return u ? d.data(u.as, s?.shouldSanitize) : d.data(void 0, s?.shouldSanitize);
      });
      for (let h = t; h < c; h++)
        o.push([]), this._fieldOrder.forEach((d, u) => {
          const f = o.length - 1, C = g[u];
          o[f][u] = C[h];
        });
      return A = this.getSchema(), { schema: A, data: o };
    }
    return { schema: A, data: [] };
  }
  getSchema() {
    return this._fieldOrder.map((t) => this._fieldMap.get(t).field.schema());
  }
  getDataMeta() {
    return this._dataMeta;
  }
  sort(t) {
    const i = this.clone();
    if (this._context) {
      const n = [];
      t.forEach((A) => {
        const o = this._fieldMap.get(A[0]);
        o && n.push([o.index, yw(A[1])]);
      });
      const s = this._context.sort(n);
      i.setContextInfo(s);
    }
    return i;
  }
  groupBy(t, i = [], n = { createId: !0 }) {
    const s = this.clone(), [A, o] = t.reduce((g, h) => {
      const d = this._fieldMap.get(h);
      return d && (g[0].push(h), g[1].push(d.index)), g;
    }, [[], []]), a = [];
    i.map((g) => {
      const h = this._fieldMap.get(g.field);
      h && a.push([h.index, ww(g.aggn)]);
    });
    const r = this._context ? this._context.group_by(o, a) : void 0;
    let l = this._fieldOrder.filter((g) => {
      var h, d;
      return ((h = this._fieldMap.get(g)) === null || h === void 0 ? void 0 : h.field) instanceof Yf && !A.includes(g) && ((d = this._fieldMap.get(g)) === null || d === void 0 ? void 0 : d.field.schema().type) !== Ct.DIMENSION;
    });
    l = [...A, ...l];
    const c = this.getClonedFieldMap(s, l);
    if (s.setContextInfo(r, l, c), n.createId !== !1) {
      const { field: g } = s._fieldMap.get(s._fieldOrder[0]), h = g.getRowsCount();
      s.createField(new Array(h).fill(0).map((d, u) => u), Yu());
    }
    return s;
  }
  select(t, i) {
    const n = this.clone();
    let s = n;
    if (this._context) {
      const A = Mw(t, this._fieldMap);
      if (A.operator) {
        const { mode: o = Bi.NORMAL } = i || {}, a = mm(o), r = this._context.select(A, a);
        switch (o) {
          case Bi.ALL: {
            n.setContextInfo(r.get_filtered_dm());
            const l = this.clone();
            l.setContextInfo(r.get_unfiltered_dm()), s = [n, l];
            break;
          }
          case Bi.INVERSE:
            n.setContextInfo(r.get_unfiltered_dm()), s = n;
            break;
          default:
            n.setContextInfo(r.get_filtered_dm()), s = n;
            break;
        }
        r.free();
      } else
        s.setContextInfo(s._context && s._context.clone());
    }
    return s;
  }
  project(t, i) {
    const n = this.clone();
    let s = n;
    const { mode: A = Bi.NORMAL } = i || {}, o = [], a = [];
    t.map((h) => {
      const d = this._fieldMap.get(h);
      d && (o.push(h), a.push(d.index));
    }), o.push(Lf);
    const r = this._fieldOrder.filter((h, d) => !a.includes(d)), l = mm(A), c = this._context ? this._context.project({ columns: a, mode: l }) : void 0;
    let g;
    switch (A) {
      case Bi.ALL: {
        g = this.getClonedFieldMap(n, o), n.setContextInfo(c ? c.get_filtered_dm() : void 0, o, g);
        const h = this.clone();
        g = this.getClonedFieldMap(h, r), h.setContextInfo(c ? c.get_unfiltered_dm() : void 0, r, g), s = [n, h];
        break;
      }
      case Bi.INVERSE:
        g = this.getClonedFieldMap(n, r), n.setContextInfo(c ? c.get_unfiltered_dm() : void 0, r, g), s = n;
        break;
      default:
        g = this.getClonedFieldMap(n, o), n.setContextInfo(c ? c.get_filtered_dm() : void 0, o, g), s = n;
    }
    return c && c.free(), s;
  }
  splitByRow(t) {
    let i = [];
    if (this._context) {
      const n = [];
      t.forEach((o) => {
        const a = this._fieldMap.get(o);
        a && n.push(a.index);
      });
      const s = this._context.split_by_row(n), A = s.get_count();
      i = [];
      for (let o = 0; o < A; o++) {
        const a = this.clone();
        a.setContextInfo(s.get_dm()), i.push(a);
      }
      s.free();
    }
    return i.reverse();
  }
  clone() {
    return new nh(this);
  }
  dispose(t) {
    const { disposePartialFields: i, disposeFields: n } = t, { dispose: s, values: A = [] } = i;
    if (s && this._context) {
      const o = A.map((a) => {
        const { index: r } = this._fieldMap.get(a);
        return r;
      });
      this._partialFieldsDisposed = !0, this._context.dispose(o);
    }
    n && this._fieldOrder.forEach((o) => {
      const { field: a } = this._fieldMap.get(o);
      a.dispose();
    }), this._context && this._context.free();
  }
  addIdField(t) {
    return this.createField(Array.from(t), Yu()), this;
  }
  calculateVariable(t, i, n) {
    const s = this.clone();
    if (this._context) {
      const A = i.map((g) => this._fieldMap.get(g).field.data()), { subtype: o = ot.CATEGORICAL, format: a } = t, r = new Array(this._context.get_partial_row_count());
      r.fill(NaN);
      const l = this._context.get_eligible_rows();
      for (let g = 0; g < this._dataMeta.rows; g++) {
        const h = n(...A.map((d) => d[g]));
        o === ot.TEMPORAL ? r[l[g]] = bw(o, h, a || ((d) => d)) : r[l[g]] = h;
      }
      const c = this._context.clone();
      s.setContextInfo(c), s.createField(r, t);
    }
    return s;
  }
  getMatchingIds(t) {
    return Array.from(this._context && t._context ? this._context.get_matching_ids(t._context) : []);
  }
  context() {
    return this._context;
  }
}
const Zk = {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [ne.SELECT]: (e) => ({
    disposeFields: !0,
    disposePartialFields: {
      dispose: !1,
      values: []
    }
  }),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [ne.PROJECT]: (e) => ({
    disposeFields: !0,
    disposePartialFields: {
      dispose: !1,
      values: []
    }
  }),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [ne.GROUPBY]: (e) => ({
    disposeFields: !0,
    disposePartialFields: {
      dispose: !0,
      values: []
    }
  }),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [ne.SORT]: (e) => ({
    disposeFields: !0,
    disposePartialFields: {
      dispose: !1,
      values: []
    }
  }),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  [ne.SPLIT]: (e) => ({
    disposeFields: !0,
    disposePartialFields: {
      dispose: !1,
      values: []
    }
  }),
  [ne.CALCULATE]: (e) => ({
    disposeFields: !0,
    disposePartialFields: {
      dispose: !0,
      values: [e.fieldInfo.name]
    }
  })
}, tv = (e, t, i, n) => {
  const { listeners: s } = n._propagationInfo;
  return i && s.length ? (s.forEach((A) => {
    A(e, t);
  }), !0) : !1;
}, Vm = (e, t) => {
  for (; e; )
    e._refCount = Math.max(e._refCount + (t ? 1 : -1), 0), e = e?.getParent();
}, ev = (e) => {
  for (; e; ) {
    const t = e?.getParent();
    !e._refCount && e.disposeResources(), e = t;
  }
}, Wm = (e) => {
  for (; e; ) {
    const t = e?.getParent();
    if (!t)
      break;
    e = t;
  }
  return e;
}, iv = (e, t) => {
  const i = /* @__PURE__ */ new Map();
  return e.forEach((n) => {
    const { dm: s = t, criteria: A, fields: o } = n;
    let a = s, r = o.slice();
    const l = o.some((c) => {
      var g;
      return ((g = s.getField(c)) === null || g === void 0 ? void 0 : g.type()) === Ct.MEASURE;
    });
    for (; a; ) {
      const c = a?.getParent(), g = a.getDerivations();
      if (g.length) {
        const { operation: h } = g[0], d = h === ne.GROUPBY && l, u = r.filter((f) => c.getField(f));
        if (d) {
          i.set(a?.id(), A);
          break;
        } else u.length < r.length && (r = u, i.set(a?.id(), A));
      }
      a = c;
    }
  }), i;
}, nv = (e, t) => {
  const { operation: i, params: n } = t.getDerivations()[0];
  let s;
  switch (i) {
    case ne.SELECT:
      s = e.select(n.query);
      break;
    case ne.GROUPBY: {
      s = e.groupBy(n.fields, n.reducers, {
        createId: !1
      });
      const A = s._context.getMatchingIds(t._context);
      s._context.addIdField(A);
      break;
    }
    case ne.PROJECT:
      s = e.project(n.fields);
      break;
    case ne.SORT:
      s = e.sort(n);
      break;
    case ne.CALCULATE:
      s = e.calculateVariable(n.fieldInfo, n.fields, n.fn);
      break;
  }
  return s;
}, Pw = (e, t, i, n) => {
  const { info: s, query: A, targetMap: o, nonPropagationDms: a } = t, { targetDms: r = /* @__PURE__ */ new Set(), payload: l, exclude: c = !0 } = s;
  if (o.get(e.id()) === !1)
    return;
  let g = n;
  const h = t.info.payload ? t.info.payload.propagateDm !== !1 : !0;
  if (A && h) {
    const I = e.id();
    (i.get(I) || !g) && (g = e.select(A), e.removeChild(g), g.detachParent());
  }
  const d = r.has(e.id());
  tv(g, l, c ? !d : d, e) === !1 && (a.push(g), n !== g && a.push(n)), e.getChildren().filter((I) => o.get(I.id()) !== !1).forEach((I) => {
    let E;
    const B = t.info.payload ? t.info.payload.propagateDm !== !1 : !0;
    g && B && (E = nv(g, I)), Pw(I, t, i, E);
  });
}, Yw = (e, t = /* @__PURE__ */ new Set(), i = !0, n = /* @__PURE__ */ new Map()) => {
  const s = e.getChildren();
  let A = !1;
  s.forEach((a) => {
    const r = Yw(a, t, i, n);
    A = A || r;
  });
  const o = t.has(e.id());
  return A = A || (i ? !o : o), n.set(e.id(), A), A;
}, qm = (e, t) => ({
  operator: Ui.EQUAL,
  value: e === Ae.defaultInvalidValue() || e instanceof qt ? void 0 : e,
  field: t
}), sv = (e, t) => {
  let i = {};
  const n = t.length;
  if (n === 1) {
    const s = e.getField(t[0]);
    s ? i = qm(s.domain()[0], t[0]) : i = {};
  } else n > 1 && (i.conditions = [], t.forEach((s, A) => {
    const o = e.getField(s);
    o && (i.operator = Ns.AND, i.conditions[A] = qm(o.domain()[0], s));
  }));
  return i;
};
class Av {
  constructor() {
    this._defaultInvalids = /* @__PURE__ */ new Set();
    const t = Object.values(ih);
    for (const i in t) {
      const n = t[i];
      this._defaultInvalids.add(n);
    }
  }
  setInvalids(t) {
    t.forEach((i) => this._defaultInvalids.add(i));
  }
  getInvalids() {
    return this._defaultInvalids;
  }
  unsetInvalids(t) {
    for (const i in t)
      this._defaultInvalids.delete(t[i]);
  }
  isInvalid(t) {
    return this._defaultInvalids.has(t);
  }
}
const ov = () => {
  let e = Zg.SUM;
  const t = new Av();
  let i = Ek;
  return {
    setDefaultAggregation: (n) => {
      e = n;
    },
    getDefaultAggregation: () => e,
    setInvalids: (n) => {
      t.setInvalids(n);
    },
    unsetInvalids: (n) => {
      t.unsetInvalids(n);
    },
    getInvalidStore: () => t,
    setDefaultInvalidValue: (n) => {
      i = n;
    },
    getDefaultInvalidValue: () => i
  };
}, av = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
class Ae extends Qn {
  static setContext(t = ho.WASM) {
    Ae._contextType = t;
  }
  constructor(t, i) {
    if (super(), this._children = [], this._derivations = [], this._preDisposeTasks = [], this._config = {
      sanitizeString: !1,
      enableDomainCompletion: !0
    }, i && (this._config = i), this._broadcastChannel = null, t instanceof Ae)
      this._context = t._context, this._derivations = [...t._derivations], this._commonDerivation = null;
    else {
      const { data: n, schema: s } = t, A = this.sanitizeSchema(s);
      switch (Ae._contextType) {
        case ho.WASM:
          this._context = this.setWasmContext({ data: n, schema: A }, { rows: n[0].length, columns: A.length }, this._config);
          break;
        default:
          this._context = this.setWasmContext({ data: n, schema: A }, { rows: n[0].length, columns: A.length }, this._config);
      }
      this._commonDerivation = null;
    }
    this._id = av(), this._propagationInfo = {
      listeners: [],
      propagationCriterias: /* @__PURE__ */ new Map()
    }, this._refCount = 1;
  }
  setWasmContext(t, i, n) {
    return new nh(t, i, n);
  }
  setContextInfo(t) {
    this._context = t;
  }
  sanitizeSchema(t) {
    const i = Ae.defaultAggregation();
    return t.map((s) => {
      const { format: A = (o) => o } = s;
      return {
        name: s.name,
        type: s.type,
        subtype: s.subtype || ZF(s.type),
        defAggFn: s.defAggFn || i,
        format: A,
        displayName: s.displayName || s.name,
        binSize: s.binSize
      };
    });
  }
  cloneFromContext(t) {
    if (Array.isArray(t)) {
      const i = t, n = [];
      return i.forEach((s) => {
        const A = this.clone();
        A.setContextInfo(s), A._derivations = [], n.push(A);
      }), n;
    } else {
      const i = this.clone();
      return i._derivations = [], i.setContextInfo(t), i;
    }
  }
  static setInvalids(t) {
    t && Ae.defaults.setInvalids(t);
  }
  static unsetInvalids(t) {
    t && Ae.defaults.unsetInvalids(t);
  }
  static defaultInvalidValue(t) {
    return t && Ae.defaults.setDefaultInvalidValue(t), Ae.defaults.getDefaultInvalidValue();
  }
  static defaultAggregation(t) {
    return t && Ae.defaults.setDefaultAggregation(t), Ae.defaults.getDefaultAggregation();
  }
  static get defaults() {
    return Ae._defaults || (Ae._defaults = ov()), Ae._defaults;
  }
  id() {
    return this._id;
  }
  setCreatorIdentifier(t) {
    return this._creatorIdentifier = t, this;
  }
  getCreatorIdentifier() {
    return this._creatorIdentifier;
  }
  getField(t) {
    return this._context.getField(t);
  }
  getParent() {
    return this._parent;
  }
  getChildren() {
    return [...this._children];
  }
  getDerivations() {
    return [...this._derivations];
  }
  removeChild(t) {
    const i = this._children.findIndex((n) => n === t);
    i > -1 && this._children.splice(i, 1);
  }
  detachParent() {
    return this._parent = void 0, this;
  }
  getData(t, i) {
    return this._context.getData(i?.start, i?.end, t, i);
  }
  getDataMeta() {
    return this._context.getDataMeta();
  }
  getSchema() {
    return this._context.getSchema();
  }
  clone(t = !0) {
    const i = new Ae(this);
    return i.setCreatorIdentifier(this.getCreatorIdentifier()), t && (Vm(this, !0), this._children.push(i), i._parent = this), i;
  }
  sort(t) {
    const i = this._context.sort(t), n = this.cloneFromContext(i);
    return n._derivations.push({ operation: ne.SORT, params: t }), n;
  }
  select(t, i) {
    const { mode: n = Bi.NORMAL } = i || {}, s = this._context.select(t, { mode: n }), A = this.cloneFromContext(s);
    return A instanceof Array ? (A[0]._derivations.push({
      operation: ne.SELECT,
      params: { query: t, options: { mode: Bi.NORMAL } }
    }), A[1]._derivations.push({
      operation: ne.SELECT,
      params: { query: t, options: { mode: Bi.INVERSE } }
    })) : A._derivations.push({
      operation: ne.SELECT,
      params: { query: t, options: { mode: n } }
    }), A;
  }
  splitByRow(t) {
    const i = this._context.splitByRow(t), n = this.cloneFromContext(i);
    return n.map((s) => {
      const A = sv(s, t);
      return s._commonDerivation = {
        operation: ne.SPLIT,
        params: { fields: t }
      }, s._derivations.push({
        operation: ne.SELECT,
        params: { query: A, options: { mode: Bi.NORMAL } }
      });
    }), n;
  }
  project(t, i) {
    const { mode: n = Bi.NORMAL } = i || {}, s = this._context.project(t, { mode: n }), A = this.cloneFromContext(s);
    return A instanceof Array ? (A[0]._derivations.push({
      operation: ne.PROJECT,
      params: { fields: t, options: { mode: Bi.NORMAL } }
    }), A[1]._derivations.push({
      operation: ne.PROJECT,
      params: { fields: t, options: { mode: Bi.INVERSE } }
    })) : A._derivations.push({ operation: ne.PROJECT, params: { fields: t, options: i } }), A;
  }
  groupBy(t, i = [], n = {}) {
    const s = this._context.groupBy(t, i, n), A = this.cloneFromContext(s);
    return A._derivations.push({ operation: ne.GROUPBY, params: { fields: t, reducers: i } }), A;
  }
  disposeRecursive(t = !0) {
    this._refCount = Math.max(this._refCount - 1, 0), (this._refCount === 0 || t) && (this.preDispose(), this.disposeResources(), this.getChildren().forEach((n) => {
      n.disposeRecursive(t);
    }));
  }
  getPropagationCriterias() {
    return this._propagationInfo.propagationCriterias;
  }
  registerPreDisposeTask(t) {
    return this._preDisposeTasks.push(t), () => {
      this.delistPreDisposeTask(t);
    };
  }
  delistPreDisposeTask(t) {
    const i = this._preDisposeTasks.findIndex((n) => n === t);
    this._preDisposeTasks.splice(i, 1);
  }
  preDispose() {
    this._preDisposeTasks.forEach((t) => {
      t();
    });
  }
  dispose(t = !0) {
    if (!this._disposed) {
      const i = this.getParent();
      this.disposeRecursive(t), Vm(i, !1), ev(i);
    }
    return this;
  }
  disposeResources() {
    var t;
    if (this._disposed)
      return this;
    const i = this._derivations[this._derivations.length - 1];
    if (this.closeBroadcastChannel(), i) {
      const n = i.operation;
      this._context.dispose(Zk[n](i.params));
    } else
      this._context.dispose({
        disposeFields: !0,
        disposePartialFields: {
          dispose: !0,
          values: []
        }
      });
    return (t = this._parent) === null || t === void 0 || t.removeChild(this), this.detachParent(), this._disposed = !0, this;
  }
  openBroadcastChannel() {
    const t = Wm(this);
    return this._broadcastChannel == null && this === t && globalThis.BroadcastChannel != null && (this._broadcastChannel = new globalThis.BroadcastChannel(nR), this._broadcastChannel.addEventListener("message", (i) => {
      i.data.creatorIdentifier != null && this.getCreatorIdentifier() != null && i.data.creatorIdentifier === this.getCreatorIdentifier() && this.propagate(i.data.queries, i.data.info, { preventBroadcast: !0 });
    })), this;
  }
  closeBroadcastChannel() {
    return this._broadcastChannel != null && (this._broadcastChannel.close(), this._broadcastChannel = null), this;
  }
  propagate(t, i, { preventBroadcast: n = !1, creatorIdentifier: s } = {
    preventBroadcast: !1
  }) {
    var A;
    const o = Wm(this);
    if (!n && s != null)
      try {
        (A = o._broadcastChannel) === null || A === void 0 || A.postMessage({ queries: t, info: i, creatorIdentifier: s });
      } catch {
      }
    const a = t.map((h) => h.criteria).filter((h) => h !== null), r = a.length ? {
      operator: i.queryOperator || "and",
      conditions: a
    } : null, l = iv(t, this), c = /* @__PURE__ */ new Map();
    Yw(o, i.targetDms, i.exclude, c);
    const g = [];
    return Pw(o, {
      query: r,
      info: i,
      targetMap: c,
      nonPropagationDms: g
    }, l), g.forEach((h) => {
      h && h.dispose(!1);
    }), this;
  }
  onPropagation(t) {
    return this._propagationInfo.listeners.push(t), this;
  }
  unsubscribePropagationListeners() {
    return this._propagationInfo.listeners = [], this;
  }
  calculateVariable(t, i, n) {
    const s = this._context.calculateVariable(this.sanitizeSchema([t])[0], i, n), A = this.cloneFromContext(s);
    return A._derivations.push({ operation: ne.CALCULATE, params: { fieldInfo: t, fields: i, fn: n } }), A;
  }
  context() {
    return this._context;
  }
  static sanitizeStringVals(t) {
    return Gw(t);
  }
}
Ae._contextType = ho.WASM;
var pt = /* @__PURE__ */ ((e) => (e.ROW_ID = "__id__", e.MEASURE_NAMES = "__measure_names__", e))(pt || {}), ka = /* @__PURE__ */ ((e) => (e.ACTION_INF = "actionInf", e.MATRIX_CREATED = "matrixCreated", e))(ka || {}), va = /* @__PURE__ */ ((e) => (e.POLAR = "polar", e.CARTESIAN = "cartesian", e))(va || {}), Jw = /* @__PURE__ */ ((e) => (e.FUNCTION = "function", e.STRING = "string", e.NUMBER = "number", e.BOOLEAN = "Boolean", e))(Jw || {});
const rv = "stack", lv = "stack100percent", Kw = "asc", Vw = "desc", jm = "horizontal", sh = "binned", Ww = "SimpleVar", RC = "ComposedVar", qw = "NullVar";
var ft = /* @__PURE__ */ ((e) => (e.DISCRETE = "discrete", e.CONTINUOUS = "continuous", e))(ft || {});
const jw = "backgroundColor", zw = "color", $w = "size", al = " ", kC = 5, bo = "_blank", Mo = "nofollow", No = {}, Fo = "", Xw = "", Zw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BACKGROUND_COLOR: jw,
  COLOR: zw,
  COL_HTML_FACET_AND_HEADER_TOP_PADDING: kC,
  DEFAULT_HYP_CLASSNAMES: Fo,
  DEFAULT_HYP_REL: Mo,
  DEFAULT_HYP_STYLES: No,
  DEFAULT_HYP_TARGET: bo,
  DEFAULT_HYP_URL: Xw,
  EMPTY_CELL_CONTENT: al,
  SCALES: ft,
  SIZE: $w
}, Symbol.toStringTag, { value: "Module" })), ml = "__id__", ht = "8bc7333f_a088_4b34_b02a_b5a6064f9b85", cv = "step";
class Gn extends Error {
  name;
  constructor(t, i) {
    super(t, i), this.name = "MuzeError";
  }
}
const { DISCRETE: gv, CONTINUOUS: hv } = ft;
class K {
  static _dataModelCls;
  _model;
  _propagationListeners;
  _id;
  _disposeListeners;
  _disposed = !1;
  _prevPayload;
  _uidMap;
  _parent;
  _fieldsConfig;
  _propagation;
  propagationState;
  constructor(t, i) {
    const n = K.DataModel();
    if (t instanceof n ? this._model = t : i ? this._model = new n(t, {
      sanitizeString: i.sanitizeString,
      enableDomainCompletion: i.enableDomainCompletion
    }) : this._model = new n(t), i) {
      const { creatorIdentifier: s } = i;
      s && this.setCreatorIdentifier(s);
    }
    this._fieldsConfig = null, this.propagationState = /* @__PURE__ */ new Map(), this._propagationListeners = [], this._id = this.model.id();
  }
  static get ComparisonOperators() {
    return this.DataModel().ComparisonOperators;
  }
  static get FilteringModes() {
    return this.DataModel().FilteringModes;
  }
  static get LogicalOperators() {
    return this.DataModel().LogicalOperators;
  }
  static get SortOrder() {
    return this.DataModel().SortOrder;
  }
  static get DateTimeFormatter() {
    return this.DataModel().DateTimeFormatter;
  }
  static get FieldType() {
    return this.DataModel().FieldType;
  }
  static get FieldSubtype() {
    return this.DataModel().FieldSubtype;
  }
  static get DerivationOperations() {
    return this.DataModel().DerivationOperations;
  }
  static Invalid(t) {
    return new qt(t);
  }
  static get AggregationFunctions() {
    return this.DataModel().AggregationFunctions;
  }
  static DataModel() {
    return Ae;
  }
  static loadData(t, i, n) {
    return this.DataModel().loadData(t, i, n);
  }
  static isInvalid(t) {
    return t instanceof qt;
  }
  static createInvalid(t) {
    const i = this.DataModel();
    return t === ot.CONTINUOUS || t === ot.TEMPORAL ? new qt(NaN) : new qt(i.defaultInvalidValue());
  }
  static getActualValue(t) {
    return this.isInvalid(t) ? t.value() : t;
  }
  get model() {
    return this._model;
  }
  static sanitiseStrings(t) {
    return this.DataModel().sanitizeStringVals(t);
  }
  setCreatorIdentifier(t) {
    return this.model.setCreatorIdentifier(t), this;
  }
  getCreatorIdentifier() {
    return this.model.getCreatorIdentifier();
  }
  getField(t) {
    return this.model.getField(t);
  }
  getFieldData(t) {
    return this.model.getField(t).data();
  }
  select(t, i) {
    if (!this.isDisposed())
      try {
        const n = this.model.select(t, i);
        return n instanceof Array ? n.map((s) => this.clone(s)) : this.clone(n);
      } catch {
        throw new Gn(
          "select operation on datamodel after it has been disposed"
        );
      }
    return null;
  }
  groupBy(t, i, n) {
    const s = this.model.groupBy(t, i, n);
    return this.clone(s);
  }
  sort(t) {
    const i = this.model._context._fieldMap, n = t.reduce(
      (A, [o, a = "asc"]) => i.get(o) === void 0 ? A : [...A, [o, a]],
      []
    );
    if (!n.length) return this;
    const s = this.model.sort(n);
    return this.clone(s);
  }
  getData(t = {}) {
    const { fieldMeta: i, shouldSanitize: n, excludeFields: s, start: A, end: o } = t, { data: a, schema: r } = this.model.getData(i, {
      start: A,
      end: o,
      shouldSanitize: n
    });
    if (s) {
      let l = a, c = r;
      return s.forEach((g) => {
        const h = c.findIndex(
          (d) => d.name === g
        );
        l = l.map(
          (d) => d.filter((u, f) => f !== h)
        ), c = c.filter(
          (d, u) => u !== h
        );
      }), { data: l, schema: c };
    }
    return { data: a, schema: r };
  }
  isEmpty() {
    const { rows: t } = this.model.getDataMeta();
    return !t;
  }
  isDimension(t) {
    const i = this.getField(t);
    return i && i.type() === Ct.DIMENSION;
  }
  isMeasure(t) {
    const i = this.getField(t);
    return i && i.type() === Ct.MEASURE;
  }
  isTemporal(t) {
    const i = this.getField(t);
    return i && i.subtype() === ot.TEMPORAL;
  }
  isBinned(t) {
    const i = this.getField(t);
    return i && i.subtype() === ot.BINNED;
  }
  isCategorical(t) {
    const i = this.getField(t);
    return i && i.subtype() === ot.CATEGORICAL;
  }
  isFieldPresent(t) {
    return !!this.getField(t);
  }
  removeChild(t) {
    this.model.removeChild(t.model);
  }
  getSchema(t) {
    const i = this.model.getSchema();
    return t && t.excludeFields ? i.filter((n) => {
      const s = n.name;
      return !t.excludeFields.includes(s);
    }) : i;
  }
  getValueAtIndex(t, i) {
    const n = this.getField(t);
    return n ? n.data()[i] : null;
  }
  // @todo remove this once dm supports timestamp in selection
  getFormattedValueAtIndex(t, i) {
    return this.getField(t).data()[i];
  }
  getFieldNames() {
    return this.getSchema().map((t) => t.name);
  }
  getFieldIndex(t) {
    return t && this.isFieldPresent(t) ? this.model._context._fieldMap.get(t).index : null;
  }
  getRowsCount() {
    return this.model.getDataMeta().rows;
  }
  getDimensions() {
    return this.getSchema().filter((t) => t.type === Ct.DIMENSION).map((t) => t.name);
  }
  hasOneValue() {
    let t = !1;
    const i = this.getFieldNames();
    for (let n = 0, s = this.getRowsCount(); n < s && !t && (t = i.some((A) => {
      const o = this.getValueAtIndex(A, n);
      return !o || K.isInvalid(o) ? !1 : o;
    }), !t); n++)
      ;
    return t;
  }
  openBroadcastChannel() {
    return this.model.openBroadcastChannel(), this;
  }
  closeBroadcastChannel() {
    return this.model.closeBroadcastChannel(), this;
  }
  dispose(t) {
    if (typeof t != "boolean" && (t = !0), this._disposeListeners && this._disposeListeners(), this._disposed = !0, !this.model._disposed)
      try {
        this.model.dispose(t);
      } catch (i) {
        throw new Gn(
          `attempt to dispose a already disposed datamodel: (${i.message})`
        );
      }
  }
  isDisposed() {
    return this.model._disposed;
  }
  project(t) {
    const i = [
      ...new Set(
        t.filter(
          (A) => this.getField(A) && A !== pt.ROW_ID
        )
      )
    ], n = this.model.project(i);
    return Array.isArray(n) ? n.map((A) => this.clone(A)) : this.clone(n);
  }
  calculateVariable(t, i, n) {
    const s = this.model.calculateVariable(t, i, n);
    return this.clone(s);
  }
  clone(t) {
    return new K(t, t._config);
  }
  getSubtype(t) {
    const i = this.getField(t);
    return i ? i.subtype() : null;
  }
  getMeasures() {
    return this.getSchema().filter(
      (t) => t.type === Ct.MEASURE && t.name !== pt.ROW_ID
    ).map((t) => t.name);
  }
  splitByRow(t) {
    return this.model.splitByRow(t).map((n) => this.clone(n));
  }
  splitByColumn(t, i) {
    const n = [];
    return t = t.length ? t : [[]], t.forEach((s) => {
      n.push(
        this.project(
          new Array(.../* @__PURE__ */ new Set([...s, ...i]))
        )
      );
    }), n;
  }
  getQueryFromIds(t, i, n = !0) {
    const s = this.getUidMap(), A = [], o = {}, a = this.isTemporal(i[0]);
    if (i.length === 1 && n && !a) {
      const r = t.map((l) => {
        let c = this.getFormattedValueAtIndex(i[0], s[l]);
        return K.isInvalid(c) && (c = K.getActualValue(c)), c;
      });
      return {
        operator: Ui.IN,
        field: i[0],
        value: r
      };
    }
    return t.forEach((r) => {
      const l = [];
      if (n) {
        let c = "";
        if (i.forEach((g) => {
          let h = this.getFormattedValueAtIndex(g, s[r]);
          K.isInvalid(h) && (h = K.getActualValue(h)), l.push({
            field: g,
            operator: Ui.EQUAL,
            value: h
          }), c += h;
        }), o[c])
          return;
        o[c] = !0;
      } else
        l.push({
          field: i[0],
          operator: Ui.EQUAL,
          value: r
        });
      A.push({
        conditions: l,
        operator: Ns.AND
      });
    }), {
      conditions: A,
      operator: Ns.OR
    };
  }
  getPropagationQuery(t, i) {
    const { fields: n, interpolated: s } = i;
    let A;
    return t ? i.isQuery ? A = t : s ? A = this.getFilterRangeQuery(
      t,
      i.type,
      i.domain
    ) : A = this.getQueryFromIds(
      t,
      n,
      i.resolveId
    ) : A = null, A;
  }
  // @TODO: remove any
  propagate(t, i, n = {}) {
    const s = Object.assign(
      {},
      {
        payload: i
      },
      n
    );
    return i.resetAllInteractions ? (this._prevPayload && i.sourceAction === this._prevPayload.sourceAction ? this.model.propagate(t, s, {
      preventBroadcast: !0,
      creatorIdentifier: this._model.getCreatorIdentifier()
    }) : this.model.propagate(t, s, {
      creatorIdentifier: this._model.getCreatorIdentifier()
    }), this._prevPayload = i) : this.model.propagate(t, s, {
      creatorIdentifier: this._model.getCreatorIdentifier()
    }), this;
  }
  getFilterRangeQuery(t, i = "", n = []) {
    const s = Object.keys(t).map((A) => {
      let o;
      return this.isCategorical(A) ? o = [
        {
          field: A,
          value: t[A],
          operator: Ui.IN
        }
      ] : o = (t[A][0] instanceof Array ? t[A] : [t[A]]).map((r) => ({
        conditions: [
          {
            field: A,
            operator: Ui.GREATER_THAN_EQUAL,
            value: r[0]
          },
          {
            field: A,
            operator: i === cv && typeof n[1] == "number" && r[1] < n[n.length - 1] ? Ui.LESS_THAN : Ui.LESS_THAN_EQUAL,
            value: r[1]
          }
        ],
        operator: Ns.AND
      })), {
        conditions: o,
        operator: Ns.OR
      };
    });
    return {
      operator: Ns.AND,
      conditions: s
    };
  }
  onPropagation(t) {
    return this._propagationListeners.push(t), this.model.unsubscribePropagationListeners().onPropagation((i, n) => {
      if (this._propagationListeners.length) {
        let s;
        i ? (s = this.clone(i), this.removeChild(s)) : s = null, s && (s._propagation = !0), this._propagationListeners.forEach(
          /* eslint-disable-next-line no-unused-vars */
          (A) => A(s, n)
        );
      }
    }), this;
  }
  unsubscribe(t) {
    return t && (this._propagationListeners = this._propagationListeners.filter(
      (i) => i !== t
    )), this;
  }
  getDerivations() {
    return this.model.getDerivations();
  }
  getAncestorDerivations() {
    const t = this.model.getParent();
    return t ? t.getDerivations() : [];
  }
  isParent(t) {
    const i = (n, s) => {
      const A = n.getParent();
      return A ? A === s ? !0 : i(A, s) : !1;
    };
    return i(this._model, t._model);
  }
  getUids() {
    return this.model.getField(ml).data();
  }
  getTemporalFields() {
    return this.getSchema().filter((t) => t.subtype === "temporal").map((t) => t.name);
  }
  getUidMap() {
    if (this._uidMap)
      return this._uidMap;
    const t = this.getUids();
    return this._uidMap = t.reduce(
      (i, n, s) => (i[n] = s, i),
      {}
    ), this._uidMap;
  }
  getDomain(t, i) {
    if (this.isEmpty())
      return null;
    const n = this.getField(t), s = n.subtype();
    return n ? i === gv ? s === sh ? n.getAllBins().slice() : n.uniques().slice() : i === hv ? n.minMax().slice() : n.domain().slice() : null;
  }
  id() {
    return this._id;
  }
  getParent() {
    return this._parent;
  }
  breakLink(t) {
    return t.removeChild(this), this.detachParent();
  }
  detachParent() {
    return this._parent = null, this.model.detachParent(), this;
  }
  replica() {
    const t = this.getFieldNames();
    return this.project(
      t.filter((i) => i !== pt.ROW_ID)
    );
  }
  createEmptyDm() {
    return this.select({
      field: ml,
      value: Number.MAX_SAFE_INTEGER,
      operator: Ui.EQUAL
    });
  }
  sanitiseStrings(t) {
    return K.sanitiseStrings(t);
  }
}
const dv = () => K;
function vC(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function tD(e) {
  return e.length === 1 && (e = uv(e)), {
    left: function(t, i, n, s) {
      for (n == null && (n = 0), s == null && (s = t.length); n < s; ) {
        var A = n + s >>> 1;
        e(t[A], i) < 0 ? n = A + 1 : s = A;
      }
      return n;
    },
    right: function(t, i, n, s) {
      for (n == null && (n = 0), s == null && (s = t.length); n < s; ) {
        var A = n + s >>> 1;
        e(t[A], i) > 0 ? s = A : n = A + 1;
      }
      return n;
    }
  };
}
function uv(e) {
  return function(t, i) {
    return vC(e(t), i);
  };
}
var fv = tD(vC), Sd = fv.right;
function Iv(e) {
  return e === null ? NaN : +e;
}
function Cv(e, t, i) {
  e = +e, t = +t, i = (s = arguments.length) < 2 ? (t = e, e = 0, 1) : s < 3 ? 1 : +i;
  for (var n = -1, s = Math.max(0, Math.ceil((t - e) / i)) | 0, A = new Array(s); ++n < s; )
    A[n] = e + n * i;
  return A;
}
var Jf = Math.sqrt(50), Kf = Math.sqrt(10), Vf = Math.sqrt(2);
function eD(e, t, i) {
  var n, s = -1, A, o, a;
  if (t = +t, e = +e, i = +i, e === t && i > 0) return [e];
  if ((n = t < e) && (A = e, e = t, t = A), (a = bg(e, t, i)) === 0 || !isFinite(a)) return [];
  if (a > 0)
    for (e = Math.ceil(e / a), t = Math.floor(t / a), o = new Array(A = Math.ceil(t - e + 1)); ++s < A; ) o[s] = (e + s) * a;
  else
    for (e = Math.floor(e * a), t = Math.ceil(t * a), o = new Array(A = Math.ceil(e - t + 1)); ++s < A; ) o[s] = (e - s) / a;
  return n && o.reverse(), o;
}
function bg(e, t, i) {
  var n = (t - e) / Math.max(0, i), s = Math.floor(Math.log(n) / Math.LN10), A = n / Math.pow(10, s);
  return s >= 0 ? (A >= Jf ? 10 : A >= Kf ? 5 : A >= Vf ? 2 : 1) * Math.pow(10, s) : -Math.pow(10, -s) / (A >= Jf ? 10 : A >= Kf ? 5 : A >= Vf ? 2 : 1);
}
function Wf(e, t, i) {
  var n = Math.abs(t - e) / Math.max(0, i), s = Math.pow(10, Math.floor(Math.log(n) / Math.LN10)), A = n / s;
  return A >= Jf ? s *= 10 : A >= Kf ? s *= 5 : A >= Vf && (s *= 2), t < e ? -s : s;
}
function Ev(e, t, i) {
  if (i == null && (i = Iv), !!(n = e.length)) {
    if ((t = +t) <= 0 || n < 2) return +i(e[0], 0, e);
    if (t >= 1) return +i(e[n - 1], n - 1, e);
    var n, s = (n - 1) * t, A = Math.floor(s), o = +i(e[A], A, e), a = +i(e[A + 1], A + 1, e);
    return o + (a - o) * (s - A);
  }
}
var Sn = "$";
function Ah() {
}
Ah.prototype = Ta.prototype = {
  constructor: Ah,
  has: function(e) {
    return Sn + e in this;
  },
  get: function(e) {
    return this[Sn + e];
  },
  set: function(e, t) {
    return this[Sn + e] = t, this;
  },
  remove: function(e) {
    var t = Sn + e;
    return t in this && delete this[t];
  },
  clear: function() {
    for (var e in this) e[0] === Sn && delete this[e];
  },
  keys: function() {
    var e = [];
    for (var t in this) t[0] === Sn && e.push(t.slice(1));
    return e;
  },
  values: function() {
    var e = [];
    for (var t in this) t[0] === Sn && e.push(this[t]);
    return e;
  },
  entries: function() {
    var e = [];
    for (var t in this) t[0] === Sn && e.push({ key: t.slice(1), value: this[t] });
    return e;
  },
  size: function() {
    var e = 0;
    for (var t in this) t[0] === Sn && ++e;
    return e;
  },
  empty: function() {
    for (var e in this) if (e[0] === Sn) return !1;
    return !0;
  },
  each: function(e) {
    for (var t in this) t[0] === Sn && e(this[t], t.slice(1), this);
  }
};
function Ta(e, t) {
  var i = new Ah();
  if (e instanceof Ah) e.each(function(a, r) {
    i.set(r, a);
  });
  else if (Array.isArray(e)) {
    var n = -1, s = e.length, A;
    if (t == null) for (; ++n < s; ) i.set(n, e[n]);
    else for (; ++n < s; ) i.set(t(A = e[n], n, e), A);
  } else if (e) for (var o in e) i.set(o, e[o]);
  return i;
}
function iD() {
  var e = [], t = [], i, n, s;
  function A(a, r, l, c) {
    if (r >= e.length)
      return i != null && a.sort(i), n != null ? n(a) : a;
    for (var g = -1, h = a.length, d = e[r++], u, f, C = Ta(), I, E = l(); ++g < h; )
      (I = C.get(u = d(f = a[g]) + "")) ? I.push(f) : C.set(u, [f]);
    return C.each(function(B, m) {
      c(E, m, A(B, r, l, c));
    }), E;
  }
  function o(a, r) {
    if (++r > e.length) return a;
    var l, c = t[r - 1];
    return n != null && r >= e.length ? l = a.entries() : (l = [], a.each(function(g, h) {
      l.push({ key: h, values: o(g, r) });
    })), c != null ? l.sort(function(g, h) {
      return c(g.key, h.key);
    }) : l;
  }
  return s = {
    object: function(a) {
      return A(a, 0, Bv, mv);
    },
    map: function(a) {
      return A(a, 0, zm, $m);
    },
    entries: function(a) {
      return o(A(a, 0, zm, $m), 0);
    },
    key: function(a) {
      return e.push(a), s;
    },
    sortKeys: function(a) {
      return t[e.length - 1] = a, s;
    },
    sortValues: function(a) {
      return i = a, s;
    },
    rollup: function(a) {
      return n = a, s;
    }
  };
}
function Bv() {
  return {};
}
function mv(e, t, i) {
  e[t] = i;
}
function zm() {
  return Ta();
}
function $m(e, t, i) {
  e.set(t, i);
}
function Xm() {
}
var _A = Ta.prototype;
Xm.prototype = {
  constructor: Xm,
  has: _A.has,
  add: function(e) {
    return e += "", this[Sn + e] = e, this;
  },
  remove: _A.remove,
  clear: _A.clear,
  values: _A.keys,
  size: _A.size,
  empty: _A.empty,
  each: _A.each
};
var nD = Array.prototype, TC = nD.map, fA = nD.slice, Zm = { name: "implicit" };
function GC(e) {
  var t = Ta(), i = [], n = Zm;
  e = e == null ? [] : fA.call(e);
  function s(A) {
    var o = A + "", a = t.get(o);
    if (!a) {
      if (n !== Zm) return n;
      t.set(o, a = i.push(A));
    }
    return e[(a - 1) % e.length];
  }
  return s.domain = function(A) {
    if (!arguments.length) return i.slice();
    i = [], t = Ta();
    for (var o = -1, a = A.length, r, l; ++o < a; ) t.has(l = (r = A[o]) + "") || t.set(l, i.push(r));
    return s;
  }, s.range = function(A) {
    return arguments.length ? (e = fA.call(A), s) : e.slice();
  }, s.unknown = function(A) {
    return arguments.length ? (n = A, s) : n;
  }, s.copy = function() {
    return GC().domain(i).range(e).unknown(n);
  }, s;
}
function LC() {
  var e = GC().unknown(void 0), t = e.domain, i = e.range, n = [0, 1], s, A, o = !1, a = 0, r = 0, l = 0.5;
  delete e.unknown;
  function c() {
    var g = t().length, h = n[1] < n[0], d = n[h - 0], u = n[1 - h];
    s = (u - d) / Math.max(1, g - a + r * 2), o && (s = Math.floor(s)), d += (u - d - s * (g - a)) * l, A = s * (1 - a), o && (d = Math.round(d), A = Math.round(A));
    var f = Cv(g).map(function(C) {
      return d + s * C;
    });
    return i(h ? f.reverse() : f);
  }
  return e.domain = function(g) {
    return arguments.length ? (t(g), c()) : t();
  }, e.range = function(g) {
    return arguments.length ? (n = [+g[0], +g[1]], c()) : n.slice();
  }, e.rangeRound = function(g) {
    return n = [+g[0], +g[1]], o = !0, c();
  }, e.bandwidth = function() {
    return A;
  }, e.step = function() {
    return s;
  }, e.round = function(g) {
    return arguments.length ? (o = !!g, c()) : o;
  }, e.padding = function(g) {
    return arguments.length ? (a = r = Math.max(0, Math.min(1, g)), c()) : a;
  }, e.paddingInner = function(g) {
    return arguments.length ? (a = Math.max(0, Math.min(1, g)), c()) : a;
  }, e.paddingOuter = function(g) {
    return arguments.length ? (r = Math.max(0, Math.min(1, g)), c()) : r;
  }, e.align = function(g) {
    return arguments.length ? (l = Math.max(0, Math.min(1, g)), c()) : l;
  }, e.copy = function() {
    return LC().domain(t()).range(n).round(o).paddingInner(a).paddingOuter(r).align(l);
  }, e.invertExtent = function(g, h) {
    var d = +g, u = arguments.length > 1 ? +h : d, f = n[1] < n[0], C = f ? i().reverse() : i(), I = C.length - 1, E, B, m, p;
    if (C.push(C[I] + this.step()), u < d && (m = d, d = u, u = m), !(u < C[0] || d > n[1 - f]))
      return E = Math.max(0, Ju(C, d)), p = Ju(C, u), B = d === u ? E : Math.max(E, p - 1), f && (m = E, E = I - B, B = I - m), E > B ? void 0 : t().slice(E, B + 1);
  }, e.invert = function(g, h) {
    var d = +g, u = arguments.length > 1 ? +h : d, f = n[1] < n[0], C = f ? i().reverse() : i(), I = C.length - 1, E, B;
    if (u < d && (B = d, d = u, u = B), !(u < C[0] || d > n[1 - f]))
      return E = Math.max(0, Ju(C, d, "left")), t()[f ? I - E : E];
  }, c();
}
function Ju(e, t, i) {
  for (var n = 0, s = e.length, A = s - 1, o, a, r, l; n < A; )
    a = Math.floor((n + A) / 2), r = Math.abs(e[a] - t), l = Math.abs(e[a + 1] - t), l <= r ? n = a + 1 : A = a;
  return !i || (o = e[A], o === t) ? A : o > t ? A === 0 ? A : i === "left" ? A - 1 : A : A === e.length - 1 || i === "left" ? A : A + 1;
}
function _d(e, t, i) {
  e.prototype = t.prototype = i, i.constructor = e;
}
function UC(e, t) {
  var i = Object.create(e.prototype);
  for (var n in t) i[n] = t[n];
  return i;
}
function or() {
}
var uo = 0.7, Ga = 1 / uo, Ea = "\\s*([+-]?\\d+)\\s*", pl = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", fs = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", pv = /^#([0-9a-f]{3,8})$/, Qv = new RegExp("^rgb\\(" + [Ea, Ea, Ea] + "\\)$"), yv = new RegExp("^rgb\\(" + [fs, fs, fs] + "\\)$"), wv = new RegExp("^rgba\\(" + [Ea, Ea, Ea, pl] + "\\)$"), Dv = new RegExp("^rgba\\(" + [fs, fs, fs, pl] + "\\)$"), xv = new RegExp("^hsl\\(" + [pl, fs, fs] + "\\)$"), Sv = new RegExp("^hsla\\(" + [pl, fs, fs, pl] + "\\)$"), tp = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
_d(or, IA, {
  copy: function(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: ep,
  // Deprecated! Use color.formatHex.
  formatHex: ep,
  formatHsl: _v,
  formatRgb: ip,
  toString: ip
});
function ep() {
  return this.rgb().formatHex();
}
function _v() {
  return AD(this).formatHsl();
}
function ip() {
  return this.rgb().formatRgb();
}
function IA(e) {
  var t, i;
  return e = (e + "").trim().toLowerCase(), (t = pv.exec(e)) ? (i = t[1].length, t = parseInt(t[1], 16), i === 6 ? np(t) : i === 3 ? new _i(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : i === 8 ? Pc(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : i === 4 ? Pc(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Qv.exec(e)) ? new _i(t[1], t[2], t[3], 1) : (t = yv.exec(e)) ? new _i(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = wv.exec(e)) ? Pc(t[1], t[2], t[3], t[4]) : (t = Dv.exec(e)) ? Pc(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = xv.exec(e)) ? op(t[1], t[2] / 100, t[3] / 100, 1) : (t = Sv.exec(e)) ? op(t[1], t[2] / 100, t[3] / 100, t[4]) : tp.hasOwnProperty(e) ? np(tp[e]) : e === "transparent" ? new _i(NaN, NaN, NaN, 0) : null;
}
function np(e) {
  return new _i(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Pc(e, t, i, n) {
  return n <= 0 && (e = t = i = NaN), new _i(e, t, i, n);
}
function sD(e) {
  return e instanceof or || (e = IA(e)), e ? (e = e.rgb(), new _i(e.r, e.g, e.b, e.opacity)) : new _i();
}
function Ql(e, t, i, n) {
  return arguments.length === 1 ? sD(e) : new _i(e, t, i, n ?? 1);
}
function _i(e, t, i, n) {
  this.r = +e, this.g = +t, this.b = +i, this.opacity = +n;
}
_d(_i, Ql, UC(or, {
  brighter: function(e) {
    return e = e == null ? Ga : Math.pow(Ga, e), new _i(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker: function(e) {
    return e = e == null ? uo : Math.pow(uo, e), new _i(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: sp,
  // Deprecated! Use color.formatHex.
  formatHex: sp,
  formatRgb: Ap,
  toString: Ap
}));
function sp() {
  return "#" + Ku(this.r) + Ku(this.g) + Ku(this.b);
}
function Ap() {
  var e = this.opacity;
  return e = isNaN(e) ? 1 : Math.max(0, Math.min(1, e)), (e === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (e === 1 ? ")" : ", " + e + ")");
}
function Ku(e) {
  return e = Math.max(0, Math.min(255, Math.round(e) || 0)), (e < 16 ? "0" : "") + e.toString(16);
}
function op(e, t, i, n) {
  return n <= 0 ? e = t = i = NaN : i <= 0 || i >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new ls(e, t, i, n);
}
function AD(e) {
  if (e instanceof ls) return new ls(e.h, e.s, e.l, e.opacity);
  if (e instanceof or || (e = IA(e)), !e) return new ls();
  if (e instanceof ls) return e;
  e = e.rgb();
  var t = e.r / 255, i = e.g / 255, n = e.b / 255, s = Math.min(t, i, n), A = Math.max(t, i, n), o = NaN, a = A - s, r = (A + s) / 2;
  return a ? (t === A ? o = (i - n) / a + (i < n) * 6 : i === A ? o = (n - t) / a + 2 : o = (t - i) / a + 4, a /= r < 0.5 ? A + s : 2 - A - s, o *= 60) : a = r > 0 && r < 1 ? 0 : o, new ls(o, a, r, e.opacity);
}
function CA(e, t, i, n) {
  return arguments.length === 1 ? AD(e) : new ls(e, t, i, n ?? 1);
}
function ls(e, t, i, n) {
  this.h = +e, this.s = +t, this.l = +i, this.opacity = +n;
}
_d(ls, CA, UC(or, {
  brighter: function(e) {
    return e = e == null ? Ga : Math.pow(Ga, e), new ls(this.h, this.s, this.l * e, this.opacity);
  },
  darker: function(e) {
    return e = e == null ? uo : Math.pow(uo, e), new ls(this.h, this.s, this.l * e, this.opacity);
  },
  rgb: function() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, i = this.l, n = i + (i < 0.5 ? i : 1 - i) * t, s = 2 * i - n;
    return new _i(
      Vu(e >= 240 ? e - 240 : e + 120, s, n),
      Vu(e, s, n),
      Vu(e < 120 ? e + 240 : e - 120, s, n),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl: function() {
    var e = this.opacity;
    return e = isNaN(e) ? 1 : Math.max(0, Math.min(1, e)), (e === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (e === 1 ? ")" : ", " + e + ")");
  }
}));
function Vu(e, t, i) {
  return (e < 60 ? t + (i - t) * e / 60 : e < 180 ? i : e < 240 ? t + (i - t) * (240 - e) / 60 : t) * 255;
}
var bv = Math.PI / 180, Mv = 180 / Math.PI, oD = -0.14861, HC = 1.78277, OC = -0.29227, bd = -0.90649, yl = 1.97294, ap = yl * bd, rp = yl * HC, lp = HC * OC - bd * oD;
function Nv(e) {
  if (e instanceof to) return new to(e.h, e.s, e.l, e.opacity);
  e instanceof _i || (e = sD(e));
  var t = e.r / 255, i = e.g / 255, n = e.b / 255, s = (lp * n + ap * t - rp * i) / (lp + ap - rp), A = n - s, o = (yl * (i - s) - OC * A) / bd, a = Math.sqrt(o * o + A * A) / (yl * s * (1 - s)), r = a ? Math.atan2(o, A) * Mv - 120 : NaN;
  return new to(r < 0 ? r + 360 : r, a, s, e.opacity);
}
function ri(e, t, i, n) {
  return arguments.length === 1 ? Nv(e) : new to(e, t, i, n ?? 1);
}
function to(e, t, i, n) {
  this.h = +e, this.s = +t, this.l = +i, this.opacity = +n;
}
_d(to, ri, UC(or, {
  brighter: function(e) {
    return e = e == null ? Ga : Math.pow(Ga, e), new to(this.h, this.s, this.l * e, this.opacity);
  },
  darker: function(e) {
    return e = e == null ? uo : Math.pow(uo, e), new to(this.h, this.s, this.l * e, this.opacity);
  },
  rgb: function() {
    var e = isNaN(this.h) ? 0 : (this.h + 120) * bv, t = +this.l, i = isNaN(this.s) ? 0 : this.s * t * (1 - t), n = Math.cos(e), s = Math.sin(e);
    return new _i(
      255 * (t + i * (oD * n + HC * s)),
      255 * (t + i * (OC * n + bd * s)),
      255 * (t + i * (yl * n)),
      this.opacity
    );
  }
}));
function Fv(e, t, i, n, s) {
  var A = e * e, o = A * e;
  return ((1 - 3 * e + 3 * A - o) * t + (4 - 6 * A + 3 * o) * i + (1 + 3 * e + 3 * A - 3 * o) * n + o * s) / 6;
}
function Rv(e) {
  var t = e.length - 1;
  return function(i) {
    var n = i <= 0 ? i = 0 : i >= 1 ? (i = 1, t - 1) : Math.floor(i * t), s = e[n], A = e[n + 1], o = n > 0 ? e[n - 1] : 2 * s - A, a = n < t - 1 ? e[n + 2] : 2 * A - s;
    return Fv((i - n / t) * t, o, s, A, a);
  };
}
function Md(e) {
  return function() {
    return e;
  };
}
function aD(e, t) {
  return function(i) {
    return e + i * t;
  };
}
function kv(e, t, i) {
  return e = Math.pow(e, i), t = Math.pow(t, i) - e, i = 1 / i, function(n) {
    return Math.pow(e + n * t, i);
  };
}
function vv(e, t) {
  var i = t - e;
  return i ? aD(e, i > 180 || i < -180 ? i - 360 * Math.round(i / 360) : i) : Md(isNaN(e) ? t : e);
}
function Tv(e) {
  return (e = +e) == 1 ? Is : function(t, i) {
    return i - t ? kv(t, i, e) : Md(isNaN(t) ? i : t);
  };
}
function Is(e, t) {
  var i = t - e;
  return i ? aD(e, i) : Md(isNaN(e) ? t : e);
}
const wl = function e(t) {
  var i = Tv(t);
  function n(s, A) {
    var o = i((s = Ql(s)).r, (A = Ql(A)).r), a = i(s.g, A.g), r = i(s.b, A.b), l = Is(s.opacity, A.opacity);
    return function(c) {
      return s.r = o(c), s.g = a(c), s.b = r(c), s.opacity = l(c), s + "";
    };
  }
  return n.gamma = e, n;
}(1);
function Gv(e) {
  return function(t) {
    var i = t.length, n = new Array(i), s = new Array(i), A = new Array(i), o, a;
    for (o = 0; o < i; ++o)
      a = Ql(t[o]), n[o] = a.r || 0, s[o] = a.g || 0, A[o] = a.b || 0;
    return n = e(n), s = e(s), A = e(A), a.opacity = 1, function(r) {
      return a.r = n(r), a.g = s(r), a.b = A(r), a + "";
    };
  };
}
var Lv = Gv(Rv);
function Uv(e, t) {
  t || (t = []);
  var i = e ? Math.min(t.length, e.length) : 0, n = t.slice(), s;
  return function(A) {
    for (s = 0; s < i; ++s) n[s] = e[s] * (1 - A) + t[s] * A;
    return n;
  };
}
function Hv(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function Ov(e, t) {
  var i = t ? t.length : 0, n = e ? Math.min(i, e.length) : 0, s = new Array(n), A = new Array(i), o;
  for (o = 0; o < n; ++o) s[o] = Nd(e[o], t[o]);
  for (; o < i; ++o) A[o] = t[o];
  return function(a) {
    for (o = 0; o < n; ++o) A[o] = s[o](a);
    return A;
  };
}
function Pv(e, t) {
  var i = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(n) {
    return i.setTime(e * (1 - n) + t * n), i;
  };
}
function ln(e, t) {
  return e = +e, t = +t, function(i) {
    return e * (1 - i) + t * i;
  };
}
function Yv(e, t) {
  var i = {}, n = {}, s;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (s in t)
    s in e ? i[s] = Nd(e[s], t[s]) : n[s] = t[s];
  return function(A) {
    for (s in i) n[s] = i[s](A);
    return n;
  };
}
var qf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Wu = new RegExp(qf.source, "g");
function Jv(e) {
  return function() {
    return e;
  };
}
function Kv(e) {
  return function(t) {
    return e(t) + "";
  };
}
function rD(e, t) {
  var i = qf.lastIndex = Wu.lastIndex = 0, n, s, A, o = -1, a = [], r = [];
  for (e = e + "", t = t + ""; (n = qf.exec(e)) && (s = Wu.exec(t)); )
    (A = s.index) > i && (A = t.slice(i, A), a[o] ? a[o] += A : a[++o] = A), (n = n[0]) === (s = s[0]) ? a[o] ? a[o] += s : a[++o] = s : (a[++o] = null, r.push({ i: o, x: ln(n, s) })), i = Wu.lastIndex;
  return i < t.length && (A = t.slice(i), a[o] ? a[o] += A : a[++o] = A), a.length < 2 ? r[0] ? Kv(r[0].x) : Jv(t) : (t = r.length, function(l) {
    for (var c = 0, g; c < t; ++c) a[(g = r[c]).i] = g.x(l);
    return a.join("");
  });
}
function Nd(e, t) {
  var i = typeof t, n;
  return t == null || i === "boolean" ? Md(t) : (i === "number" ? ln : i === "string" ? (n = IA(t)) ? (t = n, wl) : rD : t instanceof IA ? wl : t instanceof Date ? Pv : Hv(t) ? Uv : Array.isArray(t) ? Ov : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? Yv : ln)(e, t);
}
function Vv(e, t) {
  return e = +e, t = +t, function(i) {
    return Math.round(e * (1 - i) + t * i);
  };
}
var cp = 180 / Math.PI, jf = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function lD(e, t, i, n, s, A) {
  var o, a, r;
  return (o = Math.sqrt(e * e + t * t)) && (e /= o, t /= o), (r = e * i + t * n) && (i -= e * r, n -= t * r), (a = Math.sqrt(i * i + n * n)) && (i /= a, n /= a, r /= a), e * n < t * i && (e = -e, t = -t, r = -r, o = -o), {
    translateX: s,
    translateY: A,
    rotate: Math.atan2(t, e) * cp,
    skewX: Math.atan(r) * cp,
    scaleX: o,
    scaleY: a
  };
}
var xr, qu, gp, Yc;
function Wv(e) {
  return e === "none" ? jf : (xr || (xr = document.createElement("DIV"), qu = document.documentElement, gp = document.defaultView), xr.style.transform = e, e = gp.getComputedStyle(qu.appendChild(xr), null).getPropertyValue("transform"), qu.removeChild(xr), e = e.slice(7, -1).split(","), lD(+e[0], +e[1], +e[2], +e[3], +e[4], +e[5]));
}
function qv(e) {
  return e == null || (Yc || (Yc = document.createElementNS("http://www.w3.org/2000/svg", "g")), Yc.setAttribute("transform", e), !(e = Yc.transform.baseVal.consolidate())) ? jf : (e = e.matrix, lD(e.a, e.b, e.c, e.d, e.e, e.f));
}
function cD(e, t, i, n) {
  function s(l) {
    return l.length ? l.pop() + " " : "";
  }
  function A(l, c, g, h, d, u) {
    if (l !== g || c !== h) {
      var f = d.push("translate(", null, t, null, i);
      u.push({ i: f - 4, x: ln(l, g) }, { i: f - 2, x: ln(c, h) });
    } else (g || h) && d.push("translate(" + g + t + h + i);
  }
  function o(l, c, g, h) {
    l !== c ? (l - c > 180 ? c += 360 : c - l > 180 && (l += 360), h.push({ i: g.push(s(g) + "rotate(", null, n) - 2, x: ln(l, c) })) : c && g.push(s(g) + "rotate(" + c + n);
  }
  function a(l, c, g, h) {
    l !== c ? h.push({ i: g.push(s(g) + "skewX(", null, n) - 2, x: ln(l, c) }) : c && g.push(s(g) + "skewX(" + c + n);
  }
  function r(l, c, g, h, d, u) {
    if (l !== g || c !== h) {
      var f = d.push(s(d) + "scale(", null, ",", null, ")");
      u.push({ i: f - 4, x: ln(l, g) }, { i: f - 2, x: ln(c, h) });
    } else (g !== 1 || h !== 1) && d.push(s(d) + "scale(" + g + "," + h + ")");
  }
  return function(l, c) {
    var g = [], h = [];
    return l = e(l), c = e(c), A(l.translateX, l.translateY, c.translateX, c.translateY, g, h), o(l.rotate, c.rotate, g, h), a(l.skewX, c.skewX, g, h), r(l.scaleX, l.scaleY, c.scaleX, c.scaleY, g, h), l = c = null, function(d) {
      for (var u = -1, f = h.length, C; ++u < f; ) g[(C = h[u]).i] = C.x(d);
      return g.join("");
    };
  };
}
var jv = cD(Wv, "px, ", "px)", "deg)"), zv = cD(qv, ", ", ")", ")");
function $v(e) {
  return function(t, i) {
    var n = e((t = CA(t)).h, (i = CA(i)).h), s = Is(t.s, i.s), A = Is(t.l, i.l), o = Is(t.opacity, i.opacity);
    return function(a) {
      return t.h = n(a), t.s = s(a), t.l = A(a), t.opacity = o(a), t + "";
    };
  };
}
var Xv = $v(Is);
function gD(e) {
  return function t(i) {
    i = +i;
    function n(s, A) {
      var o = e((s = ri(s)).h, (A = ri(A)).h), a = Is(s.s, A.s), r = Is(s.l, A.l), l = Is(s.opacity, A.opacity);
      return function(c) {
        return s.h = o(c), s.s = a(c), s.l = r(Math.pow(c, i)), s.opacity = l(c), s + "";
      };
    }
    return n.gamma = t, n;
  }(1);
}
gD(vv);
var ar = gD(Is);
function Zv(e, t) {
  for (var i = 0, n = t.length - 1, s = t[0], A = new Array(n < 0 ? 0 : n); i < n; ) A[i] = e(s, s = t[++i]);
  return function(o) {
    var a = Math.max(0, Math.min(n - 1, Math.floor(o *= n)));
    return A[a](o - a);
  };
}
function PC(e) {
  return function() {
    return e;
  };
}
function hD(e) {
  return +e;
}
var hp = [0, 1];
function YC(e, t) {
  return (t -= e = +e) ? function(i) {
    return (i - e) / t;
  } : PC(t);
}
function tT(e) {
  return function(t, i) {
    var n = e(t = +t, i = +i);
    return function(s) {
      return s <= t ? 0 : s >= i ? 1 : n(s);
    };
  };
}
function eT(e) {
  return function(t, i) {
    var n = e(t = +t, i = +i);
    return function(s) {
      return s <= 0 ? t : s >= 1 ? i : n(s);
    };
  };
}
function iT(e, t, i, n) {
  var s = e[0], A = e[1], o = t[0], a = t[1];
  return A < s ? (s = i(A, s), o = n(a, o)) : (s = i(s, A), o = n(o, a)), function(r) {
    return o(s(r));
  };
}
function nT(e, t, i, n) {
  var s = Math.min(e.length, t.length) - 1, A = new Array(s), o = new Array(s), a = -1;
  for (e[s] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < s; )
    A[a] = i(e[a], e[a + 1]), o[a] = n(t[a], t[a + 1]);
  return function(r) {
    var l = Sd(e, r, 1, s) - 1;
    return o[l](A[l](r));
  };
}
function Fd(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp());
}
function Rd(e, t) {
  var i = hp, n = hp, s = Nd, A = !1, o, a, r;
  function l() {
    return o = Math.min(i.length, n.length) > 2 ? nT : iT, a = r = null, c;
  }
  function c(g) {
    return (a || (a = o(i, n, A ? tT(e) : e, s)))(+g);
  }
  return c.invert = function(g) {
    return (r || (r = o(n, i, YC, A ? eT(t) : t)))(+g);
  }, c.domain = function(g) {
    return arguments.length ? (i = TC.call(g, hD), l()) : i.slice();
  }, c.range = function(g) {
    return arguments.length ? (n = fA.call(g), l()) : n.slice();
  }, c.rangeRound = function(g) {
    return n = fA.call(g), s = Vv, l();
  }, c.clamp = function(g) {
    return arguments.length ? (A = !!g, l()) : A;
  }, c.interpolate = function(g) {
    return arguments.length ? (s = g, l()) : s;
  }, l();
}
function sT(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function oh(e, t) {
  if ((i = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
  var i, n = e.slice(0, i);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +e.slice(i + 1)
  ];
}
function La(e) {
  return e = oh(Math.abs(e)), e ? e[1] : NaN;
}
function AT(e, t) {
  return function(i, n) {
    for (var s = i.length, A = [], o = 0, a = e[0], r = 0; s > 0 && a > 0 && (r + a + 1 > n && (a = Math.max(1, n - r)), A.push(i.substring(s -= a, s + a)), !((r += a + 1) > n)); )
      a = e[o = (o + 1) % e.length];
    return A.reverse().join(t);
  };
}
function oT(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(i) {
      return e[+i];
    });
  };
}
var aT = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function ah(e) {
  if (!(t = aT.exec(e))) throw new Error("invalid format: " + e);
  var t;
  return new JC({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
ah.prototype = JC.prototype;
function JC(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
JC.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function rT(e) {
  t: for (var t = e.length, i = 1, n = -1, s; i < t; ++i)
    switch (e[i]) {
      case ".":
        n = s = i;
        break;
      case "0":
        n === 0 && (n = i), s = i;
        break;
      default:
        if (!+e[i]) break t;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? e.slice(0, n) + e.slice(s + 1) : e;
}
var dD;
function lT(e, t) {
  var i = oh(e, t);
  if (!i) return e + "";
  var n = i[0], s = i[1], A = s - (dD = Math.max(-8, Math.min(8, Math.floor(s / 3))) * 3) + 1, o = n.length;
  return A === o ? n : A > o ? n + new Array(A - o + 1).join("0") : A > 0 ? n.slice(0, A) + "." + n.slice(A) : "0." + new Array(1 - A).join("0") + oh(e, Math.max(0, t + A - 1))[0];
}
function dp(e, t) {
  var i = oh(e, t);
  if (!i) return e + "";
  var n = i[0], s = i[1];
  return s < 0 ? "0." + new Array(-s).join("0") + n : n.length > s + 1 ? n.slice(0, s + 1) + "." + n.slice(s + 1) : n + new Array(s - n.length + 2).join("0");
}
const up = {
  "%": function(e, t) {
    return (e * 100).toFixed(t);
  },
  b: function(e) {
    return Math.round(e).toString(2);
  },
  c: function(e) {
    return e + "";
  },
  d: sT,
  e: function(e, t) {
    return e.toExponential(t);
  },
  f: function(e, t) {
    return e.toFixed(t);
  },
  g: function(e, t) {
    return e.toPrecision(t);
  },
  o: function(e) {
    return Math.round(e).toString(8);
  },
  p: function(e, t) {
    return dp(e * 100, t);
  },
  r: dp,
  s: lT,
  X: function(e) {
    return Math.round(e).toString(16).toUpperCase();
  },
  x: function(e) {
    return Math.round(e).toString(16);
  }
};
function fp(e) {
  return e;
}
var Ip = Array.prototype.map, Cp = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function cT(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? fp : AT(Ip.call(e.grouping, Number), e.thousands + ""), i = e.currency === void 0 ? "" : e.currency[0] + "", n = e.currency === void 0 ? "" : e.currency[1] + "", s = e.decimal + "", A = e.numerals === void 0 ? fp : oT(Ip.call(e.numerals, String)), o = e.percent === void 0 ? "%" : e.percent + "", a = e.minus + "", r = e.nan === void 0 ? "NaN" : e.nan + "";
  function l(g) {
    g = ah(g);
    var h = g.fill, d = g.align, u = g.sign, f = g.symbol, C = g.zero, I = g.width, E = g.comma, B = g.precision, m = g.trim, p = g.type;
    p === "n" ? (E = !0, p = "g") : up[p] || (B === void 0 && (B = 12), m = !0, p = "g"), (C || h === "0" && d === "=") && (C = !0, h = "0", d = "=");
    var w = f === "$" ? i : f === "#" && /[boxX]/.test(p) ? "0" + p.toLowerCase() : "", Q = f === "$" ? n : /[%p]/.test(p) ? o : "", y = up[p], D = /[defgprs%]/.test(p);
    B = B === void 0 ? 6 : /[gprs]/.test(p) ? Math.max(1, Math.min(21, B)) : Math.max(0, Math.min(20, B));
    function _(x) {
      var S = w, b = Q, R, G, T;
      if (p === "c")
        b = y(x) + b, x = "";
      else {
        x = +x;
        var v = x < 0 || 1 / x < 0;
        if (x = isNaN(x) ? r : y(Math.abs(x), B), m && (x = rT(x)), v && +x == 0 && u !== "+" && (v = !1), S = (v ? u === "(" ? u : a : u === "-" || u === "(" ? "" : u) + S, b = (p === "s" ? Cp[8 + dD / 3] : "") + b + (v && u === "(" ? ")" : ""), D) {
          for (R = -1, G = x.length; ++R < G; )
            if (T = x.charCodeAt(R), 48 > T || T > 57) {
              b = (T === 46 ? s + x.slice(R + 1) : x.slice(R)) + b, x = x.slice(0, R);
              break;
            }
        }
      }
      E && !C && (x = t(x, 1 / 0));
      var H = S.length + x.length + b.length, N = H < I ? new Array(I - H + 1).join(h) : "";
      switch (E && C && (x = t(N + x, N.length ? I - b.length : 1 / 0), N = ""), d) {
        case "<":
          x = S + x + b + N;
          break;
        case "=":
          x = S + N + x + b;
          break;
        case "^":
          x = N.slice(0, H = N.length >> 1) + S + x + b + N.slice(H);
          break;
        default:
          x = N + S + x + b;
          break;
      }
      return A(x);
    }
    return _.toString = function() {
      return g + "";
    }, _;
  }
  function c(g, h) {
    var d = l((g = ah(g), g.type = "f", g)), u = Math.max(-8, Math.min(8, Math.floor(La(h) / 3))) * 3, f = Math.pow(10, -u), C = Cp[8 + u / 3];
    return function(I) {
      return d(f * I) + C;
    };
  }
  return {
    format: l,
    formatPrefix: c
  };
}
var Jc, KC, uD;
gT({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});
function gT(e) {
  return Jc = cT(e), KC = Jc.format, uD = Jc.formatPrefix, Jc;
}
function hT(e) {
  return Math.max(0, -La(Math.abs(e)));
}
function dT(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(La(t) / 3))) * 3 - La(Math.abs(e)));
}
function uT(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, La(t) - La(e)) + 1;
}
function fT(e, t, i) {
  var n = e[0], s = e[e.length - 1], A = Wf(n, s, t ?? 10), o;
  switch (i = ah(i ?? ",f"), i.type) {
    case "s": {
      var a = Math.max(Math.abs(n), Math.abs(s));
      return i.precision == null && !isNaN(o = dT(A, a)) && (i.precision = o), uD(i, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(o = uT(A, Math.max(Math.abs(n), Math.abs(s)))) && (i.precision = o - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(o = hT(A)) && (i.precision = o - (i.type === "%") * 2);
      break;
    }
  }
  return KC(i);
}
function Zl(e) {
  var t = e.domain;
  return e.ticks = function(i) {
    var n = t();
    return eD(n[0], n[n.length - 1], i ?? 10);
  }, e.tickFormat = function(i, n) {
    return fT(t(), i, n);
  }, e.nice = function(i) {
    i == null && (i = 10);
    var n = t(), s = 0, A = n.length - 1, o = n[s], a = n[A], r;
    return a < o && (r = o, o = a, a = r, r = s, s = A, A = r), r = bg(o, a, i), r > 0 ? (o = Math.floor(o / r) * r, a = Math.ceil(a / r) * r, r = bg(o, a, i)) : r < 0 && (o = Math.ceil(o * r) / r, a = Math.floor(a * r) / r, r = bg(o, a, i)), r > 0 ? (n[s] = Math.floor(o / r) * r, n[A] = Math.ceil(a / r) * r, t(n)) : r < 0 && (n[s] = Math.ceil(o * r) / r, n[A] = Math.floor(a * r) / r, t(n)), e;
  }, e;
}
function fD() {
  var e = Rd(YC, ln);
  return e.copy = function() {
    return Fd(e, fD());
  }, Zl(e);
}
function ID() {
  var e = [0, 1];
  function t(i) {
    return +i;
  }
  return t.invert = t, t.domain = t.range = function(i) {
    return arguments.length ? (e = TC.call(i, hD), t) : e.slice();
  }, t.copy = function() {
    return ID().domain(e);
  }, Zl(t);
}
function CD(e, t) {
  e = e.slice();
  var i = 0, n = e.length - 1, s = e[i], A = e[n], o;
  return A < s && (o = i, i = n, n = o, o = s, s = A, A = o), e[i] = t.floor(s), e[n] = t.ceil(A), e;
}
function IT(e, t) {
  return (t = Math.log(t / e)) ? function(i) {
    return Math.log(i / e) / t;
  } : PC(t);
}
function CT(e, t) {
  return e < 0 ? function(i) {
    return -Math.pow(-t, i) * Math.pow(-e, 1 - i);
  } : function(i) {
    return Math.pow(t, i) * Math.pow(e, 1 - i);
  };
}
function ET(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function Ep(e) {
  return e === 10 ? ET : e === Math.E ? Math.exp : function(t) {
    return Math.pow(e, t);
  };
}
function Bp(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), function(t) {
    return Math.log(t) / e;
  });
}
function mp(e) {
  return function(t) {
    return -e(-t);
  };
}
function ED() {
  var e = Rd(IT, CT).domain([1, 10]), t = e.domain, i = 10, n = Bp(10), s = Ep(10);
  function A() {
    return n = Bp(i), s = Ep(i), t()[0] < 0 && (n = mp(n), s = mp(s)), e;
  }
  return e.base = function(o) {
    return arguments.length ? (i = +o, A()) : i;
  }, e.domain = function(o) {
    return arguments.length ? (t(o), A()) : t();
  }, e.ticks = function(o) {
    var a = t(), r = a[0], l = a[a.length - 1], c;
    (c = l < r) && (g = r, r = l, l = g);
    var g = n(r), h = n(l), d, u, f, C = o == null ? 10 : +o, I = [];
    if (!(i % 1) && h - g < C) {
      if (g = Math.round(g) - 1, h = Math.round(h) + 1, r > 0) {
        for (; g < h; ++g)
          for (u = 1, d = s(g); u < i; ++u)
            if (f = d * u, !(f < r)) {
              if (f > l) break;
              I.push(f);
            }
      } else for (; g < h; ++g)
        for (u = i - 1, d = s(g); u >= 1; --u)
          if (f = d * u, !(f < r)) {
            if (f > l) break;
            I.push(f);
          }
    } else
      I = eD(g, h, Math.min(h - g, C)).map(s);
    return c ? I.reverse() : I;
  }, e.tickFormat = function(o, a) {
    if (a == null && (a = i === 10 ? ".0e" : ","), typeof a != "function" && (a = KC(a)), o === 1 / 0) return a;
    o == null && (o = 10);
    var r = Math.max(1, i * o / e.ticks().length);
    return function(l) {
      var c = l / s(Math.round(n(l)));
      return c * i < i - 0.5 && (c *= i), c <= r ? a(l) : "";
    };
  }, e.nice = function() {
    return t(CD(t(), {
      floor: function(o) {
        return s(Math.floor(n(o)));
      },
      ceil: function(o) {
        return s(Math.ceil(n(o)));
      }
    }));
  }, e.copy = function() {
    return Fd(e, ED().base(i));
  }, e;
}
function Jo(e, t) {
  return e < 0 ? -Math.pow(-e, t) : Math.pow(e, t);
}
function BD() {
  var e = 1, t = Rd(n, s), i = t.domain;
  function n(A, o) {
    return (o = Jo(o, e) - (A = Jo(A, e))) ? function(a) {
      return (Jo(a, e) - A) / o;
    } : PC(o);
  }
  function s(A, o) {
    return o = Jo(o, e) - (A = Jo(A, e)), function(a) {
      return Jo(A + o * a, 1 / e);
    };
  }
  return t.exponent = function(A) {
    return arguments.length ? (e = +A, i(i())) : e;
  }, t.copy = function() {
    return Fd(t, BD().exponent(e));
  }, Zl(t);
}
function mD() {
  var e = [], t = [], i = [];
  function n() {
    var A = 0, o = Math.max(1, t.length);
    for (i = new Array(o - 1); ++A < o; ) i[A - 1] = Ev(e, A / o);
    return s;
  }
  function s(A) {
    if (!isNaN(A = +A)) return t[Sd(i, A)];
  }
  return s.invertExtent = function(A) {
    var o = t.indexOf(A);
    return o < 0 ? [NaN, NaN] : [
      o > 0 ? i[o - 1] : e[0],
      o < i.length ? i[o] : e[e.length - 1]
    ];
  }, s.domain = function(A) {
    if (!arguments.length) return e.slice();
    e = [];
    for (var o = 0, a = A.length, r; o < a; ++o) r = A[o], r != null && !isNaN(r = +r) && e.push(r);
    return e.sort(vC), n();
  }, s.range = function(A) {
    return arguments.length ? (t = fA.call(A), n()) : t.slice();
  }, s.quantiles = function() {
    return i.slice();
  }, s.copy = function() {
    return mD().domain(e).range(t);
  }, s;
}
function VC() {
  var e = 0, t = 1, i = 1, n = [0.5], s = [0, 1];
  function A(a) {
    if (a <= a) return s[Sd(n, a, 0, i)];
  }
  function o() {
    var a = -1;
    for (n = new Array(i); ++a < i; ) n[a] = ((a + 1) * t - (a - i) * e) / (i + 1);
    return A;
  }
  return A.domain = function(a) {
    return arguments.length ? (e = +a[0], t = +a[1], o()) : [e, t];
  }, A.range = function(a) {
    return arguments.length ? (i = (s = fA.call(a)).length - 1, o()) : s.slice();
  }, A.invertExtent = function(a) {
    var r = s.indexOf(a);
    return r < 0 ? [NaN, NaN] : r < 1 ? [e, n[0]] : r >= i ? [n[i - 1], t] : [n[r - 1], n[r]];
  }, A.copy = function() {
    return VC().domain([e, t]).range(s);
  }, Zl(A);
}
function pD() {
  var e = [0.5], t = [0, 1], i = 1;
  function n(s) {
    if (s <= s) return t[Sd(e, s, 0, i)];
  }
  return n.domain = function(s) {
    return arguments.length ? (e = fA.call(s), i = Math.min(e.length, t.length - 1), n) : e.slice();
  }, n.range = function(s) {
    return arguments.length ? (t = fA.call(s), i = Math.min(e.length, t.length - 1), n) : t.slice();
  }, n.invertExtent = function(s) {
    var A = t.indexOf(s);
    return [e[A - 1], e[A]];
  }, n.copy = function() {
    return pD().domain(e).range(t);
  }, n;
}
var ju = /* @__PURE__ */ new Date(), zu = /* @__PURE__ */ new Date();
function le(e, t, i, n) {
  function s(A) {
    return e(A = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+A)), A;
  }
  return s.floor = function(A) {
    return e(A = /* @__PURE__ */ new Date(+A)), A;
  }, s.ceil = function(A) {
    return e(A = new Date(A - 1)), t(A, 1), e(A), A;
  }, s.round = function(A) {
    var o = s(A), a = s.ceil(A);
    return A - o < a - A ? o : a;
  }, s.offset = function(A, o) {
    return t(A = /* @__PURE__ */ new Date(+A), o == null ? 1 : Math.floor(o)), A;
  }, s.range = function(A, o, a) {
    var r = [], l;
    if (A = s.ceil(A), a = a == null ? 1 : Math.floor(a), !(A < o) || !(a > 0)) return r;
    do
      r.push(l = /* @__PURE__ */ new Date(+A)), t(A, a), e(A);
    while (l < A && A < o);
    return r;
  }, s.filter = function(A) {
    return le(function(o) {
      if (o >= o) for (; e(o), !A(o); ) o.setTime(o - 1);
    }, function(o, a) {
      if (o >= o)
        if (a < 0) for (; ++a <= 0; )
          for (; t(o, -1), !A(o); )
            ;
        else for (; --a >= 0; )
          for (; t(o, 1), !A(o); )
            ;
    });
  }, i && (s.count = function(A, o) {
    return ju.setTime(+A), zu.setTime(+o), e(ju), e(zu), Math.floor(i(ju, zu));
  }, s.every = function(A) {
    return A = Math.floor(A), !isFinite(A) || !(A > 0) ? null : A > 1 ? s.filter(n ? function(o) {
      return n(o) % A === 0;
    } : function(o) {
      return s.count(0, o) % A === 0;
    }) : s;
  }), s;
}
var es = le(function() {
}, function(e, t) {
  e.setTime(+e + t);
}, function(e, t) {
  return t - e;
});
es.every = function(e) {
  return e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? le(function(t) {
    t.setTime(Math.floor(t / e) * e);
  }, function(t, i) {
    t.setTime(+t + i * e);
  }, function(t, i) {
    return (i - t) / e;
  }) : es;
};
es.range;
var rh = 1e3, fo = 6e4, lh = 36e5, QD = 864e5, yD = 6048e5, Us = le(function(e) {
  e.setTime(e - e.getMilliseconds());
}, function(e, t) {
  e.setTime(+e + t * rh);
}, function(e, t) {
  return (t - e) / rh;
}, function(e) {
  return e.getUTCSeconds();
});
Us.range;
var tc = le(function(e) {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * rh);
}, function(e, t) {
  e.setTime(+e + t * fo);
}, function(e, t) {
  return (t - e) / fo;
}, function(e) {
  return e.getMinutes();
});
tc.range;
var ec = le(function(e) {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * rh - e.getMinutes() * fo);
}, function(e, t) {
  e.setTime(+e + t * lh);
}, function(e, t) {
  return (t - e) / lh;
}, function(e) {
  return e.getHours();
});
ec.range;
var ic = le(function(e) {
  e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setDate(e.getDate() + t);
}, function(e, t) {
  return (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * fo) / QD;
}, function(e) {
  return e.getDate() - 1;
});
ic.range;
function Ro(e) {
  return le(function(t) {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, function(t, i) {
    t.setDate(t.getDate() + i * 7);
  }, function(t, i) {
    return (i - t - (i.getTimezoneOffset() - t.getTimezoneOffset()) * fo) / yD;
  });
}
var Ua = Ro(0), Ha = Ro(1), WC = Ro(2), qC = Ro(3), EA = Ro(4), jC = Ro(5), zC = Ro(6);
Ua.range;
Ha.range;
WC.range;
qC.range;
EA.range;
jC.range;
zC.range;
var kd = le(function(e) {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setMonth(e.getMonth() + t);
}, function(e, t) {
  return t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12;
}, function(e) {
  return e.getMonth();
});
kd.range;
var Es = le(function(e) {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, function(e, t) {
  e.setFullYear(e.getFullYear() + t);
}, function(e, t) {
  return t.getFullYear() - e.getFullYear();
}, function(e) {
  return e.getFullYear();
});
Es.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : le(function(t) {
    t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
  }, function(t, i) {
    t.setFullYear(t.getFullYear() + i * e);
  });
};
Es.range;
var nc = le(function(e) {
  e.setUTCSeconds(0, 0);
}, function(e, t) {
  e.setTime(+e + t * fo);
}, function(e, t) {
  return (t - e) / fo;
}, function(e) {
  return e.getUTCMinutes();
});
nc.range;
var sc = le(function(e) {
  e.setUTCMinutes(0, 0, 0);
}, function(e, t) {
  e.setTime(+e + t * lh);
}, function(e, t) {
  return (t - e) / lh;
}, function(e) {
  return e.getUTCHours();
});
sc.range;
var Ac = le(function(e) {
  e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCDate(e.getUTCDate() + t);
}, function(e, t) {
  return (t - e) / QD;
}, function(e) {
  return e.getUTCDate() - 1;
});
Ac.range;
function ko(e) {
  return le(function(t) {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, function(t, i) {
    t.setUTCDate(t.getUTCDate() + i * 7);
  }, function(t, i) {
    return (i - t) / yD;
  });
}
var Oa = ko(0), Pa = ko(1), $C = ko(2), XC = ko(3), BA = ko(4), ZC = ko(5), tE = ko(6);
Oa.range;
Pa.range;
$C.range;
XC.range;
BA.range;
ZC.range;
tE.range;
var vd = le(function(e) {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCMonth(e.getUTCMonth() + t);
}, function(e, t) {
  return t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12;
}, function(e) {
  return e.getUTCMonth();
});
vd.range;
var Bs = le(function(e) {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, function(e, t) {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, function(e, t) {
  return t.getUTCFullYear() - e.getUTCFullYear();
}, function(e) {
  return e.getUTCFullYear();
});
Bs.every = function(e) {
  return !isFinite(e = Math.floor(e)) || !(e > 0) ? null : le(function(t) {
    t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  }, function(t, i) {
    t.setUTCFullYear(t.getUTCFullYear() + i * e);
  });
};
Bs.range;
function $u(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Xu(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function Sr(e, t, i) {
  return { y: e, m: t, d: i, H: 0, M: 0, S: 0, L: 0 };
}
function BT(e) {
  var t = e.dateTime, i = e.date, n = e.time, s = e.periods, A = e.days, o = e.shortDays, a = e.months, r = e.shortMonths, l = _r(s), c = br(s), g = _r(A), h = br(A), d = _r(o), u = br(o), f = _r(a), C = br(a), I = _r(r), E = br(r), B = {
    a: v,
    A: H,
    b: N,
    B: M,
    c: null,
    d: xp,
    e: xp,
    f: PT,
    g: XT,
    G: tG,
    H: UT,
    I: HT,
    j: OT,
    L: wD,
    m: YT,
    M: JT,
    p: F,
    q: k,
    Q: bp,
    s: Mp,
    S: KT,
    u: VT,
    U: WT,
    V: qT,
    w: jT,
    W: zT,
    x: null,
    X: null,
    y: $T,
    Y: ZT,
    Z: eG,
    "%": _p
  }, m = {
    a: O,
    A: P,
    b: L,
    B: q,
    c: null,
    d: Sp,
    e: Sp,
    f: AG,
    g: fG,
    G: CG,
    H: iG,
    I: nG,
    j: sG,
    L: xD,
    m: oG,
    M: aG,
    p: $,
    q: W,
    Q: bp,
    s: Mp,
    S: rG,
    u: lG,
    U: cG,
    V: gG,
    w: hG,
    W: dG,
    x: null,
    X: null,
    y: uG,
    Y: IG,
    Z: EG,
    "%": _p
  }, p = {
    a: _,
    A: x,
    b: S,
    B: b,
    c: R,
    d: wp,
    e: wp,
    f: vT,
    g: yp,
    G: Qp,
    H: Dp,
    I: Dp,
    j: NT,
    L: kT,
    m: MT,
    M: FT,
    p: D,
    q: bT,
    Q: GT,
    s: LT,
    S: RT,
    u: wT,
    U: DT,
    V: xT,
    w: yT,
    W: ST,
    x: G,
    X: T,
    y: yp,
    Y: Qp,
    Z: _T,
    "%": TT
  };
  B.x = w(i, B), B.X = w(n, B), B.c = w(t, B), m.x = w(i, m), m.X = w(n, m), m.c = w(t, m);
  function w(U, J) {
    return function(V) {
      var Y = [], nt = -1, tt = 0, st = U.length, lt, at, Dt;
      for (V instanceof Date || (V = /* @__PURE__ */ new Date(+V)); ++nt < st; )
        U.charCodeAt(nt) === 37 && (Y.push(U.slice(tt, nt)), (at = pp[lt = U.charAt(++nt)]) != null ? lt = U.charAt(++nt) : at = lt === "e" ? " " : "0", (Dt = J[lt]) && (lt = Dt(V, at)), Y.push(lt), tt = nt + 1);
      return Y.push(U.slice(tt, nt)), Y.join("");
    };
  }
  function Q(U, J) {
    return function(V) {
      var Y = Sr(1900, void 0, 1), nt = y(Y, U, V += "", 0), tt, st;
      if (nt != V.length) return null;
      if ("Q" in Y) return new Date(Y.Q);
      if ("s" in Y) return new Date(Y.s * 1e3 + ("L" in Y ? Y.L : 0));
      if (J && !("Z" in Y) && (Y.Z = 0), "p" in Y && (Y.H = Y.H % 12 + Y.p * 12), Y.m === void 0 && (Y.m = "q" in Y ? Y.q : 0), "V" in Y) {
        if (Y.V < 1 || Y.V > 53) return null;
        "w" in Y || (Y.w = 1), "Z" in Y ? (tt = Xu(Sr(Y.y, 0, 1)), st = tt.getUTCDay(), tt = st > 4 || st === 0 ? Pa.ceil(tt) : Pa(tt), tt = Ac.offset(tt, (Y.V - 1) * 7), Y.y = tt.getUTCFullYear(), Y.m = tt.getUTCMonth(), Y.d = tt.getUTCDate() + (Y.w + 6) % 7) : (tt = $u(Sr(Y.y, 0, 1)), st = tt.getDay(), tt = st > 4 || st === 0 ? Ha.ceil(tt) : Ha(tt), tt = ic.offset(tt, (Y.V - 1) * 7), Y.y = tt.getFullYear(), Y.m = tt.getMonth(), Y.d = tt.getDate() + (Y.w + 6) % 7);
      } else ("W" in Y || "U" in Y) && ("w" in Y || (Y.w = "u" in Y ? Y.u % 7 : "W" in Y ? 1 : 0), st = "Z" in Y ? Xu(Sr(Y.y, 0, 1)).getUTCDay() : $u(Sr(Y.y, 0, 1)).getDay(), Y.m = 0, Y.d = "W" in Y ? (Y.w + 6) % 7 + Y.W * 7 - (st + 5) % 7 : Y.w + Y.U * 7 - (st + 6) % 7);
      return "Z" in Y ? (Y.H += Y.Z / 100 | 0, Y.M += Y.Z % 100, Xu(Y)) : $u(Y);
    };
  }
  function y(U, J, V, Y) {
    for (var nt = 0, tt = J.length, st = V.length, lt, at; nt < tt; ) {
      if (Y >= st) return -1;
      if (lt = J.charCodeAt(nt++), lt === 37) {
        if (lt = J.charAt(nt++), at = p[lt in pp ? J.charAt(nt++) : lt], !at || (Y = at(U, V, Y)) < 0) return -1;
      } else if (lt != V.charCodeAt(Y++))
        return -1;
    }
    return Y;
  }
  function D(U, J, V) {
    var Y = l.exec(J.slice(V));
    return Y ? (U.p = c[Y[0].toLowerCase()], V + Y[0].length) : -1;
  }
  function _(U, J, V) {
    var Y = d.exec(J.slice(V));
    return Y ? (U.w = u[Y[0].toLowerCase()], V + Y[0].length) : -1;
  }
  function x(U, J, V) {
    var Y = g.exec(J.slice(V));
    return Y ? (U.w = h[Y[0].toLowerCase()], V + Y[0].length) : -1;
  }
  function S(U, J, V) {
    var Y = I.exec(J.slice(V));
    return Y ? (U.m = E[Y[0].toLowerCase()], V + Y[0].length) : -1;
  }
  function b(U, J, V) {
    var Y = f.exec(J.slice(V));
    return Y ? (U.m = C[Y[0].toLowerCase()], V + Y[0].length) : -1;
  }
  function R(U, J, V) {
    return y(U, t, J, V);
  }
  function G(U, J, V) {
    return y(U, i, J, V);
  }
  function T(U, J, V) {
    return y(U, n, J, V);
  }
  function v(U) {
    return o[U.getDay()];
  }
  function H(U) {
    return A[U.getDay()];
  }
  function N(U) {
    return r[U.getMonth()];
  }
  function M(U) {
    return a[U.getMonth()];
  }
  function F(U) {
    return s[+(U.getHours() >= 12)];
  }
  function k(U) {
    return 1 + ~~(U.getMonth() / 3);
  }
  function O(U) {
    return o[U.getUTCDay()];
  }
  function P(U) {
    return A[U.getUTCDay()];
  }
  function L(U) {
    return r[U.getUTCMonth()];
  }
  function q(U) {
    return a[U.getUTCMonth()];
  }
  function $(U) {
    return s[+(U.getUTCHours() >= 12)];
  }
  function W(U) {
    return 1 + ~~(U.getUTCMonth() / 3);
  }
  return {
    format: function(U) {
      var J = w(U += "", B);
      return J.toString = function() {
        return U;
      }, J;
    },
    parse: function(U) {
      var J = Q(U += "", !1);
      return J.toString = function() {
        return U;
      }, J;
    },
    utcFormat: function(U) {
      var J = w(U += "", m);
      return J.toString = function() {
        return U;
      }, J;
    },
    utcParse: function(U) {
      var J = Q(U += "", !0);
      return J.toString = function() {
        return U;
      }, J;
    }
  };
}
var pp = { "-": "", _: " ", 0: "0" }, ti = /^\s*\d+/, mT = /^%/, pT = /[\\^$*+?|[\]().{}]/g;
function jt(e, t, i) {
  var n = e < 0 ? "-" : "", s = (n ? -e : e) + "", A = s.length;
  return n + (A < i ? new Array(i - A + 1).join(t) + s : s);
}
function QT(e) {
  return e.replace(pT, "\\$&");
}
function _r(e) {
  return new RegExp("^(?:" + e.map(QT).join("|") + ")", "i");
}
function br(e) {
  for (var t = {}, i = -1, n = e.length; ++i < n; ) t[e[i].toLowerCase()] = i;
  return t;
}
function yT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 1));
  return n ? (e.w = +n[0], i + n[0].length) : -1;
}
function wT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 1));
  return n ? (e.u = +n[0], i + n[0].length) : -1;
}
function DT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.U = +n[0], i + n[0].length) : -1;
}
function xT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.V = +n[0], i + n[0].length) : -1;
}
function ST(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.W = +n[0], i + n[0].length) : -1;
}
function Qp(e, t, i) {
  var n = ti.exec(t.slice(i, i + 4));
  return n ? (e.y = +n[0], i + n[0].length) : -1;
}
function yp(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function _T(e, t, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(i, i + 6));
  return n ? (e.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function bT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 1));
  return n ? (e.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function MT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.m = n[0] - 1, i + n[0].length) : -1;
}
function wp(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.d = +n[0], i + n[0].length) : -1;
}
function NT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 3));
  return n ? (e.m = 0, e.d = +n[0], i + n[0].length) : -1;
}
function Dp(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.H = +n[0], i + n[0].length) : -1;
}
function FT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.M = +n[0], i + n[0].length) : -1;
}
function RT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 2));
  return n ? (e.S = +n[0], i + n[0].length) : -1;
}
function kT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 3));
  return n ? (e.L = +n[0], i + n[0].length) : -1;
}
function vT(e, t, i) {
  var n = ti.exec(t.slice(i, i + 6));
  return n ? (e.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function TT(e, t, i) {
  var n = mT.exec(t.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function GT(e, t, i) {
  var n = ti.exec(t.slice(i));
  return n ? (e.Q = +n[0], i + n[0].length) : -1;
}
function LT(e, t, i) {
  var n = ti.exec(t.slice(i));
  return n ? (e.s = +n[0], i + n[0].length) : -1;
}
function xp(e, t) {
  return jt(e.getDate(), t, 2);
}
function UT(e, t) {
  return jt(e.getHours(), t, 2);
}
function HT(e, t) {
  return jt(e.getHours() % 12 || 12, t, 2);
}
function OT(e, t) {
  return jt(1 + ic.count(Es(e), e), t, 3);
}
function wD(e, t) {
  return jt(e.getMilliseconds(), t, 3);
}
function PT(e, t) {
  return wD(e, t) + "000";
}
function YT(e, t) {
  return jt(e.getMonth() + 1, t, 2);
}
function JT(e, t) {
  return jt(e.getMinutes(), t, 2);
}
function KT(e, t) {
  return jt(e.getSeconds(), t, 2);
}
function VT(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function WT(e, t) {
  return jt(Ua.count(Es(e) - 1, e), t, 2);
}
function DD(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? EA(e) : EA.ceil(e);
}
function qT(e, t) {
  return e = DD(e), jt(EA.count(Es(e), e) + (Es(e).getDay() === 4), t, 2);
}
function jT(e) {
  return e.getDay();
}
function zT(e, t) {
  return jt(Ha.count(Es(e) - 1, e), t, 2);
}
function $T(e, t) {
  return jt(e.getFullYear() % 100, t, 2);
}
function XT(e, t) {
  return e = DD(e), jt(e.getFullYear() % 100, t, 2);
}
function ZT(e, t) {
  return jt(e.getFullYear() % 1e4, t, 4);
}
function tG(e, t) {
  var i = e.getDay();
  return e = i >= 4 || i === 0 ? EA(e) : EA.ceil(e), jt(e.getFullYear() % 1e4, t, 4);
}
function eG(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + jt(t / 60 | 0, "0", 2) + jt(t % 60, "0", 2);
}
function Sp(e, t) {
  return jt(e.getUTCDate(), t, 2);
}
function iG(e, t) {
  return jt(e.getUTCHours(), t, 2);
}
function nG(e, t) {
  return jt(e.getUTCHours() % 12 || 12, t, 2);
}
function sG(e, t) {
  return jt(1 + Ac.count(Bs(e), e), t, 3);
}
function xD(e, t) {
  return jt(e.getUTCMilliseconds(), t, 3);
}
function AG(e, t) {
  return xD(e, t) + "000";
}
function oG(e, t) {
  return jt(e.getUTCMonth() + 1, t, 2);
}
function aG(e, t) {
  return jt(e.getUTCMinutes(), t, 2);
}
function rG(e, t) {
  return jt(e.getUTCSeconds(), t, 2);
}
function lG(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function cG(e, t) {
  return jt(Oa.count(Bs(e) - 1, e), t, 2);
}
function SD(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? BA(e) : BA.ceil(e);
}
function gG(e, t) {
  return e = SD(e), jt(BA.count(Bs(e), e) + (Bs(e).getUTCDay() === 4), t, 2);
}
function hG(e) {
  return e.getUTCDay();
}
function dG(e, t) {
  return jt(Pa.count(Bs(e) - 1, e), t, 2);
}
function uG(e, t) {
  return jt(e.getUTCFullYear() % 100, t, 2);
}
function fG(e, t) {
  return e = SD(e), jt(e.getUTCFullYear() % 100, t, 2);
}
function IG(e, t) {
  return jt(e.getUTCFullYear() % 1e4, t, 4);
}
function CG(e, t) {
  var i = e.getUTCDay();
  return e = i >= 4 || i === 0 ? BA(e) : BA.ceil(e), jt(e.getUTCFullYear() % 1e4, t, 4);
}
function EG() {
  return "+0000";
}
function _p() {
  return "%";
}
function bp(e) {
  return +e;
}
function Mp(e) {
  return Math.floor(+e / 1e3);
}
var Ko, _D, bD;
BG({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function BG(e) {
  return Ko = BT(e), _D = Ko.format, Ko.parse, bD = Ko.utcFormat, Ko.utcParse, Ko;
}
var Pr = 1e3, Yr = Pr * 60, Jr = Yr * 60, Dl = Jr * 24, mG = Dl * 7, Np = Dl * 30, Zu = Dl * 365;
function pG(e) {
  return new Date(e);
}
function QG(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function eE(e, t, i, n, s, A, o, a, r) {
  var l = Rd(YC, ln), c = l.invert, g = l.domain, h = r(".%L"), d = r(":%S"), u = r("%I:%M"), f = r("%I %p"), C = r("%a %d"), I = r("%b %d"), E = r("%B"), B = r("%Y"), m = [
    [o, 1, Pr],
    [o, 5, 5 * Pr],
    [o, 15, 15 * Pr],
    [o, 30, 30 * Pr],
    [A, 1, Yr],
    [A, 5, 5 * Yr],
    [A, 15, 15 * Yr],
    [A, 30, 30 * Yr],
    [s, 1, Jr],
    [s, 3, 3 * Jr],
    [s, 6, 6 * Jr],
    [s, 12, 12 * Jr],
    [n, 1, Dl],
    [n, 2, 2 * Dl],
    [i, 1, mG],
    [t, 1, Np],
    [t, 3, 3 * Np],
    [e, 1, Zu]
  ];
  function p(Q) {
    return (o(Q) < Q ? h : A(Q) < Q ? d : s(Q) < Q ? u : n(Q) < Q ? f : t(Q) < Q ? i(Q) < Q ? C : I : e(Q) < Q ? E : B)(Q);
  }
  function w(Q, y, D, _) {
    if (Q == null && (Q = 10), typeof Q == "number") {
      var x = Math.abs(D - y) / Q, S = tD(function(b) {
        return b[2];
      }).right(m, x);
      S === m.length ? (_ = Wf(y / Zu, D / Zu, Q), Q = e) : S ? (S = m[x / m[S - 1][2] < m[S][2] / x ? S - 1 : S], _ = S[1], Q = S[0]) : (_ = Math.max(Wf(y, D, Q), 1), Q = a);
    }
    return _ == null ? Q : Q.every(_);
  }
  return l.invert = function(Q) {
    return new Date(c(Q));
  }, l.domain = function(Q) {
    return arguments.length ? g(TC.call(Q, QG)) : g().map(pG);
  }, l.ticks = function(Q, y) {
    var D = g(), _ = D[0], x = D[D.length - 1], S = x < _, b;
    return S && (b = _, _ = x, x = b), b = w(Q, _, x, y), b = b ? b.range(_, x + 1) : [], S ? b.reverse() : b;
  }, l.tickFormat = function(Q, y) {
    return y == null ? p : r(y);
  }, l.nice = function(Q, y) {
    var D = g();
    return (Q = w(Q, D[0], D[D.length - 1], y)) ? g(CD(D, Q)) : l;
  }, l.copy = function() {
    return Fd(l, eE(e, t, i, n, s, A, o, a, r));
  }, l;
}
function yG() {
  return eE(Es, kd, Ua, ic, ec, tc, Us, es, _D).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]);
}
function wG() {
  return eE(Bs, vd, Oa, Ac, sc, nc, Us, es, bD).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]);
}
function xA(e) {
  return e.match(/.{6}/g).map(function(t) {
    return "#" + t;
  });
}
const DG = xA("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), xG = xA("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");
xA("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");
const SG = xA("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");
ar(ri(300, 0.5, 0), ri(-240, 0.5, 1));
ar(ri(-100, 0.75, 0.35), ri(80, 1.5, 0.8));
ar(ri(260, 0.75, 0.35), ri(80, 1.5, 0.8));
ri();
function Td(e) {
  var t = e.length;
  return function(i) {
    return e[Math.max(0, Math.min(t - 1, Math.floor(i * t)))];
  };
}
Td(xA("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
Td(xA("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
Td(xA("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
Td(xA("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
function MD(e) {
  var t = 0, i = 1, n = !1;
  function s(A) {
    var o = (A - t) / (i - t);
    return e(n ? Math.max(0, Math.min(1, o)) : o);
  }
  return s.domain = function(A) {
    return arguments.length ? (t = +A[0], i = +A[1], s) : [t, i];
  }, s.clamp = function(A) {
    return arguments.length ? (n = !!A, s) : n;
  }, s.interpolator = function(A) {
    return arguments.length ? (e = A, s) : e;
  }, s.copy = function() {
    return MD(e).domain([t, i]).clamp(n);
  }, Zl(s);
}
const ND = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: LC,
  scaleIdentity: ID,
  scaleLinear: fD,
  scaleLog: ED,
  scaleOrdinal: GC,
  scalePow: BD,
  scaleQuantile: mD,
  scaleQuantize: VC,
  scaleSequential: MD,
  scaleThreshold: pD,
  scaleTime: yG,
  scaleUtc: wG,
  schemeCategory10: DG,
  schemeCategory20: SG,
  schemeCategory20b: xG
}, Symbol.toStringTag, { value: "Module" }));
function Ot(e) {
  for (var t = e.length / 6 | 0, i = new Array(t), n = 0; n < t; ) i[n] = "#" + e.slice(n * 6, ++n * 6);
  return i;
}
const _G = Ot("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), bG = Ot("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), MG = Ot("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), NG = Ot("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), FG = Ot("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), RG = Ot("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), kG = Ot("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), vG = Ot("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
function ce(e) {
  return Lv(e[e.length - 1]);
}
var FD = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(Ot);
const TG = ce(FD);
var RD = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(Ot);
const GG = ce(RD);
var kD = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(Ot);
const LG = ce(kD);
var UG = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(Ot);
const HG = ce(UG);
var OG = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(Ot);
const PG = ce(OG);
var YG = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(Ot);
const JG = ce(YG);
var KG = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(Ot);
const VG = ce(KG);
var WG = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(Ot);
const qG = ce(WG);
var jG = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(Ot);
const zG = ce(jG);
var $G = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(Ot);
const XG = ce($G);
var ZG = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(Ot);
const tL = ce(ZG);
var eL = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(Ot);
const iL = ce(eL);
var nL = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(Ot);
const sL = ce(nL);
var AL = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(Ot);
const oL = ce(AL);
var aL = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(Ot);
const rL = ce(aL);
var lL = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(Ot);
const cL = ce(lL);
var gL = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(Ot);
const hL = ce(gL);
var dL = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(Ot);
const uL = ce(dL);
var fL = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(Ot);
const IL = ce(fL);
var CL = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(Ot);
const EL = ce(CL);
var BL = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(Ot);
const mL = ce(BL);
var vD = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(Ot);
const pL = ce(vD);
var QL = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(Ot);
const yL = ce(QL);
var wL = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(Ot);
const DL = ce(wL);
var xL = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(Ot);
const SL = ce(xL);
var _L = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(Ot);
const bL = ce(_L);
var ML = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(Ot);
const NL = ce(ML), FL = ar(ri(300, 0.5, 0), ri(-240, 0.5, 1));
var RL = ar(ri(-100, 0.75, 0.35), ri(80, 1.5, 0.8)), kL = ar(ri(260, 0.75, 0.35), ri(80, 1.5, 0.8)), Kc = ri();
function vL(e) {
  (e < 0 || e > 1) && (e -= Math.floor(e));
  var t = Math.abs(e - 0.5);
  return Kc.h = 360 * e - 100, Kc.s = 1.5 - 1.5 * t, Kc.l = 0.8 - 0.9 * t, Kc + "";
}
function Gd(e) {
  var t = e.length;
  return function(i) {
    return e[Math.max(0, Math.min(t - 1, Math.floor(i * t)))];
  };
}
const TL = Gd(Ot("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var GL = Gd(Ot("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")), LL = Gd(Ot("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")), UL = Gd(Ot("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
const zf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  interpolateBlues: pL,
  interpolateBrBG: TG,
  interpolateBuGn: XG,
  interpolateBuPu: tL,
  interpolateCool: kL,
  interpolateCubehelixDefault: FL,
  interpolateGnBu: iL,
  interpolateGreens: yL,
  interpolateGreys: DL,
  interpolateInferno: LL,
  interpolateMagma: GL,
  interpolateOrRd: sL,
  interpolateOranges: NL,
  interpolatePRGn: GG,
  interpolatePiYG: LG,
  interpolatePlasma: UL,
  interpolatePuBu: rL,
  interpolatePuBuGn: oL,
  interpolatePuOr: HG,
  interpolatePuRd: cL,
  interpolatePurples: SL,
  interpolateRainbow: vL,
  interpolateRdBu: PG,
  interpolateRdGy: JG,
  interpolateRdPu: hL,
  interpolateRdYlBu: VG,
  interpolateRdYlGn: qG,
  interpolateReds: bL,
  interpolateSpectral: zG,
  interpolateViridis: TL,
  interpolateWarm: RL,
  interpolateYlGn: IL,
  interpolateYlGnBu: uL,
  interpolateYlOrBr: EL,
  interpolateYlOrRd: mL,
  schemeAccent: _G,
  schemeBlues: vD,
  schemeBrBG: FD,
  schemeDark2: bG,
  schemePRGn: RD,
  schemePaired: MG,
  schemePastel1: NG,
  schemePastel2: FG,
  schemePiYG: kD,
  schemeSet1: RG,
  schemeSet2: kG,
  schemeSet3: vG
}, Symbol.toStringTag, { value: "Module" })), Ld = "app.units", HL = "local.units", OL = "local.layers", TD = "app.layers", Ya = "app.group", PL = "local.group", iE = "local.canvas", YL = "app.canvas", re = "virtualScrolling", JL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CANVAS_GLOBAL_NAMESPACE: YL,
  CANVAS_LOCAL_NAMESPACE: iE,
  GROUP_GLOBAL_NAMESPACE: Ya,
  GROUP_LOCAL_NAMESPACE: PL,
  LAYER_GLOBAL_NAMESPACE: TD,
  LAYER_LOCAL_NAMESPACE: OL,
  UNIT_GLOBAL_NAMESPACE: Ld,
  UNIT_LOCAL_NAMESPACE: HL,
  VIRTUAL_SCROLLING_NAMESPACE: re
}, Symbol.toStringTag, { value: "Module" })), Mr = (e, t, i) => {
  const n = e[t];
  e[t] = e[i], e[i] = n;
}, KL = (e, t) => e > t ? -1 : e > t ? 1 : 0, GD = (e, t, i, n, s) => {
  for (; n > i; ) {
    if (n - i > 600) {
      const r = n - i + 1, l = t - i + 1, c = Math.log(r), g = 0.5 * Math.exp(2 * c / 3), h = 0.5 * Math.sqrt(c * g * (r - g) / r) * (l - r / 2 < 0 ? -1 : 1), d = Math.max(i, Math.floor(t - l * g / r + h)), u = Math.min(n, Math.floor(t + (r - l) * g / r + h));
      GD(e, t, d, u, s);
    }
    const A = e[t];
    let o = i, a = n;
    for (Mr(e, i, t), s(e[n], A) > 0 && Mr(e, i, n); o < a; ) {
      for (Mr(e, o, a), o++, a--; s(e[o], A) < 0; ) o++;
      for (; s(e[a], A) > 0; ) a--;
    }
    s(e[i], A) === 0 ? Mr(e, i, a) : (a++, Mr(e, a, n)), a <= t && (i = a + 1), t <= a && (n = a - 1);
  }
}, VL = (e, t, i, n, s) => {
  GD(
    e,
    t,
    i || 0,
    n || e.length - 1,
    s || KL
  );
}, na = (e) => ({
  children: e,
  height: 1,
  leaf: !0,
  minX: 1 / 0,
  minY: 1 / 0,
  maxX: -1 / 0,
  maxY: -1 / 0
}), Kr = (e, t) => (e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e), Vr = (e, t, i, n, s) => {
  s || (s = na(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
  for (let A = t; A < i; A++) {
    const o = e.children[A];
    Kr(s, e.leaf ? n(o) : o);
  }
  return s;
}, Vo = (e, t) => {
  Vr(e, 0, e.children.length, t, e);
}, WL = (e, t) => e.minX - t.minX, qL = (e, t) => e.minY - t.minY, tf = (e) => (e.maxX - e.minX) * (e.maxY - e.minY), Vc = (e) => e.maxX - e.minX + (e.maxY - e.minY), jL = (e, t) => (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY)), zL = (e, t) => {
  const i = Math.max(e.minX, t.minX), n = Math.max(e.minY, t.minY), s = Math.min(e.maxX, t.maxX), A = Math.min(e.maxY, t.maxY);
  return Math.max(0, s - i) * Math.max(0, A - n);
}, Fp = (e, t) => e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY, Rp = (e, t) => t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY, $L = (e, t, i) => {
  if (!i) return t.indexOf(e);
  for (let n = 0; n < t.length; n++)
    if (i(e, t[n])) return n;
  return -1;
}, kp = (e, t, i, n, s) => {
  const A = [t, i];
  for (; A.length; ) {
    if (i = A.pop(), t = A.pop(), i - t <= n) continue;
    const o = t + Math.ceil((i - t) / n / 2) * n;
    VL(e, o, t, i, s), A.push(t, o, o, i);
  }
}, vp = (e, t) => {
  const i = [];
  for (; e; )
    e.leaf ? t.push(...e.children) : i.push(...e.children), e = i.pop();
  return t;
};
class Io {
  _maxEntries;
  _minEntries;
  data;
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return vp(this.data, []);
  }
  search(t) {
    let i = this.data;
    const n = [];
    if (!Rp(t, i)) return n;
    const s = this.toBBox, A = [];
    for (; i; ) {
      for (const o of i.children) {
        const a = i.leaf ? s(o) : o;
        Rp(t, a) && (i.leaf ? n.push(o) : Fp(t, a) ? vp(o, n) : A.push(o));
      }
      i = A.pop();
    }
    return n;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let n = 0; n < t.length; n++)
        this.insert(t[n]);
      return this;
    }
    let i = this.build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = i;
    else if (this.data.height === i.height)
      this.splitRoot(this.data, i);
    else {
      if (this.data.height < i.height) {
        const n = this.data;
        this.data = i, i = n;
      }
      this.insertSingleItem(i, this.data.height - i.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this.insertSingleItem(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = na([]), this;
  }
  remove(t, i) {
    if (!t) return this;
    let n, s, A, o = this.data;
    const a = this.toBBox(t), r = [], l = [];
    for (; o || r.length; ) {
      if (o || (o = r.pop(), s = r[r.length - 1], n = l.pop(), A = !0), o.leaf) {
        const c = $L(t, o.children, i);
        if (c !== -1)
          return o.children.splice(c, 1), r.push(o), this.condense(r), this;
      }
      !A && !o.leaf && Fp(o, a) ? (r.push(o), l.push(n), n = 0, s = o, o = o.children[0]) : s ? (n++, o = s.children[n], A = !1) : o = null;
    }
    return this;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, i) {
    return t.minX - i.minX;
  }
  compareMinY(t, i) {
    return t.minY - i.minY;
  }
  build(t, i, n, s) {
    const A = n - i + 1;
    let o = this._maxEntries, a;
    if (A <= o)
      return a = na(t.slice(i, n + 1)), Vo(a, this.toBBox), a;
    s || (s = Math.ceil(Math.log(A) / Math.log(o)), o = Math.ceil(A / o ** (s - 1))), a = na([]), a.leaf = !1, a.height = s;
    const r = Math.ceil(A / o), l = r * Math.ceil(Math.sqrt(o));
    kp(t, i, n, l, this.compareMinX);
    for (let c = i; c <= n; c += l) {
      const g = Math.min(c + l - 1, n);
      kp(t, c, g, r, this.compareMinY);
      for (let h = c; h <= g; h += r) {
        const d = Math.min(h + r - 1, g);
        a.children.push(this.build(t, h, d, s - 1));
      }
    }
    return Vo(a, this.toBBox), a;
  }
  chooseSubtree(t, i, n, s) {
    for (; s.push(i), !(i.leaf || s.length - 1 === n); ) {
      let A = 1 / 0, o = 1 / 0, a;
      for (const r of i.children) {
        const l = tf(r), c = jL(t, r) - l;
        c < o ? (o = c, A = l < A ? l : A, a = r) : c === o && l < A && (A = l, a = r);
      }
      i = a || i.children[0];
    }
    return i;
  }
  insertSingleItem(t, i, n) {
    const s = n ? t : this.toBBox(t), A = [], o = this.chooseSubtree(s, this.data, i, A);
    for (o.children.push(t), Kr(o, s); i >= 0 && A[i].children.length > this._maxEntries; )
      this.split(A, i), i--;
    this.adjustParentBoxes(s, A, i);
  }
  // split overflowed node into two
  split(t, i) {
    const n = t[i], s = n.children.length, A = this._minEntries;
    this.chooseSplitAxis(n, A, s);
    const o = this.chooseSplitIndex(n, A, s), a = na(
      n.children.splice(o, n.children.length - o)
    );
    a.height = n.height, a.leaf = n.leaf, Vo(n, this.toBBox), Vo(a, this.toBBox), i ? t[i - 1].children.push(a) : this.splitRoot(n, a);
  }
  splitRoot(t, i) {
    this.data = na([t, i]), this.data.height = t.height + 1, this.data.leaf = !1, Vo(this.data, this.toBBox);
  }
  chooseSplitIndex(t, i, n) {
    let s, A = 1 / 0, o = 1 / 0;
    for (let a = i; a <= n - i; a++) {
      const r = Vr(t, 0, a, this.toBBox), l = Vr(t, a, n, this.toBBox), c = zL(r, l), g = tf(r) + tf(l);
      c < A ? (A = c, s = a, o = g < o ? g : o) : c === A && g < o && (o = g, s = a);
    }
    return s || n - i;
  }
  // sorts node children by the best axis for split
  chooseSplitAxis(t, i, n) {
    const s = t.leaf ? this.compareMinX : WL, A = t.leaf ? this.compareMinY : qL, o = this.allDistMargin(t, i, n, s), a = this.allDistMargin(t, i, n, A);
    o < a && t.children.sort(s);
  }
  // total margin of all possible split distributions where each node is at least m full
  allDistMargin(t, i, n, s) {
    t.children.sort(s);
    const A = this.toBBox, o = Vr(t, 0, i, A), a = Vr(t, n - i, n, A);
    let r = Vc(o) + Vc(a);
    for (let l = i; l < n - i; l++) {
      const c = t.children[l];
      Kr(o, t.leaf ? A(c) : c), r += Vc(o);
    }
    for (let l = n - i - 1; l >= i; l--) {
      const c = t.children[l];
      Kr(a, t.leaf ? A(c) : c), r += Vc(a);
    }
    return r;
  }
  adjustParentBoxes(t, i, n) {
    for (let s = n; s >= 0; s--)
      Kr(i[s], t);
  }
  condense(t) {
    for (let i = t.length - 1, n; i >= 0; i--)
      t[i].children.length === 0 ? i > 0 ? (n = t[i - 1].children, n.splice(n.indexOf(t[i]), 1)) : this.clear() : Vo(t[i], this.toBBox);
  }
}
const bi = (e) => e && (e.subtype() === ft.CONTINUOUS || e.subtype() === "temporal") ? ft.CONTINUOUS : ft.DISCRETE;
var Ki = /* @__PURE__ */ ((e) => (e.NATURAL_ORDER = "natural", e.ALPHABETICAL_ORDER = "alphabetical", e.FIELD_ORDER = "field", e.NESTED_ORDER = "nested", e.CUSTOM_VALUES_ORDER = "custom", e))(Ki || {});
const vo = {
  type: "natural",
  direction: Ts.ASC,
  field: {
    name: null,
    aggregation: null
  },
  nested: {
    filters: [],
    field: {
      name: null,
      aggregation: null
    }
  },
  values: null
};
var ef = Array.prototype.slice;
function XL(e) {
  return e;
}
var Mg = 1, Ng = 2, $f = 3, Wr = 4, Tp = 1e-6;
function ZL(e) {
  return "translate(" + (e + 0.5) + ",0)";
}
function tU(e) {
  return "translate(0," + (e + 0.5) + ")";
}
function eU(e) {
  return function(t) {
    return +e(t);
  };
}
function iU(e) {
  var t = Math.max(0, e.bandwidth() - 1) / 2;
  return e.round() && (t = Math.round(t)), function(i) {
    return +e(i) + t;
  };
}
function nU() {
  return !this.__axis;
}
function Ud(e, t) {
  var i = [], n = null, s = null, A = null, o = 6, a = 6, r = 3, l = e === Mg || e === Wr ? -1 : 1, c = e === Wr || e === Ng ? "x" : "y", g = e === Mg || e === $f ? ZL : tU;
  function h(d) {
    var u = n ?? (t.ticks ? t.ticks.apply(t, i) : t.domain()), f = s ?? (t.tickFormat ? t.tickFormat.apply(t, i) : XL), C = Math.max(o, 0) + r, I = t.range(), E = +I[0] + 0.5, B = +I[I.length - 1] + 0.5, m = (t.bandwidth ? iU : eU)(t.copy()), p = d.selection ? d.selection() : d, w = p.selectAll(".domain").data([null]), Q = p.selectAll(".tick").data(u, t).order(), y = Q.exit(), D = Q.enter().append("g").attr("class", "tick"), _ = Q.select("line"), x = Q.select("text");
    w = w.merge(w.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "#000")), Q = Q.merge(D), _ = _.merge(D.append("line").attr("stroke", "#000").attr(c + "2", l * o)), x = x.merge(D.append("text").attr("fill", "#000").attr(c, l * C).attr("dy", e === Mg ? "0em" : e === $f ? "0.71em" : "0.32em")).style("transform", A), d !== p && (w = w.transition(d), Q = Q.transition(d), _ = _.transition(d), x = x.transition(d), y = y.transition(d).attr("opacity", Tp).attr("transform", function(S) {
      return isFinite(S = m(S)) ? g(S) : this.getAttribute("transform");
    }), D.attr("opacity", Tp).attr("transform", function(S) {
      var b = this.parentNode.__axis;
      return g(b && isFinite(b = b(S)) ? b : m(S));
    })), y.remove(), w.attr("d", e === Wr || e == Ng ? "M" + l * a + "," + E + "H0.5V" + B + "H" + l * a : "M" + E + "," + l * a + "V0.5H" + B + "V" + l * a), Q.attr("opacity", 1).attr("transform", function(S) {
      return g(m(S));
    }), _.attr(c + "2", l * o), x.attr(c, l * C).text(f), p.filter(nU).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", e === Ng ? "start" : e === Wr ? "end" : "middle"), p.each(function() {
      this.__axis = m;
    });
  }
  return h.scale = function(d) {
    return arguments.length ? (t = d, h) : t;
  }, h.tickTransform = function(d) {
    return arguments.length ? (A = d, h) : A;
  }, h.ticks = function() {
    return i = ef.call(arguments), h;
  }, h.tickArguments = function(d) {
    return arguments.length ? (i = d == null ? [] : ef.call(d), h) : i.slice();
  }, h.tickValues = function(d) {
    return arguments.length ? (n = d == null ? null : ef.call(d), h) : n && n.slice();
  }, h.tickFormat = function(d) {
    return arguments.length ? (s = d, h) : s;
  }, h.tickSize = function(d) {
    return arguments.length ? (o = a = +d, h) : o;
  }, h.tickSizeInner = function(d) {
    return arguments.length ? (o = +d, h) : o;
  }, h.tickSizeOuter = function(d) {
    return arguments.length ? (a = +d, h) : a;
  }, h.tickPadding = function(d) {
    return arguments.length ? (r = +d, h) : r;
  }, h;
}
function sU(e) {
  return Ud(Mg, e);
}
function AU(e) {
  return Ud(Ng, e);
}
function oU(e) {
  return Ud($f, e);
}
function aU(e) {
  return Ud(Wr, e);
}
var Xf = Math.PI, Zf = 2 * Xf, vA = 1e-6, rU = Zf - vA;
function tI() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function oc() {
  return new tI();
}
tI.prototype = oc.prototype = {
  constructor: tI,
  moveTo: function(e, t) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(e, t) {
    this._ += "L" + (this._x1 = +e) + "," + (this._y1 = +t);
  },
  quadraticCurveTo: function(e, t, i, n) {
    this._ += "Q" + +e + "," + +t + "," + (this._x1 = +i) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(e, t, i, n, s, A) {
    this._ += "C" + +e + "," + +t + "," + +i + "," + +n + "," + (this._x1 = +s) + "," + (this._y1 = +A);
  },
  arcTo: function(e, t, i, n, s) {
    e = +e, t = +t, i = +i, n = +n, s = +s;
    var A = this._x1, o = this._y1, a = i - e, r = n - t, l = A - e, c = o - t, g = l * l + c * c;
    if (s < 0) throw new Error("negative radius: " + s);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = e) + "," + (this._y1 = t);
    else if (g > vA) if (!(Math.abs(c * a - r * l) > vA) || !s)
      this._ += "L" + (this._x1 = e) + "," + (this._y1 = t);
    else {
      var h = i - A, d = n - o, u = a * a + r * r, f = h * h + d * d, C = Math.sqrt(u), I = Math.sqrt(g), E = s * Math.tan((Xf - Math.acos((u + g - f) / (2 * C * I))) / 2), B = E / I, m = E / C;
      Math.abs(B - 1) > vA && (this._ += "L" + (e + B * l) + "," + (t + B * c)), this._ += "A" + s + "," + s + ",0,0," + +(c * h > l * d) + "," + (this._x1 = e + m * a) + "," + (this._y1 = t + m * r);
    }
  },
  arc: function(e, t, i, n, s, A) {
    e = +e, t = +t, i = +i, A = !!A;
    var o = i * Math.cos(n), a = i * Math.sin(n), r = e + o, l = t + a, c = 1 ^ A, g = A ? n - s : s - n;
    if (i < 0) throw new Error("negative radius: " + i);
    this._x1 === null ? this._ += "M" + r + "," + l : (Math.abs(this._x1 - r) > vA || Math.abs(this._y1 - l) > vA) && (this._ += "L" + r + "," + l), i && (g < 0 && (g = g % Zf + Zf), g > rU ? this._ += "A" + i + "," + i + ",0,1," + c + "," + (e - o) + "," + (t - a) + "A" + i + "," + i + ",0,1," + c + "," + (this._x1 = r) + "," + (this._y1 = l) : g > vA && (this._ += "A" + i + "," + i + ",0," + +(g >= Xf) + "," + c + "," + (this._x1 = e + i * Math.cos(s)) + "," + (this._y1 = t + i * Math.sin(s))));
  },
  rect: function(e, t, i, n) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t) + "h" + +i + "v" + +n + "h" + -i + "Z";
  },
  toString: function() {
    return this._;
  }
};
function Kt(e) {
  return function() {
    return e;
  };
}
var Gp = Math.abs, hi = Math.atan2, bA = Math.cos, lU = Math.max, nf = Math.min, rs = Math.sin, aa = Math.sqrt, ui = 1e-12, mA = Math.PI, ch = mA / 2, gA = 2 * mA;
function cU(e) {
  return e > 1 ? 0 : e < -1 ? mA : Math.acos(e);
}
function Lp(e) {
  return e >= 1 ? ch : e <= -1 ? -ch : Math.asin(e);
}
function gU(e) {
  return e.innerRadius;
}
function hU(e) {
  return e.outerRadius;
}
function dU(e) {
  return e.startAngle;
}
function uU(e) {
  return e.endAngle;
}
function fU(e) {
  return e && e.padAngle;
}
function IU(e, t, i, n, s, A, o, a) {
  var r = i - e, l = n - t, c = o - s, g = a - A, h = g * r - c * l;
  if (!(h * h < ui))
    return h = (c * (t - A) - g * (e - s)) / h, [e + h * r, t + h * l];
}
function Wc(e, t, i, n, s, A, o) {
  var a = e - i, r = t - n, l = (o ? A : -A) / aa(a * a + r * r), c = l * r, g = -l * a, h = e + c, d = t + g, u = i + c, f = n + g, C = (h + u) / 2, I = (d + f) / 2, E = u - h, B = f - d, m = E * E + B * B, p = s - A, w = h * f - u * d, Q = (B < 0 ? -1 : 1) * aa(lU(0, p * p * m - w * w)), y = (w * B - E * Q) / m, D = (-w * E - B * Q) / m, _ = (w * B + E * Q) / m, x = (-w * E + B * Q) / m, S = y - C, b = D - I, R = _ - C, G = x - I;
  return S * S + b * b > R * R + G * G && (y = _, D = x), {
    cx: y,
    cy: D,
    x01: -c,
    y01: -g,
    x11: y * (s / p - 1),
    y11: D * (s / p - 1)
  };
}
function CU() {
  var e = gU, t = hU, i = Kt(0), n = null, s = dU, A = uU, o = fU, a = null;
  function r() {
    var l, c, g = +e.apply(this, arguments), h = +t.apply(this, arguments), d = s.apply(this, arguments) - ch, u = A.apply(this, arguments) - ch, f = Gp(u - d), C = u > d;
    if (a || (a = l = oc()), h < g && (c = h, h = g, g = c), !(h > ui)) a.moveTo(0, 0);
    else if (f > gA - ui)
      a.moveTo(h * bA(d), h * rs(d)), a.arc(0, 0, h, d, u, !C), g > ui && (a.moveTo(g * bA(u), g * rs(u)), a.arc(0, 0, g, u, d, C));
    else {
      var I = d, E = u, B = d, m = u, p = f, w = f, Q = o.apply(this, arguments) / 2, y = Q > ui && (n ? +n.apply(this, arguments) : aa(g * g + h * h)), D = nf(Gp(h - g) / 2, +i.apply(this, arguments)), _ = D, x = D, S, b;
      if (y > ui) {
        var R = Lp(y / g * rs(Q)), G = Lp(y / h * rs(Q));
        (p -= R * 2) > ui ? (R *= C ? 1 : -1, B += R, m -= R) : (p = 0, B = m = (d + u) / 2), (w -= G * 2) > ui ? (G *= C ? 1 : -1, I += G, E -= G) : (w = 0, I = E = (d + u) / 2);
      }
      var T = h * bA(I), v = h * rs(I), H = g * bA(m), N = g * rs(m);
      if (D > ui) {
        var M = h * bA(E), F = h * rs(E), k = g * bA(B), O = g * rs(B), P;
        if (f < mA && (P = IU(T, v, k, O, M, F, H, N))) {
          var L = T - P[0], q = v - P[1], $ = M - P[0], W = F - P[1], U = 1 / rs(cU((L * $ + q * W) / (aa(L * L + q * q) * aa($ * $ + W * W))) / 2), J = aa(P[0] * P[0] + P[1] * P[1]);
          _ = nf(D, (g - J) / (U - 1)), x = nf(D, (h - J) / (U + 1));
        }
      }
      w > ui ? x > ui ? (S = Wc(k, O, T, v, h, x, C), b = Wc(M, F, H, N, h, x, C), a.moveTo(S.cx + S.x01, S.cy + S.y01), x < D ? a.arc(S.cx, S.cy, x, hi(S.y01, S.x01), hi(b.y01, b.x01), !C) : (a.arc(S.cx, S.cy, x, hi(S.y01, S.x01), hi(S.y11, S.x11), !C), a.arc(0, 0, h, hi(S.cy + S.y11, S.cx + S.x11), hi(b.cy + b.y11, b.cx + b.x11), !C), a.arc(b.cx, b.cy, x, hi(b.y11, b.x11), hi(b.y01, b.x01), !C))) : (a.moveTo(T, v), a.arc(0, 0, h, I, E, !C)) : a.moveTo(T, v), !(g > ui) || !(p > ui) ? a.lineTo(H, N) : _ > ui ? (S = Wc(H, N, M, F, g, -_, C), b = Wc(T, v, k, O, g, -_, C), a.lineTo(S.cx + S.x01, S.cy + S.y01), _ < D ? a.arc(S.cx, S.cy, _, hi(S.y01, S.x01), hi(b.y01, b.x01), !C) : (a.arc(S.cx, S.cy, _, hi(S.y01, S.x01), hi(S.y11, S.x11), !C), a.arc(0, 0, g, hi(S.cy + S.y11, S.cx + S.x11), hi(b.cy + b.y11, b.cx + b.x11), C), a.arc(b.cx, b.cy, _, hi(b.y11, b.x11), hi(b.y01, b.x01), !C))) : a.arc(0, 0, g, m, B, C);
    }
    if (a.closePath(), l) return a = null, l + "" || null;
  }
  return r.centroid = function() {
    var l = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, c = (+s.apply(this, arguments) + +A.apply(this, arguments)) / 2 - mA / 2;
    return [bA(c) * l, rs(c) * l];
  }, r.innerRadius = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Kt(+l), r) : e;
  }, r.outerRadius = function(l) {
    return arguments.length ? (t = typeof l == "function" ? l : Kt(+l), r) : t;
  }, r.cornerRadius = function(l) {
    return arguments.length ? (i = typeof l == "function" ? l : Kt(+l), r) : i;
  }, r.padRadius = function(l) {
    return arguments.length ? (n = l == null ? null : typeof l == "function" ? l : Kt(+l), r) : n;
  }, r.startAngle = function(l) {
    return arguments.length ? (s = typeof l == "function" ? l : Kt(+l), r) : s;
  }, r.endAngle = function(l) {
    return arguments.length ? (A = typeof l == "function" ? l : Kt(+l), r) : A;
  }, r.padAngle = function(l) {
    return arguments.length ? (o = typeof l == "function" ? l : Kt(+l), r) : o;
  }, r.context = function(l) {
    return arguments.length ? (a = l ?? null, r) : a;
  }, r;
}
function LD(e) {
  this._context = e;
}
LD.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function gh(e) {
  return new LD(e);
}
function UD(e) {
  return e[0];
}
function HD(e) {
  return e[1];
}
function OD() {
  var e = UD, t = HD, i = Kt(!0), n = null, s = gh, A = null;
  function o(a) {
    var r, l = a.length, c, g = !1, h;
    for (n == null && (A = s(h = oc())), r = 0; r <= l; ++r)
      !(r < l && i(c = a[r], r, a)) === g && ((g = !g) ? A.lineStart() : A.lineEnd()), g && A.point(+e(c, r, a), +t(c, r, a));
    if (h) return A = null, h + "" || null;
  }
  return o.x = function(a) {
    return arguments.length ? (e = typeof a == "function" ? a : Kt(+a), o) : e;
  }, o.y = function(a) {
    return arguments.length ? (t = typeof a == "function" ? a : Kt(+a), o) : t;
  }, o.defined = function(a) {
    return arguments.length ? (i = typeof a == "function" ? a : Kt(!!a), o) : i;
  }, o.curve = function(a) {
    return arguments.length ? (s = a, n != null && (A = s(n)), o) : s;
  }, o.context = function(a) {
    return arguments.length ? (a == null ? n = A = null : A = s(n = a), o) : n;
  }, o;
}
function EU() {
  var e = UD, t = null, i = Kt(0), n = HD, s = Kt(!0), A = null, o = gh, a = null;
  function r(c) {
    var g, h, d, u = c.length, f, C = !1, I, E = new Array(u), B = new Array(u);
    for (A == null && (a = o(I = oc())), g = 0; g <= u; ++g) {
      if (!(g < u && s(f = c[g], g, c)) === C)
        if (C = !C)
          h = g, a.areaStart(), a.lineStart();
        else {
          for (a.lineEnd(), a.lineStart(), d = g - 1; d >= h; --d)
            a.point(E[d], B[d]);
          a.lineEnd(), a.areaEnd();
        }
      C && (E[g] = +e(f, g, c), B[g] = +i(f, g, c), a.point(t ? +t(f, g, c) : E[g], n ? +n(f, g, c) : B[g]));
    }
    if (I) return a = null, I + "" || null;
  }
  function l() {
    return OD().defined(s).curve(o).context(A);
  }
  return r.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Kt(+c), t = null, r) : e;
  }, r.x0 = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Kt(+c), r) : e;
  }, r.x1 = function(c) {
    return arguments.length ? (t = c == null ? null : typeof c == "function" ? c : Kt(+c), r) : t;
  }, r.y = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Kt(+c), n = null, r) : i;
  }, r.y0 = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Kt(+c), r) : i;
  }, r.y1 = function(c) {
    return arguments.length ? (n = c == null ? null : typeof c == "function" ? c : Kt(+c), r) : n;
  }, r.lineX0 = r.lineY0 = function() {
    return l().x(e).y(i);
  }, r.lineY1 = function() {
    return l().x(e).y(n);
  }, r.lineX1 = function() {
    return l().x(t).y(i);
  }, r.defined = function(c) {
    return arguments.length ? (s = typeof c == "function" ? c : Kt(!!c), r) : s;
  }, r.curve = function(c) {
    return arguments.length ? (o = c, A != null && (a = o(A)), r) : o;
  }, r.context = function(c) {
    return arguments.length ? (c == null ? A = a = null : a = o(A = c), r) : A;
  }, r;
}
function BU(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function mU(e) {
  return e;
}
function pU() {
  var e = mU, t = BU, i = null, n = Kt(0), s = Kt(gA), A = Kt(0);
  function o(a) {
    var r, l = a.length, c, g, h = 0, d = new Array(l), u = new Array(l), f = +n.apply(this, arguments), C = Math.min(gA, Math.max(-gA, s.apply(this, arguments) - f)), I, E = Math.min(Math.abs(C) / l, A.apply(this, arguments)), B = E * (C < 0 ? -1 : 1), m;
    for (r = 0; r < l; ++r)
      (m = u[d[r] = r] = +e(a[r], r, a)) > 0 && (h += m);
    for (t != null ? d.sort(function(p, w) {
      return t(u[p], u[w]);
    }) : i != null && d.sort(function(p, w) {
      return i(a[p], a[w]);
    }), r = 0, g = h ? (C - l * B) / h : 0; r < l; ++r, f = I)
      c = d[r], m = u[c], I = f + (m > 0 ? m * g : 0) + B, u[c] = {
        data: a[c],
        index: r,
        value: m,
        startAngle: f,
        endAngle: I,
        padAngle: E
      };
    return u;
  }
  return o.value = function(a) {
    return arguments.length ? (e = typeof a == "function" ? a : Kt(+a), o) : e;
  }, o.sortValues = function(a) {
    return arguments.length ? (t = a, i = null, o) : t;
  }, o.sort = function(a) {
    return arguments.length ? (i = a, t = null, o) : i;
  }, o.startAngle = function(a) {
    return arguments.length ? (n = typeof a == "function" ? a : Kt(+a), o) : n;
  }, o.endAngle = function(a) {
    return arguments.length ? (s = typeof a == "function" ? a : Kt(+a), o) : s;
  }, o.padAngle = function(a) {
    return arguments.length ? (A = typeof a == "function" ? a : Kt(+a), o) : A;
  }, o;
}
var Up = Array.prototype.slice;
const PD = {
  draw: function(e, t) {
    var i = Math.sqrt(t / mA);
    e.moveTo(i, 0), e.arc(0, 0, i, 0, gA);
  }
}, QU = {
  draw: function(e, t) {
    var i = Math.sqrt(t / 5) / 2;
    e.moveTo(-3 * i, -i), e.lineTo(-i, -i), e.lineTo(-i, -3 * i), e.lineTo(i, -3 * i), e.lineTo(i, -i), e.lineTo(3 * i, -i), e.lineTo(3 * i, i), e.lineTo(i, i), e.lineTo(i, 3 * i), e.lineTo(-i, 3 * i), e.lineTo(-i, i), e.lineTo(-3 * i, i), e.closePath();
  }
};
var YD = Math.sqrt(1 / 3), yU = YD * 2;
const wU = {
  draw: function(e, t) {
    var i = Math.sqrt(t / yU), n = i * YD;
    e.moveTo(0, -i), e.lineTo(n, 0), e.lineTo(0, i), e.lineTo(-n, 0), e.closePath();
  }
};
var DU = 0.8908130915292852, JD = Math.sin(mA / 10) / Math.sin(7 * mA / 10), xU = Math.sin(gA / 10) * JD, SU = -Math.cos(gA / 10) * JD;
const _U = {
  draw: function(e, t) {
    var i = Math.sqrt(t * DU), n = xU * i, s = SU * i;
    e.moveTo(0, -i), e.lineTo(n, s);
    for (var A = 1; A < 5; ++A) {
      var o = gA * A / 5, a = Math.cos(o), r = Math.sin(o);
      e.lineTo(r * i, -a * i), e.lineTo(a * n - r * s, r * n + a * s);
    }
    e.closePath();
  }
}, bU = {
  draw: function(e, t) {
    var i = Math.sqrt(t), n = -i / 2;
    e.rect(n, n, i, i);
  }
};
var sf = Math.sqrt(3);
const MU = {
  draw: function(e, t) {
    var i = -Math.sqrt(t / (sf * 3));
    e.moveTo(0, i * 2), e.lineTo(-sf * i, -i), e.lineTo(sf * i, -i), e.closePath();
  }
};
var Dn = -0.5, xn = Math.sqrt(3) / 2, eI = 1 / Math.sqrt(12), NU = (eI / 2 + 1) * 3;
const FU = {
  draw: function(e, t) {
    var i = Math.sqrt(t / NU), n = i / 2, s = i * eI, A = n, o = i * eI + i, a = -A, r = o;
    e.moveTo(n, s), e.lineTo(A, o), e.lineTo(a, r), e.lineTo(Dn * n - xn * s, xn * n + Dn * s), e.lineTo(Dn * A - xn * o, xn * A + Dn * o), e.lineTo(Dn * a - xn * r, xn * a + Dn * r), e.lineTo(Dn * n + xn * s, Dn * s - xn * n), e.lineTo(Dn * A + xn * o, Dn * o - xn * A), e.lineTo(Dn * a + xn * r, Dn * r - xn * a), e.closePath();
  }
};
function RU() {
  var e = Kt(PD), t = Kt(64), i = null;
  function n() {
    var s;
    if (i || (i = s = oc()), e.apply(this, arguments).draw(i, +t.apply(this, arguments)), s) return i = null, s + "" || null;
  }
  return n.type = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : Kt(s), n) : e;
  }, n.size = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Kt(+s), n) : t;
  }, n.context = function(s) {
    return arguments.length ? (i = s ?? null, n) : i;
  }, n;
}
function Hp(e, t, i) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - i),
    e._x2,
    e._y2
  );
}
function nE(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
nE.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Hp(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        Hp(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
(function e(t) {
  function i(n) {
    return new nE(n, t);
  }
  return i.tension = function(n) {
    return e(+n);
  }, i;
})(0);
function kU(e, t, i) {
  var n = e._x1, s = e._y1, A = e._x2, o = e._y2;
  if (e._l01_a > ui) {
    var a = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, r = 3 * e._l01_a * (e._l01_a + e._l12_a);
    n = (n * a - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / r, s = (s * a - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / r;
  }
  if (e._l23_a > ui) {
    var l = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, c = 3 * e._l23_a * (e._l23_a + e._l12_a);
    A = (A * l + e._x1 * e._l23_2a - t * e._l12_2a) / c, o = (o * l + e._y1 * e._l23_2a - i * e._l12_2a) / c;
  }
  e._context.bezierCurveTo(n, s, A, o, e._x2, e._y2);
}
function KD(e, t) {
  this._context = e, this._alpha = t;
}
KD.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var i = this._x2 - e, n = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(i * i + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        kU(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Op = function e(t) {
  function i(n) {
    return t ? new KD(n, t) : new nE(n, 0);
  }
  return i.alpha = function(n) {
    return e(+n);
  }, i;
}(0.5);
function Hd(e, t) {
  this._context = e, this._t = t;
}
Hd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var i = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(i, this._y), this._context.lineTo(i, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function Pp(e) {
  return new Hd(e, 0.5);
}
function Yp(e) {
  return new Hd(e, 0);
}
function Jp(e) {
  return new Hd(e, 1);
}
function xl(e, t) {
  if ((o = e.length) > 1)
    for (var i = 1, n, s, A = e[t[0]], o, a = A.length; i < o; ++i)
      for (s = A, A = e[t[i]], n = 0; n < a; ++n)
        A[n][1] += A[n][0] = isNaN(s[n][1]) ? s[n][0] : s[n][1];
}
function hh(e) {
  for (var t = e.length, i = new Array(t); --t >= 0; ) i[t] = t;
  return i;
}
function vU(e, t) {
  return e[t];
}
function TU() {
  var e = Kt([]), t = hh, i = xl, n = vU;
  function s(A) {
    var o = e.apply(this, arguments), a, r = A.length, l = o.length, c = new Array(l), g;
    for (a = 0; a < l; ++a) {
      for (var h = o[a], d = c[a] = new Array(r), u = 0, f; u < r; ++u)
        d[u] = f = [0, +n(A[u], h, u, A)], f.data = A[u];
      d.key = h;
    }
    for (a = 0, g = t(c); a < l; ++a)
      c[g[a]].index = a;
    return i(c, g), c;
  }
  return s.keys = function(A) {
    return arguments.length ? (e = typeof A == "function" ? A : Kt(Up.call(A)), s) : e;
  }, s.value = function(A) {
    return arguments.length ? (n = typeof A == "function" ? A : Kt(+A), s) : n;
  }, s.order = function(A) {
    return arguments.length ? (t = A == null ? hh : typeof A == "function" ? A : Kt(Up.call(A)), s) : t;
  }, s.offset = function(A) {
    return arguments.length ? (i = A ?? xl, s) : i;
  }, s;
}
function GU(e, t) {
  if ((n = e.length) > 0) {
    for (var i, n, s = 0, A = e[0].length, o; s < A; ++s) {
      for (o = i = 0; i < n; ++i) o += e[i][s][1] || 0;
      if (o) for (i = 0; i < n; ++i) e[i][s][1] /= o;
    }
    xl(e, t);
  }
}
function LU(e, t) {
  if ((r = e.length) > 0)
    for (var i, n = 0, s, A, o, a, r, l = e[t[0]].length; n < l; ++n)
      for (o = a = 0, i = 0; i < r; ++i)
        (A = (s = e[t[i]][n])[1] - s[0]) > 0 ? (s[0] = o, s[1] = o += A) : A < 0 ? (s[1] = a, s[0] = a += A) : (s[0] = 0, s[1] = A);
}
function UU(e, t) {
  if (!(!((o = e.length) > 0) || !((A = (s = e[t[0]]).length) > 0))) {
    for (var i = 0, n = 1, s, A, o; n < A; ++n) {
      for (var a = 0, r = 0, l = 0; a < o; ++a) {
        for (var c = e[t[a]], g = c[n][1] || 0, h = c[n - 1][1] || 0, d = (g - h) / 2, u = 0; u < a; ++u) {
          var f = e[t[u]], C = f[n][1] || 0, I = f[n - 1][1] || 0;
          d += C - I;
        }
        r += g, l += d * g;
      }
      s[n - 1][1] += s[n - 1][0] = i, r && (i -= l / r);
    }
    s[n - 1][1] += s[n - 1][0] = i, xl(e, t);
  }
}
function VD(e) {
  var t = e.map(HU);
  return hh(e).sort(function(i, n) {
    return t[i] - t[n];
  });
}
function HU(e) {
  for (var t = 0, i = -1, n = e.length, s; ++i < n; ) (s = +e[i][1]) && (t += s);
  return t;
}
function OU(e) {
  return VD(e).reverse();
}
function PU(e) {
  return +e;
}
function WD(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var sE = 3;
(function e(t) {
  t = +t;
  function i(n) {
    return Math.pow(n, t);
  }
  return i.exponent = e, i;
})(sE);
(function e(t) {
  t = +t;
  function i(n) {
    return 1 - Math.pow(1 - n, t);
  }
  return i.exponent = e, i;
})(sE);
var YU = function e(t) {
  t = +t;
  function i(n) {
    return ((n *= 2) <= 1 ? Math.pow(n, t) : 2 - Math.pow(2 - n, t)) / 2;
  }
  return i.exponent = e, i;
}(sE);
function dh(e) {
  return (Math.pow(2, -10 * e) - 9765625e-10) * 1.0009775171065494;
}
function JU(e) {
  return ((e *= 2) <= 1 ? 1 - Math.sqrt(1 - e * e) : Math.sqrt(1 - (e -= 2) * e) + 1) / 2;
}
var iI = 4 / 11, KU = 6 / 11, VU = 8 / 11, WU = 3 / 4, qU = 9 / 11, jU = 10 / 11, zU = 15 / 16, $U = 21 / 22, XU = 63 / 64, qc = 1 / iI / iI;
function ZU(e) {
  return (e = +e) < iI ? qc * e * e : e < VU ? qc * (e -= KU) * e + WU : e < jU ? qc * (e -= qU) * e + zU : qc * (e -= $U) * e + XU;
}
var AE = 1.70158;
(function e(t) {
  t = +t;
  function i(n) {
    return (n = +n) * n * (t * (n - 1) + n);
  }
  return i.overshoot = e, i;
})(AE);
(function e(t) {
  t = +t;
  function i(n) {
    return --n * n * ((n + 1) * t + n) + 1;
  }
  return i.overshoot = e, i;
})(AE);
var tH = function e(t) {
  t = +t;
  function i(n) {
    return ((n *= 2) < 1 ? n * n * ((t + 1) * n - t) : (n -= 2) * n * ((t + 1) * n + t) + 2) / 2;
  }
  return i.overshoot = e, i;
}(AE), Ja = 2 * Math.PI, oE = 1, aE = 0.3;
(function e(t, i) {
  var n = Math.asin(1 / (t = Math.max(1, t))) * (i /= Ja);
  function s(A) {
    return t * dh(- --A) * Math.sin((n - A) / i);
  }
  return s.amplitude = function(A) {
    return e(A, i * Ja);
  }, s.period = function(A) {
    return e(t, A);
  }, s;
})(oE, aE);
var eH = function e(t, i) {
  var n = Math.asin(1 / (t = Math.max(1, t))) * (i /= Ja);
  function s(A) {
    return 1 - t * dh(A = +A) * Math.sin((A + n) / i);
  }
  return s.amplitude = function(A) {
    return e(A, i * Ja);
  }, s.period = function(A) {
    return e(t, A);
  }, s;
}(oE, aE);
(function e(t, i) {
  var n = Math.asin(1 / (t = Math.max(1, t))) * (i /= Ja);
  function s(A) {
    return ((A = A * 2 - 1) < 0 ? t * dh(-A) * Math.sin((n - A) / i) : 2 - t * dh(A) * Math.sin((n + A) / i)) / 2;
  }
  return s.amplitude = function(A) {
    return e(A, i * Ja);
  }, s.period = function(A) {
    return e(t, A);
  }, s;
})(oE, aE);
function Kp(e) {
  return function() {
    return e;
  };
}
function iH(e) {
  return e[0];
}
function nH(e) {
  return e[1];
}
function uh() {
  this._ = null;
}
function Od(e) {
  e.U = // parent node
  e.C = // color - true for red, false for black
  e.L = // left node
  e.R = // right node
  e.P = // previous node
  e.N = null;
}
uh.prototype = {
  constructor: uh,
  insert: function(e, t) {
    var i, n, s;
    if (e) {
      if (t.P = e, t.N = e.N, e.N && (e.N.P = t), e.N = t, e.R) {
        for (e = e.R; e.L; ) e = e.L;
        e.L = t;
      } else
        e.R = t;
      i = e;
    } else this._ ? (e = Vp(this._), t.P = null, t.N = e, e.P = e.L = t, i = e) : (t.P = t.N = null, this._ = t, i = null);
    for (t.L = t.R = null, t.U = i, t.C = !0, e = t; i && i.C; )
      n = i.U, i === n.L ? (s = n.R, s && s.C ? (i.C = s.C = !1, n.C = !0, e = n) : (e === i.R && (Nr(this, i), e = i, i = e.U), i.C = !1, n.C = !0, Fr(this, n))) : (s = n.L, s && s.C ? (i.C = s.C = !1, n.C = !0, e = n) : (e === i.L && (Fr(this, i), e = i, i = e.U), i.C = !1, n.C = !0, Nr(this, n))), i = e.U;
    this._.C = !1;
  },
  remove: function(e) {
    e.N && (e.N.P = e.P), e.P && (e.P.N = e.N), e.N = e.P = null;
    var t = e.U, i, n = e.L, s = e.R, A, o;
    if (n ? s ? A = Vp(s) : A = n : A = s, t ? t.L === e ? t.L = A : t.R = A : this._ = A, n && s ? (o = A.C, A.C = e.C, A.L = n, n.U = A, A !== s ? (t = A.U, A.U = e.U, e = A.R, t.L = e, A.R = s, s.U = A) : (A.U = t, t = A, e = A.R)) : (o = e.C, e = A), e && (e.U = t), !o) {
      if (e && e.C) {
        e.C = !1;
        return;
      }
      do {
        if (e === this._) break;
        if (e === t.L) {
          if (i = t.R, i.C && (i.C = !1, t.C = !0, Nr(this, t), i = t.R), i.L && i.L.C || i.R && i.R.C) {
            (!i.R || !i.R.C) && (i.L.C = !1, i.C = !0, Fr(this, i), i = t.R), i.C = t.C, t.C = i.R.C = !1, Nr(this, t), e = this._;
            break;
          }
        } else if (i = t.L, i.C && (i.C = !1, t.C = !0, Fr(this, t), i = t.L), i.L && i.L.C || i.R && i.R.C) {
          (!i.L || !i.L.C) && (i.R.C = !1, i.C = !0, Nr(this, i), i = t.L), i.C = t.C, t.C = i.L.C = !1, Fr(this, t), e = this._;
          break;
        }
        i.C = !0, e = t, t = t.U;
      } while (!e.C);
      e && (e.C = !1);
    }
  }
};
function Nr(e, t) {
  var i = t, n = t.R, s = i.U;
  s ? s.L === i ? s.L = n : s.R = n : e._ = n, n.U = s, i.U = n, i.R = n.L, i.R && (i.R.U = i), n.L = i;
}
function Fr(e, t) {
  var i = t, n = t.L, s = i.U;
  s ? s.L === i ? s.L = n : s.R = n : e._ = n, n.U = s, i.U = n, i.L = n.R, i.L && (i.L.U = i), n.R = i;
}
function Vp(e) {
  for (; e.L; ) e = e.L;
  return e;
}
function qr(e, t, i, n) {
  var s = [null, null], A = fi.push(s) - 1;
  return s.left = e, s.right = t, i && fh(s, e, t, i), n && fh(s, t, e, n), cn[e.index].halfedges.push(A), cn[t.index].halfedges.push(A), s;
}
function Rr(e, t, i) {
  var n = [t, i];
  return n.left = e, n;
}
function fh(e, t, i, n) {
  !e[0] && !e[1] ? (e[0] = n, e.left = t, e.right = i) : e.left === i ? e[1] = n : e[0] = n;
}
function sH(e, t, i, n, s) {
  var A = e[0], o = e[1], a = A[0], r = A[1], l = o[0], c = o[1], g = 0, h = 1, d = l - a, u = c - r, f;
  if (f = t - a, !(!d && f > 0)) {
    if (f /= d, d < 0) {
      if (f < g) return;
      f < h && (h = f);
    } else if (d > 0) {
      if (f > h) return;
      f > g && (g = f);
    }
    if (f = n - a, !(!d && f < 0)) {
      if (f /= d, d < 0) {
        if (f > h) return;
        f > g && (g = f);
      } else if (d > 0) {
        if (f < g) return;
        f < h && (h = f);
      }
      if (f = i - r, !(!u && f > 0)) {
        if (f /= u, u < 0) {
          if (f < g) return;
          f < h && (h = f);
        } else if (u > 0) {
          if (f > h) return;
          f > g && (g = f);
        }
        if (f = s - r, !(!u && f < 0)) {
          if (f /= u, u < 0) {
            if (f > h) return;
            f > g && (g = f);
          } else if (u > 0) {
            if (f < g) return;
            f < h && (h = f);
          }
          return !(g > 0) && !(h < 1) || (g > 0 && (e[0] = [a + g * d, r + g * u]), h < 1 && (e[1] = [a + h * d, r + h * u])), !0;
        }
      }
    }
  }
}
function AH(e, t, i, n, s) {
  var A = e[1];
  if (A) return !0;
  var o = e[0], a = e.left, r = e.right, l = a[0], c = a[1], g = r[0], h = r[1], d = (l + g) / 2, u = (c + h) / 2, f, C;
  if (h === c) {
    if (d < t || d >= n) return;
    if (l > g) {
      if (!o) o = [d, i];
      else if (o[1] >= s) return;
      A = [d, s];
    } else {
      if (!o) o = [d, s];
      else if (o[1] < i) return;
      A = [d, i];
    }
  } else if (f = (l - g) / (h - c), C = u - f * d, f < -1 || f > 1)
    if (l > g) {
      if (!o) o = [(i - C) / f, i];
      else if (o[1] >= s) return;
      A = [(s - C) / f, s];
    } else {
      if (!o) o = [(s - C) / f, s];
      else if (o[1] < i) return;
      A = [(i - C) / f, i];
    }
  else if (c < h) {
    if (!o) o = [t, f * t + C];
    else if (o[0] >= n) return;
    A = [n, f * n + C];
  } else {
    if (!o) o = [n, f * n + C];
    else if (o[0] < t) return;
    A = [t, f * t + C];
  }
  return e[0] = o, e[1] = A, !0;
}
function oH(e, t, i, n) {
  for (var s = fi.length, A; s--; )
    (!AH(A = fi[s], e, t, i, n) || !sH(A, e, t, i, n) || !(Math.abs(A[0][0] - A[1][0]) > de || Math.abs(A[0][1] - A[1][1]) > de)) && delete fi[s];
}
function aH(e) {
  return cn[e.index] = {
    site: e,
    halfedges: []
  };
}
function rH(e, t) {
  var i = e.site, n = t.left, s = t.right;
  return i === s && (s = n, n = i), s ? Math.atan2(s[1] - n[1], s[0] - n[0]) : (i === n ? (n = t[1], s = t[0]) : (n = t[0], s = t[1]), Math.atan2(n[0] - s[0], s[1] - n[1]));
}
function qD(e, t) {
  return t[+(t.left !== e.site)];
}
function lH(e, t) {
  return t[+(t.left === e.site)];
}
function cH() {
  for (var e = 0, t = cn.length, i, n, s, A; e < t; ++e)
    if ((i = cn[e]) && (A = (n = i.halfedges).length)) {
      var o = new Array(A), a = new Array(A);
      for (s = 0; s < A; ++s) o[s] = s, a[s] = rH(i, fi[n[s]]);
      for (o.sort(function(r, l) {
        return a[l] - a[r];
      }), s = 0; s < A; ++s) a[s] = n[o[s]];
      for (s = 0; s < A; ++s) n[s] = a[s];
    }
}
function gH(e, t, i, n) {
  var s = cn.length, A, o, a, r, l, c, g, h, d, u, f, C, I = !0;
  for (A = 0; A < s; ++A)
    if (o = cn[A]) {
      for (a = o.site, l = o.halfedges, r = l.length; r--; )
        fi[l[r]] || l.splice(r, 1);
      for (r = 0, c = l.length; r < c; )
        u = lH(o, fi[l[r]]), f = u[0], C = u[1], g = qD(o, fi[l[++r % c]]), h = g[0], d = g[1], (Math.abs(f - h) > de || Math.abs(C - d) > de) && (l.splice(r, 0, fi.push(Rr(
          a,
          u,
          Math.abs(f - e) < de && n - C > de ? [e, Math.abs(h - e) < de ? d : n] : Math.abs(C - n) < de && i - f > de ? [Math.abs(d - n) < de ? h : i, n] : Math.abs(f - i) < de && C - t > de ? [i, Math.abs(h - i) < de ? d : t] : Math.abs(C - t) < de && f - e > de ? [Math.abs(d - t) < de ? h : e, t] : null
        )) - 1), ++c);
      c && (I = !1);
    }
  if (I) {
    var E, B, m, p = 1 / 0;
    for (A = 0, I = null; A < s; ++A)
      (o = cn[A]) && (a = o.site, E = a[0] - e, B = a[1] - t, m = E * E + B * B, m < p && (p = m, I = o));
    if (I) {
      var w = [e, t], Q = [e, n], y = [i, n], D = [i, t];
      I.halfedges.push(
        fi.push(Rr(a = I.site, w, Q)) - 1,
        fi.push(Rr(a, Q, y)) - 1,
        fi.push(Rr(a, y, D)) - 1,
        fi.push(Rr(a, D, w)) - 1
      );
    }
  }
  for (A = 0; A < s; ++A)
    (o = cn[A]) && (o.halfedges.length || delete cn[A]);
}
var jD = [], rE;
function hH() {
  Od(this), this.x = this.y = this.arc = this.site = this.cy = null;
}
function ra(e) {
  var t = e.P, i = e.N;
  if (!(!t || !i)) {
    var n = t.site, s = e.site, A = i.site;
    if (n !== A) {
      var o = s[0], a = s[1], r = n[0] - o, l = n[1] - a, c = A[0] - o, g = A[1] - a, h = 2 * (r * g - l * c);
      if (!(h >= -1e-12)) {
        var d = r * r + l * l, u = c * c + g * g, f = (g * d - l * u) / h, C = (r * u - c * d) / h, I = jD.pop() || new hH();
        I.arc = e, I.site = s, I.x = f + o, I.y = (I.cy = C + a) + Math.sqrt(f * f + C * C), e.circle = I;
        for (var E = null, B = Sl._; B; )
          if (I.y < B.y || I.y === B.y && I.x <= B.x)
            if (B.L) B = B.L;
            else {
              E = B.P;
              break;
            }
          else if (B.R) B = B.R;
          else {
            E = B;
            break;
          }
        Sl.insert(E, I), E || (rE = I);
      }
    }
  }
}
function Ba(e) {
  var t = e.circle;
  t && (t.P || (rE = t.N), Sl.remove(t), jD.push(t), Od(t), e.circle = null);
}
var zD = [];
function dH() {
  Od(this), this.edge = this.site = this.circle = null;
}
function Wp(e) {
  var t = zD.pop() || new dH();
  return t.site = e, t;
}
function Af(e) {
  Ba(e), ma.remove(e), zD.push(e), Od(e);
}
function uH(e) {
  var t = e.circle, i = t.x, n = t.cy, s = [i, n], A = e.P, o = e.N, a = [e];
  Af(e);
  for (var r = A; r.circle && Math.abs(i - r.circle.x) < de && Math.abs(n - r.circle.cy) < de; )
    A = r.P, a.unshift(r), Af(r), r = A;
  a.unshift(r), Ba(r);
  for (var l = o; l.circle && Math.abs(i - l.circle.x) < de && Math.abs(n - l.circle.cy) < de; )
    o = l.N, a.push(l), Af(l), l = o;
  a.push(l), Ba(l);
  var c = a.length, g;
  for (g = 1; g < c; ++g)
    l = a[g], r = a[g - 1], fh(l.edge, r.site, l.site, s);
  r = a[0], l = a[c - 1], l.edge = qr(r.site, l.site, null, s), ra(r), ra(l);
}
function fH(e) {
  for (var t = e[0], i = e[1], n, s, A, o, a = ma._; a; )
    if (A = $D(a, i) - t, A > de) a = a.L;
    else if (o = t - IH(a, i), o > de) {
      if (!a.R) {
        n = a;
        break;
      }
      a = a.R;
    } else {
      A > -1e-6 ? (n = a.P, s = a) : o > -1e-6 ? (n = a, s = a.N) : n = s = a;
      break;
    }
  aH(e);
  var r = Wp(e);
  if (ma.insert(n, r), !(!n && !s)) {
    if (n === s) {
      Ba(n), s = Wp(n.site), ma.insert(r, s), r.edge = s.edge = qr(n.site, r.site), ra(n), ra(s);
      return;
    }
    if (!s) {
      r.edge = qr(n.site, r.site);
      return;
    }
    Ba(n), Ba(s);
    var l = n.site, c = l[0], g = l[1], h = e[0] - c, d = e[1] - g, u = s.site, f = u[0] - c, C = u[1] - g, I = 2 * (h * C - d * f), E = h * h + d * d, B = f * f + C * C, m = [(C * E - d * B) / I + c, (h * B - f * E) / I + g];
    fh(s.edge, l, u, m), r.edge = qr(l, e, null, m), s.edge = qr(e, u, null, m), ra(n), ra(s);
  }
}
function $D(e, t) {
  var i = e.site, n = i[0], s = i[1], A = s - t;
  if (!A) return n;
  var o = e.P;
  if (!o) return -1 / 0;
  i = o.site;
  var a = i[0], r = i[1], l = r - t;
  if (!l) return a;
  var c = a - n, g = 1 / A - 1 / l, h = c / l;
  return g ? (-h + Math.sqrt(h * h - 2 * g * (c * c / (-2 * l) - r + l / 2 + s - A / 2))) / g + n : (n + a) / 2;
}
function IH(e, t) {
  var i = e.N;
  if (i) return $D(i, t);
  var n = e.site;
  return n[1] === t ? n[0] : 1 / 0;
}
var de = 1e-6, ma, cn, Sl, fi;
function CH(e, t, i) {
  return (e[0] - i[0]) * (t[1] - e[1]) - (e[0] - t[0]) * (i[1] - e[1]);
}
function EH(e, t) {
  return t[1] - e[1] || t[0] - e[0];
}
function nI(e, t) {
  var i = e.sort(EH).pop(), n, s, A;
  for (fi = [], cn = new Array(e.length), ma = new uh(), Sl = new uh(); ; )
    if (A = rE, i && (!A || i[1] < A.y || i[1] === A.y && i[0] < A.x))
      (i[0] !== n || i[1] !== s) && (fH(i), n = i[0], s = i[1]), i = e.pop();
    else if (A)
      uH(A.arc);
    else
      break;
  if (cH(), t) {
    var o = +t[0][0], a = +t[0][1], r = +t[1][0], l = +t[1][1];
    oH(o, a, r, l), gH(o, a, r, l);
  }
  this.edges = fi, this.cells = cn, ma = Sl = fi = cn = null;
}
nI.prototype = {
  constructor: nI,
  polygons: function() {
    var e = this.edges;
    return this.cells.map(function(t) {
      var i = t.halfedges.map(function(n) {
        return qD(t, e[n]);
      });
      return i.data = t.site.data, i;
    });
  },
  triangles: function() {
    var e = [], t = this.edges;
    return this.cells.forEach(function(i, n) {
      if (a = (A = i.halfedges).length)
        for (var s = i.site, A, o = -1, a, r, l = t[A[a - 1]], c = l.left === s ? l.right : l.left; ++o < a; )
          r = c, l = t[A[o]], c = l.left === s ? l.right : l.left, r && c && n < r.index && n < c.index && CH(s, r, c) < 0 && e.push([s.data, r.data, c.data]);
    }), e;
  },
  links: function() {
    return this.edges.filter(function(e) {
      return e.right;
    }).map(function(e) {
      return {
        source: e.left.data,
        target: e.right.data
      };
    });
  },
  find: function(e, t, i) {
    for (var n = this, s, A = n._found || 0, o = n.cells.length, a; !(a = n.cells[A]); ) if (++A >= o) return null;
    var r = e - a.site[0], l = t - a.site[1], c = r * r + l * l;
    do
      a = n.cells[s = A], A = null, a.halfedges.forEach(function(g) {
        var h = n.edges[g], d = h.left;
        if (!((d === a.site || !d) && !(d = h.right))) {
          var u = e - d[0], f = t - d[1], C = u * u + f * f;
          C < c && (c = C, A = d.index);
        }
      });
    while (A !== null);
    return n._found = s, i == null || c <= i * i ? a.site : null;
  }
};
function BH() {
  var e = iH, t = nH, i = null;
  function n(s) {
    return new nI(s.map(function(A, o) {
      var a = [Math.round(e(A, o, s) / de) * de, Math.round(t(A, o, s) / de) * de];
      return a.index = o, a.data = A, a;
    }), i);
  }
  return n.polygons = function(s) {
    return n(s).polygons();
  }, n.links = function(s) {
    return n(s).links();
  }, n.triangles = function(s) {
    return n(s).triangles();
  }, n.x = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : Kp(+s), n) : e;
  }, n.y = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Kp(+s), n) : t;
  }, n.extent = function(s) {
    return arguments.length ? (i = s == null ? null : [[+s[0][0], +s[0][1]], [+s[1][0], +s[1][1]]], n) : i && [[i[0][0], i[0][1]], [i[1][0], i[1][1]]];
  }, n.size = function(s) {
    return arguments.length ? (i = s == null ? null : [[0, 0], [+s[0], +s[1]]], n) : i && [i[1][0] - i[0][0], i[1][1] - i[0][1]];
  }, n;
}
class mH extends Map {
  constructor(t, i = tx) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: i } }), t != null) for (const [n, s] of t) this.set(n, s);
  }
  get(t) {
    return super.get(sI(this, t));
  }
  has(t) {
    return super.has(sI(this, t));
  }
  set(t, i) {
    return super.set(XD(this, t), i);
  }
  delete(t) {
    return super.delete(ZD(this, t));
  }
}
class pH extends Set {
  constructor(t, i = tx) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: i } }), t != null) for (const n of t) this.add(n);
  }
  has(t) {
    return super.has(sI(this, t));
  }
  add(t) {
    return super.add(XD(this, t));
  }
  delete(t) {
    return super.delete(ZD(this, t));
  }
}
function sI({ _intern: e, _key: t }, i) {
  const n = t(i);
  return e.has(n) ? e.get(n) : i;
}
function XD({ _intern: e, _key: t }, i) {
  const n = t(i);
  return e.has(n) ? e.get(n) : (e.set(n, i), i);
}
function ZD({ _intern: e, _key: t }, i) {
  const n = t(i);
  return e.has(n) && (i = e.get(n), e.delete(n)), i;
}
function tx(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
function qp(e) {
  return e;
}
function pa(e, ...t) {
  return QH(e, qp, qp, t);
}
function QH(e, t, i, n) {
  return function s(A, o) {
    if (o >= n.length) return i(A);
    const a = new mH(), r = n[o++];
    let l = -1;
    for (const c of A) {
      const g = r(c, ++l, A), h = a.get(g);
      h ? h.push(c) : a.set(g, [c]);
    }
    for (const [c, g] of a)
      a.set(c, s(g, o));
    return t(a);
  }(e, 0);
}
function xi(e, t) {
  let i;
  if (t === void 0)
    for (const n of e)
      n != null && (i < n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of e)
      (s = t(s, ++n, e)) != null && (i < s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function ex(e, t) {
  let i;
  if (t === void 0)
    for (const n of e)
      n != null && (i > n || i === void 0 && n >= n) && (i = n);
  else {
    let n = -1;
    for (let s of e)
      (s = t(s, ++n, e)) != null && (i > s || i === void 0 && s >= s) && (i = s);
  }
  return i;
}
function Qa(e, t, i) {
  e = +e, t = +t, i = (s = arguments.length) < 2 ? (t = e, e = 0, 1) : s < 3 ? 1 : +i;
  for (var n = -1, s = Math.max(0, Math.ceil((t - e) / i)) | 0, A = new Array(s); ++n < s; )
    A[n] = e + n * i;
  return A;
}
function Ii(e, t) {
  let i = 0;
  if (t === void 0)
    for (let n of e)
      (n = +n) && (i += n);
  else {
    let n = -1;
    for (let s of e)
      (s = +t(s, ++n, e)) && (i += s);
  }
  return i;
}
function Ye(e) {
  if (!(A = e.length)) return [];
  for (var t = -1, i = ex(e, yH), n = new Array(i); ++t < i; )
    for (var s = -1, A, o = n[t] = new Array(A); ++s < A; )
      o[s] = e[s][t];
  return n;
}
function yH(e) {
  return e.length;
}
function AI() {
  return Ye(arguments);
}
function Ka(e, ...t) {
  e = new pH(e);
  for (const i of t)
    for (const n of i)
      e.delete(n);
  return e;
}
const oI = Math.PI, aI = 2 * oI, TA = 1e-6, wH = aI - TA;
function rI() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function ix() {
  return new rI();
}
rI.prototype = ix.prototype = {
  constructor: rI,
  moveTo: function(e, t) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(e, t) {
    this._ += "L" + (this._x1 = +e) + "," + (this._y1 = +t);
  },
  quadraticCurveTo: function(e, t, i, n) {
    this._ += "Q" + +e + "," + +t + "," + (this._x1 = +i) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(e, t, i, n, s, A) {
    this._ += "C" + +e + "," + +t + "," + +i + "," + +n + "," + (this._x1 = +s) + "," + (this._y1 = +A);
  },
  arcTo: function(e, t, i, n, s) {
    e = +e, t = +t, i = +i, n = +n, s = +s;
    var A = this._x1, o = this._y1, a = i - e, r = n - t, l = A - e, c = o - t, g = l * l + c * c;
    if (s < 0) throw new Error("negative radius: " + s);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = e) + "," + (this._y1 = t);
    else if (g > TA) if (!(Math.abs(c * a - r * l) > TA) || !s)
      this._ += "L" + (this._x1 = e) + "," + (this._y1 = t);
    else {
      var h = i - A, d = n - o, u = a * a + r * r, f = h * h + d * d, C = Math.sqrt(u), I = Math.sqrt(g), E = s * Math.tan((oI - Math.acos((u + g - f) / (2 * C * I))) / 2), B = E / I, m = E / C;
      Math.abs(B - 1) > TA && (this._ += "L" + (e + B * l) + "," + (t + B * c)), this._ += "A" + s + "," + s + ",0,0," + +(c * h > l * d) + "," + (this._x1 = e + m * a) + "," + (this._y1 = t + m * r);
    }
  },
  arc: function(e, t, i, n, s, A) {
    e = +e, t = +t, i = +i, A = !!A;
    var o = i * Math.cos(n), a = i * Math.sin(n), r = e + o, l = t + a, c = 1 ^ A, g = A ? n - s : s - n;
    if (i < 0) throw new Error("negative radius: " + i);
    this._x1 === null ? this._ += "M" + r + "," + l : (Math.abs(this._x1 - r) > TA || Math.abs(this._y1 - l) > TA) && (this._ += "L" + r + "," + l), i && (g < 0 && (g = g % aI + aI), g > wH ? this._ += "A" + i + "," + i + ",0,1," + c + "," + (e - o) + "," + (t - a) + "A" + i + "," + i + ",0,1," + c + "," + (this._x1 = r) + "," + (this._y1 = l) : g > TA && (this._ += "A" + i + "," + i + ",0," + +(g >= oI) + "," + c + "," + (this._x1 = e + i * Math.cos(s)) + "," + (this._y1 = t + i * Math.sin(s))));
  },
  rect: function(e, t, i, n) {
    this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t) + "h" + +i + "v" + +n + "h" + -i + "Z";
  },
  toString: function() {
    return this._;
  }
};
const Gs = 11102230246251565e-32, di = 134217729, DH = (3 + 8 * Gs) * Gs;
function of(e, t, i, n, s) {
  let A, o, a, r, l = t[0], c = n[0], g = 0, h = 0;
  c > l == c > -l ? (A = l, l = t[++g]) : (A = c, c = n[++h]);
  let d = 0;
  if (g < e && h < i)
    for (c > l == c > -l ? (o = l + A, a = A - (o - l), l = t[++g]) : (o = c + A, a = A - (o - c), c = n[++h]), A = o, a !== 0 && (s[d++] = a); g < e && h < i; )
      c > l == c > -l ? (o = A + l, r = o - A, a = A - (o - r) + (l - r), l = t[++g]) : (o = A + c, r = o - A, a = A - (o - r) + (c - r), c = n[++h]), A = o, a !== 0 && (s[d++] = a);
  for (; g < e; )
    o = A + l, r = o - A, a = A - (o - r) + (l - r), l = t[++g], A = o, a !== 0 && (s[d++] = a);
  for (; h < i; )
    o = A + c, r = o - A, a = A - (o - r) + (c - r), c = n[++h], A = o, a !== 0 && (s[d++] = a);
  return (A !== 0 || d === 0) && (s[d++] = A), d;
}
function xH(e, t) {
  let i = t[0];
  for (let n = 1; n < e; n++) i += t[n];
  return i;
}
function ac(e) {
  return new Float64Array(e);
}
const SH = (3 + 16 * Gs) * Gs, _H = (2 + 12 * Gs) * Gs, bH = (9 + 64 * Gs) * Gs * Gs, Wo = ac(4), jp = ac(8), zp = ac(12), $p = ac(16), Di = ac(4);
function MH(e, t, i, n, s, A, o) {
  let a, r, l, c, g, h, d, u, f, C, I, E, B, m, p, w, Q, y;
  const D = e - s, _ = i - s, x = t - A, S = n - A;
  m = D * S, h = di * D, d = h - (h - D), u = D - d, h = di * S, f = h - (h - S), C = S - f, p = u * C - (m - d * f - u * f - d * C), w = x * _, h = di * x, d = h - (h - x), u = x - d, h = di * _, f = h - (h - _), C = _ - f, Q = u * C - (w - d * f - u * f - d * C), I = p - Q, g = p - I, Wo[0] = p - (I + g) + (g - Q), E = m + I, g = E - m, B = m - (E - g) + (I - g), I = B - w, g = B - I, Wo[1] = B - (I + g) + (g - w), y = E + I, g = y - E, Wo[2] = E - (y - g) + (I - g), Wo[3] = y;
  let b = xH(4, Wo), R = _H * o;
  if (b >= R || -b >= R || (g = e - D, a = e - (D + g) + (g - s), g = i - _, l = i - (_ + g) + (g - s), g = t - x, r = t - (x + g) + (g - A), g = n - S, c = n - (S + g) + (g - A), a === 0 && r === 0 && l === 0 && c === 0) || (R = bH * o + DH * Math.abs(b), b += D * c + S * a - (x * l + _ * r), b >= R || -b >= R)) return b;
  m = a * S, h = di * a, d = h - (h - a), u = a - d, h = di * S, f = h - (h - S), C = S - f, p = u * C - (m - d * f - u * f - d * C), w = r * _, h = di * r, d = h - (h - r), u = r - d, h = di * _, f = h - (h - _), C = _ - f, Q = u * C - (w - d * f - u * f - d * C), I = p - Q, g = p - I, Di[0] = p - (I + g) + (g - Q), E = m + I, g = E - m, B = m - (E - g) + (I - g), I = B - w, g = B - I, Di[1] = B - (I + g) + (g - w), y = E + I, g = y - E, Di[2] = E - (y - g) + (I - g), Di[3] = y;
  const G = of(4, Wo, 4, Di, jp);
  m = D * c, h = di * D, d = h - (h - D), u = D - d, h = di * c, f = h - (h - c), C = c - f, p = u * C - (m - d * f - u * f - d * C), w = x * l, h = di * x, d = h - (h - x), u = x - d, h = di * l, f = h - (h - l), C = l - f, Q = u * C - (w - d * f - u * f - d * C), I = p - Q, g = p - I, Di[0] = p - (I + g) + (g - Q), E = m + I, g = E - m, B = m - (E - g) + (I - g), I = B - w, g = B - I, Di[1] = B - (I + g) + (g - w), y = E + I, g = y - E, Di[2] = E - (y - g) + (I - g), Di[3] = y;
  const T = of(G, jp, 4, Di, zp);
  m = a * c, h = di * a, d = h - (h - a), u = a - d, h = di * c, f = h - (h - c), C = c - f, p = u * C - (m - d * f - u * f - d * C), w = r * l, h = di * r, d = h - (h - r), u = r - d, h = di * l, f = h - (h - l), C = l - f, Q = u * C - (w - d * f - u * f - d * C), I = p - Q, g = p - I, Di[0] = p - (I + g) + (g - Q), E = m + I, g = E - m, B = m - (E - g) + (I - g), I = B - w, g = B - I, Di[1] = B - (I + g) + (g - w), y = E + I, g = y - E, Di[2] = E - (y - g) + (I - g), Di[3] = y;
  const v = of(T, zp, 4, Di, $p);
  return $p[v - 1];
}
function jc(e, t, i, n, s, A) {
  const o = (t - A) * (i - s), a = (e - s) * (n - A), r = o - a, l = Math.abs(o + a);
  return Math.abs(r) >= SH * l ? r : -MH(e, t, i, n, s, A, l);
}
const Xp = Math.pow(2, -52), zc = new Uint32Array(512);
class Ih {
  static from(t, i = vH, n = TH) {
    const s = t.length, A = new Float64Array(s * 2);
    for (let o = 0; o < s; o++) {
      const a = t[o];
      A[2 * o] = i(a), A[2 * o + 1] = n(a);
    }
    return new Ih(A);
  }
  constructor(t) {
    const i = t.length >> 1;
    if (i > 0 && typeof t[0] != "number") throw new Error("Expected coords to contain numbers.");
    this.coords = t;
    const n = Math.max(2 * i - 5, 0);
    this._triangles = new Uint32Array(n * 3), this._halfedges = new Int32Array(n * 3), this._hashSize = Math.ceil(Math.sqrt(i)), this._hullPrev = new Uint32Array(i), this._hullNext = new Uint32Array(i), this._hullTri = new Uint32Array(i), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(i), this._dists = new Float64Array(i), this.update();
  }
  update() {
    const { coords: t, _hullPrev: i, _hullNext: n, _hullTri: s, _hullHash: A } = this, o = t.length >> 1;
    let a = 1 / 0, r = 1 / 0, l = -1 / 0, c = -1 / 0;
    for (let D = 0; D < o; D++) {
      const _ = t[2 * D], x = t[2 * D + 1];
      _ < a && (a = _), x < r && (r = x), _ > l && (l = _), x > c && (c = x), this._ids[D] = D;
    }
    const g = (a + l) / 2, h = (r + c) / 2;
    let d, u, f;
    for (let D = 0, _ = 1 / 0; D < o; D++) {
      const x = af(g, h, t[2 * D], t[2 * D + 1]);
      x < _ && (d = D, _ = x);
    }
    const C = t[2 * d], I = t[2 * d + 1];
    for (let D = 0, _ = 1 / 0; D < o; D++) {
      if (D === d) continue;
      const x = af(C, I, t[2 * D], t[2 * D + 1]);
      x < _ && x > 0 && (u = D, _ = x);
    }
    let E = t[2 * u], B = t[2 * u + 1], m = 1 / 0;
    for (let D = 0; D < o; D++) {
      if (D === d || D === u) continue;
      const _ = RH(C, I, E, B, t[2 * D], t[2 * D + 1]);
      _ < m && (f = D, m = _);
    }
    let p = t[2 * f], w = t[2 * f + 1];
    if (m === 1 / 0) {
      for (let x = 0; x < o; x++)
        this._dists[x] = t[2 * x] - t[0] || t[2 * x + 1] - t[1];
      la(this._ids, this._dists, 0, o - 1);
      const D = new Uint32Array(o);
      let _ = 0;
      for (let x = 0, S = -1 / 0; x < o; x++) {
        const b = this._ids[x], R = this._dists[b];
        R > S && (D[_++] = b, S = R);
      }
      this.hull = D.subarray(0, _), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (jc(C, I, E, B, p, w) < 0) {
      const D = u, _ = E, x = B;
      u = f, E = p, B = w, f = D, p = _, w = x;
    }
    const Q = kH(C, I, E, B, p, w);
    this._cx = Q.x, this._cy = Q.y;
    for (let D = 0; D < o; D++)
      this._dists[D] = af(t[2 * D], t[2 * D + 1], Q.x, Q.y);
    la(this._ids, this._dists, 0, o - 1), this._hullStart = d;
    let y = 3;
    n[d] = i[f] = u, n[u] = i[d] = f, n[f] = i[u] = d, s[d] = 0, s[u] = 1, s[f] = 2, A.fill(-1), A[this._hashKey(C, I)] = d, A[this._hashKey(E, B)] = u, A[this._hashKey(p, w)] = f, this.trianglesLen = 0, this._addTriangle(d, u, f, -1, -1, -1);
    for (let D = 0, _, x; D < this._ids.length; D++) {
      const S = this._ids[D], b = t[2 * S], R = t[2 * S + 1];
      if (D > 0 && Math.abs(b - _) <= Xp && Math.abs(R - x) <= Xp || (_ = b, x = R, S === d || S === u || S === f)) continue;
      let G = 0;
      for (let M = 0, F = this._hashKey(b, R); M < this._hashSize && (G = A[(F + M) % this._hashSize], !(G !== -1 && G !== n[G])); M++)
        ;
      G = i[G];
      let T = G, v;
      for (; v = n[T], jc(b, R, t[2 * T], t[2 * T + 1], t[2 * v], t[2 * v + 1]) >= 0; )
        if (T = v, T === G) {
          T = -1;
          break;
        }
      if (T === -1) continue;
      let H = this._addTriangle(T, S, n[T], -1, -1, s[T]);
      s[S] = this._legalize(H + 2), s[T] = H, y++;
      let N = n[T];
      for (; v = n[N], jc(b, R, t[2 * N], t[2 * N + 1], t[2 * v], t[2 * v + 1]) < 0; )
        H = this._addTriangle(N, S, v, s[S], -1, s[N]), s[S] = this._legalize(H + 2), n[N] = N, y--, N = v;
      if (T === G)
        for (; v = i[T], jc(b, R, t[2 * v], t[2 * v + 1], t[2 * T], t[2 * T + 1]) < 0; )
          H = this._addTriangle(v, S, T, -1, s[T], s[v]), this._legalize(H + 2), s[v] = H, n[T] = T, y--, T = v;
      this._hullStart = i[S] = T, n[T] = i[N] = S, n[S] = N, A[this._hashKey(b, R)] = S, A[this._hashKey(t[2 * T], t[2 * T + 1])] = T;
    }
    this.hull = new Uint32Array(y);
    for (let D = 0, _ = this._hullStart; D < y; D++)
      this.hull[D] = _, _ = n[_];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(t, i) {
    return Math.floor(NH(t - this._cx, i - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(t) {
    const { _triangles: i, _halfedges: n, coords: s } = this;
    let A = 0, o = 0;
    for (; ; ) {
      const a = n[t], r = t - t % 3;
      if (o = r + (t + 2) % 3, a === -1) {
        if (A === 0) break;
        t = zc[--A];
        continue;
      }
      const l = a - a % 3, c = r + (t + 1) % 3, g = l + (a + 2) % 3, h = i[o], d = i[t], u = i[c], f = i[g];
      if (FH(
        s[2 * h],
        s[2 * h + 1],
        s[2 * d],
        s[2 * d + 1],
        s[2 * u],
        s[2 * u + 1],
        s[2 * f],
        s[2 * f + 1]
      )) {
        i[t] = f, i[a] = h;
        const I = n[g];
        if (I === -1) {
          let B = this._hullStart;
          do {
            if (this._hullTri[B] === g) {
              this._hullTri[B] = t;
              break;
            }
            B = this._hullPrev[B];
          } while (B !== this._hullStart);
        }
        this._link(t, I), this._link(a, n[o]), this._link(o, g);
        const E = l + (a + 1) % 3;
        A < zc.length && (zc[A++] = E);
      } else {
        if (A === 0) break;
        t = zc[--A];
      }
    }
    return o;
  }
  _link(t, i) {
    this._halfedges[t] = i, i !== -1 && (this._halfedges[i] = t);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(t, i, n, s, A, o) {
    const a = this.trianglesLen;
    return this._triangles[a] = t, this._triangles[a + 1] = i, this._triangles[a + 2] = n, this._link(a, s), this._link(a + 1, A), this._link(a + 2, o), this.trianglesLen += 3, a;
  }
}
function NH(e, t) {
  const i = e / (Math.abs(e) + Math.abs(t));
  return (t > 0 ? 3 - i : 1 + i) / 4;
}
function af(e, t, i, n) {
  const s = e - i, A = t - n;
  return s * s + A * A;
}
function FH(e, t, i, n, s, A, o, a) {
  const r = e - o, l = t - a, c = i - o, g = n - a, h = s - o, d = A - a, u = r * r + l * l, f = c * c + g * g, C = h * h + d * d;
  return r * (g * C - f * d) - l * (c * C - f * h) + u * (c * d - g * h) < 0;
}
function RH(e, t, i, n, s, A) {
  const o = i - e, a = n - t, r = s - e, l = A - t, c = o * o + a * a, g = r * r + l * l, h = 0.5 / (o * l - a * r), d = (l * c - a * g) * h, u = (o * g - r * c) * h;
  return d * d + u * u;
}
function kH(e, t, i, n, s, A) {
  const o = i - e, a = n - t, r = s - e, l = A - t, c = o * o + a * a, g = r * r + l * l, h = 0.5 / (o * l - a * r), d = e + (l * c - a * g) * h, u = t + (o * g - r * c) * h;
  return { x: d, y: u };
}
function la(e, t, i, n) {
  if (n - i <= 20)
    for (let s = i + 1; s <= n; s++) {
      const A = e[s], o = t[A];
      let a = s - 1;
      for (; a >= i && t[e[a]] > o; ) e[a + 1] = e[a--];
      e[a + 1] = A;
    }
  else {
    const s = i + n >> 1;
    let A = i + 1, o = n;
    kr(e, s, A), t[e[i]] > t[e[n]] && kr(e, i, n), t[e[A]] > t[e[n]] && kr(e, A, n), t[e[i]] > t[e[A]] && kr(e, i, A);
    const a = e[A], r = t[a];
    for (; ; ) {
      do
        A++;
      while (t[e[A]] < r);
      do
        o--;
      while (t[e[o]] > r);
      if (o < A) break;
      kr(e, A, o);
    }
    e[i + 1] = e[o], e[o] = a, n - A + 1 >= o - i ? (la(e, t, A, n), la(e, t, i, o - 1)) : (la(e, t, i, o - 1), la(e, t, A, n));
  }
}
function kr(e, t, i) {
  const n = e[t];
  e[t] = e[i], e[i] = n;
}
function vH(e) {
  return e[0];
}
function TH(e) {
  return e[1];
}
const Zp = 1e-6;
let WA = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "";
  }
  moveTo(t, i) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +i}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }
  lineTo(t, i) {
    this._ += `L${this._x1 = +t},${this._y1 = +i}`;
  }
  arc(t, i, n) {
    t = +t, i = +i, n = +n;
    const s = t + n, A = i;
    if (n < 0) throw new Error("negative radius");
    this._x1 === null ? this._ += `M${s},${A}` : (Math.abs(this._x1 - s) > Zp || Math.abs(this._y1 - A) > Zp) && (this._ += "L" + s + "," + A), n && (this._ += `A${n},${n},0,1,1,${t - n},${i}A${n},${n},0,1,1,${this._x1 = s},${this._y1 = A}`);
  }
  rect(t, i, n, s) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +i}h${+n}v${+s}h${-n}Z`;
  }
  value() {
    return this._ || null;
  }
};
class lI {
  constructor() {
    this._ = [];
  }
  moveTo(t, i) {
    this._.push([t, i]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(t, i) {
    this._.push([t, i]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
let GH = class {
  constructor(t, [i, n, s, A] = [0, 0, 960, 500]) {
    if (!((s = +s) >= (i = +i)) || !((A = +A) >= (n = +n))) throw new Error("invalid bounds");
    this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = s, this.xmin = i, this.ymax = A, this.ymin = n, this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const { delaunay: { points: t, hull: i, triangles: n }, vectors: s } = this;
    let A, o;
    const a = this.circumcenters = this._circumcenters.subarray(0, n.length / 3 * 2);
    for (let f = 0, C = 0, I = n.length, E, B; f < I; f += 3, C += 2) {
      const m = n[f] * 2, p = n[f + 1] * 2, w = n[f + 2] * 2, Q = t[m], y = t[m + 1], D = t[p], _ = t[p + 1], x = t[w], S = t[w + 1], b = D - Q, R = _ - y, G = x - Q, T = S - y, v = (b * T - R * G) * 2;
      if (Math.abs(v) < 1e-9) {
        if (A === void 0) {
          A = o = 0;
          for (const N of i) A += t[N * 2], o += t[N * 2 + 1];
          A /= i.length, o /= i.length;
        }
        const H = 1e9 * Math.sign((A - Q) * T - (o - y) * G);
        E = (Q + x) / 2 - H * T, B = (y + S) / 2 + H * G;
      } else {
        const H = 1 / v, N = b * b + R * R, M = G * G + T * T;
        E = Q + (T * N - R * M) * H, B = y + (b * M - G * N) * H;
      }
      a[C] = E, a[C + 1] = B;
    }
    let r = i[i.length - 1], l, c = r * 4, g, h = t[2 * r], d, u = t[2 * r + 1];
    s.fill(0);
    for (let f = 0; f < i.length; ++f)
      r = i[f], l = c, g = h, d = u, c = r * 4, h = t[2 * r], u = t[2 * r + 1], s[l + 2] = s[c] = d - u, s[l + 3] = s[c + 1] = h - g;
  }
  render(t) {
    const i = t == null ? t = new WA() : void 0, { delaunay: { halfedges: n, inedges: s, hull: A }, circumcenters: o, vectors: a } = this;
    if (A.length <= 1) return null;
    for (let c = 0, g = n.length; c < g; ++c) {
      const h = n[c];
      if (h < c) continue;
      const d = Math.floor(c / 3) * 2, u = Math.floor(h / 3) * 2, f = o[d], C = o[d + 1], I = o[u], E = o[u + 1];
      this._renderSegment(f, C, I, E, t);
    }
    let r, l = A[A.length - 1];
    for (let c = 0; c < A.length; ++c) {
      r = l, l = A[c];
      const g = Math.floor(s[l] / 3) * 2, h = o[g], d = o[g + 1], u = r * 4, f = this._project(h, d, a[u + 2], a[u + 3]);
      f && this._renderSegment(h, d, f[0], f[1], t);
    }
    return i && i.value();
  }
  renderBounds(t) {
    const i = t == null ? t = new WA() : void 0;
    return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), i && i.value();
  }
  renderCell(t, i) {
    const n = i == null ? i = new WA() : void 0, s = this._clip(t);
    if (s === null || !s.length) return;
    i.moveTo(s[0], s[1]);
    let A = s.length;
    for (; s[0] === s[A - 2] && s[1] === s[A - 1] && A > 1; ) A -= 2;
    for (let o = 2; o < A; o += 2)
      (s[o] !== s[o - 2] || s[o + 1] !== s[o - 1]) && i.lineTo(s[o], s[o + 1]);
    return i.closePath(), n && n.value();
  }
  *cellPolygons() {
    const { delaunay: { points: t } } = this;
    for (let i = 0, n = t.length / 2; i < n; ++i) {
      const s = this.cellPolygon(i);
      s && (s.index = i, yield s);
    }
  }
  cellPolygon(t) {
    const i = new lI();
    return this.renderCell(t, i), i.value();
  }
  _renderSegment(t, i, n, s, A) {
    let o;
    const a = this._regioncode(t, i), r = this._regioncode(n, s);
    a === 0 && r === 0 ? (A.moveTo(t, i), A.lineTo(n, s)) : (o = this._clipSegment(t, i, n, s, a, r)) && (A.moveTo(o[0], o[1]), A.lineTo(o[2], o[3]));
  }
  contains(t, i, n) {
    return i = +i, i !== i || (n = +n, n !== n) ? !1 : this.delaunay._step(t, i, n) === t;
  }
  *neighbors(t) {
    const i = this._clip(t);
    if (i) for (const n of this.delaunay.neighbors(t)) {
      const s = this._clip(n);
      if (s) {
        t: for (let A = 0, o = i.length; A < o; A += 2)
          for (let a = 0, r = s.length; a < r; a += 2)
            if (i[A] === s[a] && i[A + 1] === s[a + 1] && i[(A + 2) % o] === s[(a + r - 2) % r] && i[(A + 3) % o] === s[(a + r - 1) % r]) {
              yield n;
              break t;
            }
      }
    }
  }
  _cell(t) {
    const { circumcenters: i, delaunay: { inedges: n, halfedges: s, triangles: A } } = this, o = n[t];
    if (o === -1) return null;
    const a = [];
    let r = o;
    do {
      const l = Math.floor(r / 3);
      if (a.push(i[l * 2], i[l * 2 + 1]), r = r % 3 === 2 ? r - 2 : r + 1, A[r] !== t) break;
      r = s[r];
    } while (r !== o && r !== -1);
    return a;
  }
  _clip(t) {
    if (t === 0 && this.delaunay.hull.length === 1)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const i = this._cell(t);
    if (i === null) return null;
    const { vectors: n } = this, s = t * 4;
    return this._simplify(n[s] || n[s + 1] ? this._clipInfinite(t, i, n[s], n[s + 1], n[s + 2], n[s + 3]) : this._clipFinite(t, i));
  }
  _clipFinite(t, i) {
    const n = i.length;
    let s = null, A, o, a = i[n - 2], r = i[n - 1], l, c = this._regioncode(a, r), g, h = 0;
    for (let d = 0; d < n; d += 2)
      if (A = a, o = r, a = i[d], r = i[d + 1], l = c, c = this._regioncode(a, r), l === 0 && c === 0)
        g = h, h = 0, s ? s.push(a, r) : s = [a, r];
      else {
        let u, f, C, I, E;
        if (l === 0) {
          if ((u = this._clipSegment(A, o, a, r, l, c)) === null) continue;
          [f, C, I, E] = u;
        } else {
          if ((u = this._clipSegment(a, r, A, o, c, l)) === null) continue;
          [I, E, f, C] = u, g = h, h = this._edgecode(f, C), g && h && this._edge(t, g, h, s, s.length), s ? s.push(f, C) : s = [f, C];
        }
        g = h, h = this._edgecode(I, E), g && h && this._edge(t, g, h, s, s.length), s ? s.push(I, E) : s = [I, E];
      }
    if (s)
      g = h, h = this._edgecode(s[0], s[1]), g && h && this._edge(t, g, h, s, s.length);
    else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return s;
  }
  _clipSegment(t, i, n, s, A, o) {
    const a = A < o;
    for (a && ([t, i, n, s, A, o] = [n, s, t, i, o, A]); ; ) {
      if (A === 0 && o === 0) return a ? [n, s, t, i] : [t, i, n, s];
      if (A & o) return null;
      let r, l, c = A || o;
      c & 8 ? (r = t + (n - t) * (this.ymax - i) / (s - i), l = this.ymax) : c & 4 ? (r = t + (n - t) * (this.ymin - i) / (s - i), l = this.ymin) : c & 2 ? (l = i + (s - i) * (this.xmax - t) / (n - t), r = this.xmax) : (l = i + (s - i) * (this.xmin - t) / (n - t), r = this.xmin), A ? (t = r, i = l, A = this._regioncode(t, i)) : (n = r, s = l, o = this._regioncode(n, s));
    }
  }
  _clipInfinite(t, i, n, s, A, o) {
    let a = Array.from(i), r;
    if ((r = this._project(a[0], a[1], n, s)) && a.unshift(r[0], r[1]), (r = this._project(a[a.length - 2], a[a.length - 1], A, o)) && a.push(r[0], r[1]), a = this._clipFinite(t, a))
      for (let l = 0, c = a.length, g, h = this._edgecode(a[c - 2], a[c - 1]); l < c; l += 2)
        g = h, h = this._edgecode(a[l], a[l + 1]), g && h && (l = this._edge(t, g, h, a, l), c = a.length);
    else this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (a = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return a;
  }
  _edge(t, i, n, s, A) {
    for (; i !== n; ) {
      let o, a;
      switch (i) {
        case 5:
          i = 4;
          continue;
        case 4:
          i = 6, o = this.xmax, a = this.ymin;
          break;
        case 6:
          i = 2;
          continue;
        case 2:
          i = 10, o = this.xmax, a = this.ymax;
          break;
        case 10:
          i = 8;
          continue;
        case 8:
          i = 9, o = this.xmin, a = this.ymax;
          break;
        case 9:
          i = 1;
          continue;
        case 1:
          i = 5, o = this.xmin, a = this.ymin;
          break;
      }
      (s[A] !== o || s[A + 1] !== a) && this.contains(t, o, a) && (s.splice(A, 0, o, a), A += 2);
    }
    return A;
  }
  _project(t, i, n, s) {
    let A = 1 / 0, o, a, r;
    if (s < 0) {
      if (i <= this.ymin) return null;
      (o = (this.ymin - i) / s) < A && (r = this.ymin, a = t + (A = o) * n);
    } else if (s > 0) {
      if (i >= this.ymax) return null;
      (o = (this.ymax - i) / s) < A && (r = this.ymax, a = t + (A = o) * n);
    }
    if (n > 0) {
      if (t >= this.xmax) return null;
      (o = (this.xmax - t) / n) < A && (a = this.xmax, r = i + (A = o) * s);
    } else if (n < 0) {
      if (t <= this.xmin) return null;
      (o = (this.xmin - t) / n) < A && (a = this.xmin, r = i + (A = o) * s);
    }
    return [a, r];
  }
  _edgecode(t, i) {
    return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (i === this.ymin ? 4 : i === this.ymax ? 8 : 0);
  }
  _regioncode(t, i) {
    return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (i < this.ymin ? 4 : i > this.ymax ? 8 : 0);
  }
  _simplify(t) {
    if (t && t.length > 4) {
      for (let i = 0; i < t.length; i += 2) {
        const n = (i + 2) % t.length, s = (i + 4) % t.length;
        (t[i] === t[n] && t[n] === t[s] || t[i + 1] === t[n + 1] && t[n + 1] === t[s + 1]) && (t.splice(n, 2), i -= 2);
      }
      t.length || (t = null);
    }
    return t;
  }
};
const LH = 2 * Math.PI, qo = Math.pow;
function UH(e) {
  return e[0];
}
function HH(e) {
  return e[1];
}
function OH(e) {
  const { triangles: t, coords: i } = e;
  for (let n = 0; n < t.length; n += 3) {
    const s = 2 * t[n], A = 2 * t[n + 1], o = 2 * t[n + 2];
    if ((i[o] - i[s]) * (i[A + 1] - i[s + 1]) - (i[A] - i[s]) * (i[o + 1] - i[s + 1]) > 1e-10) return !1;
  }
  return !0;
}
function PH(e, t, i) {
  return [e + Math.sin(e + t) * i, t + Math.cos(e - t) * i];
}
class Pd {
  static from(t, i = UH, n = HH, s) {
    return new Pd("length" in t ? YH(t, i, n, s) : Float64Array.from(JH(t, i, n, s)));
  }
  constructor(t) {
    this._delaunator = new Ih(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const t = this._delaunator, i = this.points;
    if (t.hull && t.hull.length > 2 && OH(t)) {
      this.collinear = Int32Array.from({ length: i.length / 2 }, (h, d) => d).sort((h, d) => i[2 * h] - i[2 * d] || i[2 * h + 1] - i[2 * d + 1]);
      const r = this.collinear[0], l = this.collinear[this.collinear.length - 1], c = [i[2 * r], i[2 * r + 1], i[2 * l], i[2 * l + 1]], g = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
      for (let h = 0, d = i.length / 2; h < d; ++h) {
        const u = PH(i[2 * h], i[2 * h + 1], g);
        i[2 * h] = u[0], i[2 * h + 1] = u[1];
      }
      this._delaunator = new Ih(i);
    } else
      delete this.collinear;
    const n = this.halfedges = this._delaunator.halfedges, s = this.hull = this._delaunator.hull, A = this.triangles = this._delaunator.triangles, o = this.inedges.fill(-1), a = this._hullIndex.fill(-1);
    for (let r = 0, l = n.length; r < l; ++r) {
      const c = A[r % 3 === 2 ? r - 2 : r + 1];
      (n[r] === -1 || o[c] === -1) && (o[c] = r);
    }
    for (let r = 0, l = s.length; r < l; ++r)
      a[s[r]] = r;
    s.length <= 2 && s.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = s[0], o[s[0]] = 1, s.length === 2 && (o[s[1]] = 0, this.triangles[1] = s[1], this.triangles[2] = s[1]));
  }
  voronoi(t) {
    return new GH(this, t);
  }
  *neighbors(t) {
    const { inedges: i, hull: n, _hullIndex: s, halfedges: A, triangles: o, collinear: a } = this;
    if (a) {
      const g = a.indexOf(t);
      g > 0 && (yield a[g - 1]), g < a.length - 1 && (yield a[g + 1]);
      return;
    }
    const r = i[t];
    if (r === -1) return;
    let l = r, c = -1;
    do {
      if (yield c = o[l], l = l % 3 === 2 ? l - 2 : l + 1, o[l] !== t) return;
      if (l = A[l], l === -1) {
        const g = n[(s[t] + 1) % n.length];
        g !== c && (yield g);
        return;
      }
    } while (l !== r);
  }
  find(t, i, n = 0) {
    if (t = +t, t !== t || (i = +i, i !== i)) return -1;
    const s = n;
    let A;
    for (; (A = this._step(n, t, i)) >= 0 && A !== n && A !== s; ) n = A;
    return A;
  }
  _step(t, i, n) {
    const { inedges: s, hull: A, _hullIndex: o, halfedges: a, triangles: r, points: l } = this;
    if (s[t] === -1 || !l.length) return (t + 1) % (l.length >> 1);
    let c = t, g = qo(i - l[t * 2], 2) + qo(n - l[t * 2 + 1], 2);
    const h = s[t];
    let d = h;
    do {
      let u = r[d];
      const f = qo(i - l[u * 2], 2) + qo(n - l[u * 2 + 1], 2);
      if (f < g && (g = f, c = u), d = d % 3 === 2 ? d - 2 : d + 1, r[d] !== t) break;
      if (d = a[d], d === -1) {
        if (d = A[(o[t] + 1) % A.length], d !== u && qo(i - l[d * 2], 2) + qo(n - l[d * 2 + 1], 2) < g)
          return d;
        break;
      }
    } while (d !== h);
    return c;
  }
  render(t) {
    const i = t == null ? t = new WA() : void 0, { points: n, halfedges: s, triangles: A } = this;
    for (let o = 0, a = s.length; o < a; ++o) {
      const r = s[o];
      if (r < o) continue;
      const l = A[o] * 2, c = A[r] * 2;
      t.moveTo(n[l], n[l + 1]), t.lineTo(n[c], n[c + 1]);
    }
    return this.renderHull(t), i && i.value();
  }
  renderPoints(t, i) {
    i === void 0 && (!t || typeof t.moveTo != "function") && (i = t, t = null), i = i == null ? 2 : +i;
    const n = t == null ? t = new WA() : void 0, { points: s } = this;
    for (let A = 0, o = s.length; A < o; A += 2) {
      const a = s[A], r = s[A + 1];
      t.moveTo(a + i, r), t.arc(a, r, i, 0, LH);
    }
    return n && n.value();
  }
  renderHull(t) {
    const i = t == null ? t = new WA() : void 0, { hull: n, points: s } = this, A = n[0] * 2, o = n.length;
    t.moveTo(s[A], s[A + 1]);
    for (let a = 1; a < o; ++a) {
      const r = 2 * n[a];
      t.lineTo(s[r], s[r + 1]);
    }
    return t.closePath(), i && i.value();
  }
  hullPolygon() {
    const t = new lI();
    return this.renderHull(t), t.value();
  }
  renderTriangle(t, i) {
    const n = i == null ? i = new WA() : void 0, { points: s, triangles: A } = this, o = A[t *= 3] * 2, a = A[t + 1] * 2, r = A[t + 2] * 2;
    return i.moveTo(s[o], s[o + 1]), i.lineTo(s[a], s[a + 1]), i.lineTo(s[r], s[r + 1]), i.closePath(), n && n.value();
  }
  *trianglePolygons() {
    const { triangles: t } = this;
    for (let i = 0, n = t.length / 3; i < n; ++i)
      yield this.trianglePolygon(i);
  }
  trianglePolygon(t) {
    const i = new lI();
    return this.renderTriangle(t, i), i.value();
  }
}
function YH(e, t, i, n) {
  const s = e.length, A = new Float64Array(s * 2);
  for (let o = 0; o < s; ++o) {
    const a = e[o];
    A[o * 2] = t.call(n, a, o, e), A[o * 2 + 1] = i.call(n, a, o, e);
  }
  return A;
}
function* JH(e, t, i, n) {
  let s = 0;
  for (const A of e)
    yield t.call(n, A, s, e), yield i.call(n, A, s, e), ++s;
}
function KH(e) {
  var t = 0, i = e.children, n = i && i.length;
  if (!n) t = 1;
  else for (; --n >= 0; ) t += i[n].value;
  e.value = t;
}
function VH() {
  return this.eachAfter(KH);
}
function WH(e, t) {
  let i = -1;
  for (const n of this)
    e.call(t, n, ++i, this);
  return this;
}
function qH(e, t) {
  for (var i = this, n = [i], s, A, o = -1; i = n.pop(); )
    if (e.call(t, i, ++o, this), s = i.children)
      for (A = s.length - 1; A >= 0; --A)
        n.push(s[A]);
  return this;
}
function jH(e, t) {
  for (var i = this, n = [i], s = [], A, o, a, r = -1; i = n.pop(); )
    if (s.push(i), A = i.children)
      for (o = 0, a = A.length; o < a; ++o)
        n.push(A[o]);
  for (; i = s.pop(); )
    e.call(t, i, ++r, this);
  return this;
}
function zH(e, t) {
  let i = -1;
  for (const n of this)
    if (e.call(t, n, ++i, this))
      return n;
}
function $H(e) {
  return this.eachAfter(function(t) {
    for (var i = +e(t.data) || 0, n = t.children, s = n && n.length; --s >= 0; ) i += n[s].value;
    t.value = i;
  });
}
function XH(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function ZH(e) {
  for (var t = this, i = t3(t, e), n = [t]; t !== i; )
    t = t.parent, n.push(t);
  for (var s = n.length; e !== i; )
    n.splice(s, 0, e), e = e.parent;
  return n;
}
function t3(e, t) {
  if (e === t) return e;
  var i = e.ancestors(), n = t.ancestors(), s = null;
  for (e = i.pop(), t = n.pop(); e === t; )
    s = e, e = i.pop(), t = n.pop();
  return s;
}
function e3() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function i3() {
  return Array.from(this);
}
function n3() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function s3() {
  var e = this, t = [];
  return e.each(function(i) {
    i !== e && t.push({ source: i.parent, target: i });
  }), t;
}
function* A3() {
  var e = this, t, i = [e], n, s, A;
  do
    for (t = i.reverse(), i = []; e = t.pop(); )
      if (yield e, n = e.children)
        for (s = 0, A = n.length; s < A; ++s)
          i.push(n[s]);
  while (i.length);
}
function un(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = r3)) : t === void 0 && (t = a3);
  for (var i = new Ch(e), n, s = [i], A, o, a, r; n = s.pop(); )
    if ((o = t(n.data)) && (r = (o = Array.from(o)).length))
      for (n.children = o, a = r - 1; a >= 0; --a)
        s.push(A = o[a] = new Ch(o[a])), A.parent = n, A.depth = n.depth + 1;
  return i.eachBefore(c3);
}
function o3() {
  return un(this).eachBefore(l3);
}
function a3(e) {
  return e.children;
}
function r3(e) {
  return Array.isArray(e) ? e[1] : null;
}
function l3(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function c3(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function Ch(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
Ch.prototype = un.prototype = {
  constructor: Ch,
  count: VH,
  each: WH,
  eachAfter: jH,
  eachBefore: qH,
  find: zH,
  sum: $H,
  sort: XH,
  path: ZH,
  ancestors: e3,
  descendants: i3,
  leaves: n3,
  links: s3,
  copy: o3,
  [Symbol.iterator]: A3
};
function nx(e) {
  for (var t = -1, i = e.length, n, s = e[i - 1], A = 0; ++t < i; )
    n = s, s = e[t], A += n[1] * s[0] - n[0] * s[1];
  return A / 2;
}
function cI(e) {
  for (var t = -1, i = e.length, n = 0, s = 0, A, o = e[i - 1], a, r = 0; ++t < i; )
    A = o, o = e[t], r += a = A[0] * o[1] - o[0] * A[1], n += (A[0] + o[0]) * a, s += (A[1] + o[1]) * a;
  return r *= 3, [n / r, s / r];
}
const g3 = "ascending", h3 = "descending", d3 = "none", u3 = "diverging", f3 = "none", I3 = "expand", C3 = "wiggle", E3 = (e, t, i) => (n, s) => {
  const A = n[0], o = s[0];
  return i(
    [n[0], e.get(A), t.get(A)],
    [o, e.get(o), t.get(o)]
  );
};
let B3 = class jr {
  /**
   * Creates an instance of Selection.
   * @param {Array<DataObject>} data Array of DataObjects.
   * @memberof Selection
   */
  constructor(t) {
    this._dataObjects = /* @__PURE__ */ new Map(), this._updateData = /* @__PURE__ */ new Map(), this._enterData = /* @__PURE__ */ new Map(), this._exitData = /* @__PURE__ */ new Map(), this._idGetter = t;
  }
  /**
   * This method is used to supply seed data to a selection.
   *
   * @param {Array} newData Seed data to create the enter selection.
   * @param {Functon | undefined } idGetter This function is used to uniqely identify a data entry.
   * @return {Selection} Modified selection.
   * @memberof Selection
   */
  data(t) {
    const i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), A = /* @__PURE__ */ new Map(), o = this._updateData, a = this._idGetter;
    t.forEach((...g) => {
      const h = a ? a(...g) : g[1];
      s.has(h) ? A.push(h, g[0]) : s.set(h, g[0]);
    });
    let r, l = s.entries();
    for (; r = l.next().value; )
      o.has(r[0]) ? o.set(r[0], r[1]) : i.set(r[0], r[1]);
    for (l = o.entries(); r = l.next().value; )
      s.has(r[0]) || n.set(r[0], r[1]);
    for (l = A.entries(); r = l.next().value; )
      n.set(r[0], r[1]);
    const c = new jr(this._idGetter);
    return c._updateData = o, c._dataObjects = this._dataObjects, c._enterData = i, c._exitData = n, c;
  }
  /**
   * Applies the supplied callback to each data element
   * and returns a new selection.
   *
   * @param {Function} callback Callback to execute on each item.
   * @return {Selection} New selection with data created using callback.
   * @memberof Selection
   */
  append(t) {
    let i;
    const n = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), A = wt(this._mode, "update"), a = this[`_${A}Data`].entries();
    for (; i = a.next().value; )
      n.set(i[0], t(i[1])), s.set(i[0], i[1]);
    const r = new jr(this._idGetter);
    return r._updateData = s, r._dataObjects = n, r;
  }
  /**
   * This method returns an enter selection that
   * allows or update operations.
   *
   * @return {Selection} Instance of enter selection.
   * @memberof Selection
   */
  enter() {
    return this._mode = "enter", this;
  }
  /**
   * Returns a selection with exit data.
   *
   * @return {Selection} Instance of selection.
   * @memberof Selection
   */
  exit() {
    return this._mode = "exit", this;
  }
  /**
   * This method merges the data of one selection with another.
   *
   * @param {Selection} selection Instance of selection.
   * @return {Selection} Modified selection.
   * @memberof Selection
   */
  merge(t) {
    const i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    let s, A;
    for (A = this._updateData.entries(); s = A.next().value; )
      this._exitData.has(s[0]) || (n.set(s[0], s[1]), i.set(s[0], this._dataObjects.get(s[0])));
    for (A = t._updateData.entries(); s = A.next().value; )
      n.has(s[0]) || t._exitData.has(s[0]) || (n.set(s[0], s[1]), i.set(s[0], t._dataObjects.get(s[0])));
    const o = new jr(this._idGetter);
    return o._updateData = n, o._dataObjects = i, o;
  }
  each(t) {
    let i;
    const n = this._dataObjects.entries();
    for (; i = n.next().value; )
      t(i[1], this._updateData.get(i[0]), i[0]);
  }
  map(t) {
    const i = /* @__PURE__ */ new Map();
    let n;
    const s = this._dataObjects.entries();
    for (; n = s.next().value; )
      i.set(n[0], t(n[1], this._updateData.get(n[0]), n[0]));
    const A = new jr(this._idGetter);
    return A._updateData = this._updateData, A._dataObjects = i, A;
  }
  remove() {
    const t = wt(this._mode, "update");
    return this[`_${t}Data`].clear(), this;
  }
  sort(t) {
    const i = this._updateData, n = this._dataObjects, s = E3(n, i, t);
    return this._updateData = new Map([...i.entries()].sort(s)), this._dataObjects = new Map([...n.entries()].sort(s)), this;
  }
  /**
   *  Gets the object bound to a class
   *
   * @return {Object} current data set bound to the class
   * @memberof Selection
   */
  getObjects() {
    let t;
    const i = [], n = this._dataObjects, s = wt(this._mode, "update"), o = this[`_${s}Data`].entries();
    for (; t = o.next().value; )
      n.has(t[0]) && i.push(n.get(t[0]));
    return i;
  }
};
function sx(e) {
  return new B3(e);
}
const { STRING: Ax, FUNCTION: ox } = Jw, { DISCRETE: Fg, CONTINUOUS: rf } = ft, ax = window.HTMLElement;
function ke(e) {
  if (typeof e == "object") {
    if (e === null)
      return !1;
    if (Object.prototype.toString.call(e) === "[object Object]")
      return (e.constructor.toString().match(/^function (.*)\(\)/m) || [])[1] === "Object";
  }
  return !1;
}
function Zt() {
  return `id-${(/* @__PURE__ */ new Date()).getTime()}-${Math.round(Math.random() * 1e4)}`;
}
function lE(e) {
  const t = {};
  let i;
  for (const n in e)
    ({}).hasOwnProperty.call(e, n) && (i = e[n], t[n] = ke(i) ? lE(i) : i);
  return t;
}
function rx(e, t) {
  const i = [];
  return e.forEach((n) => {
    n in t || i.push(n);
  }), i;
}
const lx = {
  typeObj: (e, t) => {
    if (typeof t != "object")
      return Error("Argument type object expected");
    const i = rx(e, t);
    return i.length ? Error(`Missing keys from parameter ${i.join(", ")}`) : t;
  },
  // NOTE: not used
  /* istanbul ignore next */
  htmlElem: (e) => e instanceof ax ? e : Error("HTMLElement required")
};
function is(e, t) {
  let i = -1 / 0;
  return e.forEach((n) => {
    i = Math.max(t && typeof n == "object" ? n[t] : n, i);
  }), i;
}
function Hs(e, t) {
  let i = 1 / 0;
  return e.forEach((n) => {
    i = Math.min(t && typeof n == "object" ? n[t] : n, i);
  }), i;
}
function m3(e, t, i) {
  let n;
  const s = [];
  switch (e = e[0] instanceof Array ? e : [e], i === "categorical" && (i = Ct.DIMENSION), i) {
    case Ct.DIMENSION:
      n = [].concat(
        ...e.map(
          (A) => A.map((o) => o[t[0]]).filter((o) => o !== void 0)
        )
      );
      break;
    default:
      for (let A = 0, o = e.length; A < o; A++) {
        const a = e[A], [r, l] = t, c = a.filter((h) => !isNaN(h[r])), g = a.filter((h) => !isNaN(h[l]));
        if (c.length || g.length) {
          const h = Hs(c, r), d = Hs(g, l), u = is(c, r), f = is(g, l);
          s.push([
            Math.min(h, d),
            Math.max(u, f)
          ]);
        }
      }
      n = s.length ? [
        Math.min(...s.map((A) => A[0])),
        Math.max(...s.map((A) => A[1]))
      ] : [];
      break;
  }
  return n;
}
function rc(e) {
  return e[0] === e[1] && (e[0] = +e[0] > 0 ? 0 : e[0], e[1] = +e[1] > 0 ? e[1] : 0), e;
}
function we(e, t) {
  if (e = e.filter((i) => i && i.length), e.length)
    if (t === Fg && e) {
      const i = [], n = /* @__PURE__ */ new Set();
      return e.flat().forEach((s) => {
        K.isInvalid(s) ? s instanceof qt && !n.has(s.value()) && (i.push(s), n.add(s.value())) : i.push(s);
      }), [...new Set(i)];
    } else
      return [
        Math.min(...e.map((i) => i[0])),
        Math.max(...e.map((i) => i[i.length - 1]))
      ];
  return [];
}
function rn(e) {
  let t = [0, 0];
  return e = e.filter((i) => i && i.length), e.length && (t = [
    Math.max(...e.map((i) => i[0])),
    Math.max(...e.map((i) => i[1]))
  ]), t;
}
function p3(e, ...t) {
  return t.forEach((i) => {
    e[i] || (e[i] = {}), e = e[i];
  }), e;
}
function Eh(e) {
  const t = {};
  return e.forEach((n) => {
    Object.keys(n).forEach((s) => {
      const A = n[s];
      t[s] || (t[s] = {
        [Fg]: [],
        [rf]: []
      }), [Fg, rf].forEach((o) => {
        const a = A[o] && A[o].splitDomains;
        if (a) {
          t[s][o].splitDomains || (t[s][o].splitDomains = {});
          for (const r in a)
            t[s][o].splitDomains[r] || (t[s][o].splitDomains[r] = []), t[s][o].splitDomains[r].push(A[o].splitDomains[r]);
        } else A[o] && t[s][o].push(
          A[o]
        );
      });
    });
  }), Object.keys(t).reduce(
    (n, s) => ([Fg, rf].forEach((A) => {
      const o = t[s][A], a = t[s][A].splitDomains;
      if (a) {
        const r = p3(
          n,
          s,
          A,
          "splitDomains"
        );
        for (const l in a)
          r[l] = we(
            a[l],
            A
          );
      } else o.length && (n[s] = Object.assign({}, n[s], {
        [A]: we(o, A)
      }));
    }), n),
    {}
  );
}
const cx = {
  circle: PD,
  cross: QU,
  diamond: wU,
  square: bU,
  star: _U,
  wye: FU,
  triangle: MU
}, lc = {
  cubic: WD,
  bounce: ZU,
  linear: PU,
  elastic: eH,
  back: tH,
  poly: YU,
  circle: JU
};
function gx(e, t, i) {
  let n, s = e[0];
  const A = e.length;
  let o = i === "max" ? -1 / 0 : 1 / 0, a;
  for (let r = 0; r < A; r++)
    s = e[r], a = s[t], (i === "min" ? a < o : a > o) && (o = a, n = s);
  return n;
}
function Q3(e, t) {
  return gx(e, t, "min");
}
function gI(e, t) {
  return gx(e, t, "max");
}
function y3(e, t) {
  const i = [];
  if (t <= e[0])
    return e[0];
  if (t >= e[e.length - 1])
    return e[e.length - 1];
  let n = 0, s = e.length - 1;
  for (; s - n > 1; ) {
    const A = Math.floor((n + s) / 2);
    if (e[A] === t)
      return e[A];
    e[A] < t ? n = A : s = A;
  }
  return i.push(e[n], e[s]), i;
}
function hx(e, t, i) {
  let n = 0, A = e.length - 1, o, a, r;
  for (; n < A; )
    o = Math.floor((n + A) / 2), a = Math.abs(e[o] - t), r = Math.abs(e[o + 1] - t), r <= a ? n = o + 1 : A = o;
  if (!i)
    return A;
  const l = e[A];
  return l === t ? A : l > t ? A === 0 ? A : i === "left" ? A - 1 : A : A === e.length - 1 || i === "left" ? A : A + 1;
}
function hI(e, t) {
  const i = e.filter((n) => typeof n == "number");
  return y3(i, t);
}
function dx() {
  return window;
}
const w3 = requestAnimationFrame, D3 = cancelAnimationFrame;
function x3(e) {
  return e = e.toLowerCase(), e.replace(
    /\w\S*/g,
    (t) => t.charAt(0).toUpperCase() + t.substr(1)
  );
}
function Bh(e, t = (i) => i) {
  const i = e.reduce((n, s) => (n[t(s)] = s, n), {});
  return Object.values(i);
}
function S3(e, t) {
  let i, n;
  if (t !== void 0 ? n = Bh(e.map((s) => s[t])) : n = Bh(e), n.length > 1) {
    i = Math.abs(n[1] - n[0]);
    for (let s = 2, A = n.length; s < A; s++)
      i = Math.min(i, Math.abs(n[s] - n[s - 1]));
  } else
    i = n[0];
  return i;
}
function ms(e, t, i) {
  return e = e.replace(/^\.*/, ""), [`${i}-${e}`, `${i}-${e}-${t}`];
}
function wt(...e) {
  return e.find(
    (t) => !(typeof t > "u" || typeof t == "object" && !t)
  );
}
function ux(e) {
  const t = [], i = {}, n = Object.keys(e), s = (A) => {
    if (t.length === n.length)
      return !0;
    i[A] = !0;
    const o = e[A];
    for (let a = 0; a < o.length; a++) {
      const r = o[a];
      i[r] || s(r);
    }
    return t.push(A), !1;
  };
  for (let A = 0; A < n.length && !s(n[A]); A++)
    ;
  return t;
}
function cE(e, t) {
  for (const i in e)
    Object.hasOwnProperty.call(e, i) && t(i, e);
}
class gE {
  /**
   * Initialize the voronoi with the data given.
   * @param {Array.<Object>} data Array of points.
   */
  _voronoi;
  _voronoiFn;
  constructor(t) {
    this._voronoi = BH().x((i) => i.x).y((i) => i.y), this.data(t);
  }
  data(t) {
    return t && (this._voronoiFn = this._voronoi(t)), this;
  }
  find(t, i, n) {
    return this._voronoiFn.find(t, i, n);
  }
}
function Z(e, ...t) {
  if (e == null)
    return e;
  let i = e;
  for (let n = 0, s = t.length; n < s && (i = i[t[n]], i != null); n++)
    ;
  return i;
}
function zr(e) {
  const t = e.toString().match(/(\d+)(px)*/g);
  return t ? parseInt(t[0], 10) : null;
}
function ve(e, t) {
  Object.entries(t).forEach((i) => {
    const n = i[0], {
      sanitization: s,
      preset: A,
      onset: o,
      typeChecker: a,
      defaultValue: r
    } = i[1], l = e.constructor.prototype;
    Object.hasOwnProperty.call(l, n) || (r && (e[`_${n}`] = r), e[n] = (...c) => {
      if (c.length) {
        let g = c[0];
        return s && (g = s(e, c[0], e[`_${n}`])), A && A(e, g), a && !a(g) ? e[`_${n}`] : (e[`_${n}`] = g, o && o(e, g), e);
      }
      return e[`_${n}`];
    });
  });
}
function fx(e, t) {
  return e.reduce(
    (i, n) => (i += typeof n == "object" ? n[t] : n, i),
    0
  );
}
function hE(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let i = e.length; i >= 0; i--)
    if (e[i] !== t[i])
      return !1;
  return !0;
}
const eo = (e) => (t, i) => e === "Array" ? t ? hE(t, i) : !1 : e === "Object" ? Object.is(t, i) : t === i, _3 = (e) => e instanceof ax, yt = {
  INTERFACE_IMPL: "Method not implemented"
};
function et(e, ...t) {
  for (const i of t)
    if (i)
      for (const n in i)
        ke(e[n]) && ke(i[n]) ? et(e[n], i[n]) : i[n] instanceof Object && i[n].constructor === Object ? (e[n] = {}, et(e[n], i[n])) : e[n] = i[n];
  return e;
}
function Ix(...e) {
  let t = e[0];
  for (let i = 1; i < e.length; i++)
    t = et(t, e[i]);
  return t;
}
function Cx(e, t, i, n) {
  let s = e || sx(n);
  s = s.data(i);
  const o = s.enter().append(t).merge(s), a = s.exit();
  return a.getObjects().forEach((r) => r.remove()), a.remove(), o;
}
function b3(e, t) {
  const i = function(A, o, a) {
    return A + (o - A) * a;
  }, n = [], s = (e.length - 1) / (t - 1);
  n[0] = e[0];
  for (let A = 1; A < t - 1; A++) {
    const o = A * s, a = parseFloat(Math.floor(o).toFixed()), r = parseFloat(Math.ceil(o).toFixed()), l = o - a;
    n[A] = i(e[a], e[r], l);
  }
  return n[t - 1] = e[e.length - 1], n;
}
const M3 = (e) => {
  setTimeout(() => {
    e();
  }, 0);
};
function qA(e) {
  return e * Math.PI / 180;
}
const N3 = () => {
}, Ex = () => Nd, Yd = () => ln, Bx = () => wl, F3 = () => Xv;
function R3() {
  return {
    color: IA,
    rgb: Ql,
    hsl: CA
  };
}
const Jd = () => Zv;
function lf(e, t, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
}
function mx(e, t, i, n) {
  n || (n = 1);
  let s, A, o;
  if (t === 0)
    s = A = o = i;
  else {
    const a = i < 0.5 ? i * (1 + t) : i + t - i * t, r = 2 * i - a;
    s = lf(r, a, e + 1 / 3), A = lf(r, a, e), o = lf(r, a, e - 1 / 3);
  }
  return [s * 255, A * 255, o * 255, n];
}
function ya(e, t, i, n) {
  e = +e, t = +t, i = +i, n = +n, e /= 255, t /= 255, i /= 255;
  const s = Math.max(e, t, i), A = Math.min(e, t, i);
  let o, a;
  const r = (s + A) / 2;
  if (s === A)
    o = a = 0;
  else {
    const l = s - A;
    switch (a = r > 0.5 ? l / (2 - s - A) : l / (s + A), s) {
      case e:
        o = (t - i) / l + (t < i ? 6 : 0);
        break;
      case t:
        o = (i - e) / l + 2;
        break;
      case i:
        o = (e - t) / l + 4;
        break;
    }
    o /= 6;
  }
  return [o, a, r, n];
}
function px(e, t, i, n) {
  let s, A, o;
  const a = Math.floor(e * 6), r = e * 6 - a, l = i * (1 - t), c = i * (1 - r * t), g = i * (1 - (1 - r) * t);
  switch (a % 6) {
    case 0:
      s = i, A = g, o = l;
      break;
    case 1:
      s = c, A = i, o = l;
      break;
    case 2:
      s = l, A = i, o = g;
      break;
    case 3:
      s = l, A = c, o = i;
      break;
    case 4:
      s = g, A = l, o = i;
      break;
    case 5:
      s = i, A = l, o = c;
      break;
  }
  return [s * 255, A * 255, o * 255, n];
}
function Qx(e) {
  const t = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  e = e.replace(t, (n, s, A, o) => s + s + A + A + o + o);
  const i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
  return i ? ya(
    parseInt(i[1], 16),
    parseInt(i[2], 16),
    parseInt(i[3], 16)
  ) : "";
}
function k3(e, t, i, n, s, A, o) {
  n || (n = 1), s || (s = 255), A || (A = 255), o || (o = 255);
  const a = Math.round((1 - n) * s + n * e), r = Math.round((1 - n) * A + n * t), l = Math.round((1 - n) * o + n * i);
  return `rgb(${a},${r},${l})`;
}
function v3(e, t, i, n) {
  const [s, A, o, a] = mx(e, t, i, n);
  return k3(s, A, o, a);
}
function $r(e) {
  const t = /rgb\((\d{1,3}), (\d{1,3}), (\d{1,3})\)/, i = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g, n = /rgba?\(((25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?)\s*,\s*?){2}(25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?)\s*,?\s*([01]\.?\d*?)?\)/, s = /^hsla\(([\d.]+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/, A = /^#([0-9a-f]{3}){1,2}$/i;
  return t.test(e) || n.test(e) ? "rgb" : i.test(e) || s.test(e) ? "hsl" : A.test(e) ? "hex" : e;
}
function T3(e) {
  return e.reduce(
    (t, i, n) => (t[i] = n, t),
    {}
  );
}
function yx(e) {
  return !isNaN(e) && e !== -1 / 0 && e !== 1 / 0;
}
function wx(e) {
  const t = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "/": "&#x2F;"
  }, i = /[&<>"'/]/g;
  return `${e}`.replace(i, (n) => t[n]);
}
function G3(e) {
  return e[0].map((t, i) => e.map((n) => n[i]));
}
function Bn(e) {
  return Array.isArray(e) ? e : [e];
}
function Dx(e, t, i) {
  if (!e)
    return !1;
  typeof i != "boolean" && (i = !1);
  const n = e.prototype;
  return n instanceof t ? i = !0 : i = Dx(n, t, i), i;
}
function cc(e) {
  return RU().type(cx[e]);
}
const L3 = {
  [d3]: hh,
  [g3]: VD,
  [h3]: OU
}, U3 = {
  [u3]: LU,
  [f3]: xl,
  [I3]: GU,
  [C3]: UU
}, H3 = (e) => TU().keys(e.keys).offset(U3[e.offset]).order(L3[e.order])(e.data);
function xx(e) {
  const t = iD();
  return e.keys.forEach(
    (i) => t.key((n) => n[i])
  ), t.entries(e.data);
}
function O3(e, t) {
  return e.filter((i) => t.indexOf(i) < 0);
}
const gc = {
  curveLinear: gh,
  curveStepAfter: Jp,
  curveStepBefore: Yp,
  curveStep: Pp,
  curveCatmullRom: Op,
  stepAfter: Jp,
  catmullRom: Op,
  step: Pp,
  stepBefore: Yp,
  linear: gh
}, fn = {
  axisLeft: aU,
  axisRight: AU,
  axisTop: sU,
  axisBottom: oU,
  line: OD,
  area: EU,
  pie: pU,
  arc: CU,
  nest: iD
}, dE = {
  band: LC
}, Kd = {
  path: ix
};
function Vd(e) {
  e = e.sort((i, n) => i - n);
  let t = e[1] - e[0];
  for (let i = 2; i < e.length; i++)
    t = Math.min(t, e[i] - e[i - 1]);
  return t;
}
const Sx = {
  millisecond: "%A, %b %e, %H:%M:%S.%L",
  second: "%A, %b %e, %H:%M:%S",
  minute: "%A, %b %e, %H:%M",
  hour: "%A, %b %e, %H:%M",
  day: "%A, %b %e, %Y",
  month: "%B %Y",
  year: "%Y"
}, P3 = {
  millisecond: "%b %e, %H:%M:%S.%L",
  second: "%b %e, %H:%M:%S",
  minute: "%b %e, %H:%M",
  hour: "%b %e, %H:%M",
  day: "%b %e, %Y",
  month: "%B %Y",
  year: "%Y"
}, cf = [
  ["millisecond", "second", "minute", "hour", "day", "month", "year"],
  [1, 1e3, 6e4, 36e5, 864e5, 2592e6, 31536e6]
];
function Y3(e) {
  e < 0 && (e = cf[1][6]);
  const t = hx(cf[1], e);
  return cf[0][t];
}
function pA(e, t, i) {
  const n = Y3(t), s = i?.useShortFormatter ? P3 : Sx;
  return To(e, s[n], i);
}
function J3(e, t) {
  const i = +K.getActualValue(e), n = K.isInvalid(e) ? i : i + t;
  return [i, n];
}
function uE(e, t) {
  const i = [], [n, s] = e[0] > e[1] ? [e[1], e[0]] : e;
  if (isNaN(n))
    return isNaN(s) ? [] : [s];
  if (isNaN(s))
    return [n];
  for (const A of t)
    Xe(A) || A <= s && A >= n && i.push(A);
  return (i.length === 0 || n < i[0]) && i.unshift(n), i[i.length - 1] < s && i.push(s), i;
}
const K3 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(e) {
  setTimeout(e, 16);
};
function fE(e) {
  return (t) => K.isInvalid(t) && t in e ? e[t] : t;
}
function hc(e, t) {
  const i = {};
  if (e instanceof K) {
    const s = [
      ...e.getDerivations().reverse(),
      ...e.getAncestorDerivations().reverse()
    ].find(
      (a) => a.op === ne.GROUPBY
    ), A = wt(Z(s, "criteria"), {}), o = e.getMeasures();
    t = t.length ? t : o, t.forEach((a) => {
      if (A[a])
        i[a] = A[a];
      else {
        const r = e.getField(a);
        r && (i[a] = r.schema().defAggFn);
      }
    });
  }
  return i;
}
function dc(e, t) {
  return e.getField(t).displayName();
}
function dI(e, t, i, n = 1, s = "All") {
  return K.isInvalid(e) && K.isInvalid(t) ? n = 0 : K.isInvalid(e) ? t === s ? n = i ? -1 : 1 : n = -1 : K.isInvalid(t) ? e === s ? n = i ? 1 : -1 : n = 1 : e === s ? n = i ? 1 : -1 : t === s ? n = i ? -1 : 1 : n = String(e).localeCompare(String(t)), n;
}
function V3(e, t, i = 1) {
  if (K.isInvalid(e) && K.isInvalid(t))
    i = 0;
  else if (K.isInvalid(e))
    i = -1;
  else if (K.isInvalid(t))
    i = 1;
  else {
    const n = parseFloat(`${e}`), s = parseFloat(`${t}`);
    i = n === s ? 0 : n > s ? 1 : -1;
  }
  return i;
}
function uI(e, t) {
  return e.some((i) => K.isInvalid(i) && K.isInvalid(t) ? !0 : Array.isArray(i) && Array.isArray(t) ? hE(i, t) : i == t);
}
const tQ = {
  [Kw]: (e, t, i = "All") => dI(e, t, !0, 1, i),
  [Vw]: (e, t, i = "All") => dI(t, e, !1, -1, i)
};
function IE(e, t, i, n = "All") {
  const s = typeof e;
  return s === ox ? e(t, i, n) : s === Ax && tQ[e] ? tQ[e](t, i, n) : null;
}
function eQ(e, t, i = !0) {
  let n = 1;
  return K.isInvalid(e) && K.isInvalid(t) ? n = 0 : K.isInvalid(e) ? isNaN(Number(t)) ? n = i ? -1 : 1 : n = -1 : K.isInvalid(t) ? isNaN(Number(e)) ? n = i ? 1 : -1 : n = 1 : (e = Number(e), t = Number(t), isNaN(e) && isNaN(t) ? n = 0 : isNaN(e) ? n = i ? 1 : -1 : isNaN(t) ? n = i ? -1 : 1 : n = e - t), n;
}
const iQ = {
  [Kw]: (e, t) => eQ(e, t, !0),
  [Vw]: (e, t) => eQ(t, e, !1)
};
function CE(e, t, i) {
  const n = typeof e;
  return n === ox ? e(t, i) : n === Ax && iQ[e] ? iQ[e](t, i) : null;
}
function Wd(e, t, i = [(n) => n, (n) => n]) {
  const [n, s] = i, A = new Set(t.map((o) => s(o)));
  return e.filter((o) => A.has(n(o)));
}
function W3(e, t, i = [(n) => n, (n) => n]) {
  const [n, s] = i, A = new Set(t.map((o) => s(o)));
  return e.filter((o) => !A.has(n(o)));
}
function EE(e, t) {
  return e.reduce(
    (i, n, s) => (t(n, s, e) ? i[0].push(n) : i[1].push(n), i),
    [[], []]
  );
}
const ci = (e) => ({
  with: (...t) => t.reduce((i, n) => n(i), e || Object)
});
function rl(e) {
  const t = Object.assign({}, e), i = {
    register: (n, s) => {
      if (ke(n))
        for (const A in n)
          t[A] = n[A];
      else {
        const A = s || n.formalName();
        t[A] = n;
      }
      return i;
    },
    get: () => t
  };
  return i;
}
function q3(e, t) {
  for (let i = 0; i < e.length; i++)
    if (t.has(e[i]))
      return !0;
  return !1;
}
function rr(e, t, i = !1, n = [], s = !0) {
  const A = [Math.min(...e), Math.max(...e)];
  let o = VC().domain(A);
  if (s && (o = o.nice()), n && n.length > 2 || i) {
    const l = o.domain(), c = (l[1] - l[0]) / (i ? t : t - 1), g = Qa(l[0], l[1], c);
    return g.push(l[1]), g;
  }
  if (t < 3)
    return A;
  let a = null, r = null;
  return a = fn.axisBottom().scale(o), r = a.scale().ticks(t), Math.max(...r) < A[1] && r.push(A[1]), Math.min(...r) > A[0] && r.unshift(A[0]), r;
}
function _x({ h: e, s: t, l: i, a: n }, { h: s = 0, s: A = 0, l: o = 0, a }, r, l) {
  const c = e + "," + t + "," + i + "," + n + "," + s + "," + A + "," + o + "," + a, g = l.get(c);
  if (g)
    return g;
  const h = parseFloat(`${a || n}`), d = e + s;
  let u = t + A, f = i + o, C = h + 1;
  r || (C = h - 1), u = +(u * 100).toFixed(1), f = +(f * 100).toFixed(1);
  const I = `hsla(${Number.isNaN(d) ? 0 : d},${Number.isNaN(u) ? 0 : u}%,${Number.isNaN(f) ? 0 : f}%,${Number.isNaN(C) ? 0 : C})`;
  return l.set(c, I), I;
}
function bx(e, t) {
  const { x: i, y: n, r: s } = e, { x: A, y: o } = t;
  return Math.sqrt((i - A) ** 2 + (n - o) ** 2) <= s;
}
function lr(e, t, i = "eq", n = "and") {
  const s = t.getFieldNames(), A = e[0].reduce(
    (o, a, r) => (s.includes(a) && (o[a] = e[1][r]), o),
    {}
  );
  return Object.keys(A).length ? {
    conditions: Object.keys(A).map((o) => ({
      field: o,
      value: K.isInvalid(A[o]) ? null : A[o],
      operator: i
    })),
    operator: n
  } : {
    field: s[0],
    value: [],
    operator: "in"
  };
}
function j3(e, t) {
  return e.reduce(
    (i, n, s) => {
      const A = t ? n[t] : n;
      return i[A] = s, i;
    },
    {}
  );
}
function _l(e, t) {
  function i(n) {
    return typeof n == "object" && n != null;
  }
  if (e === t)
    return !0;
  if (i(e) && i(t)) {
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (const n in e)
      if (!_l(e[n], t[n]))
        return !1;
    return !0;
  }
  return !1;
}
function z3(e) {
  return e == null ? e : typeof e == "object" ? e.field : e;
}
function Rg(e, t) {
  e = e || [], t = t || {};
  const i = {};
  return e.forEach((n) => {
    t.hasOwnProperty(n) && (i[n] = t[n]);
  }), i;
}
function Mx(e, t) {
  e = e || [], t = t || {};
  const i = {};
  return Object.keys(t).forEach((n) => {
    e.includes(n) || (i[n] = t[n]);
  }), i;
}
function fI(e, t) {
  return e - t;
}
function $3(e, t) {
  return t - e;
}
const X3 = /* @__PURE__ */ function() {
  const e = {}, t = {};
  return {
    startMeasure: (i) => {
      t[i] = performance.now();
    },
    endMeasure: (i) => {
      i in e || (e[i] = 0), e[i] += performance.now() - t[i];
    },
    getTimings: () => e
  };
}();
function qd(e, t) {
  return new Set([...e].filter((i) => !t.has(i)));
}
function BE(e, t) {
  return new Set([...e].filter((i) => t.has(i)));
}
function Va(e, t) {
  return e >= t[0] && e <= t[1];
}
function Z3(...e) {
  return () => {
    const t = e.length;
    for (let i = 0; i < t; i++)
      e[i].call(void 0);
  };
}
function t8(e, t, i) {
  const n = e.length;
  return t < n || (e.length = t, e.fill(i, n)), e;
}
function bl(e, t) {
  const i = [];
  let n, s;
  return e.forEach(({ type: A, domains: o, fieldSubType: a }) => {
    const r = o.map((c) => c.primary.domain), l = o.map((c) => c.secondary.domain);
    a === ot.BINNED && t ? (n = we(
      [n || [], we(r, A)],
      A
    ), s = we(
      [
        s || [],
        we(l, A)
      ],
      A
    )) : (n = we(r, A), s = we(l, A)), i.push([n, s]);
  }), i;
}
function Nx(e) {
  return e == null;
}
function Zi(e) {
  return K.isInvalid(e) || e === null || e === void 0 ? e : String(e);
}
function To(e, t, i) {
  let n;
  i || (i = {});
  const s = parseInt(e.toString());
  return isNaN(s) ? e.toString() : (typeof t == "function" ? n = t(e, i) : typeof t == "string" ? n = K.isInvalid(e) ? e : K.DateTimeFormatter.formatAs(Number(e), t, i) : n = String(e), K.isInvalid(n) ? n.value() : String(n));
}
function Rs(e, t) {
  return typeof e == "object" && e !== null && t in e;
}
function Xe(e) {
  return K.isInvalid(e) || e === null || e === void 0 || Number.isNaN(e);
}
function Ml(e, t) {
  const i = Xe(e), n = Xe(t);
  return i && n ? !0 : e === t;
}
function e8(e, t, i, n, s, A, o, a) {
  const r = (i - e) * (a - A) - (o - s) * (n - t);
  if (r === 0)
    return !1;
  const l = ((a - A) * (o - e) + (s - o) * (a - t)) / r, c = ((t - n) * (o - e) + (i - e) * (a - t)) / r;
  return 0 < l && l < 1 && 0 < c && c < 1;
}
function Fx(e, t) {
  return e.empty() ? null : e.style(t);
}
function i8(e, t, i = { lineDirection: jm }) {
  let n = 0;
  const s = t.x, A = t.y, o = i.lineDirection === jm ? {
    x1: 0,
    y1: A,
    x2: s,
    y2: A
  } : {
    x1: s,
    y1: 0,
    x2: s,
    y2: A
  };
  for (let a = 0; a < e.length - 1; a++) {
    const r = e[a].x, l = e[a].y, c = e[a + 1].x, g = e[a + 1].y;
    e8(
      o.x1,
      o.y1,
      o.x2,
      o.y2,
      r,
      l,
      c,
      g
    ) && (n += 1);
  }
  return n % 2 !== 0;
}
function mh(e, t) {
  return new Array(e).fill(t).join("");
}
const ph = " , ";
function Co(e) {
  return e.map((t) => Number.isInteger(t) ? t : t.toFixed(2)).join(ph);
}
function cr(e) {
  return !!(e && e.varType() === RC);
}
function Rx(e, t) {
  const i = (e[1] - e[0]) / (t - 1), n = Qa(e[0], e[1], i);
  return n?.length && parseFloat((e[1] - n[n.length - 1]).toFixed(5)) < parseFloat(i.toFixed(5)) && n.pop(), n.push(e[1]), n;
}
const Nn = (e, t, i = {
  preserveNullColumns: !1,
  dmSchema: null
}) => {
  if (e = e.filter((c) => c && c.getRowsCount()), !e.length)
    return null;
  const n = /* @__PURE__ */ new Map();
  if (i.dmSchema)
    i.dmSchema.forEach((c) => {
      c.name !== pt.ROW_ID && n.set(c.name, c);
    });
  else
    for (let c = 0; c < e.length; c++)
      e[c].getSchema().forEach((d) => {
        d.name !== pt.ROW_ID && n.set(d.name, d);
      });
  const s = [];
  for (let c = 0; c < e.length; c++) {
    const g = e[c], h = g.getRowsCount();
    for (let d = 0; d < h; d++) {
      const u = [];
      n.forEach((f, C) => {
        const I = f.subtype, E = g.getValueAtIndex(C, d);
        Xe(E) ? u.push(null) : I === ot.CATEGORICAL ? u.push(`${E}`) : u.push(E);
      }), s.push(u);
    }
  }
  const A = s.length ? Ye(s) : [[]], o = [...n.values()], a = [], r = [];
  if (A.forEach((c, g) => {
    const h = c.every((d) => d === null);
    (i.preserveNullColumns || !h) && (a.push(o[g]), r.push(c));
  }), t && r.length) {
    const c = r[0].length;
    for (const g in t.data)
      a.find((h) => h.name === g) || (r.push(
        new Array(c).fill(0).map(() => t.data[g])
      ), a.push(t.schema.find(({ name: h }) => h === g)));
  }
  return new K(
    {
      data: r.length ? r : [[]],
      schema: a
    },
    {
      creatorIdentifier: e[0]?.getCreatorIdentifier(),
      ...e[0]?._model._config,
      ...i
    }
  );
}, us = (e) => {
  if (K.isInvalid(e))
    return e;
  const t = parseInt(e.toString());
  return isNaN(t) ? e.toString() : t;
}, nQ = (e, t) => !(e === ft.CONTINUOUS && (t === ot.BINNED || t === ot.TEMPORAL)), kx = (e, t, i) => {
  const { field: n, type: s, subtype: A } = e;
  if (t.colFacets[n] === t.rowTotalString || t.rowFacets[n] === t.columnTotalString)
    return !0;
  const o = i.y.findIndex((r) => `${r}` === n);
  if (t.isRowCollapsed && o !== -1) {
    const r = i.y[o].as();
    return nQ(r, A);
  }
  const a = i.x.findIndex((r) => `${r}` === n);
  if (t.isColCollapsed && a !== -1) {
    const r = i.x[a].as();
    return nQ(r, A);
  }
  return (t.isCollapsed || t.totals) && s === ft.CONTINUOUS && A === ot.CONTINUOUS;
}, vx = (e, t) => {
  let i = 0;
  return [jw, zw, $w].forEach((n) => {
    e.totalsAxis[n] && t && i++;
  }), i > 0;
}, uc = (e, t, i) => {
  if (!t.hyperlinkInfo)
    return;
  const {
    hyperlinkInfo: { rel: n, target: s, url: A, styles: o, classNames: a }
  } = t, { defaultClassName: r } = i;
  e.attr("href", A), e.attr("target", s), e.attr("rel", n), e.classed(`${r} ${a}`, !0);
  for (const l in o)
    e.style(l, o[l]);
}, jd = ({
  yField: e,
  xField: t,
  yFieldAs: i,
  xFieldAs: n,
  dm: s,
  transformConf: A
}) => {
  if (t === null)
    return !1;
  if (e === null)
    return !0;
  if (A.type === rv || A.type === lv)
    return A.value?.field === e;
  const o = s.getField(e) && s.getField(e).type(), a = s.getField(t) && s.getField(t).type(), r = s.getField(t) && s.getField(t).subtype(), l = s.getField(e) && s.getField(e).subtype();
  return n === ft.DISCRETE && i === ft.DISCRETE ? !0 : i === ft.CONTINUOUS && o === Ct.MEASURE || n === ft.CONTINUOUS && (a === Ct.DIMENSION || r === ot.TEMPORAL) && i === ot.CONTINUOUS && l == ot.CONTINUOUS || n === ft.DISCRETE && i === ft.CONTINUOUS;
};
function zd(e, t, i, n) {
  const { totalString: s, subTotalsPosition: A } = n || {
    totalString: "All",
    subTotalsPosition: "end"
  }, { name: o } = e, a = i.getField(o), r = a.type(), l = a.subtype();
  let c = [];
  if (t.type !== Ki.NESTED_ORDER) {
    const g = r === "dimension" && l === sh ? a.getAllBins() : a.uniques();
    c = kg(
      g,
      o,
      t,
      { totalString: s },
      i,
      null
    );
  }
  return (g, h) => {
    const d = g.includes(s) ? g.map((C) => C.toString()) : g, u = g.includes(s) ? c.map((C) => C.toString()) : c;
    let f;
    return r === "measure" ? f = kg(
      d,
      o,
      t,
      { totalString: s },
      i,
      u,
      h
    ) : r === "dimension" ? u.length === 0 || d.length <= u.length * 0.5 ? f = kg(
      d,
      o,
      t,
      { totalString: s },
      i,
      u,
      h
    ) : f = Qh(
      d,
      u
    ) : f = d, A === "start" && f[f.length - 1] === s && (f.pop(), f.unshift(s)), f;
  };
}
function kg(e, t, i, n, s, A, o = []) {
  const a = s.getField(t), r = a.subtype(), {
    type: l,
    direction: c,
    field: { name: g, aggregation: h },
    nested: {
      filters: d,
      field: { name: u, aggregation: f }
    },
    values: C
  } = i;
  if (l === Ki.NATURAL_ORDER) {
    const I = r === ot.CONTINUOUS || r === ot.TEMPORAL || r === ot.CATEGORICAL && a.isNaturallyNumeric() || r === ot.BINNED;
    return Tx(e, {
      isNumericalData: I,
      sortDirection: c,
      totalString: n.totalString
    });
  } else {
    if (l === Ki.ALPHABETICAL_ORDER)
      return Gx(e, {
        fieldSubtype: r,
        sortDirection: c,
        temporalFieldFormat: r === "temporal" ? a.schema().format : null,
        totalString: n.totalString
      });
    if (l === Ki.FIELD_ORDER)
      if (g) {
        if (!A) {
          const I = h ? [{ field: g, aggn: h }] : [];
          A = s.project([t, g]).groupBy([t], I).sort([[g, c]]).getField(t).uniques();
        }
        return Qh(e, A);
      } else
        return [...e];
    else {
      if (l === Ki.CUSTOM_VALUES_ORDER)
        return Lx(e, {
          fieldSubtype: r,
          customValues: C || []
        });
      if (l === Ki.NESTED_ORDER) {
        const I = [...d, ...o], E = I.map(({ field: m }) => m);
        let B;
        if (I.length > 0 && (B = lr(
          [E, I.map(({ value: m }) => m)],
          s
        )), u) {
          const m = s.project([
            ...E,
            t,
            u
          ]), Q = (B == null ? m : m.select(B)).groupBy(
            [...E, t],
            f ? [{ field: u, aggn: f }] : []
          ).sort([[u, c]]).getField(t).uniques();
          return Qh(e, Q);
        } else
          return [...e];
      } else
        return [...e];
    }
  }
}
function Qh(e, t) {
  const i = e.find((A) => K.isInvalid(A)), n = new Set(e), s = [];
  for (let A = 0; A < t.length; A++) {
    const o = t[A];
    if (!K.isInvalid(o) && n.has(o) ? (s.push(o), n.delete(o)) : K.isInvalid(o) && i && (s.push(i), n.delete(i)), s.length === e.length)
      break;
  }
  return n.size && s.push(...n), s;
}
function Tx(e, t) {
  const { isNumericalData: i, sortDirection: n } = t, s = [...e];
  return i ? s.sort(
    (A, o) => CE(
      n,
      A,
      o
    )
  ) : s.sort(
    (A, o) => IE(
      n,
      A,
      o,
      t.totalString
    )
  );
}
function Gx(e, t) {
  const { fieldSubtype: i, sortDirection: n, temporalFieldFormat: s } = t, A = [...e];
  if (i === ot.TEMPORAL) {
    const o = A.reduce((a, r) => (K.isInvalid(r) ? a.set(r, r) : a.set(r, To(r, s)), a), /* @__PURE__ */ new Map());
    return A.sort((a, r) => {
      if (K.isInvalid(a) && K.isInvalid(r))
        return 0;
      if (!K.isInvalid(a) && K.isInvalid(r))
        return n === Ts.ASC ? 1 : -1;
      if (K.isInvalid(a) && !K.isInvalid(r))
        return n === Ts.ASC ? -1 : 1;
      {
        const l = o.get(a), c = o.get(r);
        return n === Ts.ASC ? l.localeCompare(c) : c.localeCompare(l);
      }
    });
  } else
    return A.sort(
      (o, a) => IE(
        n,
        o,
        a,
        t.totalString
      )
    );
}
function Lx(e, t) {
  const { fieldSubtype: i, customValues: n } = t, s = [...e], A = n.reduce((o, a, r) => {
    let l;
    return a === null ? l = a : i === ot.CONTINUOUS || i === ot.TEMPORAL ? l = Number(a) : i === ot.CATEGORICAL ? l = String(a) : l = a, o.set(l, r), o;
  }, /* @__PURE__ */ new Map());
  return s.sort((o, a) => {
    K.isInvalid(o) && (o = null), K.isInvalid(a) && (a = null);
    const r = A.get(o), l = A.get(a);
    return r === void 0 && l === void 0 ? 0 : r === void 0 && l !== void 0 ? 1 : r !== void 0 && l === void 0 ? -1 : r - l;
  });
}
function Go(e, t) {
  const i = et(
    {},
    t,
    e || {}
  );
  return ["type", "direction", "field"].forEach((n) => {
    i[n] || (i[n] = t[n]);
  }), i;
}
var Ux = /* @__PURE__ */ ((e) => (e.DISCRETE = "discrete", e.CONTINOUS = "continuous", e))(Ux || {}), Hx = /* @__PURE__ */ ((e) => (e.SUM = "sum", e.AVG = "avg", e.MIN = "min", e.MAX = "max", e.FIRST = "first", e.LAST = "last", e.COUNT = "count", e.STD = "std", e))(Hx || {});
function Gi(e, t) {
  return t ? e.children[0].children[0].data[e.children[0].children[0].data.length - 2] : e.children[0].data[e.children[0].data.length - 1];
}
const Nl = (e) => e.value === al, ll = (e) => {
  const t = e.config().priority === 2;
  return (i) => {
    const n = i.ancestors().slice(0, -1).reverse().map((s) => {
      if (s.height <= (t ? 2 : 1)) {
        const A = Gi(
          i,
          i.height > 1
        ).source();
        return typeof A == "object" && A !== null ? {
          field: A.config().field,
          sourceType: A.config().metaInf.sourceType
        } : e.getNodeInfo(s, "muze-row-header");
      } else
        return e.getNodeInfo(s, "muze-corner");
    }).filter((s) => s != null);
    return n.length > 0 && Nl(n[n.length - 1]) ? n : n.filter((s) => !Nl(s));
  };
}, mE = (e, t) => {
  const i = K.isInvalid(e) ? null : e, n = K.isInvalid(t) ? null : t;
  return i === n;
}, n8 = (e, t, i) => typeof e.value < "u" && typeof t.value < "u" ? e.field === t.field && mE(e.value, t.value) && e.sourceType === t.sourceType : e.sourceType != null ? i ? e.field === t.field : e.field === t.field && e.sourceType === t.sourceType : !1, s8 = (e, t) => e.field === t.field && mE(e.value, t.value) && e.sourceType === t.sourceType, ca = (e, t, { strict: i, isCornerMatrix: n } = { strict: !1, isCornerMatrix: !1 }) => e.every((s, A) => {
  const o = t[A] == null ? {} : t[A];
  return i ? s8(s, o) : n8(s, o, n);
}), yh = (e, t) => typeof e.find(
  (i) => mE(i, t)
) < "u";
var II = "http://www.w3.org/1999/xhtml";
const sQ = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: II,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function $d(e) {
  var t = e += "", i = t.indexOf(":");
  return i >= 0 && (t = e.slice(0, i)) !== "xmlns" && (e = e.slice(i + 1)), sQ.hasOwnProperty(t) ? { space: sQ[t], local: e } : e;
}
function A8(e) {
  return function() {
    var t = this.ownerDocument, i = this.namespaceURI;
    return i === II && t.documentElement.namespaceURI === II ? t.createElement(e) : t.createElementNS(i, e);
  };
}
function o8(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function Ox(e) {
  var t = $d(e);
  return (t.local ? o8 : A8)(t);
}
function a8() {
}
function pE(e) {
  return e == null ? a8 : function() {
    return this.querySelector(e);
  };
}
function r8(e) {
  typeof e != "function" && (e = pE(e));
  for (var t = this._groups, i = t.length, n = new Array(i), s = 0; s < i; ++s)
    for (var A = t[s], o = A.length, a = n[s] = new Array(o), r, l, c = 0; c < o; ++c)
      (r = A[c]) && (l = e.call(r, r.__data__, c, A)) && ("__data__" in r && (l.__data__ = r.__data__), a[c] = l);
  return new pn(n, this._parents);
}
function l8() {
  return [];
}
function Px(e) {
  return e == null ? l8 : function() {
    return this.querySelectorAll(e);
  };
}
function c8(e) {
  typeof e != "function" && (e = Px(e));
  for (var t = this._groups, i = t.length, n = [], s = [], A = 0; A < i; ++A)
    for (var o = t[A], a = o.length, r, l = 0; l < a; ++l)
      (r = o[l]) && (n.push(e.call(r, r.__data__, l, o)), s.push(r));
  return new pn(n, s);
}
function Yx(e) {
  return function() {
    return this.matches(e);
  };
}
function g8(e) {
  typeof e != "function" && (e = Yx(e));
  for (var t = this._groups, i = t.length, n = new Array(i), s = 0; s < i; ++s)
    for (var A = t[s], o = A.length, a = n[s] = [], r, l = 0; l < o; ++l)
      (r = A[l]) && e.call(r, r.__data__, l, A) && a.push(r);
  return new pn(n, this._parents);
}
function Jx(e) {
  return new Array(e.length);
}
function h8() {
  return new pn(this._enter || this._groups.map(Jx), this._parents);
}
function wh(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
wh.prototype = {
  constructor: wh,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function d8(e) {
  return function() {
    return e;
  };
}
var AQ = "$";
function u8(e, t, i, n, s, A) {
  for (var o = 0, a, r = t.length, l = A.length; o < l; ++o)
    (a = t[o]) ? (a.__data__ = A[o], n[o] = a) : i[o] = new wh(e, A[o]);
  for (; o < r; ++o)
    (a = t[o]) && (s[o] = a);
}
function f8(e, t, i, n, s, A, o) {
  var a, r, l = {}, c = t.length, g = A.length, h = new Array(c), d;
  for (a = 0; a < c; ++a)
    (r = t[a]) && (h[a] = d = AQ + o.call(r, r.__data__, a, t), d in l ? s[a] = r : l[d] = r);
  for (a = 0; a < g; ++a)
    d = AQ + o.call(e, A[a], a, A), (r = l[d]) ? (n[a] = r, r.__data__ = A[a], l[d] = null) : i[a] = new wh(e, A[a]);
  for (a = 0; a < c; ++a)
    (r = t[a]) && l[h[a]] === r && (s[a] = r);
}
function I8(e, t) {
  if (!e)
    return d = new Array(this.size()), l = -1, this.each(function(w) {
      d[++l] = w;
    }), d;
  var i = t ? f8 : u8, n = this._parents, s = this._groups;
  typeof e != "function" && (e = d8(e));
  for (var A = s.length, o = new Array(A), a = new Array(A), r = new Array(A), l = 0; l < A; ++l) {
    var c = n[l], g = s[l], h = g.length, d = e.call(c, c && c.__data__, l, n), u = d.length, f = a[l] = new Array(u), C = o[l] = new Array(u), I = r[l] = new Array(h);
    i(c, g, f, C, I, d, t);
    for (var E = 0, B = 0, m, p; E < u; ++E)
      if (m = f[E]) {
        for (E >= B && (B = E + 1); !(p = C[B]) && ++B < u; ) ;
        m._next = p || null;
      }
  }
  return o = new pn(o, n), o._enter = a, o._exit = r, o;
}
function C8() {
  return new pn(this._exit || this._groups.map(Jx), this._parents);
}
function E8(e, t, i) {
  var n = this.enter(), s = this, A = this.exit();
  return n = typeof e == "function" ? e(n) : n.append(e + ""), t != null && (s = t(s)), i == null ? A.remove() : i(A), n && s ? n.merge(s).order() : s;
}
function B8(e) {
  for (var t = this._groups, i = e._groups, n = t.length, s = i.length, A = Math.min(n, s), o = new Array(n), a = 0; a < A; ++a)
    for (var r = t[a], l = i[a], c = r.length, g = o[a] = new Array(c), h, d = 0; d < c; ++d)
      (h = r[d] || l[d]) && (g[d] = h);
  for (; a < n; ++a)
    o[a] = t[a];
  return new pn(o, this._parents);
}
function m8() {
  for (var e = this._groups, t = -1, i = e.length; ++t < i; )
    for (var n = e[t], s = n.length - 1, A = n[s], o; --s >= 0; )
      (o = n[s]) && (A && o.compareDocumentPosition(A) ^ 4 && A.parentNode.insertBefore(o, A), A = o);
  return this;
}
function p8(e) {
  e || (e = Q8);
  function t(g, h) {
    return g && h ? e(g.__data__, h.__data__) : !g - !h;
  }
  for (var i = this._groups, n = i.length, s = new Array(n), A = 0; A < n; ++A) {
    for (var o = i[A], a = o.length, r = s[A] = new Array(a), l, c = 0; c < a; ++c)
      (l = o[c]) && (r[c] = l);
    r.sort(t);
  }
  return new pn(s, this._parents).order();
}
function Q8(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function y8() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function w8() {
  var e = new Array(this.size()), t = -1;
  return this.each(function() {
    e[++t] = this;
  }), e;
}
function D8() {
  for (var e = this._groups, t = 0, i = e.length; t < i; ++t)
    for (var n = e[t], s = 0, A = n.length; s < A; ++s) {
      var o = n[s];
      if (o) return o;
    }
  return null;
}
function x8() {
  var e = 0;
  return this.each(function() {
    ++e;
  }), e;
}
function S8() {
  return !this.node();
}
function _8(e) {
  for (var t = this._groups, i = 0, n = t.length; i < n; ++i)
    for (var s = t[i], A = 0, o = s.length, a; A < o; ++A)
      (a = s[A]) && e.call(a, a.__data__, A, s);
  return this;
}
function b8(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function M8(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function N8(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function F8(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function R8(e, t) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.removeAttribute(e) : this.setAttribute(e, i);
  };
}
function k8(e, t) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, i);
  };
}
function v8(e, t) {
  var i = $d(e);
  if (arguments.length < 2) {
    var n = this.node();
    return i.local ? n.getAttributeNS(i.space, i.local) : n.getAttribute(i);
  }
  return this.each((t == null ? i.local ? M8 : b8 : typeof t == "function" ? i.local ? k8 : R8 : i.local ? F8 : N8)(i, t));
}
function Kx(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function T8(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function G8(e, t, i) {
  return function() {
    this.style.setProperty(e, t, i);
  };
}
function L8(e, t, i) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.style.removeProperty(e) : this.style.setProperty(e, n, i);
  };
}
function U8(e, t, i) {
  return arguments.length > 1 ? this.each((t == null ? T8 : typeof t == "function" ? L8 : G8)(e, t, i ?? "")) : Wa(this.node(), e);
}
function Wa(e, t) {
  return e.style.getPropertyValue(t) || Kx(e).getComputedStyle(e, null).getPropertyValue(t);
}
function H8(e) {
  return function() {
    delete this[e];
  };
}
function O8(e, t) {
  return function() {
    this[e] = t;
  };
}
function P8(e, t) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? delete this[e] : this[e] = i;
  };
}
function Y8(e, t) {
  return arguments.length > 1 ? this.each((t == null ? H8 : typeof t == "function" ? P8 : O8)(e, t)) : this.node()[e];
}
function Vx(e) {
  return e.trim().split(/^|\s+/);
}
function QE(e) {
  return e.classList || new Wx(e);
}
function Wx(e) {
  this._node = e, this._names = Vx(e.getAttribute("class") || "");
}
Wx.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function qx(e, t) {
  for (var i = QE(e), n = -1, s = t.length; ++n < s; ) i.add(t[n]);
}
function jx(e, t) {
  for (var i = QE(e), n = -1, s = t.length; ++n < s; ) i.remove(t[n]);
}
function J8(e) {
  return function() {
    qx(this, e);
  };
}
function K8(e) {
  return function() {
    jx(this, e);
  };
}
function V8(e, t) {
  return function() {
    (t.apply(this, arguments) ? qx : jx)(this, e);
  };
}
function W8(e, t) {
  var i = Vx(e + "");
  if (arguments.length < 2) {
    for (var n = QE(this.node()), s = -1, A = i.length; ++s < A; ) if (!n.contains(i[s])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? V8 : t ? J8 : K8)(i, t));
}
function q8() {
  this.textContent = "";
}
function j8(e) {
  return function() {
    this.textContent = e;
  };
}
function z8(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function $8(e) {
  return arguments.length ? this.each(e == null ? q8 : (typeof e == "function" ? z8 : j8)(e)) : this.node().textContent;
}
function X8() {
  this.innerHTML = "";
}
function Z8(e) {
  return function() {
    this.innerHTML = e;
  };
}
function tO(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function eO(e) {
  return arguments.length ? this.each(e == null ? X8 : (typeof e == "function" ? tO : Z8)(e)) : this.node().innerHTML;
}
function iO() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function nO() {
  return this.each(iO);
}
function sO() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function AO() {
  return this.each(sO);
}
function oO(e) {
  var t = typeof e == "function" ? e : Ox(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function aO() {
  return null;
}
function rO(e, t) {
  var i = typeof e == "function" ? e : Ox(e), n = t == null ? aO : typeof t == "function" ? t : pE(t);
  return this.select(function() {
    return this.insertBefore(i.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function lO() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function cO() {
  return this.each(lO);
}
function gO() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function hO() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function dO(e) {
  return this.select(e ? hO : gO);
}
function uO(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
var zx = {}, ie = null;
if (typeof document < "u") {
  var fO = document.documentElement;
  "onmouseenter" in fO || (zx = { mouseenter: "mouseover", mouseleave: "mouseout" });
}
function IO(e, t, i) {
  return e = $x(e, t, i), function(n) {
    var s = n.relatedTarget;
    (!s || s !== this && !(s.compareDocumentPosition(this) & 8)) && e.call(this, n);
  };
}
function $x(e, t, i) {
  return function(n) {
    var s = ie;
    ie = n;
    try {
      e.call(this, this.__data__, t, i);
    } finally {
      ie = s;
    }
  };
}
function CO(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var i = "", n = t.indexOf(".");
    return n >= 0 && (i = t.slice(n + 1), t = t.slice(0, n)), { type: t, name: i };
  });
}
function EO(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var i = 0, n = -1, s = t.length, A; i < s; ++i)
        A = t[i], (!e.type || A.type === e.type) && A.name === e.name ? this.removeEventListener(A.type, A.listener, A.capture) : t[++n] = A;
      ++n ? t.length = n : delete this.__on;
    }
  };
}
function BO(e, t, i) {
  var n = zx.hasOwnProperty(e.type) ? IO : $x;
  return function(s, A, o) {
    var a = this.__on, r, l = n(t, A, o);
    if (a) {
      for (var c = 0, g = a.length; c < g; ++c)
        if ((r = a[c]).type === e.type && r.name === e.name) {
          this.removeEventListener(r.type, r.listener, r.capture), this.addEventListener(r.type, r.listener = l, r.capture = i), r.value = t;
          return;
        }
    }
    this.addEventListener(e.type, l, i), r = { type: e.type, name: e.name, value: t, listener: l, capture: i }, a ? a.push(r) : this.__on = [r];
  };
}
function mO(e, t, i) {
  var n = CO(e + ""), s, A = n.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var r = 0, l = a.length, c; r < l; ++r)
        for (s = 0, c = a[r]; s < A; ++s)
          if ((o = n[s]).type === c.type && o.name === c.name)
            return c.value;
    }
    return;
  }
  for (a = t ? BO : EO, i == null && (i = !1), s = 0; s < A; ++s) this.each(a(n[s], t, i));
  return this;
}
function oQ(e, t, i, n) {
  var s = ie;
  e.sourceEvent = ie, ie = e;
  try {
    return t.apply(i, n);
  } finally {
    ie = s;
  }
}
function Xx(e, t, i) {
  var n = Kx(e), s = n.CustomEvent;
  typeof s == "function" ? s = new s(t, i) : (s = n.document.createEvent("Event"), i ? (s.initEvent(t, i.bubbles, i.cancelable), s.detail = i.detail) : s.initEvent(t, !1, !1)), e.dispatchEvent(s);
}
function pO(e, t) {
  return function() {
    return Xx(this, e, t);
  };
}
function QO(e, t) {
  return function() {
    return Xx(this, e, t.apply(this, arguments));
  };
}
function yO(e, t) {
  return this.each((typeof t == "function" ? QO : pO)(e, t));
}
var Zx = [null];
function pn(e, t) {
  this._groups = e, this._parents = t;
}
function gr() {
  return new pn([[document.documentElement]], Zx);
}
pn.prototype = gr.prototype = {
  constructor: pn,
  select: r8,
  selectAll: c8,
  filter: g8,
  data: I8,
  enter: h8,
  exit: C8,
  join: E8,
  merge: B8,
  order: m8,
  sort: p8,
  call: y8,
  nodes: w8,
  node: D8,
  size: x8,
  empty: S8,
  each: _8,
  attr: v8,
  style: U8,
  property: Y8,
  classed: W8,
  text: $8,
  html: eO,
  raise: nO,
  lower: AO,
  append: oO,
  insert: rO,
  remove: cO,
  clone: dO,
  datum: uO,
  on: mO,
  dispatch: yO
};
function Ri(e) {
  return typeof e == "string" ? new pn([[document.querySelector(e)]], [document.documentElement]) : new pn([[e]], Zx);
}
function tS() {
  for (var e = ie, t; t = e.sourceEvent; ) e = t;
  return e;
}
function yE(e, t) {
  var i = e.ownerSVGElement || e;
  if (i.createSVGPoint) {
    var n = i.createSVGPoint();
    return n.x = t.clientX, n.y = t.clientY, n = n.matrixTransform(e.getScreenCTM().inverse()), [n.x, n.y];
  }
  var s = e.getBoundingClientRect();
  return [t.clientX - s.left - e.clientLeft, t.clientY - s.top - e.clientTop];
}
function wE(e) {
  var t = tS();
  return t.changedTouches && (t = t.changedTouches[0]), yE(e, t);
}
function wO(e, t, i) {
  arguments.length < 3 && (i = t, t = tS().changedTouches);
  for (var n = 0, s = t ? t.length : 0, A; n < s; ++n)
    if ((A = t[n]).identifier === i)
      return yE(e, A);
  return null;
}
var DO = { value: function() {
} };
function DE() {
  for (var e = 0, t = arguments.length, i = {}, n; e < t; ++e) {
    if (!(n = arguments[e] + "") || n in i || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
    i[n] = [];
  }
  return new vg(i);
}
function vg(e) {
  this._ = e;
}
function xO(e, t) {
  return e.trim().split(/^|\s+/).map(function(i) {
    var n = "", s = i.indexOf(".");
    if (s >= 0 && (n = i.slice(s + 1), i = i.slice(0, s)), i && !t.hasOwnProperty(i)) throw new Error("unknown type: " + i);
    return { type: i, name: n };
  });
}
vg.prototype = DE.prototype = {
  constructor: vg,
  on: function(e, t) {
    var i = this._, n = xO(e + "", i), s, A = -1, o = n.length;
    if (arguments.length < 2) {
      for (; ++A < o; ) if ((s = (e = n[A]).type) && (s = SO(i[s], e.name))) return s;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++A < o; )
      if (s = (e = n[A]).type) i[s] = aQ(i[s], e.name, t);
      else if (t == null) for (s in i) i[s] = aQ(i[s], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var i in t) e[i] = t[i].slice();
    return new vg(e);
  },
  call: function(e, t) {
    if ((s = arguments.length - 2) > 0) for (var i = new Array(s), n = 0, s, A; n < s; ++n) i[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (A = this._[e], n = 0, s = A.length; n < s; ++n) A[n].value.apply(t, i);
  },
  apply: function(e, t, i) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var n = this._[e], s = 0, A = n.length; s < A; ++s) n[s].value.apply(t, i);
  }
};
function SO(e, t) {
  for (var i = 0, n = e.length, s; i < n; ++i)
    if ((s = e[i]).name === t)
      return s.value;
}
function aQ(e, t, i) {
  for (var n = 0, s = e.length; n < s; ++n)
    if (e[n].name === t) {
      e[n] = DO, e = e.slice(0, n).concat(e.slice(n + 1));
      break;
    }
  return i != null && e.push({ name: t, value: i }), e;
}
function gf() {
  ie.stopImmediatePropagation();
}
function wa() {
  ie.preventDefault(), ie.stopImmediatePropagation();
}
function _O(e) {
  var t = e.document.documentElement, i = Ri(e).on("dragstart.drag", wa, !0);
  "onselectstart" in t ? i.on("selectstart.drag", wa, !0) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function bO(e, t) {
  var i = e.document.documentElement, n = Ri(e).on("dragstart.drag", null);
  t && (n.on("click.drag", wa, !0), setTimeout(function() {
    n.on("click.drag", null);
  }, 0)), "onselectstart" in i ? n.on("selectstart.drag", null) : (i.style.MozUserSelect = i.__noselect, delete i.__noselect);
}
function $c(e) {
  return function() {
    return e;
  };
}
function CI(e, t, i, n, s, A, o, a, r, l) {
  this.target = e, this.type = t, this.subject = i, this.identifier = n, this.active = s, this.x = A, this.y = o, this.dx = a, this.dy = r, this._ = l;
}
CI.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function MO() {
  return !ie.ctrlKey && !ie.button;
}
function NO() {
  return this.parentNode;
}
function FO(e) {
  return e ?? { x: ie.x, y: ie.y };
}
function RO() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function kO() {
  var e = MO, t = NO, i = FO, n = RO, s = {}, A = DE("start", "drag", "end"), o = 0, a, r, l, c, g = 0;
  function h(m) {
    m.on("mousedown.drag", d).filter(n).on("touchstart.drag", C).on("touchmove.drag", I).on("touchend.drag touchcancel.drag", E).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function d() {
    if (!(c || !e.apply(this, arguments))) {
      var m = B("mouse", t.apply(this, arguments), wE, this, arguments);
      m && (Ri(ie.view).on("mousemove.drag", u, !0).on("mouseup.drag", f, !0), _O(ie.view), gf(), l = !1, a = ie.clientX, r = ie.clientY, m("start"));
    }
  }
  function u() {
    if (wa(), !l) {
      var m = ie.clientX - a, p = ie.clientY - r;
      l = m * m + p * p > g;
    }
    s.mouse("drag");
  }
  function f() {
    Ri(ie.view).on("mousemove.drag mouseup.drag", null), bO(ie.view, l), wa(), s.mouse("end");
  }
  function C() {
    if (e.apply(this, arguments)) {
      var m = ie.changedTouches, p = t.apply(this, arguments), w = m.length, Q, y;
      for (Q = 0; Q < w; ++Q)
        (y = B(m[Q].identifier, p, wO, this, arguments)) && (gf(), y("start"));
    }
  }
  function I() {
    var m = ie.changedTouches, p = m.length, w, Q;
    for (w = 0; w < p; ++w)
      (Q = s[m[w].identifier]) && (wa(), Q("drag"));
  }
  function E() {
    var m = ie.changedTouches, p = m.length, w, Q;
    for (c && clearTimeout(c), c = setTimeout(function() {
      c = null;
    }, 500), w = 0; w < p; ++w)
      (Q = s[m[w].identifier]) && (gf(), Q("end"));
  }
  function B(m, p, w, Q, y) {
    var D = w(p, m), _, x, S, b = A.copy();
    if (oQ(new CI(h, "beforestart", _, m, o, D[0], D[1], 0, 0, b), function() {
      return (ie.subject = _ = i.apply(Q, y)) == null ? !1 : (x = _.x - D[0] || 0, S = _.y - D[1] || 0, !0);
    }))
      return function R(G) {
        var T = D, v;
        switch (G) {
          case "start":
            s[m] = R, v = o++;
            break;
          case "end":
            delete s[m], --o;
          case "drag":
            D = w(p, m), v = o;
            break;
        }
        oQ(new CI(h, G, _, m, v, D[0] + x, D[1] + S, D[0] - T[0], D[1] - T[1], b), b.apply, b, [G, Q, y]);
      };
  }
  return h.filter = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : $c(!!m), h) : e;
  }, h.container = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : $c(m), h) : t;
  }, h.subject = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : $c(m), h) : i;
  }, h.touchable = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : $c(!!m), h) : n;
  }, h.on = function() {
    var m = A.on.apply(A, arguments);
    return m === A ? h : m;
  }, h.clickDistance = function(m) {
    return arguments.length ? (g = (m = +m) * m, h) : Math.sqrt(g);
  }, h;
}
var qa = 0, Xr = 0, vr = 0, eS = 1e3, Dh, Zr, xh = 0, Eo = 0, Xd = 0, Fl = typeof performance == "object" && performance.now ? performance : Date, iS = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Zd() {
  return Eo || (iS(vO), Eo = Fl.now() + Xd);
}
function vO() {
  Eo = 0;
}
function Sh() {
  this._call = this._time = this._next = null;
}
Sh.prototype = nS.prototype = {
  constructor: Sh,
  restart: function(e, t, i) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    i = (i == null ? Zd() : +i) + (t == null ? 0 : +t), !this._next && Zr !== this && (Zr ? Zr._next = this : Dh = this, Zr = this), this._call = e, this._time = i, EI();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, EI());
  }
};
function nS(e, t, i) {
  var n = new Sh();
  return n.restart(e, t, i), n;
}
function TO() {
  Zd(), ++qa;
  for (var e = Dh, t; e; )
    (t = Eo - e._time) >= 0 && e._call.call(null, t), e = e._next;
  --qa;
}
function rQ() {
  Eo = (xh = Fl.now()) + Xd, qa = Xr = 0;
  try {
    TO();
  } finally {
    qa = 0, LO(), Eo = 0;
  }
}
function GO() {
  var e = Fl.now(), t = e - xh;
  t > eS && (Xd -= t, xh = e);
}
function LO() {
  for (var e, t = Dh, i, n = 1 / 0; t; )
    t._call ? (n > t._time && (n = t._time), e = t, t = t._next) : (i = t._next, t._next = null, t = e ? e._next = i : Dh = i);
  Zr = e, EI(n);
}
function EI(e) {
  if (!qa) {
    Xr && (Xr = clearTimeout(Xr));
    var t = e - Eo;
    t > 24 ? (e < 1 / 0 && (Xr = setTimeout(rQ, e - Fl.now() - Xd)), vr && (vr = clearInterval(vr))) : (vr || (xh = Fl.now(), vr = setInterval(GO, eS)), qa = 1, iS(rQ));
  }
}
function lQ(e, t, i) {
  var n = new Sh();
  return t = t == null ? 0 : +t, n.restart(function(s) {
    n.stop(), e(s + t);
  }, t, i), n;
}
var UO = DE("start", "end", "cancel", "interrupt"), HO = [], sS = 0, cQ = 1, BI = 2, Tg = 3, gQ = 4, mI = 5, Gg = 6;
function tu(e, t, i, n, s, A) {
  var o = e.__transition;
  if (!o) e.__transition = {};
  else if (i in o) return;
  OO(e, i, {
    name: t,
    index: n,
    // For context during callback.
    group: s,
    // For context during callback.
    on: UO,
    tween: HO,
    time: A.time,
    delay: A.delay,
    duration: A.duration,
    ease: A.ease,
    timer: null,
    state: sS
  });
}
function xE(e, t) {
  var i = ss(e, t);
  if (i.state > sS) throw new Error("too late; already scheduled");
  return i;
}
function Ys(e, t) {
  var i = ss(e, t);
  if (i.state > Tg) throw new Error("too late; already running");
  return i;
}
function ss(e, t) {
  var i = e.__transition;
  if (!i || !(i = i[t])) throw new Error("transition not found");
  return i;
}
function OO(e, t, i) {
  var n = e.__transition, s;
  n[t] = i, i.timer = nS(A, 0, i.time);
  function A(l) {
    i.state = cQ, i.timer.restart(o, i.delay, i.time), i.delay <= l && o(l - i.delay);
  }
  function o(l) {
    var c, g, h, d;
    if (i.state !== cQ) return r();
    for (c in n)
      if (d = n[c], d.name === i.name) {
        if (d.state === Tg) return lQ(o);
        d.state === gQ ? (d.state = Gg, d.timer.stop(), d.on.call("interrupt", e, e.__data__, d.index, d.group), delete n[c]) : +c < t && (d.state = Gg, d.timer.stop(), d.on.call("cancel", e, e.__data__, d.index, d.group), delete n[c]);
      }
    if (lQ(function() {
      i.state === Tg && (i.state = gQ, i.timer.restart(a, i.delay, i.time), a(l));
    }), i.state = BI, i.on.call("start", e, e.__data__, i.index, i.group), i.state === BI) {
      for (i.state = Tg, s = new Array(h = i.tween.length), c = 0, g = -1; c < h; ++c)
        (d = i.tween[c].value.call(e, e.__data__, i.index, i.group)) && (s[++g] = d);
      s.length = g + 1;
    }
  }
  function a(l) {
    for (var c = l < i.duration ? i.ease.call(null, l / i.duration) : (i.timer.restart(r), i.state = mI, 1), g = -1, h = s.length; ++g < h; )
      s[g].call(e, c);
    i.state === mI && (i.on.call("end", e, e.__data__, i.index, i.group), r());
  }
  function r() {
    i.state = Gg, i.timer.stop(), delete n[t];
    for (var l in n) return;
    delete e.__transition;
  }
}
function PO(e, t) {
  var i = e.__transition, n, s, A = !0, o;
  if (i) {
    t = t == null ? null : t + "";
    for (o in i) {
      if ((n = i[o]).name !== t) {
        A = !1;
        continue;
      }
      s = n.state > BI && n.state < mI, n.state = Gg, n.timer.stop(), n.on.call(s ? "interrupt" : "cancel", e, e.__data__, n.index, n.group), delete i[o];
    }
    A && delete e.__transition;
  }
}
function YO(e) {
  return this.each(function() {
    PO(this, e);
  });
}
function JO(e, t) {
  var i, n;
  return function() {
    var s = Ys(this, e), A = s.tween;
    if (A !== i) {
      n = i = A;
      for (var o = 0, a = n.length; o < a; ++o)
        if (n[o].name === t) {
          n = n.slice(), n.splice(o, 1);
          break;
        }
    }
    s.tween = n;
  };
}
function KO(e, t, i) {
  var n, s;
  if (typeof i != "function") throw new Error();
  return function() {
    var A = Ys(this, e), o = A.tween;
    if (o !== n) {
      s = (n = o).slice();
      for (var a = { name: t, value: i }, r = 0, l = s.length; r < l; ++r)
        if (s[r].name === t) {
          s[r] = a;
          break;
        }
      r === l && s.push(a);
    }
    A.tween = s;
  };
}
function VO(e, t) {
  var i = this._id;
  if (e += "", arguments.length < 2) {
    for (var n = ss(this.node(), i).tween, s = 0, A = n.length, o; s < A; ++s)
      if ((o = n[s]).name === e)
        return o.value;
    return null;
  }
  return this.each((t == null ? JO : KO)(i, e, t));
}
function SE(e, t, i) {
  var n = e._id;
  return e.each(function() {
    var s = Ys(this, n);
    (s.value || (s.value = {}))[t] = i.apply(this, arguments);
  }), function(s) {
    return ss(s, n).value[t];
  };
}
function AS(e, t) {
  var i;
  return (typeof t == "number" ? ln : t instanceof IA ? wl : (i = IA(t)) ? (t = i, wl) : rD)(e, t);
}
function WO(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function qO(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function jO(e, t, i) {
  var n, s = i + "", A;
  return function() {
    var o = this.getAttribute(e);
    return o === s ? null : o === n ? A : A = t(n = o, i);
  };
}
function zO(e, t, i) {
  var n, s = i + "", A;
  return function() {
    var o = this.getAttributeNS(e.space, e.local);
    return o === s ? null : o === n ? A : A = t(n = o, i);
  };
}
function $O(e, t, i) {
  var n, s, A;
  return function() {
    var o, a = i(this), r;
    return a == null ? void this.removeAttribute(e) : (o = this.getAttribute(e), r = a + "", o === r ? null : o === n && r === s ? A : (s = r, A = t(n = o, a)));
  };
}
function XO(e, t, i) {
  var n, s, A;
  return function() {
    var o, a = i(this), r;
    return a == null ? void this.removeAttributeNS(e.space, e.local) : (o = this.getAttributeNS(e.space, e.local), r = a + "", o === r ? null : o === n && r === s ? A : (s = r, A = t(n = o, a)));
  };
}
function ZO(e, t) {
  var i = $d(e), n = i === "transform" ? zv : AS;
  return this.attrTween(e, typeof t == "function" ? (i.local ? XO : $O)(i, n, SE(this, "attr." + e, t)) : t == null ? (i.local ? qO : WO)(i) : (i.local ? zO : jO)(i, n, t));
}
function tP(e, t) {
  return function(i) {
    this.setAttribute(e, t.call(this, i));
  };
}
function eP(e, t) {
  return function(i) {
    this.setAttributeNS(e.space, e.local, t.call(this, i));
  };
}
function iP(e, t) {
  var i, n;
  function s() {
    var A = t.apply(this, arguments);
    return A !== n && (i = (n = A) && eP(e, A)), i;
  }
  return s._value = t, s;
}
function nP(e, t) {
  var i, n;
  function s() {
    var A = t.apply(this, arguments);
    return A !== n && (i = (n = A) && tP(e, A)), i;
  }
  return s._value = t, s;
}
function sP(e, t) {
  var i = "attr." + e;
  if (arguments.length < 2) return (i = this.tween(i)) && i._value;
  if (t == null) return this.tween(i, null);
  if (typeof t != "function") throw new Error();
  var n = $d(e);
  return this.tween(i, (n.local ? iP : nP)(n, t));
}
function AP(e, t) {
  return function() {
    xE(this, e).delay = +t.apply(this, arguments);
  };
}
function oP(e, t) {
  return t = +t, function() {
    xE(this, e).delay = t;
  };
}
function aP(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? AP : oP)(t, e)) : ss(this.node(), t).delay;
}
function rP(e, t) {
  return function() {
    Ys(this, e).duration = +t.apply(this, arguments);
  };
}
function lP(e, t) {
  return t = +t, function() {
    Ys(this, e).duration = t;
  };
}
function cP(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? rP : lP)(t, e)) : ss(this.node(), t).duration;
}
function gP(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    Ys(this, e).ease = t;
  };
}
function hP(e) {
  var t = this._id;
  return arguments.length ? this.each(gP(t, e)) : ss(this.node(), t).ease;
}
function dP(e) {
  typeof e != "function" && (e = Yx(e));
  for (var t = this._groups, i = t.length, n = new Array(i), s = 0; s < i; ++s)
    for (var A = t[s], o = A.length, a = n[s] = [], r, l = 0; l < o; ++l)
      (r = A[l]) && e.call(r, r.__data__, l, A) && a.push(r);
  return new Os(n, this._parents, this._name, this._id);
}
function uP(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, i = e._groups, n = t.length, s = i.length, A = Math.min(n, s), o = new Array(n), a = 0; a < A; ++a)
    for (var r = t[a], l = i[a], c = r.length, g = o[a] = new Array(c), h, d = 0; d < c; ++d)
      (h = r[d] || l[d]) && (g[d] = h);
  for (; a < n; ++a)
    o[a] = t[a];
  return new Os(o, this._parents, this._name, this._id);
}
function fP(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    return i >= 0 && (t = t.slice(0, i)), !t || t === "start";
  });
}
function IP(e, t, i) {
  var n, s, A = fP(t) ? xE : Ys;
  return function() {
    var o = A(this, e), a = o.on;
    a !== n && (s = (n = a).copy()).on(t, i), o.on = s;
  };
}
function CP(e, t) {
  var i = this._id;
  return arguments.length < 2 ? ss(this.node(), i).on.on(e) : this.each(IP(i, e, t));
}
function EP(e) {
  return function() {
    var t = this.parentNode;
    for (var i in this.__transition) if (+i !== e) return;
    t && t.removeChild(this);
  };
}
function BP() {
  return this.on("end.remove", EP(this._id));
}
function mP(e) {
  var t = this._name, i = this._id;
  typeof e != "function" && (e = pE(e));
  for (var n = this._groups, s = n.length, A = new Array(s), o = 0; o < s; ++o)
    for (var a = n[o], r = a.length, l = A[o] = new Array(r), c, g, h = 0; h < r; ++h)
      (c = a[h]) && (g = e.call(c, c.__data__, h, a)) && ("__data__" in c && (g.__data__ = c.__data__), l[h] = g, tu(l[h], t, i, h, l, ss(c, i)));
  return new Os(A, this._parents, t, i);
}
function pP(e) {
  var t = this._name, i = this._id;
  typeof e != "function" && (e = Px(e));
  for (var n = this._groups, s = n.length, A = [], o = [], a = 0; a < s; ++a)
    for (var r = n[a], l = r.length, c, g = 0; g < l; ++g)
      if (c = r[g]) {
        for (var h = e.call(c, c.__data__, g, r), d, u = ss(c, i), f = 0, C = h.length; f < C; ++f)
          (d = h[f]) && tu(d, t, i, f, h, u);
        A.push(h), o.push(c);
      }
  return new Os(A, o, t, i);
}
var QP = gr.prototype.constructor;
function yP() {
  return new QP(this._groups, this._parents);
}
function wP(e, t) {
  var i, n, s;
  return function() {
    var A = Wa(this, e), o = (this.style.removeProperty(e), Wa(this, e));
    return A === o ? null : A === i && o === n ? s : s = t(i = A, n = o);
  };
}
function oS(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function DP(e, t, i) {
  var n, s = i + "", A;
  return function() {
    var o = Wa(this, e);
    return o === s ? null : o === n ? A : A = t(n = o, i);
  };
}
function xP(e, t, i) {
  var n, s, A;
  return function() {
    var o = Wa(this, e), a = i(this), r = a + "";
    return a == null && (r = a = (this.style.removeProperty(e), Wa(this, e))), o === r ? null : o === n && r === s ? A : (s = r, A = t(n = o, a));
  };
}
function SP(e, t) {
  var i, n, s, A = "style." + t, o = "end." + A, a;
  return function() {
    var r = Ys(this, e), l = r.on, c = r.value[A] == null ? a || (a = oS(t)) : void 0;
    (l !== i || s !== c) && (n = (i = l).copy()).on(o, s = c), r.on = n;
  };
}
function _P(e, t, i) {
  var n = (e += "") == "transform" ? jv : AS;
  return t == null ? this.styleTween(e, wP(e, n)).on("end.style." + e, oS(e)) : typeof t == "function" ? this.styleTween(e, xP(e, n, SE(this, "style." + e, t))).each(SP(this._id, e)) : this.styleTween(e, DP(e, n, t), i).on("end.style." + e, null);
}
function bP(e, t, i) {
  return function(n) {
    this.style.setProperty(e, t.call(this, n), i);
  };
}
function MP(e, t, i) {
  var n, s;
  function A() {
    var o = t.apply(this, arguments);
    return o !== s && (n = (s = o) && bP(e, o, i)), n;
  }
  return A._value = t, A;
}
function NP(e, t, i) {
  var n = "style." + (e += "");
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  return this.tween(n, MP(e, t, i ?? ""));
}
function FP(e) {
  return function() {
    this.textContent = e;
  };
}
function RP(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function kP(e) {
  return this.tween("text", typeof e == "function" ? RP(SE(this, "text", e)) : FP(e == null ? "" : e + ""));
}
function vP(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function TP(e) {
  var t, i;
  function n() {
    var s = e.apply(this, arguments);
    return s !== i && (t = (i = s) && vP(s)), t;
  }
  return n._value = e, n;
}
function GP(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, TP(e));
}
function LP() {
  for (var e = this._name, t = this._id, i = aS(), n = this._groups, s = n.length, A = 0; A < s; ++A)
    for (var o = n[A], a = o.length, r, l = 0; l < a; ++l)
      if (r = o[l]) {
        var c = ss(r, t);
        tu(r, e, i, l, o, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new Os(n, this._parents, e, i);
}
function UP() {
  var e, t, i = this, n = i._id, s = i.size();
  return new Promise(function(A, o) {
    var a = { value: o }, r = { value: function() {
      --s === 0 && A();
    } };
    i.each(function() {
      var l = Ys(this, n), c = l.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(r)), l.on = t;
    });
  });
}
var HP = 0;
function Os(e, t, i, n) {
  this._groups = e, this._parents = t, this._name = i, this._id = n;
}
function aS() {
  return ++HP;
}
var jo = gr.prototype;
Os.prototype = {
  constructor: Os,
  select: mP,
  selectAll: pP,
  filter: dP,
  merge: uP,
  selection: yP,
  transition: LP,
  call: jo.call,
  nodes: jo.nodes,
  node: jo.node,
  size: jo.size,
  empty: jo.empty,
  each: jo.each,
  on: CP,
  attr: ZO,
  attrTween: sP,
  style: _P,
  styleTween: NP,
  text: kP,
  textTween: GP,
  remove: BP,
  tween: VO,
  delay: aP,
  duration: cP,
  ease: hP,
  end: UP
};
var pI = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: WD
};
function OP(e, t) {
  for (var i; !(i = e.__transition) || !(i = i[t]); )
    if (!(e = e.parentNode))
      return pI.time = Zd(), pI;
  return i;
}
function PP(e) {
  var t, i;
  e instanceof Os ? (t = e._id, e = e._name) : (t = aS(), (i = pI).time = Zd(), e = e == null ? null : e + "");
  for (var n = this._groups, s = n.length, A = 0; A < s; ++A)
    for (var o = n[A], a = o.length, r, l = 0; l < a; ++l)
      (r = o[l]) && tu(r, e, t, l, o, i || OP(r, t));
  return new Os(n, this._parents, e, t);
}
gr.prototype.interrupt = YO;
gr.prototype.transition = PP;
const X = (e) => Ri(e), z = (e, t, i, n, s = [], A) => {
  const o = e instanceof HTMLElement || e instanceof SVGElement ? X(e) : e, a = n ? n[0] : null;
  let r = null, l = null, c = null, g = null, h = null, d;
  a ? a === "#" ? (r = "id", l = n) : (r = "class", l = n[0] === "." ? n : `.${n}`) : (l = t, d = !0), c = o.selectAll(l), d && (c = c.filter(function() {
    return this.parentNode === o.node();
  })), c = c.data(i, A), g = c.enter().append(t || "div"), s.enter && g.each(function(...f) {
    s.enter(X(this), ...f);
  }), h = g.merge(c), s.update && h.each(function(...f) {
    s.update(X(this), ...f);
  }), r === "class" ? h.classed(
    a === "." ? n.substring(1, n.length) : n,
    !0
  ) : r === "id" && h.attr("id", n.substring(1, n.length));
  const u = c.exit();
  return s.exit ? u.each(function(...f) {
    s.exit(X(this), ...f);
  }) : u.remove(), h;
}, Ji = (e, t) => (Object.entries(t).forEach((i) => {
  e.style(i[0], i[1]);
}, void 0), e), rS = (e, t) => {
  e.appendChild(t);
}, hQ = (e, t) => {
  for (const i in t)
    ({}).hasOwnProperty.call(t, i) && e.attr(i, t[i]);
};
function lS(e) {
  return e instanceof gr;
}
const hA = (e, t, i) => (lS(e) || (e = X(e)), i !== void 0 ? e.selectAll(`.${i}`).each(function() {
  hQ(Ri(this), t);
}) : hQ(e, t), e), YP = (e, t, i, n) => {
  Ri(e).selectAll(i).each(function(s) {
    const A = Ri(this);
    n ? n(s) && A.classed(t, !0) : A.classed(t, !0);
  });
}, JP = (e, t, i, n) => {
  Ri(e).selectAll(i).each(function(s) {
    const A = Ri(this);
    n ? n(s) && A.classed(t, !1) : A.classed(t, !1);
  });
}, vt = (e, t) => {
  lS(e) || (e = X(e));
  for (const i in t)
    ({}).hasOwnProperty.call(t, i) && e.style(i, t[i]);
  return e;
}, _E = (e) => {
  const t = Ri(e.container);
  let i;
  i = e.data, typeof i == "number" && (i = Array(i).fill(0).map((A, o) => o));
  const n = t.selectAll(e.selector).filter(function() {
    return this.parentNode === t.node();
  }).data(i), s = n.enter().append(e.append).merge(n).each(function(A, o) {
    e.each(A, Ri(this), o);
  });
  e.className && s.attr("class", e.className || ""), n.exit().remove();
}, cS = (e, t, i) => {
  const n = z(
    Ri(e),
    "clipPath",
    [1],
    `#${i}`
  );
  z(n, "rect", [1]).attr("x", t.x).attr("y", t.x).attr("width", t.width).attr("height", t.height), n.attr("clip-path", `url(#${i})`);
}, KP = (e, t) => Ri(e).selectAll(t).nodes(), _h = (e, t) => {
  const i = e.getBoundingClientRect();
  return {
    x: t.clientX - i.x,
    y: t.clientY - i.y
  };
}, io = (e, t) => {
  const i = yE(e, t);
  return {
    x: i[0],
    y: i[1]
  };
}, Rn = (e) => {
  const t = e.getBoundingClientRect(), i = window.pageXOffset || document.documentElement.scrollLeft, n = window.pageYOffset || document.documentElement.scrollTop;
  return {
    x: t.x + i,
    y: t.y + n,
    width: t.width,
    height: t.height
  };
}, gS = (e, t) => Ri(t).append(e), bt = () => ie, hr = () => kO, Ls = (e, t) => {
  let i;
  const n = "W", s = {
    "fill-opacity": 0
  }, A = typeof t == "string" ? t : t instanceof Array ? t.join(" ") : void 0;
  e.node() instanceof HTMLElement ? i = e.append("div").html(n) : i = e.append("text").text(n), A ? i.attr("class", A) : typeof t == "object" && (delete t["fill-opacity"], et(s, t)), Ji(i, s);
  const o = window.getComputedStyle(i.node()), a = {
    fontSize: o.fontSize,
    fontFamily: o.fontFamily,
    fontWeight: o.fontWeight,
    fontStyle: o.fontStyle,
    fontVariant: o.fontVariant
  };
  return i.remove(), a;
}, bE = () => "ontouchstart" in document.documentElement;
var hS = { exports: {} };
(function(e, t) {
  (function(i, n) {
    e.exports = n();
  })(window, function() {
    return function(i) {
      var n = {};
      function s(A) {
        if (n[A]) return n[A].exports;
        var o = n[A] = { i: A, l: !1, exports: {} };
        return i[A].call(o.exports, o, o.exports, s), o.l = !0, o.exports;
      }
      return s.m = i, s.c = n, s.d = function(A, o, a) {
        s.o(A, o) || Object.defineProperty(A, o, { enumerable: !0, get: a });
      }, s.r = function(A) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(A, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(A, "__esModule", { value: !0 });
      }, s.t = function(A, o) {
        if (1 & o && (A = s(A)), 8 & o || 4 & o && typeof A == "object" && A && A.__esModule) return A;
        var a = /* @__PURE__ */ Object.create(null);
        if (s.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: A }), 2 & o && typeof A != "string") for (var r in A) s.d(a, r, function(l) {
          return A[l];
        }.bind(null, r));
        return a;
      }, s.n = function(A) {
        var o = A && A.__esModule ? function() {
          return A.default;
        } : function() {
          return A;
        };
        return s.d(o, "a", o), o;
      }, s.o = function(A, o) {
        return Object.prototype.hasOwnProperty.call(A, o);
      }, s.p = "", s(s.s = 0);
    }([function(i, n, s) {
      s.r(n);
      var A = /* @__PURE__ */ function() {
        function N(M, F) {
          for (var k = 0; k < F.length; k++) {
            var O = F[k];
            O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(M, O.key, O);
          }
        }
        return function(M, F, k) {
          return F && N(M.prototype, F), k && N(M, k), M;
        };
      }(), o = function(N, M) {
        N.forEach(function(F) {
          F != null && (M[F] = 1);
        });
      }, a = function() {
        function N(M) {
          (function(F, k) {
            if (!(F instanceof k)) throw new TypeError("Cannot call a class as a function");
          })(this, N), this._set = {}, o(M, this._set);
        }
        return A(N, [{ key: "append", value: function(M) {
          return o(M, this._set), this;
        } }, { key: "toArray", value: function() {
          return Object.keys(this._set);
        } }], [{ key: "difference", value: function(M, F) {
          var k = void 0, O = [], P = M._set, L = F._set;
          for (k in P) ({}).hasOwnProperty.call(P, k) && (k in L || O.push(k));
          return new N(O);
        } }]), N;
      }(), r = /* @__PURE__ */ function() {
        function N(M, F) {
          for (var k = 0; k < F.length; k++) {
            var O = F[k];
            O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(M, O.key, O);
          }
        }
        return function(M, F, k) {
          return F && N(M.prototype, F), k && N(M, k), M;
        };
      }(), l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(N) {
        return typeof N;
      } : function(N) {
        return N && typeof Symbol == "function" && N.constructor === Symbol && N !== Symbol.prototype ? "symbol" : typeof N;
      };
      function c(N, M, F) {
        return M in N ? Object.defineProperty(N, M, { value: F, enumerable: !0, configurable: !0, writable: !0 }) : N[M] = F, N;
      }
      function g(N) {
        if (Array.isArray(N)) {
          for (var M = 0, F = Array(N.length); M < N.length; M++) F[M] = N[M];
          return F;
        }
        return Array.from(N);
      }
      var h = function(N) {
        if ((N === void 0 ? "undefined" : l(N)) === "object") {
          if (N === null) return !1;
          if (Object.prototype.toString.call(N) === "[object Object]") return (N.constructor.toString().match(/^function (.*)\(\)/m) || [])[1] === "Object";
        }
        return !1;
      }, d = typeof window > "u" ? {} : window, u = function N() {
        return N.__lastTime === (/* @__PURE__ */ new Date()).getTime() ? N.__lastTime.toString() + (N.__id++).toString() : (N.__id = 0, (N.__lastTime = (/* @__PURE__ */ new Date()).getTime()).toString() + (N.__id++).toString());
      }, f = function(N) {
        var M = [];
        return N.forEach(function(F) {
          return M.push.apply(M, g(F));
        }), M;
      }, C = function(N, M) {
        var F = [], k = null;
        return N = N && typeof N == "function" && N || function() {
        }, function(O, P) {
          [].push.apply(F, O), k === null && (k = function(L) {
            return L ? function(q) {
              setTimeout(q, 16);
            } : d.requestAnimationFrame || d.webkitRequestAnimationFrame || d.mozRequestAnimationFrame || d.oRequestAnimationFrame || d.msRequestAnimationFrame || function(q) {
              setTimeout(q, 16);
            };
          }(M)(function() {
            var L, q = F.slice(0);
            F.length = 0, k = null, (L = q, L.reduce(function($, W) {
              return W.__id in $.map || ($.map[W.__id] = 1, $.unique.push(W)), $;
            }, { map: {}, unique: [] }).unique).forEach(function($) {
              return $();
            }), N(P);
          }));
        };
      }, I = function() {
        for (var N = arguments.length, M = Array(N), F = 0; F < N; F++) M[F] = arguments[F];
        return { dependencies: M.slice(0, M.length - 1), fn: M[M.length - 1] };
      }, E = function(N) {
        var M = [], F = {};
        return N.forEach(function(k) {
          return F[k.qualifiedName] = -1;
        }), function k(O) {
          O.forEach(function(P) {
            var L, q = void 0, $ = void 0, W = void 0;
            (L = P.qualifiedName) in F ? (q = F[L]) !== -1 && q !== M.length - 1 && ($ = M.slice(0, q), W = M.slice(q + 1), M = $.concat(W), W.forEach(function(U, J) {
              return F[U.qualifiedName] = J + $.length;
            }), F[L] = M.push(P) - 1) : F[L] = M.push(P) - 1, k(P.outgoingEdges);
          });
        }(N), M;
      }, B = function() {
        for (var N = arguments.length, M = Array(N), F = 0; F < N; F++) M[F] = arguments[F];
        var k = {};
        return M.forEach(function(O) {
          Object.assign(k, c({}, O.name, O.value));
        }), k;
      }, m = function(N) {
        return N.value;
      };
      function p(N) {
        if (N == null) throw new TypeError("Cannot convert undefined or null to object");
        for (var M = Object(N), F = arguments.length, k = Array(F > 1 ? F - 1 : 0), O = 1; O < F; O++) k[O - 1] = arguments[O];
        for (var P = 0; P < k.length; P++) {
          var L = k[P];
          if (L != null) for (var q in L) Object.prototype.hasOwnProperty.call(L, q) && (M[q] = L[q]);
        }
        return M;
      }
      var w = function() {
        function N(M) {
          (function(F, k) {
            if (!(F instanceof k)) throw new TypeError("Cannot call a class as a function");
          })(this, N), this.fn = M, this.dep = [];
        }
        return r(N, [{ key: "addDependencies", value: function() {
          var M;
          return (M = this.dep).push.apply(M, arguments), this;
        } }, { key: "getDependencies", value: function() {
          return this.dep;
        } }, { key: "get", value: function() {
          return this.fn;
        } }]), N;
      }(), Q = /* @__PURE__ */ function() {
        function N(M, F) {
          for (var k = 0; k < F.length; k++) {
            var O = F[k];
            O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(M, O.key, O);
          }
        }
        return function(M, F, k) {
          return F && N(M.prototype, F), k && N(M, k), M;
        };
      }();
      function y(N) {
        if (Array.isArray(N)) {
          for (var M = 0, F = Array(N.length); M < N.length; M++) F[M] = N[M];
          return F;
        }
        return Array.from(N);
      }
      var D = function() {
        function N(M, F, k) {
          (function(O, P) {
            if (!(O instanceof P)) throw new TypeError("Cannot call a class as a function");
          })(this, N), k = k || {}, this.name = M, this.qualifiedName = F, this.edges = [], this.outgoingEdges = [], this._seed = null, this.requireResolve = !0, this.retriever = k.retriever, this.history = [], this.resolver = null, this.electricEdges = [];
        }
        return Q(N, [{ key: "addDependencies", value: function() {
          for (var M, F = this, k = arguments.length, O = Array(k), P = 0; P < k; P++) O[P] = arguments[P];
          return (M = this.edges).push.apply(M, O), O.forEach(function(L) {
            return L.outgoingEdges.push(F);
          }), this;
        } }, { key: "addElectricNode", value: function(M) {
          return this.electricEdges.push(M), this;
        } }, { key: "resolve", value: function() {
          return this.seed = this.resolver.apply(this, y(this.retrieveDetails())), this.history.push(this.seed), this.requireResolve = !1, this;
        } }, { key: "retrieveDetails", value: function() {
          return this.edges.length === 0 ? [{ name: this.name, qualifiedName: this.qualifiedName, value: this.seed }] : this.retriever.apply(this, y(this.edges.map(function(M) {
            return M.qualifiedName;
          })));
        } }, { key: "repeatHead", value: function() {
          var M = this.history, F = M[M.length - 1];
          return M.length === 0 || M.push(F), this;
        } }, { key: "flush", value: function() {
          var M = this.history, F = M[M.length - 1];
          return M.length = 0, M.push(F), this;
        } }, { key: "isRoot", value: function() {
          return this.name === null;
        } }, { key: "seed", get: function() {
          return this._seed;
        }, set: function(M) {
          return this._seed = M, this.requireResolve = !0, this;
        } }]), N;
      }(), _ = /* @__PURE__ */ function() {
        function N(M, F) {
          for (var k = 0; k < F.length; k++) {
            var O = F[k];
            O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(M, O.key, O);
          }
        }
        return function(M, F, k) {
          return F && N(M.prototype, F), k && N(M, k), M;
        };
      }(), x = function() {
        function N() {
          (function(M, F) {
            if (!(M instanceof F)) throw new TypeError("Cannot call a class as a function");
          })(this, N), this.edges = [], this.listeners = { nextFrame: [], currentFrame: [] };
        }
        return _(N, [{ key: "addEdges", value: function() {
          var M;
          return (M = this.edges).push.apply(M, arguments), this;
        } }, { key: "regListenerForCurrFrame", value: function(M) {
          var F = this, k = this.listeners.currentFrame, O = k.push(function(P, L) {
            var q = function() {
              L.apply(void 0, g(P.map(function($) {
                var W = $.history, U = W.length - 1;
                return [W[U - 1 < 0 ? 0 : U - 1], W[U]];
              })));
            };
            return q.__id = u(), q;
          }(this.edges, M)) - 1;
          return function() {
            F.listeners.currentFrame = k.filter(function(P, L) {
              return L !== O;
            });
          };
        } }, { key: "regListenerForNextFrame", value: function(M) {
          var F = this, k = this.listeners.nextFrame, O = k.push(function(P, L) {
            var q = function() {
              L.apply(void 0, g(P.map(function($) {
                var W = $.history;
                return [W[0], W[W.length - 1]];
              })));
            };
            return q.__id = u(), q;
          }(this.edges, M)) - 1;
          return function() {
            F.listeners.nextFrame = k.filter(function(P, L) {
              return L !== O;
            });
          };
        } }, { key: "hasNextFrameListener", value: function() {
          return !!this.listeners.nextFrame.length;
        } }]), N;
      }(), S = /* @__PURE__ */ function() {
        function N(M, F) {
          for (var k = 0; k < F.length; k++) {
            var O = F[k];
            O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(M, O.key, O);
          }
        }
        return function(M, F, k) {
          return F && N(M.prototype, F), k && N(M, k), M;
        };
      }();
      function b(N) {
        if (Array.isArray(N)) {
          for (var M = 0, F = Array(N.length); M < N.length; M++) F[M] = N[M];
          return F;
        }
        return Array.from(N);
      }
      var R = function() {
        function N(M) {
          var F, k = this;
          (function(O, P) {
            if (!(O instanceof P)) throw new TypeError("Cannot call a class as a function");
          })(this, N), M = p({}, { isPrintMode: !1 }, M), this.qualifiedNodeMap = {}, this.retriever = (F = this.qualifiedNodeMap, function() {
            for (var O = arguments.length, P = Array(O), L = 0; L < O; L++) P[L] = arguments[L];
            return P.map(function(q) {
              var $ = F[q];
              return { name: $.name, qualifiedName: $.qualifiedName, value: $.seed };
            });
          }), this.root = new D(null, null, { retriever: this.retriever }), this.root.resolver = B, this._wholeSet = null, this._propagate = !0, this.propagationOverride = { currentFrameListeners: !1, nextFrameListeners: !1 }, this._schedule = C(function(O) {
            var P = void 0;
            for (P in O.flushTarget) {
              if (!{}.hasOwnProperty.call(k.qualifiedNodeMap, P)) return;
              k.qualifiedNodeMap[P].flush();
            }
          }, M.isPrintMode);
        }
        return S(N, [{ key: "createNodesFrom", value: function(M, F) {
          var k = void 0, O = void 0, P = this.qualifiedNodeMap, L = this.root, q = this.retriever;
          return function $(W, U, J) {
            var V = void 0, Y = void 0, nt = void 0, tt = void 0;
            for (V in W) if ({}.hasOwnProperty.call(W, V)) if (tt = new D(V, Y = "" + U + V, { retriever: q }), P[Y] = tt, (nt = J.perv) !== void 0 ? nt.addDependencies(tt) : L.addDependencies(tt), h(k = W[V])) $(k, "" + U + V + ".", { perv: tt }), tt.resolver = B;
            else if (k instanceof w) {
              var st;
              tt.resolver = k.get(), (st = tt).addDependencies.apply(st, b(k.getDependencies().map(function(lt) {
                return P[lt];
              })));
            } else tt.resolver = m, tt.seed = k;
          }(M, F === null ? "" : F + ".", { perv: P[F] }), this._wholeSet = new a(Object.keys(this.qualifiedNodeMap)), (O = this.constructor.getResolvedList(L).concat(L).filter(function($) {
            return $.requireResolve;
          })).forEach(function($) {
            return $.resolve();
          }), E(O).forEach(function($) {
            return $.resolve();
          }), this;
        } }, { key: "getNodeValue", value: function(M) {
          if (M in this.qualifiedNodeMap) return this.qualifiedNodeMap[M].seed;
        } }, { key: "createElectricNodeOf", value: function(M, F) {
          var k, O = this, P = M.map(function(q) {
            return O.qualifiedNodeMap[q];
          }), L = (k = new x()).addEdges.apply(k, b(P));
          return P.forEach(function(q) {
            return q.addElectricNode(L);
          }), L["regListenerFor" + F.type](F.fn);
        } }, { key: "update", value: function(M) {
          var F = void 0, k = void 0, O = [], P = M.map(function(at) {
            return at[0].seed = at[1], at[0];
          });
          P.forEach(function(at) {
            return at.resolve();
          });
          var L = !0, q = !1, $ = void 0;
          try {
            for (var W, U = f(P.map(function(at) {
              return at.electricEdges;
            }))[Symbol.iterator](); !(L = (W = U.next()).done); L = !0) {
              var J = W.value;
              O.push(J);
            }
          } catch (at) {
            q = !0, $ = at;
          } finally {
            try {
              !L && U.return && U.return();
            } finally {
              if (q) throw $;
            }
          }
          if (F = new a(P.map(function(at) {
            return at.qualifiedName;
          })), !this._propagate) return this.__execUniqueElectricEdges(O), this._propagate = !0, this;
          (k = E(P)).forEach(function(at) {
            return at.resolve();
          }), F.append(k.map(function(at) {
            return at.qualifiedName;
          }));
          var V = !0, Y = !1, nt = void 0;
          try {
            for (var tt, st = f(k.map(function(at) {
              return at.electricEdges;
            }))[Symbol.iterator](); !(V = (tt = st.next()).done); V = !0) {
              var lt = tt.value;
              O.push(lt);
            }
          } catch (at) {
            Y = !0, nt = at;
          } finally {
            try {
              !V && st.return && st.return();
            } finally {
              if (Y) throw nt;
            }
          }
          return this.__execUniqueElectricEdges(Array.from(new Set(O)), F), this;
        } }, { key: "__execUniqueElectricEdges", value: function(M, F) {
          var k = this, O = [], P = [];
          return F && a.difference(this._wholeSet, F).toArray().forEach(function(L) {
            return k.qualifiedNodeMap[L].repeatHead();
          }), M.forEach(function(L) {
            O.push.apply(O, b(L.listeners.currentFrame));
          }), M.forEach(function(L) {
            P.push.apply(P, b(L.listeners.nextFrame));
          }), !this.propagationOverride.currentFrameListeners && O.forEach(function(L) {
            return L();
          }), !this.propagationOverride.nextFrameListeners && this._schedule(P, { flushTarget: F }), this.resetPropagationOverride(), this;
        } }, { key: "resetNodeValue", value: function() {
          for (var M = this, F = arguments.length, k = Array(F), O = 0; O < F; O++) k[O] = arguments[O];
          var P = k.map(function(q) {
            return M.qualifiedNodeMap[q];
          }), L = P.map(function(q) {
            return [q, q.seed];
          });
          return this.update(L), this;
        } }, { key: "stopPropagation", value: function() {
          return this._propagate = !1, this;
        } }, { key: "resetPropagationOverride", value: function() {
          return this.propagationOverride.currentFrameListeners = !1, this.propagationOverride.nextFrameListeners = !1, this;
        } }, { key: "setPropagationOverride", value: function(M) {
          return this.propagationOverride[M + "Listeners"] = !0, this;
        } }, { key: "getNodeFromQualifiedName", value: function(M) {
          return this.qualifiedNodeMap[M];
        } }], [{ key: "getResolvedList", value: function(M) {
          var F = [];
          return function k(O, P, L) {
            var q = void 0;
            O.edges.forEach(function($) {
              k($, P, L);
            }), O.isRoot() || (q = O.qualifiedName) in L || (P.push(O), L[q] = 1);
          }(M, F, {}), F;
        } }]), N;
      }(), G = /* @__PURE__ */ function() {
        function N(M, F) {
          for (var k = 0; k < F.length; k++) {
            var O = F[k];
            O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(M, O.key, O);
          }
        }
        return function(M, F, k) {
          return F && N(M.prototype, F), k && N(M, k), M;
        };
      }();
      function T(N, M, F) {
        return M in N ? Object.defineProperty(N, M, { value: F, enumerable: !0, configurable: !0, writable: !0 }) : N[M] = F, N;
      }
      function v(N) {
        if (Array.isArray(N)) {
          for (var M = 0, F = Array(N.length); M < N.length; M++) F[M] = N[M];
          return F;
        }
        return Array.from(N);
      }
      var H = function() {
        function N(M) {
          (function(F, k) {
            if (!(F instanceof k)) throw new TypeError("Cannot call a class as a function");
          })(this, N), M = p({}, { isPrintMode: !1 }, M), this._graph = new R(M), this._lockFlag = !1, this._reqQ = [];
        }
        return G(N, [{ key: "append", value: function() {
          var M = void 0, F = void 0;
          return arguments.length === 1 ? (M = null, F = arguments.length <= 0 ? void 0 : arguments[0]) : (M = arguments.length <= 0 ? void 0 : arguments[0], F = arguments.length <= 1 ? void 0 : arguments[1]), this._addPropInModel(M, F), this;
        } }, { key: "calculatedProp", value: function() {
          var M, F = void 0, k = void 0, O = void 0, P = void 0, L = void 0;
          return arguments.length > 2 ? (P = arguments.length <= 0 ? void 0 : arguments[0], O = arguments.length <= 1 ? void 0 : arguments[1], L = arguments.length <= 2 ? void 0 : arguments[2]) : (P = null, O = arguments.length <= 0 ? void 0 : arguments[0], L = arguments.length <= 1 ? void 0 : arguments[1]), F = L(I), (M = k = new w(F.fn)).addDependencies.apply(M, v(F.dependencies)), this._addPropInModel(P, T({}, O, k)), this;
        } }, { key: "_addPropInModel", value: function(M, F) {
          return this._graph.createNodesFrom(F, M), this;
        } }, { key: "on", value: function(M, F, k) {
          var O, P = M instanceof Array ? M : [M], L = this._graph.createElectricNodeOf(P, { type: "CurrFrame", fn: F });
          return k && (O = this._graph.stopPropagation().setPropagationOverride("nextFrame")).resetNodeValue.apply(O, v(M)), L;
        } }, { key: "next", value: function(M, F, k) {
          var O, P = M instanceof Array ? M : [M], L = this._graph.createElectricNodeOf(P, { type: "NextFrame", fn: F });
          return k && (O = this._graph.stopPropagation().setPropagationOverride("currentFrame")).resetNodeValue.apply(O, v(M)), L;
        } }, { key: "lock", value: function() {
          return this._lockFlag = !0, this._reqQ.length = 0, this;
        } }, { key: "unlock", value: function() {
          return this._lockFlag = !1, this.setProp(this._reqQ), this._reqQ.length = 0, this;
        } }, { key: "prop", value: function() {
          var M = void 0, F = void 0, k = void 0;
          switch (k = arguments.length) {
            case 1:
              M = arguments.length <= 0 ? void 0 : arguments[0];
              break;
            case 2:
              M = arguments.length <= 0 ? void 0 : arguments[0], F = arguments.length <= 1 ? void 0 : arguments[1];
              break;
            default:
              return this;
          }
          return k === 2 ? (this._lockFlag ? this._reqQ.push([M, F]) : this.setProp([[M, F]]), this) : this._graph.getNodeValue(M);
        } }, { key: "setProp", value: function(M) {
          var F = this;
          return M.length === 0 || this._graph.update(M.map(function(k) {
            return [F._graph.getNodeFromQualifiedName(k[0]), k[1]];
          })), this;
        } }, { key: "graph", value: function() {
          return this._graph;
        } }, { key: "serialize", value: function() {
          return this._graph.root.seed;
        } }], [{ key: "create", value: function(M, F) {
          return new N(F)._addPropInModel(null, M);
        } }]), N;
      }();
      n.default = H;
    }]);
  });
})(hS);
var VP = hS.exports;
const WP = /* @__PURE__ */ fw(VP), dQ = (e, t, i, n, s, A) => {
  let o = i;
  Array.isArray(i) || (o = [i]);
  const a = e.model[t](
    o,
    (...l) => {
      e._listeners.size && n(...l);
    },
    s
  ), r = wt(A, e._listeners.size);
  e._listeners.set(r, a);
};
class Rl {
  /**
   * Creates an instance of Store.
   * @param {Object} config The object to create the state store with.
   * @memberof Store
   */
  model;
  _listeners;
  _queue;
  _locked;
  constructor(t, i) {
    i = et({}, { isPrintMode: !1 }, i), this.model = WP.create(t, { isPrintMode: i.isPrintMode }), this._listeners = /* @__PURE__ */ new Map(), this._queue = /* @__PURE__ */ new Map(), this._locked = !1;
  }
  lockModel() {
    return this.model.lock(), this._locked = !0, this;
  }
  unlockModel() {
    return this._locked = !1, this.model.unlock(), this.flushQueue(), this;
  }
  flushQueue() {
    this._queue.forEach((i, n) => {
      const s = i.reduce((A, o) => o(A), this.model.prop(n));
      this.model.prop(n, s);
    }), this._queue.clear();
  }
  /**
   * This method returns a plain JSON object
   * with all the fields in the state store.
   *
   * @return {Object} Serialized representation of state store.
   * @memberof Store
   */
  serialize() {
    return this.model.serialize();
  }
  commit(t, i) {
    if (i instanceof Function)
      if (this._locked) {
        let n = this._queue.get(t);
        n || (n = [], this._queue.set(t, n)), n.push(i);
      } else {
        const n = this.model.prop(t);
        this.model.prop(t, i(n));
      }
    else
      this.model.prop(t, i);
    return this;
  }
  /**
   * This method is used to register a callback that will execute
   * when one or more properties change.
   *
   * @param {string | Array} propNames name of property or array of props.
   * @param {Function} callBack The callback to execute.
   * @memberof Store
   */
  registerChangeListener(t, i, n, s) {
    return dQ(this, "next", t, i, n, s), this;
  }
  /**
   * This method is used to register a callback that will execute
   * when one or more properties change.
   *
   * @param {string | Array} propNames name of property or array of props.
   * @param {Function} callBack The callback to execute.
   * @memberof Store
   */
  registerImmediateListener(t, i, n, s) {
    dQ(this, "on", t, i, n, s);
  }
  /**
   * This method is used to get the name of the property
   * from the state store.
   *
   * @param {string} propName The name of the field in state store.
   * @return {any} The value of the field.
   * @memberof Store
   */
  get(t, i) {
    const n = this.model.prop(t);
    return i ? n && n[i] : n;
  }
  /**
   * This method is used to register a computed property that is computed every time
   * the store value changes.
   *
   * @param {string} propName The name of the property to create.
   * @param {Function} callBack The function to execute when depemdent props change.
   * @memberof Store
   */
  computed(t, i) {
    return this.model.calculatedProp(t, i);
  }
  append(...t) {
    return this.model.append(...t), this;
  }
  unsubscribeAll() {
    return this._listeners.forEach((t) => t()), this._listeners.clear(), this;
  }
  unsubscribe(t) {
    const i = this._listeners.get(t);
    return i && i(), this._listeners.delete(t), this;
  }
}
const dS = (e, t, i, n = {}, s) => {
  let A;
  const o = i instanceof Rl ? i : new Rl({}, { isPrintMode: !!s }), a = {}, { namespace: r, subNamespace: l } = n;
  for (const c in t)
    if ({}.hasOwnProperty.call(t, c)) {
      A = t[c];
      const g = r ? `${r}.${c}` : c;
      if (l) {
        const h = wt(o.get(g));
        h[l] = A.value, a[g] = h;
      } else
        a[c] = A.value;
      e[c] = /* @__PURE__ */ ((h, d, u) => (...f) => {
        if (f.length) {
          const { takesMultipleParams: I = !1 } = d || {};
          let E = I ? f : f[0];
          if (d) {
            let B;
            const m = h.get(u, l), { sanitization: p, typeCheck: w, typeExpected: Q } = d;
            typeof p == "function" && (E = p(E, m, e)), typeof w == "function" ? w(E) && (B = E) : typeof w == "string" && w === "constructor" ? E && E.constructor.name === Q && (B = E) : B = E;
            const y = d.preset, D = Bn(h.get(u, l));
            y && y(B, e), I && D.forEach((_, x) => {
              B[x] === void 0 && (B[x] = _);
            }), B && h.commit(u, B);
          } else
            h.commit(u, E);
          return e;
        }
        return h.get(u, l);
      })(o, A.meta, g);
    }
  if (l)
    for (const c in a)
      o.commit(c, a[c][l]);
  else r === void 0 ? o.append(a) : o.append(r, a);
  return [e, o];
};
var Hi = { init: function(t) {
  var i = t.document, n = t.navigator, s = n.userAgent, A = "DIV", o = Math.ceil, a = Math.floor, r = "fusioncharts-smartlabel-", l = r + "container", c = r + "tag", g = r + "br";
  return Hi = { initialized: !0, win: t, containerClass: l, classNameWithTag: c, classNameWithTagBR: g, maxDefaultCacheLimit: 1e3, classNameReg: /\bfusioncharts-smartlabel-tag\b/, classNameBrReg: /\bfusioncharts-smartlabel-br\b/, spanAdditionRegx: /(<[^<\>]+?\>)|(&(?:[a-z]+|#[0-9]+);|.)/gi, spanAdditionReplacer: '$1<span class="' + c + '">$2</span>', spanRemovalRegx: new RegExp("\\<span[^\\>]+?" + c + "[^\\>]{0,}\\>(.*?)\\<\\/span\\>", "ig"), xmlTagRegEx: new RegExp("<[^>][^<]*[^>]+>", "i"), brRegex: new RegExp("({br[ ]*})|(<br[ ]*>)|(<br[ ]*/>)|(<BR[ ]*/>)|(<br\\>)", "g"), ltgtquotRegex: /&lt;|&gt;|&quot;|&#034;|&#039;/g, nbspRegex: /&nbsp;|&#160;|&#xA0;/g, htmlSpecialEntityRegex: /&amp;|&quot;|&lt;|&gt;/g, brReplaceRegex: /<br\/>/gi, testStrAvg: "WgI", parentContainerStyle: { position: "absolute", top: "-9999em", whiteSpace: "nowrap", padding: "0px", width: "1px", height: "1px", overflow: "hidden" }, supportedStyle: { font: "font", fontFamily: "font-family", "font-family": "font-family", fontWeight: "font-weight", "font-weight": "font-weight", fontSize: "font-size", "font-size": "font-size", lineHeight: "line-height", "line-height": "line-height", fontStyle: "font-style", "font-style": "font-style" }, getDocumentSupport: function() {
    var d, u, f;
    return i.getElementsByClassName ? (d = "getElementsByClassName", u = c, f = !0) : (d = "getElementsByTagName", u = "span", f = !1), { isIE: /msie/i.test(s) && !t.opera, hasSVG: !!(t.SVGAngle || i.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1")), isHeadLess: new RegExp(" HtmlUnit").test(s), isWebKit: new RegExp(" AppleWebKit/").test(s), childRetriverFn: d, childRetriverString: u, noClassTesting: f };
  }, createContainer: function(d) {
    var u, f;
    if (d && (d.offsetWidth || d.offsetHeight)) {
      if (d.appendChild)
        return d.appendChild(f = i.createElement(A)), f.className = l, f.setAttribute("aria-hidden", "true"), f.setAttribute("role", "presentation"), f;
    } else if (u = i.getElementsByTagName("body")[0], u && u.appendChild)
      return f = i.createElement(A), f.className = l, f.setAttribute("aria-hidden", "true"), f.setAttribute("role", "presentation"), u.appendChild(f), f;
  }, getNearestBreakIndex: function(d, u, f) {
    if (!d || !d.length)
      return 0;
    var C, I = f._getWidthFn(), E = 0, B = 0, m = I(d), p = m / d.length;
    if (C = u, E = o(u / p), m < u)
      return d.length - 1;
    for (E > d.length && (C = u - m, E = d.length); C > 0; )
      if (C = u - I(d.substr(0, E)), B = a(C / p), B)
        E += B;
      else
        return E;
    for (; C < 0; )
      if (C = u - I(d.substr(0, E)), B = a(C / p), B)
        E += B;
      else
        return E;
    return E;
  }, parseStyle: function() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = {};
    return u.fontSize = (d.fontSize || d["font-size"] || "12px") + "", u.fontVariant = d.fontVariant || d["font-variant"] || "normal", u.fontWeight = d.fontWeight || d["font-weight"] || "normal", u.fontStyle = d.fontStyle || d["font-style"] || "normal", u.fontFamily = d.fontFamily || d["font-family"] || "Verdana,sans", u.fontSize += u.fontSize.indexOf("px") === -1 ? "px" : "", u;
  }, setLineHeight: function(d) {
    var u = d.fontSize;
    return d.lineHeight = d.lineHeight || d["line-height"] || parseInt(u, 10) * 1.2 + "px", d;
  }, _getCleanHeight: function(d) {
    return d = d.replace(/px/g, ""), Number(d);
  }, _getDimentionUsingDiv: function() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", u = arguments.length > 1 ? arguments[1] : void 0, f = u._container;
    return d instanceof Array && (d = d.join("")), f.innerHTML = d, { width: f.offsetWidth, height: f.offsetHeight };
  }, _getDimentionUsingCanvas: function() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", u = arguments.length > 1 ? arguments[1] : void 0, f = u.ctx, C = u.style, I = Hi._getCleanHeight(C.lineHeight);
    return d instanceof Array ? (d = d.join(""), d = d.replace(/<br \/>/g, "")) : d = d.replace(/<br \/>/g, ""), { width: f.measureText(d).width, height: I };
  }, _hasOnlyBRTag: function() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return !Hi.xmlTagRegEx.test(d) && Hi.brRegex.test(d);
  }, _getDimentionOfMultiLineText: function() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", u = arguments.length > 1 ? arguments[1] : void 0, f, C, I = d.replace(Hi.brRegex, "<br />"), E = Hi._getTextArray(I), B = 0, m = 0, p = u._getWidthFn(), w = Hi._getCleanHeight(u.style.lineHeight), Q = w, y, D = {};
    for (f = 0, C = E.length; f < C; f++)
      E[f] === "<br />" ? (m = Math.max(m, B), B = 0, Q += w) : (y = p(E[f]), B += y, D[E[f]] = y);
    return m = Math.max(m, B), { height: Q, width: m, detailObj: D };
  }, _getTextArray: function() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", u, f, C, I, E, B, m = [];
    for (E = d.split("<br />"), C = E.length, u = 0; u < C; u++) {
      for (B = E[u].split(""), I = B.length, f = 0; f < I; f++)
        m.push(B[f]);
      u !== C - 1 && m.push("<br />");
    }
    return m;
  }, _findLastIndex: function() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], u = arguments.length > 1 ? arguments[1] : void 0, f, C = d.length;
    for (f = C - 1; f >= 0; f--)
      if (d[f] === u)
        return f;
    return -1;
  } }, Hi;
} }, ja = Hi.initialized ? Hi : Hi.init(window), QI = ja.win.document, Lg = ja.getDocumentSupport(), hf = Lg.isWebKit ? 0 : 4.5;
function dr(e, t, i) {
  var n;
  i = i > 5 ? i : 5, i = i < 20 ? i : 20, this.maxContainers = i, this.first = null, this.last = null, this.containers = {}, this.length = 0, this.rootNode = e, t && (n = QI.createElementNS("http://www.w3.org/2000/svg", "svg"), n.setAttributeNS("http://www.w3.org/2000/svg", "xlink", "http://www.w3.org/1999/xlink"), n.setAttributeNS("http://www.w3.org/2000/svg", "height", "0"), n.setAttributeNS("http://www.w3.org/2000/svg", "width", "0"), this.svgRoot = n, this.rootNode.appendChild(n));
}
dr.prototype.get = function(e) {
  var t, i, n, s = this.containers, A = this.length, o = this.maxContainers, a = "";
  for (i in ja.supportedStyle)
    e[i] !== void 0 && (a += ja.supportedStyle[i] + ":" + e[i] + ";");
  if (!a)
    return !1;
  if (n = s[a])
    this.first !== n && (n.prev && (n.prev.next = n.next), n.next && (n.next.prev = n.prev), n.next = this.first, n.next.prev = n, this.last === n && (this.last = n.prev), n.prev = null, this.first = n);
  else {
    if (A >= o)
      for (t = A - o + 1; t--; )
        this.removeContainer(this.last);
    n = this.addContainer(a);
  }
  return n;
};
dr.prototype._makeDivNode = function(e) {
  var t, i = e.keyStr;
  e.node || (e.node = QI.createElement("div"), e.node.className = "fusioncharts-div", this.rootNode.appendChild(e.node)), t = e.node, Lg.isIE && !Lg.hasSVG ? t.style.setAttribute("cssText", i) : t.setAttribute("style", i), t.setAttribute("aria-hidden", "true"), t.setAttribute("role", "presentation"), t.style.display = "inline-block", t.innerHTML = ja.testStrAvg, e.lineHeight = t.offsetHeight, e.avgCharWidth = t.offsetWidth / 3, Lg.isBrowserLess ? (e.svgText || (e.svgText = QI.createElementNS("http://www.w3.org/2000/svg", "text"), this.svgRoot.appendChild(t)), t = e.svgText, t.setAttribute("style", i), t.textContent = ja.testStrAvg, e.lineHeight = t.getBBox().height, e.avgCharWidth = (t.getBBox().width - hf) / 3, t.textContent = "...", e.ellipsesWidth = t.getBBox().width - hf, t.textContent = ".", e.dotWidth = t.getBBox().width - hf) : (t.innerHTML = "...", e.ellipsesWidth = t.offsetWidth, t.innerHTML = ".", e.dotWidth = t.offsetWidth, t.innerHTML = "");
};
dr.prototype.addContainer = function(e) {
  var t;
  return this.containers[e] = t = { next: null, prev: null, node: null, ellipsesWidth: 0, lineHeight: 0, dotWidth: 0, avgCharWidth: 4, keyStr: e, charCache: {} }, t.next = this.first, t.next && (t.next.prev = t), this.first = t, this.last || (this.last = t), this.length += 1, t;
};
dr.prototype.removeContainer = function(e) {
  var t = e.keyStr;
  !t || !this.length || !e || (this.length -= 1, e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), this.first === e && (this.first = e.next), this.last === e && (this.last = e.prev), e.node && e.node.parentNode.removeChild(e.node), delete this.containers[t]);
};
dr.prototype.dispose = function() {
  var e, t = this.containers;
  this.maxContainers = null;
  for (e in t)
    this.removeContainer(t[e]);
  this.rootNode.parentNode.removeChild(this.rootNode), this.rootNode = null, this.first = null, this.last = null;
};
function kl(e) {
  "@babel/helpers - typeof";
  return kl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, kl(e);
}
function uQ(e, t) {
  var i = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function fQ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var i = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uQ(Object(i), !0).forEach(function(n) {
      qP(e, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : uQ(Object(i)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return e;
}
function qP(e, t, i) {
  return (t = jP(t)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e;
}
function jP(e) {
  var t = zP(e, "string");
  return kl(t) == "symbol" ? t : t + "";
}
function zP(e, t) {
  if (kl(e) != "object" || !e) return e;
  var i = e[Symbol.toPrimitive];
  if (i !== void 0) {
    var n = i.call(e, t);
    if (kl(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
var Tt = Hi.initialized ? Hi : Hi.init(window), uS = Tt.win.document, fS = Tt.win.Math, GA = fS.max, $P = fS.round, IQ = { " ": "&nbsp;" }, jA = Tt.getDocumentSupport(), XP = jA.isWebKit ? 0 : 4.5;
function pi(e, t, i) {
  var n, s, A, o = !1, a = window.document.createElement("canvas");
  i = i || {}, i.maxCacheLimit = isFinite(A = i.maxCacheLimit) ? A : Tt.maxDefaultCacheLimit, typeof e == "string" && (e = uS.getElementById(e)), n = Tt.createContainer(e), n.innerHTML = Tt.testStrAvg, (jA.isHeadLess || !jA.isIE && !n.offsetHeight && !n.offsetWidth) && (o = !0), n.innerHTML = "";
  for (s in Tt.parentContainerStyle)
    n.style[s] = Tt.parentContainerStyle[s];
  this.parentContainer = n, this.ctx = a && a.getContext && a.getContext("2d"), this._containerManager = new dr(n, o, 10), this._showNoEllipses = !t, this._init = !0, this.style = {}, this.oldStyle = {}, this.options = i, this.setStyle();
}
function ZP(e, t, i, n, s) {
  for (var A = [], o, a, r, l = []; o = e.exec(i); )
    a = document.createElement("p"), r = o[0] + "Dummy</abbr>", a.innerHTML = r, A.push({ tagName: o[0], index: o.index, title: a.childNodes[0].title ? a.childNodes[0].title : "", endTagName: s });
  for (; o = t.exec(i); )
    l.push({ tagName: s, index: o.index });
  return { tag: A, endtag: l };
}
function tY(e) {
  var t = {};
  if (!e || !e.style || !e.style.cssText)
    return t;
  for (var i = function(l) {
    return l.replace(/(?:^|[-])(\w)/g, function(c, g) {
      return g = c.substr(0, 1) === "-" ? g.toUpperCase() : g, g || "";
    });
  }, n = e.style.cssText.split(";"), s = 0; s < n.length; ++s) {
    var A = n[s].trim();
    if (A) {
      var o = A.split(":"), a = i(o[0].trim());
      t[a] = o[1].trim();
    }
  }
  return t;
}
function eY(e, t, i, n, s) {
  for (var A = [], o, a, r, l, c = []; o = e.exec(i); )
    a = document.createElement("p"), r = o[0] + "Dummy</span>", a.innerHTML = r, l = tY(a.childNodes[0]), A.push({ tagName: o[0], index: o.index, style: l || "", endTagName: s });
  for (; o = t.exec(i); )
    c.push({ tagName: s, index: o.index });
  return { tag: A, endtag: c };
}
function iY(e, t, i, n, s) {
  for (var A = [], o, a, r, l = []; o = e.exec(i); )
    a = document.createElement("p"), r = o[0] + "</a>", a.innerHTML = r, A.push({ tagName: o[0], index: o.index, href: a.childNodes[0].href ? a.childNodes[0].href : "", target: a.childNodes[0].target ? a.childNodes[0].target : "", hreflang: a.childNodes[0].hreflang ? a.childNodes[0].hreflang : "", referrerpolicy: a.childNodes[0].referrerpolicy ? a.childNodes[0].referrerpolicy : "", rel: a.childNodes[0].rel ? a.childNodes[0].rel : "", endTagName: s });
  for (; o = t.exec(i); )
    l.push({ tagName: s, index: o.index });
  return { tag: A, endtag: l };
}
function _n(e, t, i, n, s) {
  var A = [], o, a = [];
  if (e)
    for (; o = e.exec(i); )
      A.push({ tagName: n, index: o.index, endTagName: s });
  if (t)
    for (; o = t.exec(i); )
      a.push({ tagName: s, index: o.index });
  return { tag: A, endtag: a };
}
function IS(e, t, i, n, s, A, o, a, r, l, c, g, h, d) {
  var u, f, C = [e, t, i, n, s, A, o, a, r, l, c, g, h, d], I = [];
  for (f = 0; f < C.length; f++)
    for (var E in C[f])
      if (C[f][E].length)
        for (u = 0; u < C[f][E].length; u++)
          I.push(C[f][E][u]);
  return I = I.sort(function(B, m) {
    return B.index - m.index;
  }), I;
}
function Ug(e) {
  var t = /<br\s*\/?>/g, i = _n(t, void 0, e, "<br />", ""), n = IS({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, i);
  return n;
}
function Da(e) {
  var t = /<u>/g, i = /<\/u>/g, n = /<b>/g, s = /<\/b>/g, A = /<strong>/g, o = /<\/strong>/g, a = /<em>/g, r = /<\/em>/g, l = /<i>/g, c = /<\/i>/g, g = /<del>/g, h = /<\/del>/g, d = /<s>/g, u = /<\/s>/g, f = /<strike>/g, C = /<\/strike>/g, I = /<sub>/g, E = /<\/sub>/g, B = /<sup>/g, m = /<\/sup>/g, p = /<abbr[\s]+([^>]+)>/g, w = /<\/abbr>/g, Q = /<span[\s]+([^>]+)>/g, y = /<\/span>/g, D = /<a[\s]+([^>]+)>/g, _ = /<\/a>/g, x = /<br\s*\/?>/g, S = _n(t, i, e, "<u>", "</u>"), b = _n(n, s, e, "<b>", "</b>"), R = _n(a, r, e, "<em>", "</em>"), G = _n(f, C, e, "<strike>", "</strike>"), T = _n(I, E, e, "<sub>", "</sub>"), v = _n(B, m, e, "<sup>", "</sup>"), H = ZP(p, w, e, "<abbr>", "</abbr>"), N = iY(D, _, e, "<a>", "</a>"), M = eY(Q, y, e, "<span>", "</span>"), F = _n(A, o, e, "<strong>", "</strong>"), k = _n(l, c, e, "<i>", "</i>"), O = _n(g, h, e, "<del>", "</del>"), P = _n(d, u, e, "<s>", "</s>"), L = _n(x, void 0, e, "<br />", ""), q = IS(S, b, R, G, T, v, H, N, M, F, k, O, P, L);
  return q;
}
function sA(e, t, i, n) {
  return t < 0 && (t = e.length + t, t < 0 && (t = 0)), e.slice(0, t) + (n || "") + e.slice(t + i);
}
function nY(e, t, i, n) {
  var s, A, o, a = e, r = i.index, l = i.index, c = i.index + 6;
  if (!t.length)
    return { text: e, charOffset: n };
  for (A = 0, o = t.length - 1, t[A].endTagName && (c = l + t[A].endTagName.length + 6); A <= o; )
    if (t[A].endTagName)
      if (A === o)
        a = sA(a, l, 0, t[A].endTagName), a = sA(a, c, 0, t[A].tagName), r = r + t[A].endTagName.length, l = r - t[A].endTagName.length, c = r + t[A].endTagName.length + 6 + t[A].tagName.length, n += t[A].endTagName.length, n += t[A].tagName.length, A++, o--;
      else if (t[A].endTagName !== t[o].tagName) {
        for (s = A; s <= o; s++)
          if (t[s + 1] && t[A].endTagName === t[s + 1].tagName) {
            A = s + 2;
            break;
          }
        s > o && (a = sA(a, l, 0, t[A].endTagName), a = sA(a, l + t[A].endTagName.length + 6, 0, t[A].tagName), r = r + t[A].endTagName.length, l = l + t[A].endTagName.length, c = r + t[A].endTagName.length + 6 + t[A].tagName.length, n += t[A].endTagName.length, n += t[A].tagName.length, A++);
      } else
        A++, o--;
    else
      A++, o--;
  return { text: a, charOffset: n, newBrIndex: r };
}
function sY(e) {
  var t = Ug(e), i, n = 0, s = {}, A, o, a = 0, r;
  if (!e)
    return "";
  if (!t.length)
    return e;
  for (A = t[0].index, i = 0; i < t.length; i++)
    s.charOffset && s.charOffset > 0 ? (A = t[i].index + s.charOffset, t[i].index = A) : A = t[i].index, o = e.substring(a, A), r = Da(o), n = s.charOffset ? s.charOffset : n, s = nY(e, r, t[i], n), s.newBrIndex && (a = s.newBrIndex + 6), e = s.text;
  return e;
}
function AY(e, t) {
  var i, n = 0, s = e, A = t.length - 1, o = e.length;
  if (!t.length)
    return e;
  for (; n <= A; )
    if (t[n].endTagName)
      if (n === A)
        s = sA(s, o, 0, t[n].endTagName), n++, A--;
      else if (t[n].endTagName !== t[A].tagName) {
        for (i = n; i <= A; i++)
          if (t[i + 1] && t[n].endTagName === t[i + 1].tagName) {
            n = i + 2;
            break;
          }
        i > A && (s = sA(s, o, 0, t[n].endTagName), n++);
      } else
        n++, A--;
    else
      n++, A--;
  return s;
}
function oY(e, t) {
  var i = e, n = t, s = "", A, o = "", a = 0, r, l;
  if (i === n)
    return i;
  if (i === "" && n !== "")
    return n;
  if (n === "" && i !== "")
    return i;
  for (r = 0, l = 0; r < i.length; )
    if (i[r] && !n[l]) {
      s += i.substring(r, i.length);
      break;
    } else if (n[l] && !i[r]) {
      s += n.substring(l, n.length);
      break;
    } else if (i[r] === n[l])
      if (i[r] === "<") {
        for (o = i[r], a = r + 1; a < i.length; ) {
          if (i[a] === ">") {
            o += i[a];
            break;
          }
          o += i[a], a++;
        }
        a >= i.length ? (s += i[r], r++, l++) : (A = Da(o), A && A.length ? (s += o, r += o.length) : (s += o, r += o.length, l += o.length));
      } else
        s += i[r], r++, l++;
    else if (i[r] === "<") {
      for (o = i[r], a = r + 1; a < i.length; ) {
        if (i[a] === ">") {
          o += i[a];
          break;
        }
        o += i[a], a++;
      }
      a >= i.length ? (s += i[r], r++, l++) : (A = Da(o), A && A.length ? (s += o, r += o.length) : (s += o, r += o.length, l += o.length));
    } else if (n[l] === "<") {
      for (o = n[l], a = l + 1; a < n.length; ) {
        if (n[a] === ">") {
          o += n[a];
          break;
        }
        o += n[a], a++;
      }
      a >= n.length ? (s += n[l], r++, l++) : (A = Da(o), A && A.length ? (s += o, l += o.length) : (s += o, r += o.length, l += o.length));
    } else i[r] === " " ? r++ : n[l] === " " && l++;
  return s;
}
function CQ(e, t) {
  var i = e, n = Da(e), s = Ug(t), A = Ug(e), o, a, r = t, l, c = 0;
  if (e === t)
    return e;
  if (A.length) {
    for (l = 0; l < A.length; l++) {
      for (c = 0, o = A[l].index; e[o] !== ">"; )
        c++, o++;
      e = sA(e, A[l].index, c + 1, ""), A[l + 1] && (a = l + 1, A[l + 1].index -= a * (c + 1));
    }
    if (s.length)
      for (l = 0; l < s.length; l++) {
        for (c = 0, o = s[l].index; r[o] !== ">"; )
          c++, o++;
        r = sA(r, s[l].index, c + 1, "<br />"), s[l + 1] && (a = l + 1, s[l + 1].index -= a * (c + 1), s[l + 1].index += a * 6);
      }
    t = r, i = e, n = Da(e), s = Ug(t);
  }
  if (n.length)
    if (s.length)
      i = oY(e, t), i = sY(i);
    else
      return AY(e, n);
  else return t;
  return i;
}
pi.textToLines = function(e) {
  return e = e || {}, e.text ? typeof e.text != "string" && (e.text = e.text.toString()) : e.text = "", e.lines = e.text.split(/\n|<br\s*?\/?>/ig), e;
};
pi.prototype._calCharDimWithCache = function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 ? arguments[1] : void 0, i = arguments.length > 2 ? arguments[2] : void 0;
  if (!this._init)
    return !1;
  var n, s, A, o, a, r = this.options.maxCacheLimit, l = this.style || {}, c, g, h, d;
  return c = this._advancedCache = this._advancedCache || (this._advancedCache = {}), g = this._advancedCacheKey || (this._advancedCacheKey = []), h = e + l.fontSize + l.fontFamily + l.fontWeight + l.fontStyle, d = e + "init" + l.fontSize + l.fontFamily + l.fontWeight + l.fontStyle, !this.ctx && IQ[e] && (e = IQ[e]), t ? (a = c[d]) === void 0 && (s = this._getDimention(e.repeat ? e.repeat(i) : Array(i + 1).join(e)).width, A = this._getDimention(e).width, a = c[d] = (s - i * A) / (i + 1), g.push(d), g.length > r && delete c[g.shift()]) : a = 0, (o = c[h]) ? { width: o.width, height: o.height } : (n = this._getDimention(e), n.width += a, c[h] = { width: n.width, height: n.height }, g.push(h), g.length > r && delete c[g.shift()], n);
};
pi.prototype._getDimention = function(e) {
  return this.requireDiv || !this.ctx ? Tt._getDimentionUsingDiv(e, this) : Tt._getDimentionUsingCanvas(e, this);
};
pi.prototype._getWidthFn = function() {
  var e = this, t = e._containerObj, i = t.svgText;
  return i ? function(n) {
    var s, A;
    return i.textContent = n, s = i.getBBox(), A = s.width - XP, A < 1 && (A = s.width), A;
  } : function(n) {
    return e.requireDiv || !e.ctx ? Tt._getDimentionUsingDiv(n, e).width : Tt._getDimentionUsingCanvas(n, e).width;
  };
};
pi.prototype._isSameStyle = function() {
  var e = this, t = e.oldStyle || {}, i = e.style;
  return !(i.fontSize !== t.fontSize || i.fontFamily !== t.fontFamily || i.fontStyle !== t.fontStyle || i.fontWeight !== t.fontWeight || i.fontVariant !== t.fontVariant);
};
pi.prototype._setStyleOfCanvas = function() {
  if (!this._isSameStyle()) {
    var e = this, t = e.style, i, n, s = t.fontStyle, A = t.fontVariant, o = t.fontWeight, a = t.fontSize, r = t.fontFamily;
    a += a.indexOf("px") === -1 ? "px" : "", i = s + " " + A + " " + o + " " + a + " " + r, e.ctx.font = i, n = this._containerObj = this._containerManager.get(t), this._containerObj ? (this._container = n.node, this._context = n.context, this._cache = n.charCache, this._lineHeight = n.lineHeight, this._styleNotSet = !1) : this._styleNotSet = !0, n.ellipsesWidth = e._calCharDimWithCache("...", !1).width, n.dotWidth = e._calCharDimWithCache(".", !1).width, n.lineHeight = this._lineHeight = n.lineHeight || Tt._getCleanHeight(t.lineHeight), this.oldStyle = t;
  }
};
pi.prototype._setStyleOfDiv = function() {
  var e, t = this.style;
  this._containerObj = e = this._containerManager.get(t), e.node || this._containerManager._makeDivNode(this._containerObj), this._containerObj ? (this._container = e.node, this._context = e.context, this._cache = e.charCache, this._lineHeight = e.lineHeight, this._styleNotSet = !1) : this._styleNotSet = !0;
};
pi.prototype._updateStyle = function() {
  return this.requireDiv || !this.ctx ? this._setStyleOfDiv() : this._setStyleOfCanvas();
};
pi.prototype.setStyle = function(e) {
  return this.style = Tt.parseStyle(e), Tt.setLineHeight(this.style), this;
};
pi.prototype.useEllipsesOnOverflow = function(e) {
  return this._init ? (this._showNoEllipses = !e, this) : this;
};
pi.prototype.getSmartText = function(e, t, i, n) {
  var s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  if (!this._init)
    return !1;
  e == null ? e = "" : typeof e != "string" && (e = e.toString());
  var A, o, a, r, l, c, g, h, d, u, f, C, I, E, B, m, p, w, Q, y, D, _, x, S, b, R, G = !1, T = 0, v = -1, H = -1, N = -1, M = 0, F = 0, k = [], O = "", P = 0, L, q = this._showNoEllipses ? "" : "...", $, W, U, J, V, Y, nt = this.ctx, tt = [], st = -1, lt = -1, at = -1, Dt, Qt, St = function(_t) {
    _t = _t.replace(/^\s\s*/, "");
    for (var zt = /\s/, te = _t.length; zt.test(_t.charAt(te -= 1)); )
      ;
    return _t.slice(0, te + 1);
  }, At = { text: e, maxWidth: t, maxHeight: i, width: null, height: null, oriTextWidth: null, oriTextHeight: null, oriText: e, isTruncated: !1 };
  if (G = s.hasHTMLTag !== void 0 ? s.hasHTMLTag : Tt.xmlTagRegEx.test(e) || Tt.nbspRegex.test(e), Dt = Tt._hasOnlyBRTag(e), this.requireDiv = G && !Dt, this._updateStyle(), $ = this._lineHeight, W = this._context, U = this._container, J = this._containerObj, V = J.ellipsesWidth, Y = J.dotWidth, c = e.replace(Tt.spanAdditionRegx, "$2"), C = this._getWidthFn(), $ - i <= 1 && $ - i >= 0 && (i *= 1.2), nt || U) {
    if (!jA.isBrowserLess) {
      if (s.cleanText !== !0 ? (r = e = e.replace(Tt.ltgtquotRegex, function(Vt) {
        switch (Vt) {
          case "&lt;":
            return "<";
          case "&gt;":
            return ">";
          case "&quot;":
            return '"';
          case "&#034;":
            return '"';
          case "&#039;":
            return "'";
        }
      }), L = e, r = e = r.replace(/<u>/g, "").replace(/<\/u>/g, "").replace(/<b>/g, "").replace(/<\/b>/g, "").replace(/<strong>/g, "").replace(/<\/strong>/g, "").replace(/<em>/g, "").replace(/<\/em>/g, "").replace(/<i>/g, "").replace(/<\/i>/g, "").replace(/<strike>/g, "").replace(/<\/strike>/g, "").replace(/<s>/g, "").replace(/<\/s>/g, "").replace(/<del>/g, "").replace(/<\/del>/g, "").replace(/<sub>/g, "").replace(/<\/sub>/g, "").replace(/<sup>/g, "").replace(/<\/sup>/g, "").replace(/<a[\s]+([^>]+)>/g, "").replace(/<\/a>/g, "").replace(/<abbr[\s]+([^>]+)>/g, "").replace(/<\/abbr>/g, "").replace(/<span[\s]+([^>]+)>/g, "").replace(/<\/span>/g, "")) : (r = e, L = e), G ? Dt ? (e = e.replace(Tt.brRegex, "<br />"), Qt = Tt._getDimentionOfMultiLineText(e, this), At.oriTextWidth = g = Qt.width, At.oriTextHeight = h = Qt.height) : (U.innerHTML = e, At.oriTextWidth = g = U.offsetWidth, At.oriTextHeight = h = U.offsetHeight) : (r = e, s.cleanText !== !0 && (r = e = e.replace(Tt.ltgtquotRegex, function(Vt) {
        switch (Vt) {
          case "&lt;":
            return "<";
          case "&gt;":
            return ">";
          case "&quot;":
            return '"';
          case "&#034;":
            return '"';
          case "&#039;":
            return "'";
        }
      }), r = e = r.replace(/<u>/g, "").replace(/<\/u>/g, "").replace(/<b>/g, "").replace(/<\/b>/g, "").replace(/<strong>/g, "").replace(/<\/strong>/g, "").replace(/<em>/g, "").replace(/<\/em>/g, "").replace(/<i>/g, "").replace(/<\/i>/g, "").replace(/<strike>/g, "").replace(/<\/strike>/g, "").replace(/<s>/g, "").replace(/<\/s>/g, "").replace(/<del>/g, "").replace(/<\/del>/g, "").replace(/<sub>/g, "").replace(/<\/sub>/g, "").replace(/<sup>/g, "").replace(/<\/sup>/g, "").replace(/<a[\s]+([^>]+)>/g, "").replace(/<\/a>/g, "").replace(/<abbr[\s]+([^>]+)>/g, "").replace(/<\/abbr>/g, "").replace(/<span[\s]+([^>]+)>/g, "").replace(/<\/span>/g, "")), B = this.getSize(r, !0, { hasHTMLTag: G, hasOnlyBrTag: Dt, cleanText: !0 }), At.oriTextWidth = g = B.width, At.oriTextHeight = h = B.height), h <= i && g <= t)
        return O = CQ(L, e), At.text = O, At.width = At.oriTextWidth = g, At.height = At.oriTextHeight = h, At;
      if ($ > i)
        return At.text = "", At.width = At.oriTextWidth = 0, At.height = At.oriTextHeight = 0, At;
    }
    if (e = St(e).replace(/(\s+)/g, " "), l = this._showNoEllipses ? t : t - V, !G || Dt) {
      if (k = Tt._getTextArray(e), A = k.length, o = "", a = [], f = k[0], this._cache[f] ? Q = this._cache[f].width : (Q = C(f), this._cache[f] = { width: Q }), l > Q && !Dt)
        a = e.substr(0, Tt.getNearestBreakIndex(e, l, this)).split("");
      else {
        if (Q > t)
          return At.text = "", At.width = At.oriTextWidth = At.height = At.oriTextHeight = 0, At;
        q && (l = t - 2 * Y, l > Q ? q = ".." : (l = t - Y, l > Q ? q = "." : (l = 0, q = "")));
      }
      if (P = a.length, M = C(a.join("")), F = this._lineHeight, n) {
        for (; P < A; P += 1) {
          if (f = a[P] = k[P], a[P] === "<br />") {
            F += this._lineHeight, N = P, T = GA(T, M), M = 0, o = null;
            continue;
          }
          if (this._cache[f] ? Q = this._cache[f].width : ((!B || !(Q = B.detailObj[f])) && (Q = C(f)), this._cache[f] = { width: Q }), M += Q, M > l && (o || (o = a.slice(0, -1).join("")), M > t))
            return At.text = St(o) + q, At.tooltext = At.oriText, At.width = GA(T, M), At.height = F, At.isTruncated = !0, At;
        }
        return At.text = a.join(""), At.width = GA(T, M), At.height = F, At;
      } else {
        for (; P < A; P += 1) {
          if (f = a[P] = k[P], f === " " && !W && (f = this.ctx ? " " : "&nbsp;"), a[P] === "<br />") {
            if (T = GA(T, M), F += this._lineHeight, F <= i) {
              N = P, M = 0, o = null;
              continue;
            } else if (F > i)
              return o = a.slice(0, -1).join(""), At.text = St(o) + q, At.tooltext = c, At.width = T, At.height = F - this._lineHeight, At.isTruncated = !0, At;
          }
          if (this._cache[f] ? Q = this._cache[f].width : ((!B || !(Q = B.detailObj[f])) && (Q = C(f)), this._cache[f] = { width: Q }), M += Q, M > l && (o || (o = a.slice(0, -1).join("")), M > t)) {
            if (k[P + 1] === "<br />")
              continue;
            if (H = Tt._findLastIndex(k.slice(0, a.length), " "), v = Tt._findLastIndex(k.slice(0, a.length), "-"), H > N ? (M = C(a.slice(N + 1, H).join("")), a.splice(H, 1, "<br />"), N = H, d = H + 1) : v > N ? (v === a.length - 1 ? (M = C(a.slice(N + 1, H).join("")), a.splice(v, 1, "<br />-")) : (M = C(a.slice(N + 1, H).join("")), a.splice(v, 1, "-<br />")), N = v, d = v + 1) : (a.splice(a.length - 1, 1, "<br />" + k[P]), at = a.length - 2, M = C(a.slice(N + 1, at + 1).join("")), N = at, d = P), F += this._lineHeight, F > i)
              return At.text = St(o) + q, At.tooltext = At.oriText, At.width = t, At.height = F - this._lineHeight, At.isTruncated = !0, At;
            T = GA(T, M), o = null, Dt ? M = Tt._getDimentionOfMultiLineText(a.slice(N + 1).join(""), this).width : (u = Tt.getNearestBreakIndex(e.substr(d), l, this), M = C(e.substr(d, u || 1)), a.length < d + u && (a = a.concat(e.substr(a.length, d + u - a.length).split("")), P = a.length - 1));
          }
        }
        return T = GA(T, M), O = CQ(L, a.join("")), At.text = O, At.width = T, At.height = F, At;
      }
    } else {
      for (c = e.replace(Tt.spanAdditionRegx, "$2"), e = e.replace(Tt.spanAdditionRegx, Tt.spanAdditionReplacer), e = e.replace(/(<br\s*\/*\>)/g, '<span class="' + [Tt.classNameWithTag, " ", Tt.classNameWithTagBR].join("") + '">$1</span>'), U.innerHTML = e, m = U[jA.childRetriverFn](jA.childRetriverString), p = 0, w = m.length; p < w; p += 1)
        y = m[p], (jA.noClassTesting || Tt.classNameReg.test(y.className)) && (D = y.innerHTML, D !== "" && (D === " " ? lt = tt.length : D === "-" && (st = tt.length), tt.push({ spaceIdx: lt, dashIdx: st, elem: y }), k.push(D)));
      if (P = 0, A = tt.length, Q = A && tt[0].elem.offsetWidth, Q > t || !A)
        return At.text = "", At.width = At.oriTextWidth = At.height = At.oriTextHeight = 0, At;
      if (Q > l && !this._showNoEllipses && (l = t - 2 * Y, l > Q ? q = ".." : (l = t - Y, l > Q ? q = "." : (l = 0, q = ""))), I = tt[0].elem.offsetLeft, E = tt[0].elem.offsetTop, n)
        for (; P < A; P += 1)
          y = tt[P].elem, _ = y.offsetLeft - I + y.offsetWidth, _ > l && (R || (R = P), U.offsetWidth > t && (b = P, P = A));
      else
        for (; P < A; P += 1)
          y = tt[P].elem, x = y.offsetHeight + (y.offsetTop - E), _ = y.offsetLeft - I + y.offsetWidth, S = null, _ > l ? (R || (R = P), _ > t && (H = tt[P].spaceIdx, v = tt[P].dashIdx, H > N ? (tt[H].elem.innerHTML = "<br/>", N = H) : v > N ? (v === P ? tt[v].elem.innerHTML = "<br/>-" : tt[v].elem.innerHTML = "-<br/>", N = v) : y.parentNode.insertBefore(S = uS.createElement("br"), y), y.offsetHeight + y.offsetTop > i ? (S ? S.parentNode.removeChild(S) : N === v ? tt[v].elem.innerHTML = "-" : tt[H].elem.innerHTML = " ", b = P, P = A) : R = null)) : x > i && (b = P, P = A);
      if (b < A) {
        for (At.isTruncated = !0, R = R || b, P = A - 1; P >= R; P -= 1)
          y = tt[P].elem, y.parentNode.removeChild(y);
        for (; P >= 0; P -= 1)
          y = tt[P].elem, Tt.classNameBrReg.test(y.className) ? y.parentNode.removeChild(y) : P = 0;
      }
      At.text = U.innerHTML.replace(Tt.spanRemovalRegx, "$1").replace(/\&amp\;/g, "&"), At.isTruncated && (At.text += q, At.tooltext = c);
    }
    return At.height = U.offsetHeight, At.width = U.offsetWidth, At;
  } else
    return At.error = new Error("Body Tag Missing!"), At;
};
pi.prototype.getSize = function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!this._init)
    return !1;
  e == null ? e = "" : typeof e != "string" && (e = e.toString());
  var n, s, A, o, a, r = 0, l = 0, c, g = {}, h = i.hasHTMLTag, d = i.hasOnlyBrTag;
  if (typeof h > "u" && (h = Tt.xmlTagRegEx.test(e) || Tt.nbspRegex.test(e)), typeof d > "u" && (d = Tt._hasOnlyBRTag(e)), this.requireDiv = h && !d, i.cleanText || (e = e.replace(Tt.ltgtquotRegex, function(u) {
    switch (u) {
      case "&lt;":
        return "<";
      case "&gt;":
        return ">";
      case "&quot;":
        return '"';
      case "&#034;":
        return '"';
      case "&#039;":
        return "'";
    }
  }), e = e.replace(/<u>/g, "").replace(/<\/u>/g, "").replace(/<b>/g, "").replace(/<\/b>/g, "").replace(/<strong>/g, "").replace(/<\/strong>/g, "").replace(/<em>/g, "").replace(/<\/em>/g, "").replace(/<i>/g, "").replace(/<\/i>/g, "").replace(/<strike>/g, "").replace(/<\/strike>/g, "").replace(/<s>/g, "").replace(/<\/s>/g, "").replace(/<del>/g, "").replace(/<\/del>/g, "").replace(/<sub>/g, "").replace(/<\/sub>/g, "").replace(/<sup>/g, "").replace(/<\/sup>/g, "").replace(/<a[\s]+([^>]+)>/g, "").replace(/<\/a>/g, "").replace(/<abbr[\s]+([^>]+)>/g, "").replace(/<\/abbr>/g, "").replace(/<span[\s]+([^>]+)>/g, "").replace(/<\/span>/g, "")), this._updateStyle(), c = this._container, t)
    for (n = e.split(""), o = 0, a = n.length; o < a; o++)
      s = n[o], A = this._calCharDimWithCache(s, !1, n.length), l = GA(l, A.height), r += A.width, g[s] = A.width;
  else
    return this._calCharDimWithCache(e);
  return d ? fQ(fQ({}, Tt._getDimentionOfMultiLineText(e, this)), {}, { detailObj: g }) : h ? (c.innerHTML = e, { width: c.offsetWidth, height: c.offsetHeight, detailObj: g }) : { width: $P(r), height: l, detailObj: g };
};
pi.prototype.getOriSize = function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return this.getSize(e, t, i);
};
pi.prototype.dispose = function() {
  return this._init ? (this._containerManager && this._containerManager.dispose && this._containerManager.dispose(), delete this._container, delete this._context, delete this._cache, delete this._containerManager, delete this._containerObj, delete this.id, delete this.style, delete this.parentContainer, delete this._showNoEllipses, this) : this;
};
const aY = {
  cleanText: !0,
  hasHTMLTag: !1
};
let rY = class {
  labelManager;
  constructor(t = 1, i = "body") {
    this.labelManager = new pi(t, i);
  }
  static textToLines(t) {
    return pi.textToLines(t);
  }
  getOriSize(t = "") {
    return this.labelManager.getOriSize(t, !0, aY);
  }
  setStyle(t = {}) {
    return this.labelManager.setStyle(t), this;
  }
  useEllipsesOnOverflow(t = !1) {
    return this.labelManager.useEllipsesOnOverflow(t), this;
  }
  getSmartText(t, i, n, s, A = { hasHTMLTag: !1, cleanText: !0 }) {
    return this.labelManager.getSmartText(
      t,
      i,
      n,
      s,
      A
    );
  }
};
const CS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AggregationType: Hx,
  CONSTANTS: Zw,
  COORD_TYPES: va,
  CommonProps: ka,
  DEFAULT_SORT_CONFIG: vo,
  DUMMY_FIELD_NAME: ht,
  DataModel: Ae,
  DataStore: K,
  Delaunay: Pd,
  ERROR_MSG: yt,
  FieldAs: Ux,
  get FieldSubtype() {
    return ot;
  },
  get FieldType() {
    return Ct;
  },
  ID_FIELD_NAME: ml,
  Invalid: qt,
  LabelManager: rY,
  MuzeError: Gn,
  get Operations() {
    return ne;
  },
  Path: Kd,
  RTree: Io,
  ReservedFields: pt,
  SORT_ORDERING_TYPE: Ki,
  STATE_NAMESPACES: JL,
  Scales: dE,
  Store: Rl,
  Symbols: fn,
  VARIABLE_TYPE_COMPOSED_VAR: RC,
  VARIABLE_TYPE_NULL_VAR: qw,
  VARIABLE_TYPE_SIMPLE_VAR: Ww,
  Voronoi: gE,
  addClass: YP,
  angleToRadian: qA,
  appendElement: rS,
  applyHyperLink: uc,
  applyStyle: Ji,
  arraysEqual: hE,
  cancelAnimFrame: D3,
  capitalizeFirst: x3,
  cellFromLeaf: Gi,
  checkExistence: rx,
  clipElement: cS,
  clone: lE,
  colorInterpolator: Bx,
  colorSchemes: zf,
  componentRegistry: rl,
  containsTotalsAxis: vx,
  createElement: gS,
  createElements: _E,
  createSelection: Cx,
  createValuesSorter: zd,
  d3Difference: Ka,
  d3Group: pa,
  d3Hierarchy: un,
  d3Hsl: CA,
  d3Max: xi,
  d3Min: ex,
  d3Mouse: wE,
  d3Range: Qa,
  d3Sum: Ii,
  d3Transpose: Ye,
  d3Zip: AI,
  dataSelect: sx,
  deepClone: Ix,
  deepEquals: _l,
  defaultValue: wt,
  detectColor: $r,
  difference: W3,
  easeFns: lc,
  escapeHTML: wx,
  extendArray: t8,
  extendsClass: Dx,
  extractExcludingKeyValues: Mx,
  extractKeyValues: Rg,
  formatTemporal: pA,
  formatTimestampAs: To,
  genStringOfLength: mh,
  generateGetterSetters: ve,
  getArrayDiff: O3,
  getArrayIndexMap: T3,
  getArraySum: fx,
  getBinRange: J3,
  getClientPoint: io,
  getClosestIndexOf: hx,
  getD3Drag: hr,
  getDataStore: dv,
  getDependencyOrder: ux,
  getDomainForBinnedField: uE,
  getDomainFromData: m3,
  getElementPosition: Rn,
  getElementsByClassName: KP,
  getEvent: bt,
  getFormattedBinValue: Co,
  getIndexMap: j3,
  getMax: is,
  getMaxPoint: gI,
  getMin: Hs,
  getMinDiff: S3,
  getMinPoint: Q3,
  getMousePos: _h,
  getNearestValue: hI,
  getNodeTargetDeterminator: ll,
  getNormalizedFieldName: z3,
  getObjProp: Z,
  getQualifiedClassName: ms,
  getQueryFromTarget: lr,
  getRangeWithSteps: Rx,
  getReadableTicks: rr,
  getSelectionStyle: Fx,
  getSmallestDiff: Vd,
  getSmartComputedStyle: Ls,
  getSymbol: cc,
  getUniqueId: Zt,
  getValueParser: fE,
  getWindow: dx,
  hasMatchingTarget: ca,
  hasTargetDomainValue: yh,
  hasTouch: bE,
  hexToHsv: Qx,
  hslInterpolator: F3,
  hslToRgb: mx,
  hslaToRgb: v3,
  hsvToRgb: px,
  intSanitizer: zr,
  interpolateArray: b3,
  interpolator: Ex,
  intersect: Wd,
  intersectAny: q3,
  isComposedVariable: cr,
  isEmptyCellTarget: Nl,
  isEqual: eo,
  isHTMLElem: _3,
  isIncludesInArray: uI,
  isInvalidValue: Xe,
  isNullOrUndefined: Nx,
  isObjectWithKey: Rs,
  isPointInsidePolygon: i8,
  isRetinalFieldCollapsed: kx,
  isSameValue: Ml,
  isSimpleObject: ke,
  isValidValue: yx,
  isValueWithinRange: Va,
  isVertical: jd,
  makeElement: z,
  mergeFns: Z3,
  mergeRecursive: et,
  mix: ci,
  multiFieldUnionDomain: Eh,
  nestCollection: xx,
  nextAnimFrame: K3,
  nextFrame: M3,
  numberInterpolator: Yd,
  numericAsc: fI,
  numericDesc: $3,
  objectIterator: cE,
  parseNumberFromString: us,
  partition: EE,
  pathInterpolators: gc,
  perfCalculator: X3,
  piecewiseInterpolator: Jd,
  pointWithinCircle: bx,
  polygonArea: nx,
  polygonCentroid: cI,
  removeClass: JP,
  replaceCSSPrefix: N3,
  reqAnimFrame: w3,
  resolveFieldView: bi,
  retrieveFieldDisplayName: dc,
  retrieveNearestGroupByReducers: hc,
  rgbToHsv: ya,
  sanitizeDomainWhenEqual: rc,
  sanitizeIP: lx,
  sanitizeSortConfig: Go,
  scales: ND,
  selectElement: X,
  setAttrs: hA,
  setDifference: qd,
  setIntersection: BE,
  setStyles: vt,
  sortCategoricalData: dI,
  sortCategoricalField: IE,
  sortContinuousField: CE,
  sortNumericData: V3,
  sortValues: kg,
  sortValuesBasedOnOtherValues: Qh,
  sortValuesWithAlphabeticalOrderingType: Gx,
  sortValuesWithCustomValuesOrderingType: Lx,
  sortValuesWithNaturalOrderingType: Tx,
  stack: H3,
  symbolFns: cx,
  throttle: Gf,
  timeDay: ic,
  timeFormats: Sx,
  timeFriday: jC,
  timeHour: ec,
  timeInterval: le,
  timeMillisecond: es,
  timeMinute: tc,
  timeMonday: Ha,
  timeMonth: kd,
  timeSaturday: zC,
  timeSecond: Us,
  timeSunday: Ua,
  timeThursday: EA,
  timeTuesday: WC,
  timeWednesday: qC,
  timeWeek: Ua,
  timeYear: Es,
  toArray: Bn,
  toTextualValue: Zi,
  transactor: dS,
  transformColor: _x,
  transformColors: R3,
  transposeArray: G3,
  unionAxisDomainsRowColumnWise: bl,
  unionDomain: we,
  unionExtendDomainDiff: rn,
  unionModels: Nn,
  unique: Bh,
  utcDay: Ac,
  utcFriday: ZC,
  utcHour: sc,
  utcMillisecond: es,
  utcMinute: nc,
  utcMonday: Pa,
  utcMonth: vd,
  utcSaturday: tE,
  utcSecond: Us,
  utcSunday: Oa,
  utcThursday: BA,
  utcTuesday: $C,
  utcWednesday: XC,
  utcWeek: Oa,
  utcYear: Bs
}, Symbol.toStringTag, { value: "Module" })), On = "muze", Wt = "stack", Xt = "stack100percent", jn = "group", ns = "identity", lY = "angle", cY = "radius", ME = "size", NE = "color", FE = "opacity", RE = "backgroundColor", kE = "shape", vE = "text", gY = "detail", hY = "outerRadiusValue", ES = "middle", Gt = {
  X: "x",
  Y: "y",
  X0: "x0",
  Y0: "y0",
  RADIUS: "radius",
  RADIUS0: "radius0",
  ANGLE: "angle",
  ANGLE0: "angle0",
  COLOR: "color",
  OPACITY: "opacity",
  BACKGROUND_COLOR: "backgroundColor",
  SHAPE: "shape",
  SIZE: "size",
  TEXT: "text",
  DETAIL: "detail"
}, dY = "stroke-dasharray", BS = "asc", TE = "sum", mS = "area", pS = "arc", QS = "line", uY = "text", yS = "point", GE = "bar", fY = "tick", IY = "simple", wS = "base", DS = "left", xS = "right", As = "center", LE = "auto", Si = "outside-top", Wi = "outside-right", Ps = "outside-bottom", vn = "outside-left", za = "inside-top", $a = "inside-right", Xa = "inside-bottom", Za = "inside-left", UE = [
  Si,
  Wi,
  Ps,
  vn
], HE = [
  As,
  za,
  $a,
  Xa,
  Za
], SS = 5, _S = 5, bS = 10, MS = 20, NS = 50, FS = 0.35, RS = 0.9, kS = 0.7, vS = 0.5, CY = "#393945", yI = On + "-text-cell-prop-color-default-dark", wI = On + "-text-cell-prop-color-default-light", TS = On + "-area-border", DI = 2, xa = 3, OA = 5, vl = 1, bh = "groupPlotHover", Bo = "group-highlight", eu = "group-plot-highlighter", EY = "vertical", BY = "horizontal", tr = "percentage", mY = "value", pY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AGG_FN_SUM: TE,
  ANCHORS_INSIDE: HE,
  ANCHORS_OUTSIDE: UE,
  ANGLE: lY,
  ARC_LAYER: pS,
  AREA_BORDERS_PATH_CLASSNAME: TS,
  AREA_LAYER: mS,
  ASCENDING: BS,
  AUTO: LE,
  BACKGROUND_COLOR: RE,
  BAR_LAYER: GE,
  BASE_LAYER: wS,
  CENTER: As,
  CLASSPREFIX: On,
  COLOR: NE,
  DARK_BACKGROUND_FONT_COLOR: CY,
  DETAIL: gY,
  ENCODING: Gt,
  EXTRA_RADIUS_PERC: FS,
  GROUP: jn,
  GROUP_HIGHLIGHT_BEHAVIOUR: Bo,
  GROUP_PLOT_HIGHLIGHTER_SIDE_EFFECT: eu,
  GROUP_PLOT_HOVER_PHYSICAL_ACTION: bh,
  HORIZONTAL: BY,
  IDENTITY: ns,
  INSIDE_BOTTOM: Xa,
  INSIDE_LEFT: Za,
  INSIDE_RIGHT: $a,
  INSIDE_TOP: za,
  LABEL_PADDING: DI,
  LEFT: DS,
  LINE_LAYER: QS,
  MAX_ALLOWED_RADIUS_REDUCE_FOR_CLIPPING_IN_PERC: vS,
  MAX_EXTRA_RADIUS: NS,
  MAX_ITERATION_COUNT_ON_GROUPING: SS,
  MAX_LENGTH_FOR_CONNECTOR: RS,
  MAX_LENGTH_FOR_OVERLAPPING_CONNECTOR: kS,
  MIN_EXTRA_RADIUS: MS,
  OPACITY: FE,
  OUTER_RADIUS_VALUE: hY,
  OUTSIDE_BOTTOM: Ps,
  OUTSIDE_LEFT: vn,
  OUTSIDE_RIGHT: Wi,
  OUTSIDE_TOP: Si,
  PERCENTAGE: tr,
  PIVOT_MULTI_TEXT_INNER_CELL_DISTANCE: xa,
  PIVOT_MULTI_TEXT_OUTER_CELL_BORDER_WIDTH: vl,
  PIVOT_MULTI_TEXT_OUTER_CELL_DISTANCE: OA,
  POINT_LAYER: yS,
  RADIUS: cY,
  RIGHT: xS,
  SHAPE: kE,
  SIMPLE_LAYER: IY,
  SIZE: ME,
  STACK: Wt,
  STACK100PERCENT: Xt,
  STROKE_DASHARRAY: dY,
  TEXT: vE,
  TEXT_ANCHOR_MIDDLE: ES,
  TEXT_CELL_CLASSNAME_DARK_FONT_COLOR: yI,
  TEXT_CELL_CLASSNAME_LIGHT_FONT_COLOR: wI,
  TEXT_LABEL_CONNECTOR_CROOK_DISTANCE: bS,
  TEXT_LABEL_VERTICAL_PADDING: _S,
  TEXT_LAYER: uY,
  TICK_LAYER: fY,
  VALUE: mY,
  VERTICAL: EY
}, Symbol.toStringTag, { value: "Module" })), QY = {}, yY = {
  executePostPropagation: !1
}, Ht = {
  CANVAS: "canvas",
  UNIT: "unit",
  LAYER: "layer",
  AXIS: "axis",
  LEGEND: "legend"
}, ze = {
  ALL: "all",
  EACH: "each"
}, mt = {
  INITIALIZED: "initialized",
  BEFORE_RENDERED: "beforeRendered",
  AFTER_RENDERED: "afterRendered",
  BEFORE_LAYOUT: "beforeLayout",
  AFTER_LAYOUT: "afterLayout",
  BEFORE_DISPOSED: "beforeDisposed",
  AFTER_DISPOSED: "afterDisposed",
  ANIMATION_END: "animationEnd"
}, Xc = "canvas-aggregate-event-tag", Zc = "visual-group-aggregate-event-tag", tg = "visual-unit-aggregate-event-tag";
class $e {
  constructor(t) {
    const { componentPath: i, modifier: n, hookName: s } = typeof t == "object" ? t : GS(String(t));
    if (!(Array.isArray(i) && i.length && n && s))
      throw new Error("Invalid event name syntax!");
    this.componentPath = i, this.modifier = n, this.hookName = s;
  }
  stringify() {
    return `${this.componentPath.join(":")}.${this.modifier}.${this.hookName}`;
  }
}
const GS = (e) => {
  const t = e.trim().split(".");
  let i, n, s;
  if (t.length === 1)
    i = [], n = ze.EACH, s = t[0];
  else if (t.length === 2)
    i = t[0].split(":"), n = ze.ALL, s = t[1];
  else if (t.length === 3)
    i = t[0].split(":"), n = t[1], s = t[2];
  else
    throw new Error(`Invalid event name, could not parse: ${e}`);
  return {
    componentPath: i,
    modifier: n,
    hookName: s
  };
};
class OE {
  constructor(t, i) {
    this._parent = t || null, this._events = /* @__PURE__ */ new Map(), this._config = et({}, QY, i || {});
  }
  addListener(t, i, n, s) {
    return this._addAnyListener(t, i, !1, !1, n, s), this;
  }
  on(t, i, n, s) {
    return this.addListener(t, i, n, s), this;
  }
  once(t, i, n, s) {
    return this._addAnyListener(t, i, !0, !1, n, s), this;
  }
  prependListener(t, i, n, s) {
    return this._addAnyListener(t, i, !1, !0, n, s), this;
  }
  prependOnceListener(t, i, n, s) {
    return this._addAnyListener(t, i, !0, !0, n, s), this;
  }
  _addAnyListener(t, i, n, s, A, o) {
    const { executePostPropagation: a } = et(
      {},
      yY,
      o
    ), r = t.stringify(), l = {
      listener: i,
      once: n,
      meta: A || null,
      executePostPropagation: a
    }, c = this._events.get(r);
    c ? s ? c.unshift(l) : c.push(l) : this._events.set(r, [l]);
  }
  removeListener(t, i) {
    const n = t.stringify(), s = this._events.get(n);
    if (s) {
      for (let A = s.length - 1; A >= 0; A--)
        if (s[A].listener === i) {
          s.splice(A, 1);
          break;
        }
    }
    return this;
  }
  off(t, i) {
    return this.removeListener(t, i), this;
  }
  removeAllListeners(t) {
    const i = t.stringify();
    return this._events.delete(i), this;
  }
  listeners(t) {
    const i = t.stringify();
    return (this._events.get(i) || []).slice();
  }
  eventNames() {
    return [...this._events.keys()].map((t) => new $e(t));
  }
  listenerCount(t) {
    const i = t.stringify();
    return (this._events.get(i) || []).length;
  }
  emit(t) {
    const i = t.name.stringify(), s = (this._events.get(i) || []).slice(), A = [];
    for (let o = 0; o < s.length; o++) {
      const a = s[o];
      if (a.executePostPropagation) {
        A.push(a);
        continue;
      }
      if (this._triggerSingleListener(a, t), t.isStoppedImmediatePropagation())
        return this;
    }
    t.isStoppedPropagation() || this._parent && this._parent.emit(t);
    for (let o = 0; o < A.length; o++) {
      const a = A[o];
      if (this._triggerSingleListener(a, t), t.isStoppedImmediatePropagation())
        return this;
    }
    return this;
  }
  _triggerSingleListener(t, i) {
    const n = i.name.stringify();
    if (t.once) {
      const s = this._events.get(n) || [], A = s.findIndex(
        (o) => o.listener === t.listener
      );
      s.splice(A, 1);
    }
    try {
      t.listener.call(this, i, t.meta);
    } catch (s) {
      console.error(s);
    }
  }
  remove() {
    this._events.clear();
  }
  createChild(t) {
    return new OE(this, t);
  }
  parent(...t) {
    return t.length ? (this._parent = t[0], this) : this._parent;
  }
  config(...t) {
    return t.length ? (this._config = t[0], this) : this._config;
  }
}
const wY = {
  name: null,
  emitter: null,
  target: null,
  data: null,
  virtualScrolling: { viewportRange: null, partialRange: null }
};
class DY {
  constructor(t) {
    t = et({}, wY, t), this.name = t.name, this.emitter = t.emitter, this.target = t.target, this.data = t.data, this.virtualScrolling = t.virtualScrolling, this.timestamp = Date.now(), this._stopPropagation = !1, this._stopImmediatePropagation = !1;
  }
  stopPropagation() {
    this._stopPropagation = !0;
  }
  stopImmediatePropagation() {
    this._stopImmediatePropagation = !0;
  }
  isStoppedPropagation() {
    return this._stopPropagation;
  }
  isStoppedImmediatePropagation() {
    return this._stopImmediatePropagation;
  }
}
const EQ = (e, t, i, n, s, A) => {
  let o = [null, null], a = [null, null], r, l, c = !1;
  t.forEach((g, h) => {
    g.forEach((d, u) => {
      d && d.eventManager()[A ? "prependListener" : "on"](
        e,
        (f) => {
          const { rowRange: C, colRange: I } = n(), E = (m) => {
            i.call(void 0, {
              eventObjects: m ? [...r, ...m] : r,
              ranges: { rowRange: C, colRange: I }
            });
          };
          if (!(BQ(o, C) && BQ(a, I))) {
            o = [...C], a = [...I], r = [], l = /* @__PURE__ */ new Set();
            for (let m = o[0]; m <= o[1]; m++)
              for (let p = a[0]; p <= a[1]; p++)
                t[m] && t[m][p] && l.add(`${m}-${p}`);
            c = !1;
          }
          if (c) {
            E([f]);
            return;
          }
          const B = `${h}-${u}`;
          l.has(B) && (r.push(f), l.delete(B)), l.size === 0 && (E(), c = !0);
        },
        s,
        {
          executePostPropagation: !0
        }
      );
    });
  });
}, BQ = (e, t) => e[0] === t[0] && e[1] === t[1], xY = (e, t, i, n) => {
  let s, A;
  const o = t.filter((r) => !!r), a = () => {
    s = [], A = /* @__PURE__ */ new Set();
  };
  a(), o.forEach((r) => {
    r.eventManager().on(
      e,
      (l) => {
        A.has(r) && a(), s.push(l), A.add(r), s.length >= o.length && (i.call(void 0, s), a());
      },
      n,
      {
        executePostPropagation: !0
      }
    );
  });
}, Js = () => {
  const e = [];
  return {
    newCallback: () => {
      let t;
      const i = new Promise((n) => {
        t = n;
      });
      return e.push(i), () => {
        t();
      };
    },
    onAllCallbacksCalled: () => Promise.all(e)
  };
}, Lo = (e) => class extends e {
  constructor(...t) {
    super(...t), this._eventManager = null;
  }
  eventManager(...t) {
    return t.length ? (this._eventManager = t[0], this) : this._eventManager;
  }
  createChildEventManager(t) {
    return this._eventManager.createChild(t);
  }
  emitEvent(t) {
    if (this._eventManager) {
      const i = et(
        { emitter: this, target: [this] },
        t
      ), n = new DY(i);
      this._eventManager.emit(n);
    }
  }
  associatedHookComponentPaths() {
    throw new Error("Please implement this method!");
  }
  emitSelfHooks(t, i, n) {
    const s = Array.isArray(t) ? t : [t], A = n || this.associatedHookComponentPaths();
    s.forEach((o) => {
      A.forEach((a) => {
        const r = et({}, i, {
          name: new $e({
            componentPath: a,
            modifier: ze.EACH,
            hookName: o
          })
        });
        this.emitEvent(r);
      });
    });
  }
}, LS = (e) => (t) => class extends ci(t).with(Lo) {
  constructor(...i) {
    super(...i);
  }
  addListener(i, n, s) {
    return this.eventManager().addListener(
      this._resolveEventName(i),
      n,
      s
    ), this;
  }
  on(i, n, s) {
    return this.eventManager().on(
      this._resolveEventName(i),
      n,
      s
    ), this;
  }
  once(i, n, s) {
    return this.eventManager().once(
      this._resolveEventName(i),
      n,
      s
    ), this;
  }
  prependListener(i, n, s) {
    return this.eventManager().prependListener(
      this._resolveEventName(i),
      n,
      s
    ), this;
  }
  prependOnceListener(i, n, s) {
    return this.eventManager().prependOnceListener(
      this._resolveEventName(i),
      n,
      s
    ), this;
  }
  removeListener(i, n) {
    return this.eventManager().removeListener(
      this._resolveEventName(i),
      n
    ), this;
  }
  off(i, n) {
    return this.eventManager().off(this._resolveEventName(i), n), this;
  }
  removeAllListeners(i) {
    return this.eventManager().removeAllListeners(
      this._resolveEventName(i)
    ), this;
  }
  listeners(i) {
    return this.eventManager().listeners(
      this._resolveEventName(i)
    );
  }
  eventNames() {
    return this.eventManager().eventNames();
  }
  listenerCount(i) {
    return this.eventManager().listenerCount(
      this._resolveEventName(i)
    );
  }
  _resolveEventName(i) {
    const n = GS(i);
    return n.componentPath.length || (n.componentPath = [e]), new $e(n);
  }
};
class US {
  formalName() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Sets or gets the dependencies.
   * @param {Object} dependencies Dependencies needed by layer
   * @return {BaseLayer} Instance of base layer.
   */
  dependencies() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Returns the config of the layer
   *
   * @param {Object} config Configuration of layer
   * @return {Object} configuration of layer
   */
  config() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Acts as a getter or setter function
   * When setter
   * Returns the datamodel of the layer
   * @param { DataModel } dataModel instance of DataModel
   * @return { DataModel } DataModel instance of the layer
   */
  data() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Returns a serialized schema of the layer
   * @return {Object} Serialized schema
   */
  serialize() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Returns the unique identifier of this layer
   * @return {string} id of the layer
   */
  id() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /*
   * This method resolves the x, y, x0 and y0 values from the transformed data.
   * It also checks the type of transformed data for example, if it is a stacked data
   * then it fetches the y and y0 values from the stacked data.
   * @param {Array.<Array>} transformedData transformed data
   * @param {Object} fieldMap field definitions
   * @param {string} transformType type of transformed data - stack, group or identity.
   * @return {Array.<Object>} Normalized data
   * @private
   */
  normalizeTransformedData() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Gets the transform method from transform factory based on type of transform. It then calls the
   * transform method with the data and passes the configuration parameters of transform such as
   * groupBy, value field, etc.
   *
   * @param {DataModel} dataModel Instance of dataModel
   * @param {Object} config configuration for transforming data
   * @return {Array.<Array>} Transformed data.
   * @private
   */
  getTransformedData() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Calculates the domain from the data.
   * It checks the type of field and calculates the domain based on that. For example, if it
   * is a quantitative or temporal field, then it calculates the min and max from the data or
   * if it is a nominal field then it gets all the values from the data of that field.
   * @param {Array} data DataArray
   * @return {Array} Domain values array.
   */
  _calculateDomainFromData() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Returns the domain for the axis.
   *
   * @param {string} encodingType type of encoding x, y, color, etc.
   * @return {Object} Axis domains
   */
  getDomain() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Abstract method for getting nearest point
   * @return {BaseLayer} Instance of base layer
   */
  getNearestPoint() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Abstract method for highlighting points
   * @return {BaseLayer} Instance of base layer
   */
  highlightPoint() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Abstract method for deselecting points
   * @return {BaseLayer} Instance of base layer
   */
  dehighlightPoint() {
    return this;
  }
  linkLayerStore() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Sets the container element for the layer to be renderered.
   * @param {SVGElement} mountPoint SVG element or group element.
   */
  mount() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  render() {
    throw new Error(yt.INTERFACE_IMPL);
  }
}
const Ke = "bottom", Se = "top", Ze = "left", tn = "right", SY = {
  [Ze]: fn.axisLeft,
  [Ke]: fn.axisBottom,
  [tn]: fn.axisRight,
  [Se]: fn.axisTop
}, be = "linear", ps = "band", QA = "temporal", PE = "temporalUTC", HS = "color", ga = "ordinal", OS = "quantize", YE = "quantile", iu = "log", nu = "pow", PS = "identity", Zs = "sequential", JE = "threshold", YS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAND: ps,
  COLOR: HS,
  IDENTITY: PS,
  LINEAR: be,
  LOG: iu,
  ORDINAL: ga,
  POW: nu,
  QUANTILE: YE,
  QUANTIZE: OS,
  SEQUENTIAL: Zs,
  THRESHOLD: JE,
  TIME: QA,
  UTCTIME: PE
}, Symbol.toStringTag, { value: "Module" })), _Y = "dimension", su = "categorical", bY = "measure", Au = "temporal", zi = "binned", MY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BINNED: zi,
  CATEGORICAL: su,
  DIMENSION: _Y,
  MEASURE: bY,
  TEMPORAL: Au
}, Symbol.toStringTag, { value: "Module" })), df = "muze", NY = "continuous", Oe = "continous", De = "discrete", FY = "sequential", xI = "ordinal", KE = "linear", JS = "band", RY = "quantize", kY = "color", vY = "shape", TY = "size", GY = "hidden", kn = "bottom", qn = "top", LY = "rgb", UY = "hex", HY = "hsla", OY = "hsl", PY = [1], Mh = 2, KS = 10, YY = 6, JY = 10, PA = "right", YA = "left", bn = "padding", KY = 6, VE = "direct-sort-target-row-headers", WE = "direct-sort-target-row-band-axis", qE = "direct-sort-target-column-band-axis", VS = "direct-sort-target-row-continuous-axis", WS = "direct-sort-target-column-continuous-axis", qS = "_directSortContainer", jS = "_directSortTarget", zS = 5, VY = kC, {
  scaleLinear: mQ,
  scaleThreshold: WY,
  scaleLog: qY,
  scalePow: jY,
  scaleIdentity: zY,
  scaleOrdinal: $S,
  scaleSequential: XS,
  scaleQuantize: $Y,
  scaleQuantile: XY,
  scaleBand: ZY,
  scaleTime: t4,
  scaleUtc: e4
} = ND, no = {
  [be]: mQ,
  [ps]: ZY,
  [OS]: $Y,
  [YE]: XY,
  [JE]: WY,
  [Zs]: XS,
  [iu]: qY,
  [nu]: jY,
  [PS]: zY,
  [QA]: t4,
  [PE]: e4,
  [HS]: mQ,
  [ga]: $S
};
function i4(e) {
  return e[0] === "i" ? XS(zf[e]) : $S(zf[e]);
}
function n4(e) {
  let t = "";
  return e && typeof e == "string" ? t = e[0] === "i" ? FY : xI : t = xI, t;
}
function Ks(e) {
  let t = e.range;
  if (!e.type || !no[e.type])
    throw new Error(`${e.type} is not a valid scale type`);
  if (!Array.isArray(e.range))
    throw new Error("range parameter must be an array");
  let i = null;
  if (e.type === KE && e.interpolator) {
    if (i = no[e.interpolator], e.interpolator === nu)
      return i().range(t).exponent(e.exponent);
    if (e.interpolator === iu)
      return i().range(t).base([e.base]);
  } else
    i = no[e.type];
  return e.type === RY && i().nice(), i().range(t);
}
const ou = {
  id: Zt(),
  adjustRange: !1,
  axisName: {
    defClassName: "axis-name"
  },
  axisNamePadding: 5,
  base: 10,
  classPrefix: df,
  className: `${df}-axis`,
  exponent: 1,
  interpolator: "linear",
  fixedBaseline: !0,
  labels: {
    rotation: null,
    smartTicks: null,
    className: ""
  },
  orientation: "left",
  format: (e) => e,
  padding: 0.3,
  paddingInner: null,
  paddingOuter: null,
  nice: !0,
  numberOfTicks: null,
  rotate: !1,
  show: !0,
  showAxisName: !0,
  showInnerTicks: !0,
  showOuterTicks: !0,
  tickSize: 6,
  style: {},
  type: "linear",
  tickFormat: null,
  tickValues: null,
  tickInterval: {
    step: null,
    multiplier: 1,
    start: 0
  },
  interaction: {
    menu: {
      showIcon: !1,
      onIconClick: () => {
      }
    }
  },
  xOffset: 0,
  yOffset: 0,
  defaultSort: "asc",
  transition: {
    disabled: !1
  },
  ticks: {
    labels: {
      rotation: 45,
      style: {
        "font-size": "12px",
        "font-family": '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif',
        "font-weight": "400",
        "font-style": "normal",
        "text-align": "center",
        fill: "#858585"
      },
      "&:highlight": {
        style: {
          "font-weight": "bold",
          fill: "#595959"
        }
      }
    }
  },
  title: {
    style: {
      "font-size": "14px",
      "font-family": '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif',
      "font-weight": "400",
      "font-style": "normal",
      fill: "#5f5f5f"
    }
  },
  ordering: et({}, vo),
  hyperlink: {
    enabled: !1,
    sanitizeHyperlink: !0,
    encode: !0,
    defaultClassName: `${df}-hyperlink-text`,
    generateHref: (e) => ({
      target: bo,
      rel: Mo,
      url: e.formattedValue,
      styles: No,
      classNames: Fo
    })
  }
}, s4 = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.99707%206H7.99707V5H9.99707V6Z'%20fill='%2363656E'/%3e%3cpath%20d='M7.99707%208V9H11.9971V8H7.99707Z'%20fill='%2363656E'/%3e%3cpath%20d='M7.99707%2012H13.9971V11H7.99707V12Z'%20fill='%2363656E'/%3e%3cpath%20d='M4.99869%209.49978H6.74576C6.88383%209.49978%206.99576%209.6117%206.99576%209.74978C6.99576%209.81149%206.97293%209.87103%206.93167%209.91692L4.68379%2012.4171C4.59148%2012.5198%204.43341%2012.5282%204.33074%2012.4359C4.32415%2012.43%204.31789%2012.4237%204.31197%2012.4171L2.06409%209.91692C1.97178%209.81425%201.98018%209.65618%202.08286%209.56387C2.12875%209.5226%202.18829%209.49978%202.25%209.49978H3.99869L3.99869%205H4.99869L4.99869%209.49978Z'%20fill='%2363656E'/%3e%3c/svg%3e", pQ = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M4.46626%203.22656L3%207.61306H3.76687L4.11043%206.52717H5.78527L6.13496%207.61306H6.98159L5.53374%203.22656H4.46626ZM4.30061%205.93208L4.95092%203.89527L5.59509%205.93208H4.30061ZM3%2012.8893V12.9998H6.33128V12.3433H4.20245L6.39263%208.71758V8.61328H3.22699V9.25745H5.23926L3%2012.8893Z'%20fill='%2363656E'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M9.06394%209.64348L11.3118%2012.1437C11.3177%2012.1503%2011.324%2012.1566%2011.3306%2012.1625C11.4333%2012.2548%2011.5913%2012.2464%2011.6836%2012.1437L13.9315%209.64348C13.9728%209.59759%2013.9956%209.53805%2013.9956%209.47634C13.9956%209.33827%2013.8837%209.22634%2013.7456%209.22634H11.999L11.999%204.72656H10.999L10.999%209.22634L9.24984%209.22634C9.18813%209.22634%209.12859%209.24917%209.0827%209.29043C8.98002%209.38274%208.97162%209.54081%209.06394%209.64348Z'%20fill='%2363656E'/%3e%3c/svg%3e", A4 = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M11%208.01172V2.01172H10V8.01172H11Z'%20fill='%2363656E'/%3e%3cpath%20d='M8%208.01172V4.01172H7V8.01172H8Z'%20fill='%2363656E'/%3e%3cpath%20d='M5%206.01172V8.01172H4V6.01172H5Z'%20fill='%2363656E'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M10.4169%2013.9356L12.9171%2011.6877C12.9237%2011.6818%2012.93%2011.6755%2012.9359%2011.6689C13.0282%2011.5663%2013.0198%2011.4082%2012.9171%2011.3159L10.4169%209.068C10.371%209.02673%2010.3115%209.00391%2010.2498%209.00391C10.1117%209.00391%209.99978%209.11584%209.99978%209.25391V11.0039L4%2011.0039V12.0039L9.99978%2012.0039V13.7497C9.99978%2013.8114%2010.0226%2013.8709%2010.0639%2013.9168C10.1562%2014.0195%2010.3142%2014.0279%2010.4169%2013.9356Z'%20fill='%2363656E'/%3e%3c/svg%3e", o4 = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M14.0029%205.5H8.00293V4.5H14.0029V5.5ZM7.99707%208.5H11.9971V7.5H7.99707V8.5ZM8.00293%2011.5H10.0029V10.5H8.00293V11.5Z'%20fill='%2363656E'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M2.0636%209.41692L4.31148%2011.9171C4.3174%2011.9237%204.32367%2011.93%204.33025%2011.9359C4.43292%2012.0282%204.59099%2012.0198%204.6833%2011.9171L6.93118%209.41692C6.97245%209.37103%206.99527%209.31149%206.99528%209.24978C6.99528%209.11171%206.88335%208.99978%206.74528%208.99978L4.9982%208.99978L4.9982%204.5H3.9982L3.9982%208.99978L2.24951%208.99978C2.1878%208.99978%202.12826%209.0226%202.08237%209.06387C1.97969%209.15618%201.97129%209.31425%202.0636%209.41692Z'%20fill='%2363656E'/%3e%3c/svg%3e", QQ = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M3.29443%207.50263V7.61306H6.62572V6.95662H4.49689L6.68707%203.33086V3.22656H3.52143V3.87073H5.53369L3.29443%207.50263ZM4.46626%208.61328L3%2012.9998H3.76687L4.11043%2011.9139H5.78527L6.13496%2012.9998H6.98159L5.53374%208.61328H4.46626ZM4.30061%2011.3188L4.95092%209.28199L5.59509%2011.3188H4.30061Z'%20fill='%2363656E'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M11.9806%209.22634H13.7277C13.8658%209.22634%2013.9777%209.33827%2013.9777%209.47634C13.9777%209.53805%2013.9549%209.59759%2013.9136%209.64348L11.6657%2012.1437C11.5734%2012.2464%2011.4153%2012.2548%2011.3127%2012.1625C11.3061%2012.1566%2011.2998%2012.1503%2011.2939%2012.1437L9.04603%209.64348C8.95371%209.54081%208.96212%209.38274%209.06479%209.29043C9.11068%209.24917%209.17022%209.22634%209.23194%209.22634H10.9806V4.72656H11.9806V9.22634Z'%20fill='%2363656E'/%3e%3c/svg%3e", a4 = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M4.99609%202.00391L4.99609%208.00391H3.99609V2.00391H4.99609ZM7.99658%208.01172V4.01172H6.99658V8.01172H7.99658ZM10.9961%208.00391V6.00391H9.99609V8.00391H10.9961Z'%20fill='%2363656E'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M10.4169%2013.9356L12.9171%2011.6877C12.9237%2011.6818%2012.93%2011.6755%2012.9359%2011.6689C13.0282%2011.5663%2013.0198%2011.4082%2012.9171%2011.3159L10.4169%209.068C10.371%209.02673%2010.3115%209.00391%2010.2498%209.00391C10.1117%209.00391%209.99978%209.11584%209.99978%209.25391V11.0039L4%2011.0039V12.0039L9.99978%2012.0039V13.7497C9.99978%2013.8114%2010.0226%2013.8709%2010.0639%2013.9168C10.1562%2014.0195%2010.3142%2014.0279%2010.4169%2013.9356Z'%20fill='%2363656E'/%3e%3c/svg%3e", jE = "data:image/svg+xml,%3csvg%20width='8'%20height='5'%20viewBox='0%200%208%205'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8%200.166992L4.01413%204.16699L0%200.166992L8%200.166992Z'%20fill='%2363656E'/%3e%3c/svg%3e", r4 = "data:image/svg+xml,%3csvg%20width='8'%20height='4'%20viewBox='0%200%208%204'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8%202.1787e-09L4.01413%204L0%200L8%202.1787e-09Z'%20fill='%2318A0FB'/%3e%3c/svg%3e", l4 = "data:image/svg+xml,%3csvg%20width='6'%20height='6'%20viewBox='0%200%206%206'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M3%206C4.65685%206%206%204.65685%206%203C6%201.34315%204.65685%200%203%200C1.34315%200%200%201.34315%200%203C0%204.65685%201.34315%206%203%206Z'%20fill='%2368C3EC'/%3e%3c/svg%3e", c4 = "data:image/svg+xml,%3csvg%20width='4'%20height='8'%20viewBox='0%200%204%208'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M3.68672%203.22579C4.10268%203.6529%204.10617%204.34181%203.68672%204.77251L0.753166%207.78471C0.337204%208.21183%200%207.98771%200%207.25171L0%200.746587C0%200.0251014%200.333713%20-0.217118%200.753166%200.213581'%20fill='%2363656E'/%3e%3c/svg%3e", g4 = "data:image/svg+xml,%3csvg%20width='4'%20height='8'%20viewBox='0%200%204%208'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M0.313282%203.22579C-0.10268%203.6529%20-0.106171%204.34181%200.313282%204.77251L3.24683%207.78471C3.6628%208.21183%204%207.98771%204%207.25171L4%200.746587C4%200.0251012%203.66629%20-0.217118%203.24683%200.213581'%20fill='%2363656E'/%3e%3c/svg%3e", uf = "sort-label", ff = "sort-menu", eg = "asc", h4 = 16, ZS = (e, t) => {
  const {
    target: { type: i, data: n, meta: s },
    targets: A,
    container: o,
    sortStatus: a,
    text: r,
    isOverlay: l,
    cellRender: c,
    directSortEnabled: g,
    hyperlinkInfo: h,
    hyperLinkConfig: d
  } = t;
  vt(o, {
    display: "grid",
    "grid-auto-flow": "column",
    "grid-template-columns": "1fr",
    position: "relative"
  });
  let u;
  if (!a)
    u = jE;
  else {
    const I = a.sortInfo.direction;
    i === VE ? u = I === eg ? pQ : QQ : i === WE ? u = I === eg ? A4 : a4 : i === qE ? u = I === eg ? s4 : o4 : u = I === eg ? pQ : QQ;
  }
  const f = [];
  r && f.push({
    type: uf,
    className: uf,
    data: {
      label: r.label,
      originalText: r.originalText
    }
  }), f.push({
    type: ff,
    className: ff,
    contextData: {
      type: i,
      data: n,
      meta: s
    },
    icon: u,
    sortStatus: a,
    directSortEnabled: g
  }), z(
    o,
    "div",
    f,
    null,
    {},
    (I) => I.type
  ).each(function(I) {
    const E = X(this), { type: B } = I;
    if (E.classed(I.className, !0), B === uf) {
      vt(E, {
        display: "flex",
        "align-items": A.length > 1 ? "center" : "start",
        "justify-content": r.align,
        overflow: "hidden"
      });
      let m = E;
      h && (m = z(E, "a", (w) => [w]), uc(
        m,
        {
          hyperlinkInfo: h
        },
        d
      ));
      const p = z(m, "span", [I.data]).text((w) => w.label).classed("tick-label", !0);
      vt(
        p,
        Object.assign({
          "white-space": "nowrap",
          overflow: "hidden",
          "text-overflow": "ellipsis",
          "line-height": "normal"
        })
      );
    } else if (B === ff) {
      vt(E, {
        display: "flex",
        "align-items": A.length > 1 ? "center" : "start",
        "justify-content": "center",
        cursor: "pointer"
      }), l && !a && vt(E, {
        position: "absolute",
        right: "3px",
        top: "50%",
        transform: "translateY(-50%)"
      });
      const m = z(E, "div", [1]);
      m.classed("icon-holder", !0), vt(m, {
        display: "flex",
        "align-items": "center",
        "justify-content": "center"
      }), z(m, "img", [I.icon]).attr("src", (p) => p), E.style("display", a ? "flex" : "none");
    }
  }), c === "html" && t_(o);
}, zE = (e) => {
  const t = e.node()[qS];
  return (t ? X(t) : e).selectAll(".sort-menu");
}, au = (e) => {
  const t = e.node()[jS];
  return t ? X(t) : e;
}, t_ = (e) => {
  const { height: t } = e.node().getBoundingClientRect(), i = Math.min(t, h4);
  if (i > 0) {
    const s = zE(e).select(".icon-holder");
    vt(s, {
      width: i + "px",
      height: i + "px"
    });
  }
}, $E = ({
  baseTargets: e,
  directSortEnabledInfo: t
}) => {
  const i = [];
  t.rowsHeaders && i.push(e.rowsHeaders);
  const n = e.axis;
  return t.axes.x && n.forEach((s) => {
    i.push(`.muze-axis-cell-top ${s}`), i.push(`.muze-axis-cell-bottom ${s}`);
  }), t.axes.y && n.forEach((s) => {
    i.push(`.muze-axis-cell-left ${s}`), i.push(`.muze-axis-cell-right ${s}`);
  }), i;
}, fc = (e, t) => t, Nh = (e, t, i) => {
  switch (Z(e, "constructor")) {
    case Function:
      return e(t, i);
    case Array:
      return e;
    default:
      return t;
  }
}, d4 = (e) => e || 5, e_ = (e, t) => {
  const i = e.config().orientation, { axisDomainRanges: n } = t, s = e.domain();
  let A = null, o, a;
  switch (i) {
    case "top":
      o = n.x[1], a = !0;
      break;
    case "bottom":
      o = n.x[0], a = !0;
      break;
    case "left":
      o = n.y[0], a = !1;
      break;
    case "right":
      o = n.y[1], a = !1;
      break;
  }
  return a && o ? A = {
    ...o,
    absStartIdx: o.startIdx,
    absEndIdx: o.endIdx
  } : !a && o && (A = {
    ...o,
    absStartIdx: s.length - 1 - o.endIdx,
    absEndIdx: s.length - 1 - o.startIdx
  }), A;
}, i_ = (e) => {
  const {
    axisInst: t,
    directSortContainer: i,
    targetElemData: n,
    allTargetElems: s,
    textInfo: A,
    isOverlay: o,
    cellRender: a,
    hyperlinkInfo: r,
    hyperLinkConfig: l
  } = e, c = t.currentNestedSortInfo(), g = {
    [t.config().field]: (u) => t.getFormattedText(u)
  };
  if (c) {
    const { facetsPath: u } = c;
    u.forEach(({ field: f, formatter: C }) => {
      g[f] = (...I) => C(...I);
    });
  }
  let h = null;
  t instanceof xe || t instanceof Be ? c && Ml(
    c.axisTarget.value,
    n.rawValue
  ) ? h = {
    sortInfo: c.sortInfo,
    targetField: c.targetField,
    metaInfo: {
      sourceType: t.config().sourceType
    },
    formatterByFields: g
  } : h = null : t instanceof Ln && (c && Ml(
    c.axisTarget.value,
    n.fieldName
  ) ? h = {
    sortInfo: c.sortInfo,
    targetField: c.targetField,
    metaInfo: {
      sourceType: t.config().sourceType
    },
    formatterByFields: g
  } : h = null);
  let d;
  t instanceof xe || t instanceof Be ? d = t.isYAxis() ? WE : qE : t instanceof Ln && (d = t.isYAxis() ? VS : WS), ZS(t, {
    target: {
      type: d,
      data: n,
      meta: {
        axisFieldName: t.config().field
      }
    },
    targets: s,
    container: i,
    sortStatus: h,
    text: A,
    isOverlay: o,
    cellRender: a,
    directSortEnabled: t.directSortEnabled(),
    hyperlinkInfo: r,
    hyperLinkConfig: l
  });
}, ig = {
  [qn]: {
    [bn]: {
      [qn]: 3,
      [kn]: 0,
      [YA]: 5,
      [PA]: 5
    }
  },
  [kn]: {
    [bn]: {
      [qn]: 4,
      [kn]: 0,
      [YA]: 5,
      [PA]: 5
    }
  },
  [YA]: {
    [bn]: {
      [qn]: 0,
      [kn]: 0,
      [YA]: 6,
      [PA]: 6
    }
  },
  [PA]: {
    [bn]: {
      [qn]: 0,
      [kn]: 0,
      [YA]: 6,
      [PA]: 6
    }
  }
}, cl = 3, n_ = 28;
function u4(e) {
  return e = Math.max(Math.min(e, n_), 1), le(
    (t) => {
      t.getDate() >= e || t.setMonth(t.getMonth() - 1), t.setDate(e), t.setHours(0, 0, 0, 0);
    },
    (t, i) => {
      t.setMonth(t.getMonth() + i);
    },
    (t, i) => i.getMonth() - t.getMonth() + (i.getFullYear() - t.getFullYear()) * 12,
    (t) => t.getMonth()
  );
}
function f4(e) {
  return e = Math.max(Math.min(e, n_), 1), le(
    (t) => {
      t.getUTCDate() >= e || t.setUTCMonth(t.getUTCMonth() - 1), t.setUTCDate(e), t.setUTCHours(0, 0, 0, 0);
    },
    (t, i) => {
      t.setUTCMonth(t.getUTCMonth() + i);
    },
    (t, i) => i.getUTCMonth() - t.getUTCMonth() + (i.getUTCFullYear() - t.getUTCFullYear()) * 12,
    (t) => t.getUTCMonth()
  );
}
function I4(e) {
  e = Math.max(Math.min(e, 11), 0);
  const t = le(
    (i) => {
      i.getMonth() < e && i.setFullYear(i.getFullYear() - 1), i.setMonth(e, 1), i.setHours(0, 0, 0, 0);
    },
    (i, n) => {
      i.setFullYear(i.getFullYear() + n);
    },
    (i, n) => n.getFullYear() - i.getFullYear(),
    (i) => i.getFullYear()
  );
  return t.every = (i) => !isFinite(i = Math.floor(i)) || !(i > 0) ? null : le(
    (n) => {
      const s = Math.floor(n.getFullYear() / i) * i;
      s === n.getFullYear() && n.getMonth() < e ? n.setFullYear(s - i) : n.setFullYear(s), n.setMonth(e, 1), n.setHours(0, 0, 0, 0);
    },
    (n, s) => {
      n.setFullYear(n.getFullYear() + s * i);
    }
  ), t;
}
function C4(e) {
  e = Math.max(Math.min(e, 11), 0);
  const t = le(
    (i) => {
      i.getUTCMonth() < e && i.setUTCFullYear(i.getUTCFullYear() - 1), i.setUTCMonth(e, 1), i.setUTCHours(0, 0, 0, 0);
    },
    (i, n) => {
      i.setUTCFullYear(i.getUTCFullYear() + n);
    },
    (i, n) => n.getUTCFullYear() - i.getUTCFullYear(),
    (i) => i.getUTCFullYear()
  );
  return t.every = (i) => !isFinite(i = Math.floor(i)) || !(i > 0) ? null : le(
    (n) => {
      const s = Math.floor(n.getUTCFullYear() / i) * i;
      s === n.getUTCFullYear() && n.getUTCMonth() < e ? n.setUTCFullYear(s - i) : n.setUTCFullYear(s), n.setUTCMonth(e, 1), n.setUTCHours(0, 0, 0, 0);
    },
    (n, s) => {
      n.setUTCFullYear(n.getUTCFullYear() + s * i);
    }
  ), t;
}
const XE = 1, ZE = XE * 1e3, ru = ZE * 60, tB = ru * 60, mo = tB * 24, s_ = mo * 30, A_ = mo * 365, E4 = 0.7, o_ = [1, 2, 3, 5, 6, 7, 10, 14], B4 = [
  Ua,
  Ha,
  WC,
  qC,
  EA,
  jC,
  zC
], m4 = [
  Oa,
  Pa,
  $C,
  XC,
  BA,
  ZC,
  tE
];
function a_() {
  return le(
    (e) => e.setHours(0, 0, 0, 0),
    (e, t) => e.setDate(e.getDate() + t),
    (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * ru) / mo
  );
}
function r_() {
  return le(
    (e) => e.setUTCHours(0, 0, 0, 0),
    (e, t) => e.setUTCDate(e.getUTCDate() + t),
    (e, t) => (t - e) / mo
  );
}
function AA(e, t, i) {
  let n, s;
  e === "millisecond" ? (n = i ? Date.prototype.getUTCMilliseconds : Date.prototype.getMilliseconds, s = 999) : e === "second" ? (n = i ? Date.prototype.getUTCSeconds : Date.prototype.getSeconds, s = 59) : e === "minute" ? (n = i ? Date.prototype.getUTCMinutes : Date.prototype.getMinutes, s = 59) : e === "hour" && (n = i ? Date.prototype.getUTCHours : Date.prototype.getHours, s = 23);
  const A = t * E4, o = s % t, a = s - o;
  return o + 1 < A ? (r) => n.call(r) !== a : () => !0;
}
const l_ = {
  millisecond: [
    XE,
    () => es,
    () => es,
    AA.bind(void 0, "millisecond"),
    1e3,
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    (e) => 1e3 % e === 0
  ],
  second: [
    ZE,
    () => Us,
    () => Us,
    AA.bind(void 0, "second"),
    60,
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    (e) => 60 % e === 0
  ],
  minute: [
    ru,
    () => tc,
    () => nc,
    AA.bind(void 0, "minute"),
    60,
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    (e) => 60 % e === 0
  ],
  hour: [
    tB,
    () => ec,
    () => sc,
    AA.bind(void 0, "hour"),
    24,
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    (e) => 24 % e === 0
  ],
  day: [
    mo,
    () => a_(),
    () => r_(),
    null,
    30,
    (e) => o_.includes(e)
  ],
  week: [
    mo * 7,
    (e) => B4[e],
    (e) => m4[e],
    null,
    1 / 0,
    () => !0
  ],
  month: [
    s_,
    (e) => u4(e),
    (e) => f4(e),
    null,
    12,
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    (e) => 12 % e === 0
  ],
  year: [
    A_,
    (e) => I4(e),
    (e) => C4(e),
    null,
    1 / 0,
    () => !0
  ]
}, c_ = (e, t, i, n, s, A) => [
  s > 1 ? `every ${s} ${e}s` : `every ${e}`,
  n * s,
  s > 1 && A ? t.every(s).filter(A(s, !1)) : t.every(s),
  s > 1 && A ? i.every(s).filter(A(s, !0)) : i.every(s)
], yQ = {
  millisecond: {
    baseDuration: XE,
    filterFn: AA.bind(void 0, "millisecond"),
    intervalInst: es,
    utcIntervalInst: es,
    // Should meet this condition: 1000 % multiplier === 0.
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    multipliers: [1, 100, 200, 500]
  },
  second: {
    baseDuration: ZE,
    filterFn: AA.bind(void 0, "second"),
    intervalInst: Us,
    utcIntervalInst: Us,
    // Should meet this condition: 60 % multiplier === 0.
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    multipliers: [1, 2, 3, 4, 5, 10, 15, 20, 30]
  },
  minute: {
    baseDuration: ru,
    filterFn: AA.bind(void 0, "minute"),
    intervalInst: tc,
    utcIntervalInst: nc,
    // Should meet this condition: 60 % multiplier === 0.
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    multipliers: [1, 2, 3, 4, 5, 10, 15, 20, 30]
  },
  hour: {
    baseDuration: tB,
    filterFn: AA.bind(void 0, "hour"),
    intervalInst: ec,
    utcIntervalInst: sc,
    // Should meet this condition: 24 % multiplier === 0.
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    multipliers: [1, 2, 3, 4, 6, 12]
  },
  day: {
    baseDuration: mo,
    filterFn: null,
    intervalInst: a_(),
    utcIntervalInst: r_(),
    multipliers: o_.slice()
  },
  month: {
    baseDuration: s_,
    filterFn: null,
    intervalInst: kd,
    utcIntervalInst: vd,
    // Should meet this condition: 12 % multiplier === 0.
    // The multiplier should be such that the ticks are evenly spaced and no irregular intervals.
    multipliers: [1, 2, 3, 4, 6]
  },
  year: {
    baseDuration: A_,
    filterFn: null,
    intervalInst: Es,
    utcIntervalInst: Bs,
    multipliers: [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      15,
      20,
      25,
      30,
      35,
      40,
      45,
      50,
      60,
      70,
      80,
      90,
      100,
      200,
      300,
      400,
      500,
      600,
      700,
      800,
      900,
      1e3
    ]
  }
}, g_ = [];
Object.keys(yQ).forEach((e) => {
  const { baseDuration: t, filterFn: i, intervalInst: n, utcIntervalInst: s, multipliers: A } = yQ[e];
  A.forEach((o) => {
    const a = c_(
      e,
      n,
      s,
      t,
      o,
      i
    );
    g_.push(a);
  });
});
function p4(e, t) {
  const { tickInterval: i } = t, { step: n, multiplier: s } = i;
  if (!n)
    return;
  if (!Object.keys(l_).includes(n)) {
    t.tickInterval.step = null;
    return;
  }
  const o = isFinite(s) ? Math.floor(+s) : 1;
  t.tickInterval.multiplier = Math.max(o, 1);
}
function Q4(e, t) {
  e = e.slice().map((f) => /* @__PURE__ */ new Date(+f));
  let i = 0, n = e.length - 1, s = e[i], A = e[n], o;
  A < s && (o = i, i = n, n = o, o = s, s = A, A = o);
  let a = s, r = A;
  const l = t.floor(s), c = t.ceil(s);
  Math.abs(c - s) / Math.abs(c - l) >= 0.5 ? a = l : a = s;
  const h = t.floor(A), d = t.ceil(A);
  return Math.abs(A - h) / Math.abs(d - h) >= 0.5 ? r = d : r = A, e[i] = a, e[n] = r, e;
}
function y4(e) {
  const t = e.getTickSkippingInterval(), { nice: i } = e.config();
  let n = e.scale();
  if (i) {
    const o = Q4(
      e.originalDomain(),
      t
    );
    n.domain(o), e._domain = o;
  }
  let s = n.ticks(t);
  const A = s.length;
  if (Q_(e, s)) {
    const o = Math.floor(A / 2);
    s = [s[o]];
  } else
    s = Og(
      e,
      e.axis(),
      s,
      A
    );
  return s;
}
const w4 = (e) => {
  const t = y4(e);
  e.renderConfig({
    tickValues: t
  });
}, D4 = (...e) => d_(...e), h_ = (...e) => d_(...e), d_ = (e, t, {
  canTicksShift: i = !0,
  spaceBetweenTicks: n = 0,
  allowExtremeLabelsOverflow: s = !0,
  preserveLastTick: A = !0
} = {
  canTicksShift: !0,
  spaceBetweenTicks: 0,
  allowExtremeLabelsOverflow: !0,
  preserveLastTick: !0
}) => {
  const o = e.config(), [a, r] = e.range();
  let l = Number.isFinite(o.labels.rotation) ? o.labels.rotation : 0;
  const { orientation: c } = e.config();
  let g;
  const h = e._interpolator, d = e.dependencies().labelManager;
  d.setStyle(e._tickLabelStyle);
  const u = e._tickFormatter(t), f = t.map(
    (C, I) => d.getOriSize(u(C, I))
  );
  if (c === "bottom" || c === "top") {
    const C = l ? f.map((w) => {
      const { width: Q, height: y } = mn(
        l,
        w.width,
        w.height
      );
      return { width: Q + n, height: y };
    }) : f.map(({ width: w, height: Q }) => ({
      width: w + n,
      height: Q
    })), I = e.isBinnedAxis() ? 0 : Math.max(0, e.getUnitWidth() - 1) / 2;
    let E = t.map((w, Q) => ({
      position: e.getScaleValue(w) + I,
      dimension: C[Q].width,
      crossDimension: C[Q].height,
      tickRawValue: t[Q],
      isTickShifted: i ? Q === 0 : !1
    }));
    const B = s ? 0 : E.findIndex(({ position: w, dimension: Q, isTickShifted: y }) => (y ? w + Q / 2 : w - Q / 2) > a), m = s ? E.length - 1 : E.length - 1 - E.slice().reverse().findIndex(
      ({ position: w, dimension: Q }) => w + Q / 2 < r
    ), p = h.skipTicks(
      E.slice(
        B,
        m + 1
      ),
      { preserveLastTick: A },
      l,
      e,
      c
    );
    g = t.slice(B, m + 1).filter((w, Q) => p.includes(Q));
  } else {
    const C = l ? f.map((_) => {
      const { width: x, height: S } = mn(
        l,
        _.width,
        _.height
      );
      return { width: x, height: S + n };
    }) : f.map(({ width: _, height: x }) => ({
      width: _,
      height: x + n
    })), I = e.isBinnedAxis() ? 0 : Math.max(0, e.getUnitWidth() - 1) / 2, B = t.map((_, x) => ({
      position: e.getScaleValue(_) + I,
      dimension: C[x].height,
      crossDimension: Math.floor(C[x].width),
      tickRawValue: t[x],
      originalIdx: x,
      isTickShifted: i ? x === 0 : !1
    })).slice().reverse(), m = s ? 0 : B.findIndex(
      ({ position: _, dimension: x }) => _ - x / 2 > r
    ), p = B.slice().reverse().findIndex(({ position: _, dimension: x, isTickShifted: S }) => (S ? _ - x / 2 : _ + x / 2) < a), w = s ? B.length - 1 : p === -1 ? p : B.length - 1 - p, Q = h.skipTicks(
      B.slice(
        m,
        w + 1
      ),
      { preserveLastTick: A },
      l,
      e,
      c
    ), D = B.slice(m, w + 1).filter((_, x) => Q.includes(x)).map(
      (_) => _.originalIdx
    );
    g = t.filter(
      (_, x) => D.includes(x)
    );
  }
  return g;
}, u_ = "wholeRange", Fh = "startValue", f_ = "continuous", lu = "center", I_ = "start", wQ = (e, t) => (e[0] += t[0], e[1] -= t[1], e), DQ = (e, t, i) => (e[0] -= i[0], e[1] += t[1], e), x4 = {
  [Se]: wQ,
  [Ke]: wQ,
  [Ze]: DQ,
  [tn]: DQ
}, LA = (e, t, i, n) => {
  e.range(i), n && e.renderConfig({ [`${t}Offset`]: n });
}, S4 = (e, t, i) => {
  const n = Math.abs(t[1] - t[0]), s = Math.abs(i[1] - i[0]);
  let A, o;
  if (i[0] instanceof Date && isNaN(i[0]))
    o = 0;
  else {
    A = n / (s || i[0]);
    const a = A * e, r = n / a, l = n / (r + 1);
    o = (n - l * r) / 2;
  }
  return o;
}, Rh = (e, t, i, n, s) => {
  const { orientation: A, adjustRange: o } = s;
  let a;
  if (o) {
    const c = S4(e, t, i);
    a = n.map((g) => Math.max(g, c));
  } else
    a = n;
  const r = a.map(
    (c) => Math.max(c, KY)
  );
  return x4[A](
    t,
    r,
    n
  );
}, mn = (e = 0, t, i) => {
  let n = i, s = t;
  if (e) {
    const A = (e || 0) * Math.PI / 180;
    s = Math.abs(i * Math.sin(A)) + Math.abs(t * Math.cos(A)), n = Math.abs(t * Math.sin(A)) + Math.abs(i * Math.cos(A));
  }
  return { width: s, height: n };
}, _4 = (e, t, i, n, s) => {
  const A = Math.PI / 180 * s, o = Math.cos(A), a = Math.sin(A);
  return [
    o * (i - e) + a * (n - t) + e,
    o * (n - t) - a * (i - e) + t
  ];
}, Ic = (e) => {
  let t = 0, i = 0;
  const n = e.logicalSpace(), s = e.config(), { orientation: A, xOffset: o, yOffset: a } = s;
  A === Ze && (t = o === void 0 ? n.width : o), A === Se && (i = a === void 0 ? n.height : a), e.renderConfig({ xOffset: t, yOffset: i });
}, Hg = (e, t, i) => {
  const n = e.axis(), s = i || e.binSize(), { bins: A, fieldInstance: o, field: a } = e.config();
  let r, l;
  return e._config.alignZeroLine ? [r, l] = e._domain : [r, l] = o.data().getField(a).domain(), A.display === f_ ? i ? Qa(r, l + s / 2, s) : t == null ? n.scale().ticks() : n.scale().ticks(t) : A.position === I_ ? Qa(r, l + s / 2, s) : A.position === lu ? Qa(r + s / 2, l + s / 2, s) : t == null ? n.scale().ticks() : n.scale().ticks(t);
};
function b4(e, t) {
  let i = Math.floor(e / t);
  return t * (i + 1);
}
const M4 = (e, t) => {
  let i = e[0], n = 1;
  for (n; n < t; n++) {
    let s = e[n];
    if (s == i)
      return !0;
    i = s;
  }
  return !1;
}, Og = (e, t, i, n) => {
  const s = e._tickFormatter(i);
  let A = 0;
  for (; n > 0; ) {
    if (i.length !== A) {
      let o = i.map((r, l) => s(r, l));
      if (A = o.length, e instanceof fr && !M4(o, A) || [...new Set(o)].length === A)
        break;
    }
    n -= 1, i = t.scale().ticks(n);
  }
  return i;
}, N4 = (e, t, i, n) => {
  let s = 0, A = [], { numberOfTicks: o, fieldInstance: a } = n.config();
  const r = a.subtype() === zi;
  let l;
  if (r) {
    l = Hg(n), l = Og(n, i, l, l.length);
    const c = n.config();
    let g;
    K.isInvalid(l[l.length - 1]) && l.length >= 2 ? g = n.getFormattedText(
      l[l.length - 2],
      l.length - 2,
      l
    ) : g = n.getFormattedText(
      l[l.length - 1],
      l.length - 1,
      l
    );
    const h = n._dependencies.labelManager.getOriSize(g);
    let d = Number.isFinite(c.labels.rotation) ? c.labels.rotation : 0;
    const { bins: u } = n.config(), { width: f, height: C } = mn(
      d,
      h.width,
      h.height
    ), I = n.isYAxis() ? C : f;
    let B = n.getValueFromPixels(I + 5);
    return B = Number.isInteger(n.binSize()) ? Math.ceil(B) : B.toFixed(2), n instanceof qi && B > n.binSize() && (u.display === f_ ? l = Hg(n, null, B) : l = Hg(
      n,
      null,
      b4(B, n.binSize())
    ), l = Og(n, i, l, l.length)), l;
  } else {
    l = i.scale().ticks();
    const c = l.length, g = n._minTickDistance.width;
    return s = c, c * (t + g) > e && (s = Math.floor(
      e / (t + g)
    )), o = o || s, s = Math.min(
      o,
      Math.max(Mh, s)
    ), l = i.scale().ticks(s), A = Og(n, i, l, s), A.length > s && (A = A.filter((h, d) => h === 0 ? !0 : d % 2 === 0)), s === Mh && (A = i.scale().ticks(KS), A = [A[0], A[A.length - 1]]), A;
  }
}, C_ = (e) => {
  let t = "", i = { width: 0, height: 0 }, n = {}, s;
  const A = [], o = e.scale(), { tickValues: a, showAxisName: r, labels: l } = e.renderConfig(), {
    name: c,
    labels: { rotation: g },
    fieldSubtype: h,
    fieldAs: d,
    hyperlink: u
  } = e.config(), { labelManager: f } = e.dependencies();
  let C = o.ticks || o.quantile || o.domain;
  h === zi && d === NY && (C = () => Hg(e)), f.setStyle(e._tickLabelStyle), s = a || C();
  let I = l.rotation || g;
  I && I < 0 && (I = 360 + I);
  const E = [];
  let B = () => {
  };
  return u?.enabled && (B = e.getHyperLinkInfo), s = s.map((p, w) => {
    const Q = e.getFormattedText(p, w, s), y = f.getOriSize(Q);
    return A.push(y), e.constructor.type() === JS && s.length > 1 && I && // Skip the last tick if rotation meets the range.
    ((I > 0 && I < 90 || I > 180 && I < 270) && w === s.length - 1 || // Skip the first tick if rotation meets the range.
    (I > 90 && I < 180 || I > 270 && I < 360) && w === 0) || y.width > i.width && (t = Q, n = e.smartTicks() ? e.smartTicks()[w] : {}, i = y, n = n || y), E.push(
      B(e, p, Q, w, s)
    ), Q;
  }), f.setStyle(e._axisNameStyle), {
    axisNameDimensions: r ? f.getOriSize(c) : { width: 0, height: 0 },
    largestTick: t,
    largestTickDimensions: i,
    allTickDimensions: A,
    axisTicks: s,
    smartTick: n,
    hyperlinksInfo: E,
    hyperLinkConfig: u,
    tickSize: e.getTickSize()
  };
}, F4 = (e, t) => {
  let i = {};
  const { labels: n } = e.renderConfig(), { smartTicks: s, rotation: A } = n, {
    largestTickDimensions: o,
    axisTicks: a,
    smartTick: r,
    axisNameDimensions: l,
    allTickDimensions: c,
    tickSize: g
  } = C_(e), { height: h, width: d } = o;
  return e.domain().length === 0 ? {
    allTickDimensions: c,
    tickSize: 0,
    tickDimensions: { height: 0, width: 0 },
    axisNameDimensions: l,
    largestTickDimensions: o,
    axisTicks: a
  } : (s && !t ? i = r : i = { width: d, height: h }, i = mn(
    A,
    i.width,
    i.height
  ), {
    allTickDimensions: c,
    tickSize: g,
    tickDimensions: i,
    axisNameDimensions: l,
    largestTickDimensions: o,
    axisTicks: a
  });
}, E_ = (e, t, i) => {
  let n, s;
  const A = e.domain(), o = e._minTickDistance.width, { tickSize: a, tickDimensions: r, axisNameDimensions: l } = t, { axisNamePadding: c, tickValues: g, labels: h } = e.config(), { showAxisName: d } = e.renderConfig(), { height: u } = l, { height: f, width: C } = r;
  if (n = i && i.length ? i[1] - i[0] : (C + o) * 3, s = 0, g) {
    const I = e.getMinTickDifference(), [E, B] = [
      Math.min(...g, ...A),
      Math.max(...g, ...A)
    ];
    n = (B - E) / Math.abs(I) * (C + e._minTickDistance.width);
  }
  return (!i || !i.length) && h.rotation !== 0 ? s = Math.max(C, f) : s = f, s += (d ? u + c : 0) + a, {
    width: n,
    height: s
  };
}, B_ = (e, t) => {
  let i, n;
  const s = e.domain(), {
    tickSize: A,
    tickDimensions: o,
    axisNameDimensions: a,
    largestTickDimensions: r
  } = t, { axisNamePadding: l, tickValues: c, metaInf: g } = e.config(), { showAxisName: h, labels: d } = e.renderConfig(), { height: u } = a, { height: f, width: C } = o;
  let I = 0;
  if (i = 0, n = C, e.constructor.type() === JS) {
    const { width: E, height: B } = r, { rotation: m } = d;
    let p = m;
    m > 90 && m < 270 && (p = (180 + m) % 360);
    let w;
    if (p >= 0 && p < 90) {
      const Q = qA(p);
      w = E * Math.cos(Q);
    } else if (p === 90 || p === 270)
      w = B;
    else if (p > 270 && p <= 360) {
      const Q = qA(360 - p);
      w = E * Math.cos(Q);
    }
    g.canvasDimensions.width ? n = Math.min(w, g.canvasDimensions.width * 0.5) : n = w, n = Math.max(n, B), I = zS;
  }
  if (c) {
    const E = e.getMinTickDifference(), [B, m] = [
      Math.min(...c, ...s),
      Math.max(...c, ...s)
    ];
    i = (m - B) / Math.abs(E) * f;
  }
  return n += (h ? I + u + l : 0) + A, {
    height: i,
    width: n
  };
}, m_ = (e, t) => {
  const i = e.range(), n = e.getAxisDimensions(t), s = e.overrideDimension && e.overrideDimension();
  let {
    orientation: A,
    bandwidth: o = 0,
    labels: { rotation: a }
  } = e.config();
  const { show: r } = e.renderConfig(), {
    // largestTickDimensions,
    allTickDimensions: l
  } = n, c = e._minTickDistance.width, g = e._minTickDistance.height, h = r;
  if (A === Se || A === Ke) {
    let { width: f, height: C } = E_(
      e,
      n,
      i
    );
    if (s.width)
      f = s.width;
    else if (!i || !i.length)
      if (e instanceof Be) {
        const I = l.length ? is(l.map((B) => B.width)) : 0, E = e._dependencies.labelManager.getOriSize("WWWWWWWWWW...");
        f = l.length * Math.min(
          I + c,
          E.width + c
        );
      } else
        f = l.reduce((I, E) => {
          const B = a === 0 || a === 180 || a === 360 ? Math.max(E.width, E.height) : Math.min(E.width, E.height);
          return I + (o ? Math.max(E.width, E.height, o) : B + c);
        }, 0);
    return h === !1 && (C = 0), { width: f, height: C };
  }
  let { width: d, height: u } = B_(e, n);
  return s.height ? u = s.height : u || (u = l.reduce((f, C) => {
    let I = a === 90 || a === 270 ? Math.max(C.width, C.height) : Math.min(C.width, C.height);
    const E = e._dependencies.labelManager.getOriSize("W").height;
    return I = Math.max(E, I), f + (o ? Math.max(C.width, C.height, o) : I + g);
  }, 0)), h === !1 && (d = 0), { width: d, height: u };
}, eB = (e, t = !1) => {
  const i = e.range(), n = e.getAxisDimensions(), { orientation: s } = e.config(), { show: A, showAxisName: o } = e.renderConfig(), { axisNameDimensions: a, largestTickDimensions: r, axisTicks: l } = n;
  if (A === !1)
    return {
      width: 0,
      height: 0
    };
  const { width: c } = a;
  if (s === Se || s === Ke) {
    const { width: u, height: f } = E_(
      e,
      n,
      i
    );
    return {
      width: Math.max(u, o ? c : 0),
      height: f
    };
  }
  let { width: g, height: h } = B_(e, n);
  t && !h && (h = l.length * (r.height + e._minTickDistance.height));
  const d = Math.max(h, o ? c : 0);
  return {
    width: g,
    height: d
  };
}, R4 = (e, t) => {
  let i = e.slice(0, 2);
  return e.length || (i = t), i.forEach((n, s) => {
    (n === null || isNaN(n)) && (i[s] = t[s]);
  }), i.sort((n, s) => n - s);
}, p_ = (e, t) => {
  const { domain: i } = e.config();
  return i && (t = R4(i, t)), wt(t, []);
}, Q_ = (e, t) => {
  let i = e.getFormattedText(t[0], 0, t), n = 1;
  for (n; n < t.length; n++) {
    let s = e.getFormattedText(t[n], n, t);
    if (s != i)
      break;
    i = s;
  }
  return n === t.length;
}, k4 = (e, t) => {
  const i = e.scale.bind(e);
  let n = i().domain();
  i().domain(t);
  let s = i().ticks();
  return i().domain(n), Q_(e, s) ? [t[0], Math.ceil(t[1])] : t;
}, v4 = (e, t) => {
  let i = t;
  e instanceof Ln && (i = k4(e, t));
  const { nice: n } = e.config(), s = e.scale.bind(e);
  s().domain(i), n && s().nice(), e._domain = s().domain();
}, T4 = (e, t) => {
  e.scale().domain(t), e._domain = t, e.originalDomain(t), e.resetTickSkippingInterval();
}, G4 = (e = {}, t = {}, i) => !Object.keys(e).length || !Object.keys(t).length ? !1 : i.some((n) => e[n] !== t[n]), L4 = (e, t) => {
  const { orientation: i, isOffset: n } = e.config(), s = e._minDiff;
  if (e.range().length && (i === Se || i === Ke)) {
    e.applyTickSkipping();
    const { largestTickDimensions: A } = e.getAxisDimensions(), o = e.getTickValues().length, { width: a, height: r, padding: l } = e.availableSpace(), { left: c, right: g } = l, h = Math.min(
      A.width,
      (a - (o - 1) * e._minTickDistance.width) / o
    );
    e.maxTickSpaces({
      width: h
    });
    let d = [0, a - c - g];
    const u = Rh(
      s,
      d,
      t,
      [h / 2, h / 2],
      e.config()
    );
    LA(e, "y", u, n ? r : null), e.setTickConfig();
  }
}, U4 = (e, t, i) => {
  const n = i.getOriSize(e);
  return i.useEllipsesOnOverflow(!0), i.getSmartText(e, t, n.height, !0);
}, H4 = (e) => {
  (e.paddingInner === null || e.paddingInner === void 0) && (e.paddingInner = e.padding), (e.paddingOuter === null || e.paddingOuter === void 0) && (e.paddingOuter = e.padding), e.padding = Math.min(1, Math.max(0, Number.parseFloat(e.padding))), e.paddingInner = Math.min(
    1,
    Math.max(0, Number.parseFloat(e.paddingInner))
  ), e.paddingOuter = Math.min(
    1,
    Math.max(0, Number.parseFloat(e.paddingOuter))
  );
}, O4 = (e) => {
  if (!e.tickFormat) {
    const t = e.numberFormat || ((i) => i);
    e.tickFormat = (i) => t(i.rawValue);
  }
}, P4 = (e) => {
  const { domain: t } = e;
  !e.nice && t && t.length && t.filter((i) => i === null).length !== 2 && (e.nice = !1);
}, Y4 = (e, t) => {
  e instanceof Ln || delete t.tickValues;
}, xQ = (e, t) => {
  const { orientation: i } = e.config(), n = Z(t, "axisDomainRanges", e.axisType()) || [];
  return (i === Ze || i === Ke ? n[0] : n[1]) || null;
}, y_ = (e, t, i, n, s, A) => {
  const o = e.scale(), a = o.range();
  o.range(t);
  const r = [
    [i, n],
    [s, A]
  ].map(([l, c], g) => {
    const h = e.getScaleValue(l), d = t[g], u = Math.abs(h - d), f = c / 2;
    return f >= u ? f - u : 0;
  });
  return o.range(a), r;
}, J4 = (e, t, i, n, s, A) => {
  const o = e.scale(), a = o.range(), r = [...t];
  o.range(t);
  const l = e.getScaleValue(i), c = e.getScaleValue(s), g = n / 2, h = A / 2, d = e.availableSpace().height, u = l + g, f = c - h;
  return u > d && (r[0] -= u - d), f < 0 && (r[1] += Math.abs(f)), o.range(a), r;
}, cu = (e) => (e < 0 && (e = 360 + e), e);
function K4(e, t, i) {
  let n = 0, s, A;
  i ? (s = e.length - 2, A = t - 1) : (s = e.length - 1, A = t);
  const o = [];
  if (A > 0) {
    const a = Math.ceil((s - n) / A);
    for (let r = 0; r < e.length; r += a)
      o.push(e[r]);
  }
  return i && o.push(e[e.length - 1]), o;
}
function SQ(e) {
  if (e && e.labels) {
    const { rotation: t } = e.labels;
    t != null && (e.labels.rotation = cu(t));
  }
}
const cs = {
  resolveTickLabelOverflowDirection: (e, t) => {
    const i = e % 360, n = Math.sign(i), s = Math.abs(i);
    return Math.abs(i) === 90 || Math.abs(i) === 270 || Math.abs(i) === 180 || n === 0 ? 0 : t === Ke ? n > 0 ? i > 0 && i < 90 || i > 180 && i < 270 ? -1 : 1 : s > 0 && s < 90 || s > 180 && s < 270 ? 1 : -1 : t === Se || t === Ze ? n > 0 ? i > 0 && i < 90 || i > 180 && i < 270 ? 1 : -1 : s > 0 && s < 90 || s > 180 && s < 270 ? -1 : 1 : t === tn ? n > 0 ? i > 0 && i < 90 || i > 180 && i < 270 ? -1 : 1 : s > 0 && s < 90 || s > 180 && s < 270 ? 1 : -1 : 0;
  },
  getVisibleDimensionsForTickLabels: (e, t, i) => {
    const {
      labels: { rotation: n = 0 }
    } = e.renderConfig(), { orientation: s } = e.config(), { width: A, height: o } = e.availableSpace(), { height: a, width: r } = e.maxTickSpaces(), { height: l, width: c } = mn(
      n,
      r,
      a
    ), { labelManager: g } = e._dependencies, h = e.getUnitWidth(), d = e.resolveTickLabelOverflowDirection(
      n,
      s
    ), u = n % 360, f = Math.abs(u) === 90 || Math.abs(u) === 270;
    return t.map((C, I) => {
      const E = e.getScaleValue(C), B = i(C, I), { width: m, height: p } = g.getOriSize(B), { width: w, height: Q } = mn(
        n,
        m,
        p
      );
      if (e.isXAxis()) {
        let D = d < 0 ? E + h / 2 : d > 0 ? A - (E + h / 2) : w;
        D = Math.min(D, w);
        let _ = f ? w : l;
        return {
          width: f ? a : Math.abs(u) === 180 ? Math.min(D - 5, h) : Math.abs(
            (D - 5) / Math.cos((180 - u) * Math.PI / 180)
          ),
          height: _
        };
      } else {
        let y = d < 0 ? E + h / 2 : d > 0 ? o - (E + h / 2) : Q, D = f ? Q : c;
        return {
          width: f ? w : Math.abs(u) === 180 ? c : Math.abs(
            y / Math.cos((180 - u) * Math.PI / 180)
          ),
          height: D
        };
      }
    });
  },
  setTickConfig: (e) => {
    let t, i, n = e.domain(), { labels: s, tickValues: A, showAxisName: o } = e.renderConfig();
    const a = e.getTickValues(), { labelManager: r } = e._dependencies;
    let {
      paddingInner: l,
      paddingOuter: c,
      renderer: g,
      isCompact: h,
      orientation: d,
      axisNamePadding: u,
      name: f,
      bins: C
    } = e.config(), {
      height: I,
      width: E,
      noWrap: B
    } = e.maxTickSpaces();
    const m = d === "top" || d === "bottom", p = !m;
    A && e.axis().tickValues(A), t = A || a || n, r.setStyle(e._axisNameStyle);
    const w = o ? r.getOriSize(f).height : 0;
    r.setStyle(e._tickLabelStyle), e.scale().paddingInner(l), e.scale().paddingOuter(c);
    const Q = p && h ? !0 : !!(s.rotation % 360);
    Q && (B = !0);
    let y, D;
    if (n && n.length) {
      const _ = A || a || n, x = e._tickFormatter(_), S = Q ? e.getVisibleDimensionsForTickLabels(_, x) : _.map(() => ({ width: E, height: I })), b = e.range(), R = s.rotation, G = Math.abs(R) === 90 || Math.abs(R) === 270, T = Math.abs(R) === 45 || Math.abs(R) === 315;
      let v = R > 90 ? 360 - R : R;
      v = 90 - v, v = v * Math.PI / 180;
      const { height: H } = e.maxTickSpaces();
      t = _.map((N, M, F) => {
        const { width: k, height: O } = S[M];
        if (r.useEllipsesOnOverflow(!0), e.isBinnedAxis() && g !== "html") {
          const { display: P, position: L } = C;
          if (T || G) {
            const q = e.getUnitWidth();
            let $, W;
            if (Number.isInteger(N) && !Xe(N)) {
              $ = `${F[M]}${ph}${F[M] + e.binSize()}`;
              const { width: J } = r.getOriSize(
                P === "wholeRange" ? $ : N
              );
              W = J;
            } else if (!Xe(N)) {
              $ = `${F[M].toFixed(2)}${ph}${(F[M] + e.binSize()).toFixed(2)}`;
              const { width: J } = r.getOriSize(
                P === "wholeRange" ? $ : N.toFixed(2)
              );
              W = J;
            }
            let U = p ? L === "center" ? e.getScaleValue(N) + q / 2 : e.getScaleValue(N) + q : L === "center" ? e.getScaleValue(N) + q / 2 : e.getScaleValue(N);
            if (d === "left") {
              const J = W * Math.cos(v), V = R > 90 ? U - b[1] : b[0] - U, Y = Math.trunc(U);
              y = Y == b[0] || Y == b[1] || V < J, (M === 0 ? y && R !== 315 : y) && (D = Y == b[0] || Y == b[1] ? 0 : V / Math.cos(v));
            }
            if (d === "right") {
              const J = W * Math.cos(v), V = R > 90 ? b[0] - U : U - b[1], Y = Math.trunc(U);
              y = Y == b[0] || Y == b[1] || V < J, (M === 0 ? y && R !== 45 : y) && (D = Y == b[0] || Y == b[1] ? 0 : V / Math.cos(v));
            }
            if (d === "bottom") {
              const J = W * Math.cos(v), V = R > 90 ? b[1] - U : U - b[0], Y = Math.trunc(U);
              y = Y == b[0] || Y == b[1] || V > J, (M === 0 ? y && R !== 315 : y) && (D = Y == b[0] || Y == b[1] ? 0 : V / Math.cos(v));
            }
            if (d === "top") {
              const J = W * Math.cos(v), V = R > 90 ? U - b[0] : b[1] - U, Y = Math.trunc(U);
              y = Y == b[0] || Y == b[1] || V > J, (M === 0 ? y && R !== 45 : y) && (D = Y == b[0] || Y == b[1] ? 0 : V / Math.cos(v));
            }
          }
          i = r.getSmartText(
            x(N, M),
            y ? D : h && F.length > 2 && !Q ? 1 / 0 : m ? k : Q ? O : k,
            m ? O : k,
            B
          );
        } else {
          if (d === "bottom" && (T || G)) {
            const { width: P } = r.getOriSize(N), L = e.getScaleValue(N), q = P * Math.sin(v), $ = R > 90 ? b[0] - L : L - b[0], W = R > 90 ? q < $ : q > $, U = P * Math.cos(v), J = H + YY - JY, V = U > J;
            W && !G ? D = $ / Math.sin(v) : V && (D = J / Math.cos(v)), y = W || V;
          }
          if (p) {
            const { width: P, height: L } = e.availableSpace(), q = e.getTickSize();
            let $ = P;
            g === "html" ? $ = P - cl : $ = P - (o ? zS + w + u : 0) - q;
            const { rotation: W } = s;
            let U = W;
            W > 90 && W < 270 && (U = (180 + W) % 360);
            const J = qA(U), V = 10, Y = 10, nt = Math.max(...b), tt = e.getScaleValue(N);
            let st = $;
            if (U >= 0 && U < 90) {
              const lt = Math.abs(nt - tt), at = $ * Math.tan(J);
              if (lt >= at)
                st = $ / Math.cos(J);
              else {
                const Dt = qA(90 - U);
                st = Math.max(lt - V, 0) / Math.cos(Dt);
              }
            } else if (U === 90 || U === 270)
              st = h ? L : e.getScaleStep() - Y;
            else if (U > 270 && U <= 360) {
              const lt = tt, at = qA(360 - U), Dt = $ * Math.tan(at);
              if (lt >= Dt)
                st = $ / Math.cos(at);
              else {
                const Qt = qA(
                  90 - (360 - U)
                );
                st = lt / Math.cos(Qt);
              }
            }
            i = r.getSmartText(
              x(N, M),
              st,
              st,
              !0
            );
          } else
            i = r.getSmartText(
              x(N, M),
              y ? D : g === "html" ? k - cl : h && F.length > 2 && !Q ? 1 / 0 : m ? k : Q ? O : k,
              m ? O : k,
              B
            );
        }
        if (M === 0 && g !== "html" && e.isBinnedAxis()) {
          const { position: P } = C;
          if (P === "start" && !y) {
            const L = e._tickFormatter(n), q = F[0], $ = F[1], W = L(q, 0), U = L($, 1);
            let { width: J, height: V } = r.getOriSize(W), { width: Y } = r.getOriSize(U);
            const nt = e.getScaleValue(q), tt = e.getScaleValue($);
            nt + J + Y / 2 > tt && (J = tt - Y / 2), i = r.getSmartText(
              x(N, M),
              J,
              V,
              B
            );
          }
        }
        return r.constructor.textToLines(i);
      });
    }
    return e.smartTicks(t), e;
  },
  getTickValues(e) {
    e._config.labels = e._renderConfig.labels;
    const t = e.axis().scale().domain();
    if (e._config.renderer === "html" || !e._config.isCompact)
      return t;
    if (e instanceof Be && e._config.isCompact) {
      const i = e.dependencies().labelManager;
      i.setStyle(e._tickLabelStyle);
      const n = e._tickFormatter(t);
      let s = "", A = !1;
      Xe(t[t.length - 1]) ? (s = n(
        t[t.length - 2],
        t.length - 2
      ), A = !0) : s = n(
        t[t.length - 1],
        t.length - 1
      );
      const o = i.getOriSize(s);
      let a = Number.MIN_VALUE;
      t.forEach((u, f) => {
        const C = n(u, f), I = i.getOriSize(C).width;
        I > a && (a = I);
      });
      const r = Number.isFinite(e.config().labels.rotation) ? e.config().labels.rotation : 0, { width: l, height: c } = mn(
        r,
        Math.max(a, o.width),
        o.height
      ), g = e.isYAxis() ? c : l, h = Math.floor(
        Math.abs(e.range()[1] - e.range()[0]) / (g + 5)
      );
      let d = K4(
        t,
        h,
        A
      );
      if (e.isXAxis() && d.length > 2) {
        if (A) {
          const w = d[d.length - 2], Q = d[d.length - 1], y = n(
            w,
            d.length - 2
          ), D = i.getOriSize(
            y
          ).width, _ = e.getScaleValue(w), x = e.getScaleValue(Q);
          _ + D > x && d.splice(-2, 1);
        }
        const u = d[0], f = d[1], C = n(u, 0), I = n(f, 1), E = i.getOriSize(C).width, B = i.getOriSize(I).width, m = e.getScaleValue(u), p = e.getScaleValue(f);
        m + E + B / 2 > p && d.splice(0, 1);
      }
      return d;
    } else
      return D4(e, t, {
        canTicksShift: !1,
        spaceBetweenTicks: 4,
        allowExtremeLabelsOverflow: e.isXAxis() ? !(e._config.isFacet || e._config.isGrandTotalsEnabled) : !1,
        preserveLastTick: !1
      });
  },
  getIndex(e, t, i) {
    const n = e.domain(), s = K.isInvalid(t) ? t.value() : t, A = e.config().orientation;
    let o;
    return A === Ze || A === tn ? o = n.length - n.findIndex(
      (a) => s == (K.isInvalid(a) ? a.value() : a)
    ) - 1 : o = n.findIndex(
      (a) => s == (K.isInvalid(a) ? a.value() : a)
    ), i && (o -= i.startIdx), o;
  }
}, Sa = {
  getTickValues: (e) => {
    let t = 0;
    const { orientation: i } = e.config(), { tickValues: n } = e.renderConfig(), s = e.range(), A = e.axis(), o = Math.abs(s[0] - s[1]), a = e.axisComponentDimensions().largestTickDimensions;
    if (n)
      return n;
    t = a[i === Ke || i === Se ? "width" : "height"];
    const r = N4(
      o,
      t,
      A,
      e
    );
    return h_(
      e,
      r,
      e.isBinnedAxis() ? {
        allowExtremeLabelsOverflow: e.isXAxis() ? !(e._config.isFacet || e._config.isGrandTotalsEnabled) : !1
      } : {}
    );
  },
  setTickConfig: (e) => {
    const { tickValues: t, showInnerTicks: i } = e.renderConfig(), n = e.axis();
    if (!i) {
      const r = n.tickValues() || [];
      let l = [];
      return r.length >= 2 && !e.config().belongsToTouchedColumn ? (l.push(r[0]), l.push(r[r.length - 1])) : l = [], n.tickValues(l), e;
    }
    t && t instanceof Array && e.axis().tickValues(t);
    const s = e.getTickValues();
    n.tickValues(s);
    const A = e.dependencies().labelManager;
    A.setStyle(e._tickLabelStyle);
    const o = e._tickFormatter(s), a = s.map((r, l) => {
      const c = o(r, l), g = A.getOriSize(c);
      return g.text = c, g;
    });
    return e.smartTicks(a), e;
  },
  /**
   * Sets a fixed baseline for the first ticks so that they can render effectively within
   * the given area
   *
   * @param {*} tickText
   * @param {*} config
   * @param {*} labelManager
   */
  setFixedBaseline(e, t) {
    const { orientation: i } = e.config(), { labels: n } = e.renderConfig(), { rotation: s } = n, A = e.axis(), o = A.tickValues(), a = e.smartTicks();
    if (a && a.length) {
      const { width: r, height: l } = e.smartTicks()[0];
      A.tickTransform((c) => {
        if (c === o[0]) {
          if (i === Ze || i === tn)
            return `translate(0, -${l / 3}px)`;
          if ((i === Se || i === Ke) && !s)
            return `translate(${r / 2}px,  0px)`;
        }
        return "";
      });
    }
    return t;
  }
}, V4 = (e, t, i) => {
  const { orientation: n, fixedBaseline: s } = i.config(), A = i.renderConfig(), a = i.axis().tickSize(), {
    labels: { rotation: r }
  } = A;
  let l = r;
  return l < 0 && (l = 360 + l), l = 360 - l, e.map((c, g) => {
    const h = g === 0 && s, { height: d, width: u } = t[g], { height: f, width: C } = mn(
      r,
      u,
      d
    );
    let I = i.getScaleValue(c);
    i.isYAxis() && (I = i.availableSpace().height - I);
    let E = [0], B = [0];
    if (n === "left") {
      const m = l > 0 && l < 180 ? 1 : l > 180 && l < 360 ? -1 : l === 0 ? 0.5 : l === 180 ? -0.5 : -1, p = l > 90 && l <= 135 ? -1 : l >= 135 && l < 225 ? -2 : l >= 225 && l < 270 ? -1 : 0;
      E.push(-1 * a), h ? m < 0 && B.push(m * f) : B.push(m * (f / 2)), E.push(p * C / 2);
    } else if (n === "right") {
      const m = l > 0 && l < 180 ? -1 : l > 180 && l < 360 ? 1 : l === 0 ? 0.5 : l === 180 ? -0.5 : -1, p = l > 90 && l <= 135 ? 1 : l > 135 && l < 225 ? 2 : l >= 225 && l < 270 ? 1 : 0;
      E.push(a), h ? m < 0 && B.push(m * f) : B.push(m * (f / 2)), E.push(p * C / 2);
    } else if (n === "bottom") {
      const m = l === 270 ? 0.5 : l > 0 && l < 180 ? -0.5 : l >= 180 && l < 360 ? 0 : 1, p = l > 0 && l < 180 || l > 180 && l < 360 ? 1 : 0;
      B.push(a), h ? m > 0 ? E.push(m * C / 2) : E.push(-1 * m * C / 2) : E.push(m * (C / 2)), B.push(p * f / 2), l === 270 && h && E.push(3), l >= 180 && l < 360 && h && E.push(C / 2), l === 0 && !h && E.push(-1 * C / 2);
    } else if (n === "top") {
      const m = l > 0 && l < 90 ? 0 : l >= 90 && l < 180 ? -0.5 : l >= 180 && l < 270 ? 0.5 : l >= 270 && l < 360 ? 0 : 1, p = -1;
      B.push(p * a), h ? E.push(m * C) : E.push(m * (C / 2)), B.push(p * (f / 2)), h && (l > 0 && l < 90 ? E.push(1 * C / 2) : l >= 90 && l < 180 ? E.push(1 * C) : l >= 270 && l < 360 && E.push(1 * C / 2));
    }
    return [E, B] = _4(
      0,
      0,
      _Q(E),
      _Q(B),
      l
    ), {
      position: I,
      rotation: l,
      xShift: E,
      yShift: B
    };
  });
}, _Q = (e) => e.reduce((t, i) => t + i, 0), Cc = "x", gu = "y", W4 = "width", q4 = "height", j4 = "measurement", w_ = "config", z4 = "minUnitWidth", $4 = "minUnitHeight", X4 = "dimensions", Z4 = "measures", mi = "dimension", ha = "measure", kh = "continuous", vh = "binned", t9 = "pivot", e9 = "format", i9 = "mount", n9 = "hasDataUpdated", D_ = "rows", x_ = "columns", s9 = "data", zA = "col", Oi = "row", Ec = "column", yA = "color", ur = "opacity", po = "shape", wA = "size", Th = "detail", S_ = "layers", __ = "transform", Gh = "ordinal", iB = "linear", Je = "left", oi = "right", Pe = "top", Ee = "bottom", b_ = "retinal", A9 = "cell", hu = "xAxes", du = "yAxes", o9 = "entryCell", a9 = "initialized", r9 = "exitCell", l9 = "axis", c9 = "unit", g9 = "updated", h9 = "beforeupdate", d9 = "valueMatrix", u9 = "facet-headers", f9 = "radius", I9 = "angle", M_ = "angle0", C9 = "arc", E9 = "categorical", er = "temporal", N_ = "bar", F_ = "line", R_ = "point", B9 = "Primary", m9 = "Secondary", p9 = "both", k_ = "interaction", v_ = "gridLines", T_ = "gridBands", G_ = "header", Lh = "headerTitle", Tl = "rowFacetHeader", Uh = "columnFacetHeader", nB = "facet", L_ = "table", Q9 = "default", y9 = "asc", w9 = "desc", Vi = "dark", eA = "none", Hh = "normal", _a = "darker", U_ = 70, uu = "muze", SI = "headerTitlePadding", _I = "textAlign", bI = "start", D9 = "end", UA = "header-type-field-name", MI = "header-type-totals-title", gn = "normal", ye = "total", gs = "sub-total", Gl = "backgroundColor", H_ = "composedMark", x9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ANGLE: I9,
  ANGLE0: M_,
  ARC: C9,
  ASCENDING: y9,
  AXIS: l9,
  BACKGROUND_COLOR: Gl,
  BAR: N_,
  BEFORE_UPDATE: h9,
  BINNED: vh,
  BOTH: p9,
  BOTTOM: Ee,
  CATEGORICAL: E9,
  CELL: A9,
  CELL_SOURCE_TYPE_NORMAL: gn,
  CELL_SOURCE_TYPE_SUB_TOTAL: gs,
  CELL_SOURCE_TYPE_TOTAL: ye,
  COL: zA,
  COLOR: yA,
  COLUMN: Ec,
  COLUMNS: x_,
  COLUMN_FACET_HEADER: Uh,
  COMPOSED_MARK: H_,
  CONFIG: w_,
  CONTINUOUS: kh,
  DARK: Vi,
  DARKER: _a,
  DATA: s9,
  DEFAULT: Q9,
  DEFAULT_BANDWIDTH_ARC_MARK: U_,
  DESCENDING: w9,
  DETAIL: Th,
  DIMENSION: mi,
  DIMENSIONS: X4,
  END: D9,
  ENTRY_CELLS: o9,
  EXIT_CELLS: r9,
  FACET: nB,
  FACET_HEADERS: u9,
  FORMAT: e9,
  GRID_BANDS: T_,
  GRID_LINES: v_,
  HAS_DATA_UPDATED: n9,
  HEADER: G_,
  HEADER_TITLE: Lh,
  HEADER_TITLE_PADDING: SI,
  HEADER_TYPE_FIELD_NAME: UA,
  HEADER_TYPE_TOTALS_TITLE: MI,
  HEIGHT: q4,
  INITIALIZED: a9,
  INTERACTION: k_,
  LAYERS: S_,
  LEFT: Je,
  LINE: F_,
  LINEAR: iB,
  MEASURE: ha,
  MEASUREMENT: j4,
  MEASURES: Z4,
  MIN_UNIT_HEIGHT: $4,
  MIN_UNIT_WIDTH: z4,
  MOUNT: i9,
  MUZE_CLASSNAME_PREFIX: uu,
  NONE: eA,
  NORMAL: Hh,
  OPACITY: ur,
  ORDINAL: Gh,
  PIVOT: t9,
  POINT: R_,
  PRIMARY: B9,
  RADIUS: f9,
  RETINAL: b_,
  RIGHT: oi,
  ROW: Oi,
  ROWS: D_,
  ROW_FACET_HEADER: Tl,
  SECONDARY: m9,
  SHAPE: po,
  SIZE: wA,
  START: bI,
  TABLE: L_,
  TEMPORAL: er,
  TEXT_ALIGN: _I,
  TOP: Pe,
  TRANSFORM: __,
  UNIT: c9,
  UPDATED: g9,
  VALUE_MATRIX: d9,
  WIDTH: W4,
  X: Cc,
  X_AXES: hu,
  Y: gu,
  Y_AXES: du
}, Symbol.toStringTag, { value: "Module" })), S9 = (e, t, i, n) => {
  const s = e.config(), A = e.axis(), o = e.renderConfig(), a = e.smartTicks(), r = A.scale(), c = (r.ticks || r.quantile || r.domain)(), h = A.tickValues() || c, d = e.axis().tickSize(), { tickStartIdx: u } = n, { orientation: f } = s, { labels: C } = o;
  let I = C.rotation;
  if (I < 0 && (I = 360 + I), I = 360 - I, e instanceof Ln || e instanceof qi) {
    let E;
    E = h.slice(u);
    const B = V4(
      E,
      a.slice(u),
      e
    );
    return t.each(function(m, p) {
      const { xShift: w, yShift: Q, rotation: y } = B[p], D = String(
        a[u + p] ? a[u + p].text : m
      );
      let _ = "", x = 0, S = 0;
      f === Se ? _ = `translate(0, -${d}) rotate(${y}, 0, 0)` : f === Ke ? _ = `translate(0, ${d}) rotate(${y}, 0, 0)` : f === Ze ? _ = `translate(-${d}, 0) rotate(${y}, 0, 0)` : f === tn && (_ = `translate(${d}, 0) rotate(${y}, 0, 0)`), X(this).attr("x", w).attr("y", Q).attr("dx", x).attr("dy", S).attr("transform", _).text(D).style("transform", "");
    }), t;
  }
  return t.each(function(E, B) {
    const m = String(
      a[u + B] ? a[u + B].text : E
    ), p = i.getOriSize(m), w = p.width, Q = p.width / 2;
    let y = 0, D = 0, _ = 0, x = 0, S = "";
    f === Se ? (S = `translate(0, -${d}) rotate(${I}, 0, 0)`, x = 3, I >= 180 && I <= 360 ? y = Q : y = -Q, I === 0 || I === 360 ? (y = 0, x = 0) : I === 180 && (y = 0, x = 6)) : f === Ke ? (S = `translate(0, ${d}) rotate(${I}, 0, 0)`, x = 3, I >= 180 && I <= 360 ? (y = -Q, _ = -3) : (y = Q, _ = 3), I === 0 || I === 360 ? (y = 0, x = d + 3, _ = 0) : I === 180 && (y = 0, x = -3, _ = 0)) : f === Ze ? (S = `translate(-${d}, 0) rotate(${I}, 0, 0)`, x = "0.3em", I < 90 ? _ = 0 : I === 90 ? (y = Q, x = 9) : I > 90 && I <= 180 || I > 180 && I < 270 ? _ = w : I === 270 ? (y = Q, x = -5) : _ = 0) : f === tn && (S = `translate(${d}, 0) rotate(${I}, 0, 0)`, x = "0.3em", I < 90 ? _ = 0 : I === 90 ? (y = -Q, x = -5) : I > 90 && I <= 180 ? _ = -w : I > 180 && I < 270 ? _ = w : I === 270 ? (y = -Q, x = 5) : _ = 0), X(this).attr("x", y).attr("y", D).attr("dx", _).attr("dy", x).attr("transform", S).text(m).style("transform", "");
  }), t;
}, _9 = (e, t, i, n) => {
  if (t instanceof Be) {
    const {
      bins: { position: s },
      orientation: A
    } = t.config();
    if (s === lu)
      return "";
    const o = i.text, a = t.dependencies().labelManager, r = t.range(), l = a.getOriSize(o), c = t.getScaleValue(e);
    if ((A === qn || A === kn) && n === 0 && c <= r[0])
      return `translate(${l.width / 2}, 0)`;
    if ((A === Ze || A === tn) && n === 0 && c >= r[1])
      return `translate(0, ${-l.height / 2})`;
  }
  return "";
}, b9 = (e, t, i, n, s, A) => {
  const { _smartTicks: o } = t, a = t.config(), r = t.renderConfig(), l = t.dependencies().labelManager, { orientation: c, classPrefix: g } = a, h = wt(n, a.transition), { labels: d } = r, { rotation: u, smartTicks: f } = d, { tickStartIdx: C } = s, I = e.selectAll(".tick text");
  if (I.selectAll("tspan").remove(), u)
    S9(t, I, l, s);
  else if (!u && !f)
    I.attr("transform", "");
  else if (I.text(""), I.attr("transform", function(E, B) {
    return _9(
      E,
      t,
      o[B],
      B
    );
  }), c === qn || c === kn) {
    I.attr("y", 0).attr("x", 0).text("");
    const E = z(
      I,
      "tspan",
      (m, p) => o[C + p] ? o[C + p].lines : [],
      `${g}-smart-text`
    );
    E.attr("dy", "0").style("opacity", "0");
    let B = E;
    h.disabled || (B = E.transition().duration(h.duration).on("end", A.newCallback())), I.each(function(m, p) {
      const w = X(this).selectAll("tspan"), Q = C + p;
      w.attr("dy", (y, D) => {
        if (o[Q])
          return c === kn || D !== 0 ? o[Q].oriTextHeight : -o[Q].oriTextHeight * (o[Q].lines.length - 1) - i;
      });
    }), B.style("opacity", 1).text((m) => m).attr("x", 0);
  } else
    z(
      I,
      "tspan",
      (B, m) => o[C + m].lines,
      `${g}-smart-text`
    ).text((B) => B);
  return I;
}, M9 = (e) => {
  const { fixedBaseline: t } = e.config(), { showInnerTicks: i } = e.renderConfig(), n = e.domain();
  t && n.length && i && e.setFixedBaseline();
}, N9 = (e, t, i) => {
  const { axisNameHeight: n, availableSpace: s } = i;
  switch (t) {
    case Ze:
      e.attr(
        "transform",
        `translate(${-(s.width - n)},${s.height / 2})rotate(-90)`
      );
      break;
    case tn:
      e.attr(
        "transform",
        `translate(${s.width - n},${s.height / 2})rotate(90)`
      );
      break;
    case Se:
      e.attr(
        "transform",
        `translate(${s.width / 2},${-s.height + n})`
      );
      break;
    case Ke:
      e.attr(
        "transform",
        `translate(${s.width / 2},${s.height - n / 2})`
      );
      break;
  }
  return e;
}, F9 = (e, t, i) => {
  const s = t.getAttribute("transform").match(
    /translate\(([^,]+),\s*([^)]+)\)/
  ), A = t.getBBox(), o = A.width, a = A.height, r = s ? parseFloat(s[1]) : 0, l = s ? parseFloat(s[2]) : 0;
  switch (i) {
    case Ze:
      e.attr(
        "transform",
        `translate(${r - a / 3},${l - o / 2 - 5})rotate(-90)`
      );
      break;
    case tn:
      e.attr(
        "transform",
        `translate(${r + a / 3},${l + o / 2 + 5})rotate(90)`
      );
      break;
    case Se:
      e.attr(
        "transform",
        `translate(${r + o / 2 + 5},${l - a / 3})`
      );
      break;
    case Ke:
      e.attr(
        "transform",
        `translate(${r + o / 2 + 5},${l - a / 3})`
      );
      break;
  }
  return e;
};
function R9(e, t, i) {
  const n = et(
    e.renderConfig(),
    t
  ), s = e.config(), { show: A, xOffset: o, yOffset: a, showAxisName: r, labels: l, smartAxisName: c } = n, g = e.mount(), {
    orientation: h,
    axisNamePadding: d,
    className: u,
    id: f,
    classPrefix: C,
    labels: { className: I },
    interaction: {
      menu: { showIcon: E, onIconClick: B }
    }
  } = s;
  let m = wt(n.transition, s.transition);
  if (!A)
    return;
  const p = z(
    X(g),
    "g",
    [e],
    `${u.split(" ")[0]}`,
    {},
    (S) => S.config().id
  );
  p.attr("class", u), p.attr("transform", `translate(${o},${a})`);
  let w = [], Q, y;
  if (e.domain().length > 0) {
    const S = e.dependencies().labelManager, b = e.range(), R = e.axis(), G = e.scale(), {
      _tickLabelStyle: T,
      _tickFormatter: v
    } = e;
    y = e.getTickSize(), S.setStyle(T);
    const H = G.ticks || G.quantile || G.domain;
    if (e instanceof xe || e instanceof Be) {
      const F = v9(
        e,
        n
      );
      let k, O, P;
      F ? (k = F.visibleTicks, O = F.tickStartIdx, P = F.tickEndIdx) : (k = R.tickValues(), O = 0, P = k.length - 1), w = k, R.tickValues(w), Q = { tickStartIdx: O, tickEndIdx: P };
    } else
      w = R.tickValues() || H(), Q = { tickStartIdx: 0, tickEndIdx: w.length - 1 };
    const N = w.map((F, k) => ({
      value: F,
      type: e.isXAxis() ? hu : du,
      getDataPath: () => {
        const O = w[k];
        return [
          ...e.config().metaInf.facets,
          {
            field: e.config().fieldInstance,
            value: O,
            sourceType: e.config().metaInf.sourceType
          }
        ];
      }
    }));
    if (R.tickFormat(v(w)), Math.abs(b[0] - b[1]), e.axisComponentDimensions().largestTickDimensions, M9(e), !l.rotation && l.smartTicks === !1) {
      const F = m.disabled;
      let k = p;
      F || (k = p.transition().duration(1e3).on("end", i.newCallback())), k.call(R), p.selectAll(".tick").data(N);
    } else {
      if (p.call(R), p.selectAll(".tick").data(N), e instanceof Be) {
        const {
          bins: { position: F }
        } = e.config();
        F === "start" && p.selectAll(".tick").each(function() {
          const k = X(this), O = e.getUnitWidth(), L = k.attr("transform").match(
            /translate\(([^,]+),([^)]+)\)/
          );
          if (L) {
            const q = parseFloat(L[1]), $ = parseFloat(L[2]), W = e.config().orientation;
            k.attr(
              "transform",
              `translate(${W === qn || W === kn ? q - O / 2 : q}, ${W === Ze || W === tn ? $ + O / 2 : $})`
            );
          }
        });
      }
      b9(
        p,
        e,
        y,
        null,
        Q,
        i
      );
    }
    p.selectAll(".tick").classed(`${C}-ticks`, !0), p.selectAll(".tick line").classed(`${C}-tick-lines`, !0);
    const M = p.selectAll(".tick text");
    M.classed(`${C}-ticks`, !0).classed(`${C}-ticks-${f}`, !0).classed(I, !0), s.useExternalCSS || Object.entries(s.ticks.labels.style).forEach(([F, k]) => {
      M.style(F, k);
    });
  } else
    p.selectAll(".tick").remove();
  let D, _;
  r && E ? (_ = z(p, "g", [1], "icon-holder").attr("cursor", "pointer").attr("pointer-events", "bounding-box"), D = z(
    _,
    "text",
    [c],
    `${C}-axis-name`
  )) : D = z(
    p,
    "text",
    [c],
    `${C}-axis-name`
  ), D.attr("text-anchor", "middle").classed(`${C}-axis-name-${f}`, !0).text((S) => S.text), s.useExternalCSS || Object.entries(s.title.style).forEach(
    ([S, b]) => D.style(S, b)
  ), D.classed(GY, !r);
  const x = {
    axisNameHeight: c.height,
    availableSpace: e.availableSpace()
  };
  if (N9(D, h, x), r && E) {
    const S = D.node(), b = z(_, "image", [1]).attr("xlink:href", jE).attr("width", "8px").attr("height", "5px").classed("caret-icon", !0);
    B != null && _.on(
      "click",
      () => B(
        {
          facetPath: e.config().metaInf.facets,
          field: e.config().fieldInstance,
          value: e.config().field,
          sourceType: e.config().metaInf.sourceType
        },
        e
      )
    ), F9(b, S, h);
  }
  r && D.style("padding", `${d}px`), k9(e, {
    visibleTicks: w,
    ticksContainer: p,
    showAxisName: r
  });
}
const k9 = (e, t) => {
  const { visibleTicks: i, ticksContainer: n, showAxisName: s } = t;
  if (!(e instanceof xe || e instanceof Be || e instanceof Ln && s))
    return;
  const A = e.mount(), o = X(X(A).node().parentElement);
  o.style("position", "relative");
  const { orientation: a } = e.config(), { x: r, y: l } = If(
    n.attr("transform")
  ), c = [];
  if (e instanceof Ln) {
    const h = n.selectAll("text.muze-axis-name"), { x: d, y: u } = If(
      h.attr("transform")
    ), f = e.config().field, C = r + d, I = l + u, E = e.isXAxis() ? {
      left: `${C}px`,
      top: `${I + 3}px`,
      transform: "translateX(-50%)"
    } : {
      left: `${C + 5}px`,
      top: `${I}px`,
      transform: "translateY(-50%)"
    };
    c.push({
      key: `direct-sort-container-measure-axis-${f}`,
      targetElem: h,
      targetData: {
        fieldName: f,
        getDataPath: () => [
          ...e.config().metaInf.facets,
          {
            field: e.config().fieldInstance,
            value: e.config().field,
            sourceType: e.config().metaInf.sourceType
          }
        ]
      },
      boxStyle: E
    });
  } else {
    const h = e.domain(), d = Symbol("Invalid value"), u = /* @__PURE__ */ new Map(), f = (C) => Xe(C) ? d : C;
    i.forEach((C) => {
      const I = Ml(
        h[h.length - 1],
        C
      );
      u.set(f(C), {
        rawValue: C,
        isLastValueInDomain: I,
        getDataPath: () => [
          ...e.config().metaInf.facets,
          {
            field: e.config().fieldInstance,
            value: C,
            sourceType: e.config().metaInf.sourceType
          }
        ]
      });
    }), n.selectAll("g.tick.muze-ticks").each(function() {
      const C = X(this), I = C.data()[0].value, E = C.node().textContent, { x: B, y: m } = If(
        C.attr("transform")
      ), p = u.get(f(I)), w = r + B, Q = l + m;
      let y = {};
      a === Ze ? y = {
        right: "0px",
        top: `${Q}px`,
        transform: "translateY(-50%)"
      } : a === tn ? y = {
        left: "0px",
        top: `${Q}px`,
        transform: "translateY(-50%)"
      } : a === qn ? y = {
        left: `${w}px`,
        bottom: "0px",
        transform: "translateX(-50%)"
      } : a === kn && (y = {
        left: `${w}px`,
        top: "0px",
        transform: "translateX(-50%)"
      }), c.push({
        key: `direct-sort-container-${I}`,
        targetElem: C,
        targetData: {
          value: E,
          ...p
        },
        boxStyle: y
      });
    });
  }
  z(
    o,
    "div",
    c,
    "muze-direct-sort-box",
    {},
    (h) => h.key
  ).each(function(h, d, u) {
    const f = X(this), { targetElem: C, targetData: I, boxStyle: E } = h;
    vt(f, {
      ...E,
      background: "white",
      position: "absolute"
    });
    const B = z(
      f,
      "div",
      [1],
      "muze-direct-sort-container",
      {},
      null
    );
    C.node()[qS] = B.node(), B.node()[jS] = C.node(), i_({
      axisInst: e,
      directSortContainer: B,
      targetElemData: I,
      allTargetElems: u,
      textInfo: null,
      isOverlay: !1,
      cellRender: "svg"
    });
  });
}, v9 = (e, t) => {
  const i = e_(e, t);
  if (!i)
    return null;
  const n = e.domain(), s = e.getTickValues();
  let A, o, a;
  if (n.length === s.length)
    A = s.slice(i.absStartIdx, i.absEndIdx + 1), o = i.absStartIdx, a = i.absEndIdx;
  else {
    const r = n.slice(
      i.absStartIdx,
      i.absEndIdx + 1
    ), l = /* @__PURE__ */ new Map();
    for (let g = 0; g < r.length; g++) {
      const h = r[g];
      l.set(h, g);
    }
    o = Math.max(
      0,
      s.findIndex((g) => l.get(g) != null)
    );
    const c = Math.max(
      0,
      s.slice().reverse().findIndex((g) => l.get(g) != null)
    );
    a = s.length - 1 - c, A = s.slice(o, a + 1);
  }
  return {
    visibleTicks: A,
    tickStartIdx: o,
    tickEndIdx: a
  };
};
function If(e) {
  let t = 0, i = 0;
  const n = e.match(/translate\(([^()]+)\)/);
  if (n) {
    const s = n[1].split(",").map((A) => A.trim()).map((A) => +A);
    t = s[0], i = s[1];
  }
  return { x: t, y: i };
}
const Cf = (e) => cu(e), Ef = (e) => cu(e), bQ = (e, t) => {
  let i, n;
  const s = e.config(), {
    width: A,
    height: o,
    padding: a
  } = e.availableSpace(), { top: r, left: l, bottom: c, right: g } = a, { isOffset: h } = t, { labels: d } = e.renderConfig(), { rotation: u } = d, {
    fixedBaseline: f,
    axisNamePadding: C,
    tickValues: I,
    labels: { rotation: E }
  } = s, { tickDimensions: B, allTickDimensions: m, axisNameDimensions: p, tickSize: w } = e.getAxisDimensions(), { height: Q, width: y } = B, _ = (e instanceof xe || e instanceof Be ? !1 : e.renderConfig().showAxisName) ? C : 0, x = { smartTicks: !0, rotation: d.rotation }, S = e._minTickDistance, b = e._minTickSpace, R = e._minDiff, G = e.domain(), T = p.height, v = S.width, H = Math.min(b.width, y), N = Math.min(b.height, Q);
  return {
    [QA]: {
      x: () => {
        !I && e.applyTickSkipping();
        const M = e.getTickValues(), F = M.length;
        i = (A - (F - 1) * v) / F, n = o - T - w - _, i < H && u !== 0 && (x.rotation = u, i < N && (n = o, i = N, e.renderConfig({
          showInnerTicks: !1,
          showOuterTicks: !1
        }))), o < T && e.renderConfig({ show: !1 });
        let k = [0, A - l - g];
        const O = e._dependencies.labelManager, P = e._tickFormatter(M), L = M.length ? O.getOriSize(P(M[0], 0)) : { width: 0, height: 0 }, q = M.length ? O.getOriSize(
          P(M[M.length - 1], M.length - 1)
        ) : { width: 0, height: 0 }, $ = s.labels && Number.isFinite(s.labels.rotation) ? s.labels.rotation : 0, [W, U] = [
          L,
          q
        ].map((nt) => mn($, nt.width, nt.height).width), J = y_(
          e,
          k,
          M[0],
          W,
          M[M.length - 1],
          U
        );
        let V = [...k];
        const Y = s.adjustRange ? Rh(R, k, G, J, s) : k;
        return V[0] += J[0], V[1] -= J[1], Y[0] = Math.max(V[0], Y[0]), Y[1] = Math.min(V[1], Y[1]), LA(
          e,
          "y",
          Y,
          h ? o : null
        ), e.maxTickSpaces({
          width: i,
          height: n,
          noWrap: u !== null
        }), E != null && (x.rotation = Cf(E)), x;
      },
      y: () => {
        !I && e.applyTickSkipping();
        let M = A, F = [o - r - c, 0];
        const k = e.getTickValues(), O = e._dependencies.labelManager, P = e._tickFormatter(k), L = k.length ? O.getOriSize(P(k[0], 0)) : { width: 0, height: 0 }, q = k.length ? O.getOriSize(
          P(k[k.length - 1], k.length - 1)
        ) : { width: 0, height: 0 }, $ = s.labels && Number.isFinite(s.labels.rotation) ? s.labels.rotation : 0, [W, U] = [
          L,
          q
        ].map((Y) => mn($, Y.width, Y.height).height), J = J4(
          e,
          F,
          k[0],
          W,
          k[k.length - 1],
          U
        ), V = s.adjustRange ? Rh(
          R,
          F,
          G,
          [Q / 2, Q / 2],
          s
        ) : F;
        return V[0] = Math.min(J[0], V[0]), V[1] = Math.max(J[1], V[1]), LA(e, "x", V, h ? A : null), A - T - _ <= v && (M = 0, e.renderConfig({
          showInnerTicks: !1,
          showOuterTicks: !1
        })), e.maxTickSpaces({
          width: M,
          height: o,
          noWrap: !0
        }), A < T && e.renderConfig({ show: !1 }), E != null && (x.rotation = Ef(E)), x;
      }
    },
    [ps]: {
      x: () => {
        const M = e.config().renderer;
        LA(
          e,
          "y",
          [0, A - l - g],
          h ? o : null
        );
        const F = e.range(), k = e.getTickValues();
        return i = (F[1] - F[0]) / (I || G).length - v, n = o - T - w - _, i < H && u !== 0 ? (x.rotation = u === null ? 45 : u, x.smartTicks = !1, i = Math.max(n, H), n < H && e.renderConfig({ showAxisName: !1 })) : (I || M === "svg" && k) && A / (M === "svg" && k ? k.length : G.length) - v < H && e.range([N / 2, A - N / 2]), o < T && e.renderConfig({ show: !1 }), i = (F[1] - F[0]) / (I || k || G).length - v, e.maxTickSpaces({
          width: i,
          height: n,
          noWrap: u !== null
        }), E != null && (x.rotation = Cf(E)), x;
      },
      y: () => {
        LA(
          e,
          "x",
          [o - c, r],
          h ? A : null
        );
        const M = e.range(), F = e.getTickValues();
        i = (M[0] - M[1]) / (I || G).length - v;
        let k = A - T - w - _;
        return k <= v && (k = 0, e.renderConfig({
          showInnerTicks: !1,
          showOuterTicks: !1
        })), i = (M[0] - M[1]) / (I || F || G).length - v, e.maxTickSpaces({
          width: k,
          height: u === 0 ? o : i,
          noWrap: !0
        }), A < T && e.renderConfig({ show: !1 }), E != null && (x.rotation = Ef(E)), x;
      }
    },
    [be]: {
      x: () => {
        x.smartTicks = !1;
        const M = y / 2, k = [(f ? 0 : M) + l, A - g - M];
        LA(e, "y", k, h ? o : null);
        const O = e.range(), P = m.length * (y + v), L = O[1] - O[0], { showAxisName: q } = e.config();
        return L < P && d.rotation !== null && (o - y - _ - w > T ? (x.rotation = null, e.renderConfig({
          showInnerTicks: !0,
          showAxisName: q
        })) : (x.rotation = -90, e.renderConfig({
          showInnerTicks: !0,
          showAxisName: !1
        }))), o < T && e.renderConfig({ show: !1 }), E != null && (x.rotation = Cf(E)), x;
      },
      y: () => {
        x.smartTicks = !1;
        const M = Q / 2, F = f ? 1 : M, k = [o - c - F, M + r];
        return LA(e, "x", k, h ? A : null), A < y + T + _ && (e.renderConfig({ showInnerTicks: !1 }), A < T && e.renderConfig({ show: !1 })), E != null && (x.rotation = Ef(E)), x;
      }
    }
  };
}, T9 = {
  availableSpace: {},
  axisDimensions: {},
  axisComponentDimensions: {},
  config: {
    sanitization: (e, t) => {
      const i = Object.assign({}, e._config || {}), n = et({}, i);
      t = et(n, t), Y4(e, t), p4(e, t), t.axisNamePadding = Math.max(t.axisNamePadding, 0);
      const s = G4(t, i, [
        "interpolator",
        "exponent",
        "base",
        "orientation"
      ]), A = e.sanitizeTickFormatter(t);
      return s && (e._scale = e.createScale(t), e._axis = e.createAxis(t)), e._tickFormatter = (o) => A(o), e.resetRenderConfig(t), H4(t), t.ordering = Go(
        t.ordering,
        ou.ordering
      ), SQ(t), t = e.resolveConfig(t), t;
    }
  },
  renderConfig: {
    sanitization: (e, t) => {
      const i = Object.assign({}, e._renderConfig || {});
      return t = et(i, t), SQ(t), t;
    }
  },
  logicalSpace: {},
  mount: {},
  range: {
    sanitization: (e, t) => (e.scale().range(t), e.logicalSpace(null), t)
  },
  smartTicks: {},
  tickSize: {},
  maxTickSpaces: {
    sanitization: (e, t) => {
      const i = Object.assign({}, e._maxTickSpaces || {});
      return t = et(i, t), t;
    }
  },
  valueParser: {
    defaultValue: (e) => e
  }
};
class fu extends ci().with(Lo) {
  /**
   * Creates an instance of SimpleAxis.
   * @memberof SimpleAxis
   */
  constructor(t, i, n) {
    super(), this.eventManager(n), this._id = Zt(), this._dependencies = i, this._mount = null, this._range = [], this._domain = [], this._domainLock = !1, this._axisDimensions = {}, this._smartTicks = [], this._overriddenDimension = {}, this._directSortInfo = {
      currentNestedSortInfo: null,
      directSortEnabled: !0
    };
    const s = this.getDefaultConfig();
    t.className?.includes("muze-pivot-table-axis") && (s.showAxisName = !1);
    const A = et(s, t), o = X("body"), a = A.classPrefix;
    A.useExternalCSS ? (this._tickLabelStyle = Ls(
      o,
      `${a}-ticks`
    ), this._axisNameStyle = Ls(
      o,
      `${a}-axis-name`
    )) : (this._tickLabelStyle = A.ticks.labels.style, this._axisNameStyle = A.title.style), i.labelManager.setStyle(this._tickLabelStyle), ve(this, T9), this.config(A), this.calculateMinTickSpaceAndTickDistance(i), this._scale = this.createScale(this._config), this._axis = this.createAxis(this._config), this._cachedExtendedDomainDiffs = null, this.emitSelfHooks(mt.INITIALIZED);
  }
  getDefaultConfig() {
    return et({}, ou);
  }
  calculateMinTickSpaceAndTickDistance(t) {
    if (this.config().renderer === "html")
      this._minTickDistance = {
        width: 0,
        height: 0
      };
    else {
      const i = t.labelManager.getOriSize("w");
      this._minTickDistance = {
        width: i.width * 3 / 4,
        height: i.height / 2
      };
    }
    this._minTickSpace = t.labelManager.getOriSize("www...");
  }
  axisType() {
    const { orientation: t } = this.config();
    return t === Se || t === Ke ? "x" : "y";
  }
  resolveConfig(t) {
    return t;
  }
  /**
   * Sets a fixed baseline for the first ticks so that they can render effectively within
   * the given area
   *
   * @param {*} tickText
   * @param {*} config
   * @param {*} labelManager
   */
  setFixedBaseline() {
    return this;
  }
  /**
   *
   *
   * @readonly
   * @memberof SimpleAxis
   */
  scale(...t) {
    return t.length ? (this._scale = t[0], this) : this._scale;
  }
  resetDomain() {
    return this._domain = [], this;
  }
  /**
   *
   *
   * @readonly
   * @memberof SimpleAxis
   */
  axis(...t) {
    return t.length ? (this._axis = t[0], this) : this._axis;
  }
  /**
   *
   *
   * @param {*} d
   *
   * @memberof SimpleAxis
   */
  domain(...t) {
    if (t.length) {
      const i = this.getValidDomain(t[0]);
      return this.scale().domain(i), this._domain = this.scale().domain(), this.setAxisComponentDimensions(), this.logicalSpace(null), this;
    }
    return this._domain;
  }
  extendDomain(t, i = { fieldToShowInPercentage: !1 }) {
    const n = [...this.range()].sort(fI), s = this.invert(n[0] - t[0]), A = this.invert(n[1] + t[1]), o = [s, A].sort(fI);
    this.domain(o, {
      overrideUserDomain: !!i.fieldToShowInPercentage
    });
  }
  cachedExtendedDomainDiffs(...t) {
    return t.length ? (this._cachedExtendedDomainDiffs = t[0], this) : this._cachedExtendedDomainDiffs;
  }
  /**
   * Overwrites domain with user defined domain (if present)
   * @param {Object} context reference to current axes
   * @param {Array} domain default domain
   *
   * @return {Array} domain
   */
  getValidDomain(t) {
    const { domain: i } = this.config();
    return i && (t = i), wt(t, []);
  }
  setAxisComponentDimensions() {
    this.axisComponentDimensions(C_(this));
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  dependencies() {
    return this._dependencies;
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  createScale(t) {
    const { base: i, padding: n, interpolator: s, exponent: A } = t, o = this.range();
    return Ks({
      interpolator: s,
      exponent: A,
      base: i,
      range: o,
      type: this.constructor.type()
    });
  }
  formatTickValue(t, i) {
    const n = i(t);
    return Zi(n);
  }
  sanitizeTickFormatter(t) {
    const { tickFormat: i, format: n } = t;
    return i ? (s) => (A, o) => i(
      { formattedValue: this.formatTickValue(A, n), rawValue: A },
      { context: this, tickIndex: o, allRawTicks: s }
    ) : () => (s) => this.formatTickValue(s, n);
  }
  resetRenderConfig(t) {
    const {
      labels: i,
      show: n,
      showInnerTicks: s,
      showOuterTicks: A,
      showAxisName: o,
      xOffset: a,
      yOffset: r,
      tickValues: l,
      smartAxisName: c
    } = t;
    return this.renderConfig({
      labels: i,
      show: n,
      showInnerTicks: s,
      showOuterTicks: A,
      showAxisName: o,
      xOffset: a,
      yOffset: r,
      tickValues: l,
      smartAxisName: c
    }), this;
  }
  resetLogicalSpace() {
    this.logicalSpace(null), this.range([]), this.resetRenderConfig(this.config());
  }
  getFormattedText(t, i, n) {
    const s = this._tickFormatter;
    return s(n)(t, i);
  }
  getHyperLinkInfo(t, i, n, s, A) {
    const { hyperlink: o } = t.config();
    let a = o.generateHref(
      {
        formattedValue: n,
        rawValue: i
      },
      { context: t, tickIndex: s, allRawTicks: A }
    );
    const r = t.config().fieldInstance.data(), [l, c, g] = o.sanitizeHyperlink ? r.sanitiseStrings([
      a.target,
      a.rel,
      a.url
    ]) : [a.target, a.rel, a.url], h = g || n;
    return {
      target: l || bo,
      rel: c || Mo,
      url: o.encode ? encodeURI(h) : h,
      classNames: a.classNames ? a.classNames : Fo,
      styles: a.styles ? a.styles : No
    };
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  createAxis(t) {
    const { orientation: i } = t, n = SY[i];
    return n ? n(this.scale()) : null;
  }
  setTickValues(t) {
    const i = this.renderConfig();
    this.config({ ...i, tickValues: t }), this.tickValues = t, this.axis().tickValues(t);
  }
  /**
   * This method is used to set the space availiable to render
   * the SimpleCell.
   *
   * @param {number} width The width of SimpleCell.
   * @param {number} height The height of SimpleCell.
   * @memberof AxisCell
   */
  setAvailableSpace(t = 0, i, n, s) {
    let A = {};
    const { orientation: o } = this.config(), a = this.constructor.type();
    if (a === Au) {
      const r = this.availableSpace();
      (!r || r.width !== t || r.height !== i) && this.resetTickSkippingInterval();
    }
    return this.availableSpace({ width: t, height: i, padding: n }), o === Se || o === Ke ? A = bQ(this, { isOffset: s })[a].x() : A = bQ(this, { isOffset: s })[a].y(), this.renderConfig({
      labels: A
    }), this.isBinnedAxis() || this.setTickConfig(), this.setSmartAxisName(), this;
  }
  setSmartAxisName() {
    const { orientation: t, name: i } = this.config(), n = t === Se || t === Ke ? "width" : "height", s = this.availableSpace()[n], A = this.dependencies().labelManager;
    return A.setStyle(this._axisNameStyle), this.renderConfig({
      smartAxisName: U4(i, s, A)
    }), this;
  }
  /**
   *
   *
   * @memberof SimpleAxis
   */
  setTickConfig() {
    return this;
  }
  getScaleValue(t) {
    if (t != null)
      return this.scale()(t);
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  getTickSize() {
    return this.axis().tickSize();
  }
  /**
   * Gets the space occupied by the parts of an axis
   *
   * @return {Object} object with details about sizes of the axis.
   * @memberof SimpleAxis
   */
  getAxisDimensions(...t) {
    return this.axisDimensions(F4(this, ...t)), this.axisDimensions();
  }
  /**
   * Gets the space occupied by the axis.
   *
   * @param {Object} config The config.
   * @param {boolean} config.useRawSpace Whether to consider the original dimensions without any smartTick.
   *
   * @return {Object} object with details about size of the axis.
   * @memberof SimpleAxis
   */
  getLogicalSpace() {
    if (!this.logicalSpace()) {
      const t = eB(this);
      this.logicalSpace(t), this._implicitSpace = t;
    }
    return Ic(this), this.logicalSpace();
  }
  /**
   * Returns the value from the domain when given a value from the range.
   * @param {number} value Value from the range.
   * @return {number} Value
   */
  invert(t) {
    return this.scale().invert(t);
  }
  getNearestInvertedValue(t) {
    return this.invert(t);
  }
  getValueFromPixels(t) {
    return 1 / this.getPixelToValueRatio() * t;
  }
  /**
   * Gets the nearest range value from the given range values.
   * @param {number} v1 Start range value
   * @param {number} v2 End range value
   *
   * @return {Array} range values
   */
  getNearestRange(t, i) {
    return [t, i];
  }
  invertExtent(t, i) {
    return [this.invert(t), this.invert(i)];
  }
  getMinTickDifference() {
    return this.domain();
  }
  getFormattedTickValues(t) {
    return t;
  }
  /**
   * This method returns the width in pixels for one
   * unit along the axis. It is only applicable to band scale
   * and returns undefined for other scale type.
   *
   * @return {number} the width of one band along band scale axis
   * @memberof SimpleAxis
   */
  getUnitWidth() {
    return 0;
  }
  /**
   * This method returns an object that can be used to
   * reconstruct this instance.
   *
   * @return {Object} the serializable props of axis
   * @memberof SimpleAxis
   */
  serialize() {
    return {
      name: this.name,
      type: this.type,
      range: this.range(),
      config: this.config()
    };
  }
  /**
   * Returns the id of the axis.
   * @return {string} Unique identifier of the axis.
   */
  get id() {
    return this._id;
  }
  renderAsHTML(t) {
    const i = this.mount(), {
      className: n,
      orientation: s,
      classPrefix: A,
      id: o,
      useExternalCSS: a,
      ticks: {
        labels: { style: r }
      },
      labels: { align: l, className: c },
      isBold: g,
      firstRowZebraType: h
    } = this.config(), { show: d } = this.renderConfig(), u = s === Ze, f = s === tn, C = u || f;
    if (!d) return;
    const I = e_(this, t), E = I ? I.translate : 0;
    let B;
    C ? B = `translateY(${E}px)` : B = `translateX(${E}px)`;
    const { _smartTicks: m } = this, p = this.domain();
    let w = m;
    I && (w = m.slice(
      I.absStartIdx,
      I.absEndIdx + 1
    ));
    const Q = this.getScaleStep(), y = I ? I.visibleCellDimension : w.length * Q + this.getScalePaddingOuter(), D = z(
      X(i),
      "div",
      [this],
      `${n.split(" ")[0]}`,
      {},
      (T) => T.config().id
    );
    D.attr("class", n).style("float", "none").style("display", "grid").style("grid-auto-flow", C ? "row" : "column").style("justify-content", "stretch").style("width", C ? "100%" : `${y}px`).style("height", C ? `${y}px` : "100%").style("transform", B), D.style(
      `grid-auto-${C ? "rows" : "columns"}`,
      "1fr"
    );
    const { hyperlinksInfo: _, hyperLinkConfig: x } = this.axisComponentDimensions() ?? {}, S = C ? _.slice().reverse() : _, b = (C ? w.slice().reverse() : w).map(({ text: T, oriText: v }, H) => {
      const N = this.domain(), M = N.slice(
        I.absStartIdx,
        I.absEndIdx + 1
      ), F = M[this.isYAxis() ? M.length - 1 - H : H], k = N[N.length - 1] === F;
      return {
        value: T.replace(/<br \/>/g, " "),
        originalText: v,
        rawValue: F,
        isLastValueInDomain: k,
        type: this.isXAxis() ? hu : du,
        hyperlinkInfo: S[H],
        hyperLinkConfig: x,
        getDataPath: () => {
          const P = N.slice(
            I.absStartIdx,
            I.absEndIdx + 1
          ), L = P[this.isYAxis() ? P.length - 1 - H : H];
          return [
            ...this.config().metaInf.facets,
            {
              field: this.config().fieldInstance,
              value: L,
              sourceType: this.config().metaInf.sourceType
            }
          ];
        }
      };
    }), R = (T, v, H) => {
      i_({
        axisInst: this,
        directSortContainer: T,
        targetElemData: v,
        allTargetElems: H,
        textInfo: {
          label: v.value,
          originalText: v.originalText,
          align: l || (u ? "end" : f ? "start" : "center")
        },
        hyperlinkInfo: v.hyperlinkInfo,
        hyperLinkConfig: v.hyperLinkConfig,
        isOverlay: !C,
        cellRender: "html"
      });
    }, G = z(
      D,
      "div",
      b,
      "tick",
      {
        enter: (T, v, H, N) => {
          R(T, v, N);
        },
        update: (T, v, H, N) => {
          R(T, v, N);
        }
      }
    );
    a || Object.entries(r).forEach(([T, v]) => {
      G.style(T, g && T === "font-weight" ? "600" : v);
    }), G.style("white-space", "nowrap").style(
      `${bn}-${qn}`,
      G.size() > 1 ? ig[s][bn][qn] : VY + "px"
    ).style(
      `${bn}-${kn}`,
      ig[s][bn][kn] + "px"
    ).style(
      `${bn}-${YA}`,
      ig[s][bn][YA] + "px"
    ).style(
      `${bn}-${PA}`,
      ig[s][bn][PA] + "px"
    ).style("line-height", 1).classed(`${A}-ticks`, !0).classed(`${A}-ticks-${o}`, !0).classed(c, !0), G.each(function({ rawValue: T }) {
      X(this).classed("muze-totals-label", T === "All");
    }), C ? G.each(function(T, v) {
      const H = I ? p.length - I.absEndIdx - 1 + v : v;
      let N = "";
      h === "odd" ? N = `${A}-text-row-${(H + 1) % 2 === 0 ? "even" : "odd"}` : N = `${A}-text-row-${(H + 1) % 2 === 0 ? "odd" : "even"}`, X(this).classed(`${A}-text-row-even`, !1).classed(`${A}-text-row-odd`, !1).classed(N, !0).style(
        `padding-${u ? "right" : "left"}`,
        `${cl}px`
      );
    }) : (G.style("overflow", "hidden"), G.style(
      "padding-left",
      `${cl}px`
    ), G.style(
      "padding-right",
      `${cl}px`
    ));
  }
  associatedHookComponentPaths() {
    return [
      [Ht.AXIS, this.axisType()],
      [Ht.AXIS]
    ];
  }
  /**
   * This method is used to render the axis inside
   * the supplied svg container.
   *
   * @param {SVGElement} svg the svg element in which to render the path
   * @memberof SimpleAxis
   */
  /* istanbul ignore next */
  render(t, i = {}) {
    if (this.mount()) {
      const n = {
        viewportRange: Z(i, "viewportRange") || null,
        partialRange: xQ(this, i) || null
      }, s = Js();
      this.emitSelfHooks(mt.BEFORE_RENDERED, {
        virtualScrolling: n
      }), this.setTickConfig(), this.config().renderer === "html" ? this.renderAsHTML(i) : R9(this, i, s), this.emitSelfHooks(mt.AFTER_RENDERED, {
        virtualScrolling: n
      }), s.onAllCallbacksCalled().then(() => {
        this.emitSelfHooks(mt.ANIMATION_END, {
          virtualScrolling: n
        });
      });
    }
    return this;
  }
  emitAllRenderHooksWhenRenderSkipped(t) {
    const i = {
      viewportRange: Z(t, "viewportRange") || null,
      partialRange: xQ(this, t) || null
    };
    this.emitSelfHooks(
      [
        mt.BEFORE_RENDERED,
        mt.AFTER_RENDERED,
        mt.ANIMATION_END
      ],
      { virtualScrolling: i }
    );
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  remove() {
    return X(this.mount()).remove(), this._dependencies = null, this._mount = null, this._range = null, this._domain = null, this._domainLock = null, this._axisDimensions = null, this._smartTicks = null, this._overriddenDimension = null, this._directSortInfo = null, this._tickLabelStyle = null, this._axisNameStyle = null, this._scale = null, this._axis = null, this._cachedExtendedDomainDiffs = null, this;
  }
  /**
   *
   *
   * @memberof SimpleAxis
   */
  unsubscribe() {
    return this;
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  isReverse() {
    const t = this.range();
    return t[0] > t[1];
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  getPixelToValueRatio() {
    const t = this.scale(), i = t.range(), n = t.domain();
    return Math.abs(i[1] - i[0]) / (n[1] - n[0]);
  }
  _getRawTickValue(t) {
    return K.getActualValue(t);
  }
  getTicksBasedOnData(t) {
    const i = X(this.mount()).selectAll(".tick");
    let n = null, s = null;
    return t && (n = i.filter(
      (A) => K.getActualValue(t) === this._getRawTickValue(
        A.getDataPath ? A.getDataPath().pop().value : A
      )
    ), s = i.filter(
      (A) => K.getActualValue(t) !== this._getRawTickValue(
        A.getDataPath ? A.getDataPath().pop().value : A
      )
    )), {
      selectionSet: n,
      rejectionSet: s || i
    };
  }
  getIndex() {
    return null;
  }
  getLastTickElement() {
    return this.mount().querySelector(".tick:last-child");
  }
  isXAxis() {
    const { orientation: t } = this.config();
    return t === Se || t === Ke;
  }
  isYAxis() {
    const { orientation: t } = this.config();
    return t === Ze || t === tn;
  }
  currentNestedSortInfo(...t) {
    return t.length ? (this._directSortInfo.currentNestedSortInfo = t[0], this) : this._directSortInfo.currentNestedSortInfo;
  }
  directSortEnabled(...t) {
    return t.length ? (this._directSortInfo.directSortEnabled = t[0], this) : this._directSortInfo.directSortEnabled;
  }
  isBinnedAxis() {
    return !1;
  }
}
const sB = (e, { preserveLastTick: t } = { preserveLastTick: !0 }, i, n, s) => {
  const A = [];
  if (n) {
    if (s === "bottom" || s === "top") {
      if (i = i < 0 ? 360 - Math.abs(i) : i, i !== 0 && i !== 180 && i !== 360)
        return MQ(e, i, n, s);
    } else if (i -= 90, i = i < 0 ? 360 - Math.abs(i) : i, i !== 0 && i !== 180)
      return MQ(e, i, n, s);
  }
  let o = 0, a = "replace";
  const r = () => {
    a = a === "push" ? "replace" : "push";
  };
  let l = 0;
  for (; l < e.length; ) {
    if (l === 0 || t && l === e.length - 1) {
      A.push(l), l++;
      continue;
    }
    const c = A[A.length - 1], g = ng(
      e[c],
      e[l]
    ), h = e[l + 1] ? ng(e[l], e[l + 1]) : !0;
    g && h ? (o > 0 && e[l].crossDimension > e[o].crossDimension && (o = l), l++) : a === "push" ? (A.push(l), o = l, l++, r()) : (A[A.length - 1] = o, l = o + 1, r());
  }
  return A.filter((c, g) => {
    if (g === 0 || t && g === A.length - 1)
      return !0;
    const h = ng(
      e[A[g - 1]],
      e[A[g]]
    ), d = e[A[g + 1]] ? ng(
      e[A[g]],
      e[A[g + 1]]
    ) : !1;
    return !(h || d);
  });
}, ng = (e, t) => {
  const i = e.isTickShifted ? e.position + e.dimension : e.position + e.dimension / 2, n = t.isTickShifted ? t.position - t.dimension : t.position - t.dimension / 2;
  return i > n;
}, MQ = (e, t, i, n) => {
  const [s, A] = i.range();
  let o;
  const a = n === "bottom" || n === "top" ? "dimension" : "crossDimension", r = n === "bottom" || n === "top" ? "crossDimension" : "dimension";
  let l = [];
  const c = e.length;
  if (c) {
    if (t > 0 && t <= 30) {
      let h = Number.MIN_VALUE, d = Number.MAX_VALUE;
      e.forEach((f, C) => {
        const I = e[C][a];
        h = Math.max(h, I), d = Math.min(d, I);
      }), o = (h + d) / 2 + DI;
    }
    (t > 30 && t <= 160 || t > 170) && (o = e[0][r] + DI);
    const g = Math.floor(Math.abs(A - s) / o);
    if (g < c) {
      const h = Math.floor(c / g);
      e.forEach((d, u) => {
        (u === 0 || u === c - 1 || u > 0 && u <= c - h && u % h === 0) && l.push(u);
      });
    } else
      e.forEach((h, d) => {
        l.push(d);
      });
  }
  return l;
};
class AB {
  skipTicks(t, i) {
    return sB(t, i);
  }
}
class O_ extends AB {
  createScale(t) {
    const { range: i } = t, n = no.linear;
    return this._scale = n().range(i), this._scale;
  }
  getScaleValue(t) {
    return this._scale(t) + 0.5;
  }
  sanitizeDomain(t) {
    return t.length && (t = rc(t)), t;
  }
}
class G9 extends AB {
  createScale(t) {
    const { range: i, base: n } = t, s = no.log;
    return this._scale = s().range(i).base(n), this._scale;
  }
  getScaleValue(t) {
    const i = this._scale;
    return t <= 0 ? i(i.domain()[0]) : i(t) + 0.5;
  }
  sanitizeDomain(t) {
    return t[0] <= 0 && (t[0] = Math.max(1, t[0])), t[1] <= 0 && (t[1] = Math.max(1, t[1])), t;
  }
  isTickOverlapping(t, i) {
    const n = t.position + t.dimension / 2, s = i.position - i.dimension / 2;
    return n > s;
  }
}
class L9 extends AB {
  createScale(t) {
    const { range: i, exponent: n } = t, s = no.pow;
    return this._scale = s().range(i).exponent(n), this._scale;
  }
  getScaleValue(t) {
    return this._scale(t) + 0.5;
  }
  sanitizeDomain(t) {
    return t;
  }
}
const U9 = {
  [iu]: G9,
  [nu]: L9,
  [be]: O_
};
class Ln extends fu {
  constructor(t, ...i) {
    O4(t), P4(t), super(t, ...i);
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  createScale(t) {
    const { base: i, padding: n, interpolator: s, exponent: A } = t, o = this.range(), a = U9[s];
    this._interpolator = new a();
    let r = this._interpolator.createScale({
      padding: n,
      exponent: A,
      base: i,
      range: o
    });
    return r = r.nice(), r;
  }
  /**
   *
   *
   * @static
   *
   * @memberof ContinousAxis
   */
  static type() {
    return be;
  }
  getScaleValue(t) {
    if (t != null)
      return this._interpolator.getScaleValue(t);
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  getTickSize() {
    const { showInnerTicks: t, showOuterTicks: i } = this.renderConfig(), n = this.axis();
    return n.tickSizeInner(t === !1 ? 0 : this.config().tickSize), n.tickSizeOuter(i === !1 ? 0 : this.config().tickSize), n.tickSize();
  }
  /**
   *
   *
   * @param {*} d
   *
   * @memberof SimpleAxis
   */
  domain(...t) {
    if (t.length) {
      const i = t[0], n = t.length > 1 && t[t.length - 1] || {
        overrideUserDomain: !1
      }, s = this._interpolator.sanitizeDomain(
        n.overrideUserDomain ? i : p_(this, i)
      );
      return v4(this, s), this.setAxisComponentDimensions(), this.logicalSpace(null), this;
    }
    return this._domain;
  }
  /**
   * This method is used to set the space availiable to render
   * the SimpleCell.
   *
   * @param {number} width The width of SimpleCell.
   * @param {number} height The height of SimpleCell.
   * @memberof AxisCell
   */
  setAvailableSpace(...t) {
    return super.setAvailableSpace(...t), this.getTickSize(), this;
  }
  /**
   *
   *
   * @param {*} tickValues
   *
   * @memberof SimpleAxis
   */
  setTickConfig() {
    return Sa.setTickConfig(this);
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  getTickValues() {
    return Sa.getTickValues(this);
  }
  getMinTickDifference() {
    return Vd(this.renderConfig().tickValues);
  }
  /**
   * Sets a fixed baseline for the first ticks so that they can render effectively within
   * the given area
   *
   * @param {*} tickText
   * @param {*} config
   * @param {*} labelManager
   */
  setFixedBaseline(t) {
    return Sa.setFixedBaseline(this, t);
  }
}
class xe extends fu {
  constructor(...t) {
    super(...t), this._interpolator = {
      skipTicks: sB
    };
  }
  /**
   *
   *
   * @static
   *
   * @memberof BandAxis
   */
  static type() {
    return ps;
  }
  resolveTickLabelOverflowDirection(t, i) {
    return cs.resolveTickLabelOverflowDirection(
      t,
      i
    );
  }
  getVisibleDimensionsForTickLabels(t, i) {
    return cs.getVisibleDimensionsForTickLabels(
      this,
      t,
      i
    );
  }
  setTickConfig() {
    return cs.setTickConfig(this);
  }
  overrideDimension(t) {
    return t == null ? this._overriddenDimension : (this._overriddenDimension = t, this);
  }
  /**
   * Gets the space occupied by the axis
   *
   * @param {Object} config The config.
   * @param {boolean} config.useRawSpace Whether to consider the original dimensions without any smartTick.
   *
   * @return {Object} object with details about size of the axis.
   * @memberof SimpleAxis
   */
  getLogicalSpace(t) {
    if (t = t || {}, !this.logicalSpace()) {
      const i = m_(
        this,
        t.useRawSpace
      );
      this.logicalSpace(i), this._implicitSpace = i;
    }
    return Ic(this), this.logicalSpace();
  }
  /**
   *
   * The return tick values must be data instead of formatted ticks.
   * @memberof BandAxis
   */
  getTickValues() {
    return cs.getTickValues(this);
  }
  formatTickValue(t, i, n, s) {
    let A;
    return n === K.FieldSubtype.TEMPORAL && s === De ? A = Xe(t) ? t : i.rawFormat()(t) : A = t, Zi(A);
  }
  getScaleStep() {
    return this.scale().step();
  }
  getScalePaddingOuter() {
    const t = this.scale();
    return t.step() * t.paddingOuter();
  }
  getScalePaddingInner() {
    const t = this.scale();
    return t.step() * t.paddingInner();
  }
  getScaleBandwidth() {
    return this.scale().bandwidth();
  }
  sanitizeTickFormatter(t) {
    const {
      internalFormat: i = ({ rawValue: c }) => c,
      tickFormat: n,
      fieldAs: s,
      fieldSubtype: A,
      fieldInstance: o,
      grandTotalFormatter: a,
      metaInf: r
    } = t, l = (c, g, h, d) => {
      const u = i(
        { rawValue: g },
        { context: this, tickIndex: h, allRawTicks: d }
      );
      return c(
        {
          formattedValue: this.formatTickValue(
            u,
            o,
            A,
            s
          ),
          rawValue: g
        },
        { context: this, tickIndex: h, allRawTicks: d }
      );
    };
    return a && r.sourceType === "total" ? (c) => (g, h) => l(a, g, h, c) : n ? (c) => (g, h) => l(n, g, h, c) : (c) => (g, h) => {
      const d = i(
        { rawValue: g },
        { context: this, tickIndex: h, allRawTicks: c }
      );
      return this.formatTickValue(
        d,
        o,
        A,
        s
      );
    };
  }
  /**
   *
   *
   *
   * @memberof BandAxis
   */
  getUnitWidth() {
    return this.scale().bandwidth();
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  getTickSize() {
    const { showInnerTicks: t, showOuterTicks: i } = this.renderConfig(), n = this.axis();
    return n.tickSizeInner(t ? this.config().tickSize : 0), n.tickSizeOuter(i ? this.config().tickSize : 0), n.tickSize();
  }
  invertExtent(t, i) {
    return this.scale().invertExtent(t, i);
  }
  /**
   * It accepts a range value and returns one of axis
   * domain values. It assumes that a range value will
   * be associated with a domain value if the range value is in this range:
   *    [domainValPosition - innerPadding / 2, domainValPosition + bandwidth + innerPadding / 2]
   */
  getNearestInvertedValue(t) {
    const i = this.isXAxis() ? this.domain() : [...this.domain()].reverse(), n = this.getUnitWidth(), s = this.getScalePaddingInner();
    let A = this.invert(t);
    A === void 0 && (A = i[0]);
    const o = i.indexOf(A), a = this.getScaleValue(A), r = [
      a - s / 2,
      a + n + s / 2
    ];
    return Va(t, r) ? A : t < r[0] ? i[o - 1] : t > r[1] ? i[o + 1] : void 0;
  }
  /**
   * Gets the nearest range value from the given range values.
   * @param {number} v1 Start range value
   * @param {number} v2 End range value
   * @return {Array} range values
   */
  getNearestRange(t, i) {
    const n = this.scale(), s = n.range(), A = s[0] > s[1], o = this.invertExtent(t, i), a = n(A ? o[o.length - 1] : o[0]), r = n(A ? o[0] : o[o.length - 1]) + n.bandwidth();
    return [a, r];
  }
  getValidDomain(t) {
    let i = super.getValidDomain(t);
    const n = this.config().orientation;
    return (n === "left" || n === "right") && i.reverse(), i;
  }
  extendDomain() {
  }
  getIndex(t, i) {
    return cs.getIndex(this, t, i);
  }
}
function H9(e) {
  const t = e.originalDomain(), i = e._minDiff, n = e._dependencies.labelManager, {
    width: s,
    height: A,
    padding: o
  } = e.availableSpace();
  let a = e._minTickSpace.width, r = e._minTickSpace.height;
  const l = e.config(), c = e.config().useUTC, g = cu(l.labels.rotation), h = mn(
    g,
    a,
    r
  );
  a = h.width, r = h.height;
  let d, u, f, C, I;
  e.isXAxis() ? (d = "width", u = e._minTickDistance.width, f = s, C = a, I = { left: o.left, right: o.right }) : (d = "height", u = e._minTickDistance.height, f = A, C = r, I = { left: o.top, right: o.bottom });
  let E = Math.floor(
    (f + u) / (C + u)
  );
  const B = g_.slice();
  let m = B.length - 1;
  const {
    step: p,
    multiplier: w,
    start: Q
  } = l.tickInterval;
  if (t.length >= 2 && t.every(
    (_) => _ != null && !Number.isNaN(_)
  )) {
    if (p) {
      const [
        _,
        x,
        S,
        b,
        R,
        G
      ] = l_[p], T = x(Q), v = S(Q);
      let H, N = 1;
      for (; H = w * N, !(H > R || Math.abs(t[1] - t[0]) === 0 || H * _ > Math.abs(t[1] - t[0])); ) {
        if (G(H)) {
          const F = c_(
            p,
            T,
            v,
            _,
            H,
            b
          );
          if (NQ(e, F, {
            maxPossibleTicks: E,
            useUTC: c,
            labelManager: n,
            tickDimensionType: d,
            minDistanceBetweenTicks: u,
            availableSpaceDimen: f,
            padding: I,
            minDiff: i,
            domain: t,
            axisConfig: l
          }))
            return F[c ? 3 : 2];
        }
        N++;
      }
    }
    for (let _ = 0; _ < B.length; _++) {
      const x = B[_];
      if (NQ(e, x, {
        maxPossibleTicks: E,
        useUTC: c,
        labelManager: n,
        tickDimensionType: d,
        minDistanceBetweenTicks: u,
        availableSpaceDimen: f,
        padding: I,
        minDiff: i,
        domain: t,
        axisConfig: l
      })) {
        m = _;
        break;
      }
    }
  }
  return B[m][c ? 3 : 2];
}
function NQ(e, t, i) {
  const {
    maxPossibleTicks: n,
    useUTC: s,
    labelManager: A,
    tickDimensionType: o,
    minDistanceBetweenTicks: a,
    availableSpaceDimen: r,
    padding: l,
    minDiff: c,
    domain: g,
    axisConfig: h
  } = i, { labels: d } = h, u = Math.abs(g[1] - g[0]);
  if (Math.floor(
    u / t[1] + 1
  ) <= n) {
    const C = e.scale().ticks(t[s ? 3 : 2]), I = C.length, E = e._tickFormatter(C), B = C.map((_, x) => {
      const { width: S, height: b } = A.getOriSize(E(_, x));
      return mn(
        d.rotation,
        S,
        b
      )[o];
    }), p = Math.max(...B) * I + (I - 1) * a;
    let w = [0, r - l.left - l.right];
    const Q = y_(
      e,
      w,
      C[0],
      B[0],
      C[C.length - 1],
      B[B.length - 1]
    ), y = Rh(
      c,
      w,
      g,
      Q,
      e.config()
    ), D = Math.abs(y[0] - y[1]);
    return p <= D;
  }
  return !1;
}
class fr extends fu {
  constructor(...t) {
    super(...t), this._minDiff = 1 / 0, this._originalDomain = null, this._tickSkippingInterval = null;
  }
  /**
   *
   *
   *
   * @memberof TimeAxis
   */
  createScale(t) {
    const { base: i, padding: n, interpolator: s, exponent: A } = t, o = this.range();
    return Ks({
      interpolator: s,
      exponent: A,
      base: i,
      range: o,
      type: t.useUTC ? PE : QA
    });
  }
  /**
   *
   *
   * @static
   *
   * @memberof TimeAxis
   */
  static type() {
    return QA;
  }
  formatTickValue(t) {
    const i = this.scale().tickFormat()(t);
    return Zi(i);
  }
  sanitizeTickFormatter(t) {
    const { tickFormat: i } = t;
    return i ? (n) => (s, A) => i(
      {
        formattedValue: this.formatTickValue(s),
        rawValue: s.getTime()
      },
      {
        context: this,
        tickIndex: A,
        allRawTicks: n.map((o) => o.getTime())
      }
    ) : () => (n) => this.formatTickValue(n);
  }
  /**
   *
   *
   *
   * @memberof SimpleAxis
   */
  getTickSize() {
    const { showInnerTicks: t, showOuterTicks: i } = this.renderConfig(), n = this.axis();
    return n.tickSizeInner(t === !1 ? 0 : 6), n.tickSizeOuter(i === !1 ? 0 : 6), super.getTickSize();
  }
  /**
   *
   *
   *
   * @memberof TimeAxis
   */
  getTickValues() {
    return this.renderConfig().tickValues || this.scale().ticks();
  }
  /**
   *
   *
   * @param {*} diff
   *
   * @memberof TimeAxis
   */
  minDiff(t) {
    return this._minDiff = Math.min(this._minDiff, t), this;
  }
  applyTickSkipping() {
    w4(this);
  }
  /**
   *
   *
   * @param {*} d
   *
   * @memberof SimpleAxis
   */
  domain(...t) {
    if (t.length) {
      const i = p_(this, t[0]);
      return T4(this, i), this.setAxisComponentDimensions(), this.logicalSpace(null), L4(this, i), this;
    }
    return this._domain;
  }
  overrideDimension(t) {
    return t == null ? this._overriddenDimension : (this._overriddenDimension = t, this);
  }
  getMinTickDifference() {
    return Vd(this.config().tickValues);
  }
  /**
   * This method is used to set the space availiable to render
   * the SimpleCell.
   *
   * @param {number} width The width of SimpleCell.
   * @param {number} height The height of SimpleCell.
   * @memberof AxisCell
   */
  setAvailableSpace(...t) {
    return super.setAvailableSpace(...t), this.getTickSize(), this;
  }
  /**
   *
   *
   * @returns
   * @memberof BandAxis
   */
  setTickConfig() {
    let t, i;
    const { labels: n, tickValues: s } = this.renderConfig(), {
      height: A,
      width: o,
      noWrap: a
    } = this.maxTickSpaces(), { labelManager: r } = this._dependencies, l = this.getTickValues();
    s && this.axis().tickValues(s);
    const { width: c, height: g } = mn(
      n.rotation,
      o,
      A
    );
    if (t = s || l, r.setStyle(this._tickLabelStyle), l && l.length) {
      const h = s || l, d = this._tickFormatter(h);
      t = h.map((u, f) => (r.useEllipsesOnOverflow(!0), i = r.getSmartText(
        d(u, f),
        c,
        g,
        a
      ), r.constructor.textToLines(i)));
    }
    return this.smartTicks(t), this;
  }
  originalDomain(...t) {
    return t.length ? (this._originalDomain = t[0], this) : this._originalDomain || this.domain();
  }
  getTickSkippingInterval() {
    return this._tickSkippingInterval || (this._tickSkippingInterval = H9(this)), this._tickSkippingInterval;
  }
  resetTickSkippingInterval() {
    this._tickSkippingInterval = null;
  }
  _getRawTickValue(t) {
    return new Date(t).getTime();
  }
}
function O9(e) {
  const { fieldInstance: t, field: i } = e.config();
  return t.data().getField(i).getBinSize();
}
function Oh(e, t) {
  return Xe(t) ? t : +t + +e.binSize();
}
class Zn extends fu {
  constructor(...t) {
    super(...t), this.binSize(O9(this));
  }
  binSize(...t) {
    return t.length ? (this._binSize = t[0], this) : this._binSize;
  }
  isBinnedAxis() {
    return !0;
  }
}
const P9 = et(
  {},
  ou,
  {
    bins: {
      display: u_,
      position: lu
    },
    labels: {
      rotation: null
    },
    padding: 0,
    paddingInner: 0,
    paddingOuter: 0
  }
), Y9 = et(
  {},
  ou,
  {
    bins: {
      display: Fh,
      position: lu
    }
  }
);
class Be extends Zn {
  constructor(...t) {
    super(...t), this._interpolator = {
      skipTicks: sB
    };
  }
  getDefaultConfig() {
    return et({}, P9);
  }
  createScale(t) {
    const { padding: i } = t, n = this.range();
    return Ks({
      range: n,
      type: "band"
    });
  }
  static type() {
    return ps;
  }
  resolveConfig(t) {
    const { bins: i, orientation: n } = t, s = n === "top" || n === "bottom";
    let A = {};
    return (t.labels.rotation === void 0 || t.labels.rotation === null) && (A = {
      labels: {
        rotation: s ? -45 : 0
      }
    }), i.display === Fh && !i.position && (A.bins = {
      position: "start"
    }), et({}, t, A);
  }
  getIndex(t, i) {
    return cs.getIndex(this, t, i);
  }
  getTickValues() {
    return cs.getTickValues(this);
  }
  getUnitWidth() {
    return this.scale().bandwidth();
  }
  formatTickValue(t) {
    const i = this.config().bins.display;
    return typeof t == "string" ? t : Xe(t) ? Zi(t) : i === Fh ? Zi(Number.isInteger(t) ? t : t.toFixed(2)) : Co([t, Oh(this, t)]);
  }
  sanitizeTickFormatter(t) {
    const { tickFormat: i, grandTotalFormatter: n, metaInf: s } = t, A = (o, a, r, l) => o(
      {
        formattedValue: this.formatTickValue(a),
        rawValue: Xe(a) ? a : [a, Oh(this, a)]
      },
      { context: this, tickIndex: r, allRawTicks: l }
    );
    return n && s.sourceType === "total" ? (o) => (a, r) => A(n, a, r, o) : i ? (o) => (a, r) => A(i, a, r, o) : () => (o) => this.formatTickValue(o);
  }
  setTickConfig() {
    return cs.setTickConfig(this);
  }
  resolveTickLabelOverflowDirection(t, i) {
    return cs.resolveTickLabelOverflowDirection(
      t,
      i
    );
  }
  getVisibleDimensionsForTickLabels(t, i) {
    return cs.getVisibleDimensionsForTickLabels(
      this,
      t,
      i
    );
  }
  overrideDimension(t) {
    return t == null ? this._overriddenDimension : (this._overriddenDimension = t, this);
  }
  /**
   * Gets the space occupied by the axis
   *
   * @param {Object} config The config.
   * @param {boolean} config.useRawSpace Whether to consider the original dimensions without any smartTick.
   *
   * @return {Object} object with details about size of the axis.
   * @memberof SimpleAxis
   */
  getLogicalSpace(t) {
    if (t = t || {}, !this.logicalSpace()) {
      const i = m_(
        this,
        t.useRawSpace
      );
      this.logicalSpace(i), this._implicitSpace = i;
    }
    return Ic(this), this.logicalSpace();
  }
  getValidDomain(t) {
    const { domain: i, orientation: n } = this.config(), s = i || t;
    return n === "left" || n === "right" ? s.slice().reverse() : s;
  }
  getScaleStep() {
    return this.scale().step();
  }
  getScalePaddingOuter() {
    const t = this.scale();
    return t.step() * t.paddingOuter();
  }
  getScalePaddingInner() {
    const t = this.scale();
    return t.step() * t.paddingInner();
  }
  getScaleBandwidth() {
    return this.scale().bandwidth();
  }
  getScaleValue(t) {
    if (t != null)
      return this.scale()(t);
  }
  extendDomain() {
  }
}
class qi extends Zn {
  static type() {
    return be;
  }
  getDefaultConfig() {
    return et({}, Y9);
  }
  resolveConfig(t) {
    const i = t.bins, n = {};
    return i.display === Fh && (n.bins = {
      position: I_
    }), et({}, t, n);
  }
  createScale(t) {
    const { base: i, padding: n, exponent: s } = t, A = this.range(), o = O_;
    this._interpolator = new o();
    let a = this._interpolator.createScale({
      padding: n,
      exponent: s,
      base: i,
      range: A
    });
    return a = a.nice(), a;
  }
  sanitizeTickFormatter(t) {
    const { tickFormat: i, format: n } = t;
    return i ? (s) => (A, o) => {
      const a = [A, Oh(this, A)];
      return i(
        { formattedValue: this.formatTickValue(a, n), rawValue: a },
        { context: this, tickIndex: o, allRawTicks: s }
      );
    } : () => (s) => {
      const A = [s, Oh(this, s)];
      return this.formatTickValue(A, n);
    };
  }
  formatTickValue(t, i) {
    const { bins: n } = this.config();
    if (n.display === u_)
      return Zi(i(Co(t)));
    {
      const s = i(t[0]);
      return Zi(
        Number.isInteger(s) ? s : s && s.toFixed(2)
      );
    }
  }
  getTickValues() {
    return Sa.getTickValues(this);
  }
  setTickConfig() {
    return Sa.setTickConfig(this);
  }
  getUnitWidth() {
    return this.getBinWidth();
  }
  getBinWidth() {
    return Math.abs(
      this.getScaleValue(this.domain()[0] + this.binSize()) - this.getScaleValue(this.domain()[0])
    );
  }
  /**
   * Sets a fixed baseline for the first ticks so that they can render effectively within
   * the given area
   *
   * @param {*} tickText
   * @param {*} config
   * @param {*} labelManager
   */
  setFixedBaseline(t) {
    return Sa.setFixedBaseline(this, t);
  }
}
const FQ = {
  Pink: { hex: "ffc0cb", rgb: "255,192,203" },
  LightPink: { hex: "ffb6c1", rgb: "255,182,193" },
  HotPink: { hex: "ff69b4", rgb: "255,105,180" },
  DeepPink: { hex: "ff1493", rgb: "255,20,147" },
  PaleVioletRed: { hex: "db7093", rgb: "219,112,147" },
  MediumVioletRed: { hex: "c71585", rgb: "199,21,133" },
  LightSalmon: { hex: "ffa07a", rgb: "255,160,122" },
  Salmon: { hex: "fa8072", rgb: "250,128,114" },
  DarkSalmon: { hex: "e9967a", rgb: "233,150,122" },
  LightCoral: { hex: "f08080", rgb: "240,128,128" },
  IndianRed: { hex: "cd5c5c", rgb: "205,92,92" },
  Crimson: { hex: "dc143c", rgb: "220,20,60" },
  FireBrick: { hex: "b22222", rgb: "178,34,34" },
  DarkRed: { hex: "8b0000", rgb: "139,0,0" },
  Red: { hex: "ff0000", rgb: "255,0,0" },
  OrangeRed: { hex: "ff4500", rgb: "255,69,0" },
  Tomato: { hex: "ff6347", rgb: "255,99,71" },
  Coral: { hex: "ff7f50", rgb: "255,127,80" },
  DarkOrange: { hex: "ff8c00", rgb: "255,140,0" },
  Orange: { hex: "ffa500", rgb: "255,165,0" },
  Gold: { hex: "ffd700", rgb: "255,215,0" },
  Yellow: { hex: "ffff00", rgb: "255,255,0" },
  LightYellow: { hex: "ffffe0", rgb: "255,255,224" },
  LemonChiffon: { hex: "fffacd", rgb: "255,250,205" },
  LightGoldenrodYellow: { hex: "fafad2", rgb: "250,250,210" },
  PapayaWhip: { hex: "ffefd5", rgb: "255,239,213" },
  Moccasin: { hex: "ffe4b5", rgb: "255,228,181" },
  PeachPuff: { hex: "ffdab9", rgb: "255,218,185" },
  PaleGoldenrod: { hex: "eee8aa", rgb: "238,232,170" },
  Khaki: { hex: "f0e68c", rgb: "240,230,140" },
  DarkKhaki: { hex: "bdb76b", rgb: "189,183,107" },
  Cornsilk: { hex: "fff8dc", rgb: "255,248,220" },
  BlanchedAlmond: { hex: "ffebcd", rgb: "255,235,205" },
  Bisque: { hex: "ffe4c4", rgb: "255,228,196" },
  NavajoWhite: { hex: "ffdead", rgb: "255,222,173" },
  Wheat: { hex: "f5deb3", rgb: "245,222,179" },
  BurlyWood: { hex: "deb887", rgb: "222,184,135" },
  Tan: { hex: "d2b48c", rgb: "210,180,140" },
  RosyBrown: { hex: "bc8f8f", rgb: "188,143,143" },
  SandyBrown: { hex: "f4a460", rgb: "244,164,96" },
  Goldenrod: { hex: "daa520", rgb: "218,165,32" },
  DarkGoldenrod: { hex: "b8860b", rgb: "184,134,11" },
  Peru: { hex: "cd853f", rgb: "205,133,63" },
  Chocolate: { hex: "d2691e", rgb: "210,105,30" },
  SaddleBrown: { hex: "8b4513", rgb: "139,69,19" },
  Sienna: { hex: "a0522d", rgb: "160,82,45" },
  Brown: { hex: "a52a2a", rgb: "165,42,42" },
  Maroon: { hex: "800000", rgb: "128,0,0" },
  DarkOliveGreen: { hex: "556b2f", rgb: "85,107,47" },
  Olive: { hex: "808000", rgb: "128,128,0" },
  OliveDrab: { hex: "6b8e23", rgb: "107,142,35" },
  YellowGreen: { hex: "9acd32", rgb: "154,205,50" },
  LimeGreen: { hex: "32cd32", rgb: "50,205,50" },
  Lime: { hex: "00ff00", rgb: "0,255,0" },
  LawnGreen: { hex: "7cfc00", rgb: "124,252,0" },
  Chartreuse: { hex: "7fff00", rgb: "127,255,0" },
  GreenYellow: { hex: "adff2f", rgb: "173,255,47" },
  SpringGreen: { hex: "00ff7f", rgb: "0,255,127" },
  MediumSpringGreen: { hex: "00fa9a", rgb: "0,250,154" },
  LightGreen: { hex: "90ee90", rgb: "144,238,144" },
  PaleGreen: { hex: "98fb98", rgb: "152,251,152" },
  DarkSeaGreen: { hex: "8fbc8f", rgb: "143,188,143" },
  MediumSeaGreen: { hex: "3cb371", rgb: "60,179,113" },
  SeaGreen: { hex: "2e8b57", rgb: "46,139,87" },
  ForestGreen: { hex: "228b22", rgb: "34,139,34" },
  Green: { hex: "008000", rgb: "0,128,0" },
  DarkGreen: { hex: "006400", rgb: "0,100,0" },
  MediumAquamarine: { hex: "66cdaa", rgb: "102,205,170" },
  Aqua: { hex: "00ffff", rgb: "0,255,255" },
  Cyan: { hex: "00ffff", rgb: "0,255,255" },
  LightCyan: { hex: "e0ffff", rgb: "224,255,255" },
  PaleTurquoise: { hex: "afeeee", rgb: "175,238,238" },
  Aquamarine: { hex: "7fffd4", rgb: "127,255,212" },
  Turquoise: { hex: "40e0d0", rgb: "64,224,208" },
  MediumTurquoise: { hex: "48d1cc", rgb: "72,209,204" },
  DarkTurquoise: { hex: "00ced1", rgb: "0,206,209" },
  LightSeaGreen: { hex: "20b2aa", rgb: "32,178,170" },
  CadetBlue: { hex: "5f9ea0", rgb: "95,158,160" },
  DarkCyan: { hex: "008b8b", rgb: "0,139,139" },
  Teal: { hex: "008080", rgb: "0,128,128" },
  LightSteelBlue: { hex: "b0c4de", rgb: "176,196,222" },
  PowderBlue: { hex: "b0e0e6", rgb: "176,224,230" },
  LightBlue: { hex: "add8e6", rgb: "173,216,230" },
  SkyBlue: { hex: "87ceeb", rgb: "135,206,235" },
  LightSkyBlue: { hex: "87cefa", rgb: "135,206,250" },
  DeepSkyBlue: { hex: "00bfff", rgb: "0,191,255" },
  DodgerBlue: { hex: "1e90ff", rgb: "30,144,255" },
  CornflowerBlue: { hex: "6495ed", rgb: "100,149,237" },
  SteelBlue: { hex: "4682b4", rgb: "70,130,180" },
  RoyalBlue: { hex: "4169e1", rgb: "65,105,225" },
  Blue: { hex: "0000ff", rgb: "0,0,255" },
  MediumBlue: { hex: "0000cd", rgb: "0,0,205" },
  DarkBlue: { hex: "00008b", rgb: "0,0,139" },
  Navy: { hex: "000080", rgb: "0,0,128" },
  MidnightBlue: { hex: "191970", rgb: "25,25,112" },
  Lavender: { hex: "e6e6fa", rgb: "230,230,250" },
  Thistle: { hex: "d8bfd8", rgb: "216,191,216" },
  Plum: { hex: "dda0dd", rgb: "221,160,221" },
  Violet: { hex: "ee82ee", rgb: "238,130,238" },
  Orchid: { hex: "da70d6", rgb: "218,112,214" },
  Fuchsia: { hex: "ff00ff", rgb: "255,0,255" },
  Magenta: { hex: "ff00ff", rgb: "255,0,255" },
  MediumOrchid: { hex: "ba55d3", rgb: "186,85,211" },
  MediumPurple: { hex: "9370db", rgb: "147,112,219" },
  BlueViolet: { hex: "8a2be2", rgb: "138,43,226" },
  DarkViolet: { hex: "9400d3", rgb: "148,0,211" },
  DarkOrchid: { hex: "9932cc", rgb: "153,50,204" },
  DarkMagenta: { hex: "8b008b", rgb: "139,0,139" },
  Purple: { hex: "800080", rgb: "128,0,128" },
  Indigo: { hex: "4b0082", rgb: "75,0,130" },
  DarkSlateBlue: { hex: "483d8b", rgb: "72,61,139" },
  SlateBlue: { hex: "6a5acd", rgb: "106,90,205" },
  MediumSlateBlue: { hex: "7b68ee", rgb: "123,104,238" },
  White: { hex: "ffffff", rgb: "255,255,255" },
  Snow: { hex: "fffafa", rgb: "255,250,250" },
  Honeydew: { hex: "f0fff0", rgb: "240,255,240" },
  MintCream: { hex: "f5fffa", rgb: "245,255,250" },
  Azure: { hex: "f0ffff", rgb: "240,255,255" },
  AliceBlue: { hex: "f0f8ff", rgb: "240,248,255" },
  GhostWhite: { hex: "f8f8ff", rgb: "248,248,255" },
  WhiteSmoke: { hex: "f5f5f5", rgb: "245,245,245" },
  Seashell: { hex: "fff5ee", rgb: "255,245,238" },
  Beige: { hex: "f5f5dc", rgb: "245,245,220" },
  OldLace: { hex: "fdf5e6", rgb: "253,245,230" },
  FloralWhite: { hex: "fffaf0", rgb: "255,250,240" },
  Ivory: { hex: "fffff0", rgb: "255,255,240" },
  AntiqueWhite: { hex: "faebd7", rgb: "250,235,215" },
  Linen: { hex: "faf0e6", rgb: "250,240,230" },
  LavenderBlush: { hex: "fff0f5", rgb: "255,240,245" },
  MistyRose: { hex: "ffe4e1", rgb: "255,228,225" },
  Gainsboro: { hex: "dcdcdc", rgb: "220,220,220" },
  LightGray: { hex: "d3d3d3", rgb: "211,211,211" },
  Silver: { hex: "c0c0c0", rgb: "192,192,192" },
  DarkGrey: { hex: "a9a9a9", rgb: "169,169,169" },
  Grey: { hex: "808080", rgb: "128,128,128" },
  DimGrey: { hex: "696969", rgb: "105,105,105" },
  LightSlateGrey: { hex: "778899", rgb: "119,136,153" },
  SlateGrey: { hex: "708090", rgb: "112,128,144" },
  DarkSlateGrey: { hex: "2f4f4f", rgb: "47,79,79" },
  Black: { hex: "000000", rgb: "0,0,0" }
}, NI = [
  "#1f77b4",
  "#ff7f0e",
  "#2ca02c",
  "#d62728",
  "#9467bd",
  "#8c564b",
  "#e377c2",
  "#7f7f7f",
  "#bcbd22",
  "#17becf"
], J9 = "#eaeaea", Ll = {
  range: NI,
  value: NI[0],
  step: !1,
  stops: 5,
  type: KE,
  repeatRange: !1,
  domainRangeMap: {},
  ordering: et({}, vo),
  splitBy: {
    field: null,
    values: {}
  },
  invalidValueColor: null,
  domain: []
}, oB = (e) => `hsla(${e[0] * 360},${e[1] * 100}%,${e[2] * 100}%,${e[3] || 1})`, RQ = (e) => (e.split(" ") || []).reduce(
  (t, i) => `${t}${i.charAt(0).toUpperCase()}${i.slice(1)}`,
  ""
), FI = (e, t) => {
  let i = "";
  if (typeof e == "string")
    if (e = e.replace(/ /g, ""), e = e.toLowerCase(), $r(e) === OY || $r(e) === HY)
      i = e.match(/(\d+(\.\d+)?)/g), i = [
        i[0] / 360,
        i[1] / 100,
        i[2] / 100,
        wt(Number(i[3]), 1)
      ];
    else if ($r(e) === UY)
      i = Qx(e);
    else if ($r(e) === LY) {
      const n = e.substring(e.indexOf("(") + 1, e.lastIndexOf(")")).split(/,\s*/);
      i = ya(...n);
    } else FQ[RQ(e)] && (i = ya(...FQ[RQ(e)].rgb.split(",")));
  else e instanceof Array ? i = e : i = ya(t);
  return i;
}, K9 = {
  config: {
    sanitization: (e, t) => {
      const i = et({}, e.constructor.defaultConfig());
      t.type === KE && (t.range = t.range || [i.range[0]], t.range = t.range.length > 1 ? t.range : [J9, ...t.range]);
      const n = et(i, e.config()), s = et(n, t);
      return Array.isArray(s.range) && (s.range = s.range.map(
        (A, o) => FI(A, NI[o])
      ), s.stops = t.stops ? t.stops : t.range && t.range.length > 2 ? t.range.length : null), s.value = FI(s.value, s.value), s.ordering = Go(
        s.ordering,
        Ll.ordering
      ), t.subtype === zi ? (s.step = typeof t.step != "boolean" ? !0 : t.step, s.stops = t.stops ? t.stops : null) : s.stops = s.stops ? s.stops : Ll.stops, s;
    }
  },
  domain: {},
  scale: {},
  uniqueValues: {},
  isGlobal: {}
}, V9 = (e) => Array.isArray(e) ? e.length >= 2 : Number.isFinite(e), P_ = (e, t, i, n, s) => {
  let A = [];
  if (Array.isArray(t))
    if (A = t.slice().sort((o, a) => o - a), V9(A))
      e[0] < A[0] && A.unshift(e[0]), e[1] > A[A.length - 1] && A.push(e[1]);
    else
      throw new Gn("Invalid stops provided in config", {
        cause: "Invalid `stops` provided in config (typeof `stops`: (Array && Array.length > 1) || Number)."
      });
  else
    A = rr(e, t, i, n, s);
  return { domain: e, newStops: A };
}, W9 = (e, t) => {
  let i = [];
  const n = Math.min(t.length, 18);
  if (e > n) {
    const s = Jd()(
      Bx(),
      t.map((A) => oB(A))
    );
    for (let A = 0; A < e; A++)
      i[A] = s(A / (e - 1));
  } else
    i = t.slice(0, e);
  return { newRange: i };
}, q9 = (e) => ({ domain: e.map((i, n) => n / (e.length - 1)), uniqueVals: e, scaleDomain: [0, 1] }), kQ = (e, t, i) => ({
  domain: e,
  uniqueVals: e,
  scaleDomain: [0, 1],
  range: i
}), j9 = (e, t, i) => ({
  uniqueVals: e,
  domain: e,
  nice: !0,
  range: i
}), z9 = (e, t, i, n, s, A) => {
  const o = rc(e), a = n && A && !t ? uE(o, A) : P_(o, t, !0, i, s)?.newStops, { newRange: r } = W9(a.length - 1, i);
  return { uniqueVals: o, domain: a, nice: s, range: r };
}, $9 = (e, t, i) => {
  const { domain: n, newStops: s } = P_(
    rc(e),
    i.length > 2 ? t : i.length - 1,
    !1,
    i
  ), A = i.map((o) => oB(o));
  return { uniqueVals: n, domain: s, nice: !0, range: A };
}, X9 = (e, t, i, n) => {
  const s = n.indexOf(e), A = i[s];
  return t(A);
}, vQ = (e, t, i) => {
  const n = (e - i[0]) / (i[i.length - 1] - i[0]);
  return fc(e, t(n), t(0));
}, Bf = (e, t, i) => fc(e, t(e), t(i[0])), Z9 = () => ({
  [`${Oe}-${Oe}-${Zs}`]: {
    scale: Zs,
    domainRange: () => kQ,
    value: () => vQ
  },
  [`${Oe}-${De}-${Zs}`]: {
    scale: Zs,
    domainRange: () => kQ,
    value: () => vQ
  },
  [`${De}-${De}-${Zs}`]: {
    scale: Zs,
    domainRange: () => q9,
    value: () => X9
  },
  [`${De}-${De}-${ga}`]: {
    scale: ga,
    domainRange: () => j9,
    value: () => Bf
  },
  [`${Oe}-${Oe}-${ga}`]: {
    scale: be,
    domainRange: () => $9,
    value: () => Bf
  },
  [`${Oe}-${De}-${ga}`]: {
    scale: YE,
    domainRange: () => z9,
    value: () => Bf
  }
}), t6 = (e, t, i) => Z9()[`${e}-${t}-${i || ""}`];
class Iu extends ci().with(
  Lo
) {
  constructor(t) {
    super(), this.eventManager(t), this._valuesSorter = null;
  }
  setupValuesSorter(t) {
    const { field: i, ordering: n } = this.config();
    i && (this._valuesSorter = zd(
      { name: i },
      n,
      t
    ));
  }
  sortValues(t) {
    return this._valuesSorter ? this._valuesSorter(t) : t;
  }
}
class ir extends Iu {
  /**
   * Creates an instance of SimpleAxis.
   * @param {Object} config input parameters.
   * @param {Object | undefined} params.range Type of color range.
   * @param {string} params.name the label to show on axis.
   * @param {string} params.type The type of scale to handle.
   * @memberof ColorAxis
   */
  constructor(t, i) {
    super(i), ve(this, K9), this.config(t), this._domainType = this._config.type === "linear" ? Oe : De, this._rangeType = this._config.type === "linear" && !this._config.step ? Oe : De, this._schemeType = n4(this._config.range), this._colorStrategy = this.setColorStrategy(
      this._domainType,
      this._rangeType,
      this._schemeType
    ), this._scale = this.createScale(this._colorStrategy), this._scaleRange = this._scale.range(), this._id = Zt(), this.updateDomain(t.domain), this.emitSelfHooks(mt.INITIALIZED);
  }
  associatedHookComponentPaths() {
    return [
      [Ht.AXIS, "color"],
      [Ht.AXIS]
    ];
  }
  /**
   *
   *
   * @static
   *
   * @memberof ColorAxis
   */
  static defaultConfig() {
    return Ll;
  }
  /**
   *
   *
   * @static
   *
   * @memberof ColorAxis
   */
  static type() {
    return kY;
  }
  /**
   *
   *
   * @param {*} colorStrategy
   *
   * @memberof ColorAxis
   */
  createScale(t) {
    const { range: i } = this.config();
    return i && typeof i == "string" ? i4(i) : Ks({
      type: t.scale,
      range: i
    });
  }
  /**
   *
   *
   * @param {*} domainType
   * @param {*} rangeType
   * @param {*} schemeType
   *
   * @memberof ColorAxis
   */
  setColorStrategy(t, i, n, s) {
    return t6(t, i, n);
  }
  /**
   *
   *
   * @param {*} domainVal
   *
   * @memberof ColorAxis
   */
  getHslString(t) {
    return oB(t);
  }
  /**
   * @param {*} domainVal
   *
   * @memberof ColorAxis
   */
  getColor(t) {
    if (this.config().metaInfo?.isTotalsAxis)
      return this.getHslString(this.config().range[0]);
    const { domainRangeMap: i, invalidValueColor: n } = this.config();
    return i[t] ? i[t] : Xe(t) && n ? n : this.getHslString(this.getRawColor(t));
  }
  getScaleRange() {
    return this._scaleRange;
  }
  /**
   *
   *
   * @param {*} domainVal
   *
   * @memberof ColorAxis
   */
  getRawColor(t) {
    const i = this.domain();
    if (i && t !== void 0) {
      const n = [...i].sort((l, c) => l < c), s = Math.min(...n), A = Math.max(...n);
      t < s ? t = s : t > A && (t = A);
      const o = this.scale(), a = o.range ? o.range() : null, r = this._colorStrategy.value(a)(
        t,
        o,
        this.domain(),
        this.uniqueValues()
      );
      if (r) {
        if (typeof r == "string") {
          const l = r.substring(r.indexOf("(") + 1, r.lastIndexOf(")")).split(/,\s*/);
          return ya(...l);
        }
        return [...r];
      }
    }
    return [...this.config().value];
  }
  setRangeWithInterpolatedColors(t, i) {
    const { domain: n, range: s } = i, A = n.length, o = s.length, { repeatRange: a } = this.config();
    if (t === xI && A > o && !a) {
      const r = [], l = n.map((c, g) => g / A);
      this._linearScale = no.linear().range(this._config.range).domain(l);
      for (let c = 0, g = A; c < g; c++) {
        const h = 1 / g * c;
        r.push([...this._linearScale(h)]);
      }
      this.scale().range(r);
    }
  }
  updateDomain(t = []) {
    if (t.length) {
      const i = this._scaleRange || null, n = this._colorStrategy.domainRange(), s = this._colorStrategy.scale, { domain: A, stops: o } = this.config(), a = !!(Array.isArray(o) && o.length), r = !a && !!(Array.isArray(A) && A.length);
      a && (t = o.map((c) => c));
      const l = n(
        t,
        o,
        i,
        this._config.subtype === zi ? this._config.binSize : null,
        !(a || r || this._config.subtype === zi),
        this._config.subtype === zi ? this._config.bins.filter((c) => !Xe(c)) : null
      );
      this.domain(l.domain), l.range && this.scale().range(l.range), this.uniqueValues(l.uniqueVals), this.scale().domain(l.scaleDomain || this.domain()), this.setRangeWithInterpolatedColors(s, l);
    }
    return this;
  }
  /**
   * This method returns an object that can be used to
   * reconstruct this instance.
   *
   * @return {Object} the serializable props of axis
   * @memberof ShapeAxis
   */
  serialize() {
    return {
      type: this.constructor.type(),
      scale: this.scale(),
      domain: this.domain(),
      config: this.config()
    };
  }
  transformColor(t, i) {
    const n = t[0] * 360, s = t[1] * 100, A = t[2] * 100, o = Math.min(wt(t[3], 0), 1), a = n + i[0], r = s + i[1], l = A + i[2], c = Math.min(o + i[3] || 0, 1);
    return {
      color: `hsla(${a},${r}%,${l}%,${c})`,
      hsla: [a / 360, r / 100, l / 100, c]
    };
  }
  /**
   * Returns the id of the axis.
   * @return {string} Unique identifier of the axis.
   */
  id() {
    return this._id;
  }
  getHslArray(t) {
    return FI(t);
  }
}
const e6 = (e) => {
  const t = e;
  return { domain: e.map((n, s) => s / (e.length - 1)), uniqueVals: t, scaleDomain: [0, 1] };
}, i6 = (e, t, i, n) => {
  const s = n.findIndex((a) => K.isInvalid(a) ? a.value() === e : a === e), A = i[s];
  return Jd()(Yd(), [...t.range()])(A);
}, n6 = (e) => ({ uniqueVals: e, domain: e }), s6 = (e, t, i) => fc(e, t(e), t(i[0])), A6 = {
  [`${De}-${Oe}`]: {
    scale: be,
    domain: e6,
    range: i6
  },
  [`${Oe}-${Oe}`]: {
    scale: be,
    domain: n6,
    range: s6
  }
}, o6 = (e, t) => A6[`${e}-${t}`], Ph = {
  value: 1,
  range: [0.1, 1],
  ordering: et({}, vo)
}, a6 = {
  config: {
    sanitization: (e, t) => {
      e._userRange = t.range;
      const i = et(
        {},
        Ph,
        e._config || {},
        t
      );
      return i.ordering = Go(
        i.ordering,
        Ph.ordering
      ), i;
    }
  },
  domain: {
    sanitization: (e, t) => (e.scale().domain(t), t)
  },
  range: {},
  scale: {},
  uniqueValues: {},
  isGlobal: {}
};
class r6 extends Iu {
  constructor(t, i) {
    super(i), ve(this, a6), this._id = Zt(), this.config(this.constructor.defaultConfig()), this.config(t), this._domainType = this._config.type === "linear" ? Oe : De, this._config.range = this._userRange ? this._userRange : this._config.range, this._rangeType = Oe, this._opacityStrategy = this.setStrategy(this._domainType, this._rangeType), this._scale = this.createScale(this._opacityStrategy), this._range = this._config.range, this.updateDomain(t.domain), this.emitSelfHooks(mt.INITIALIZED);
  }
  associatedHookComponentPaths() {
    return [
      [Ht.AXIS, "opacity"],
      [Ht.AXIS]
    ];
  }
  /**
   *
   *
   * @static
   *
   * @memberof OpacityAxis
   */
  static defaultConfig() {
    return Ph;
  }
  /**
   *
   *
   * @static
   *
   * @memberof OpacityAxis
   */
  static type() {
    return ur;
  }
  /**
   * This method is used to assign a domain to the axis.
   *
   * @param {Array} domain the domain of the scale
   * @memberof OpacityAxis
   */
  updateDomain(t) {
    if (t) {
      const i = this._opacityStrategy.domain, n = i(this.sortValues(t));
      this.domain(n.domain), this.uniqueValues(n.uniqueVals), this.scale().domain(n.scaleDomain || this.domain());
    }
    return this;
  }
  getOpacity(t = 0) {
    let i;
    const { value: n, as: s } = this.config(), A = this.scale(), o = this.domain() || [1, 1];
    if (this.config().metaInfo?.isTotalsAxis) {
      const { range: a } = this.config();
      return a[a.length - 1];
    }
    if (!A || o[0] === o[1] || isNaN(o[0]) && isNaN(o[1]) || o.length === 1 || t === null || t === void 0 || s === ft.CONTINUOUS && K.isInvalid(t))
      i = n;
    else {
      const a = K.getActualValue(t);
      return s === "discrete" && this.uniqueValues().findIndex(
        (r) => K.getActualValue(r) === a
      ) === -1 ? 0 : this._opacityStrategy.range(
        a,
        A,
        this.domain(),
        this.uniqueValues()
      );
    }
    return i;
  }
  /**
   *
   *
   * @param {*} domainType
   * @param {*} rangeType
   *
   * @memberof OpacityAxis
   */
  setStrategy(t, i) {
    return o6(t, i);
  }
  /**
   *
   *
   *
   * @memberof OpacityAxis
   */
  createScale(t) {
    const { range: i } = this.config();
    return Ks({
      type: t.scale,
      range: i
    });
  }
  /**
   * This method returns an object that can be used to
   * reconstruct this instance.
   *
   * @return {Object} the serializable props of axis.
   * @memberof OpacityAxis
   */
  serialize() {
    return {
      type: this.constructor.type(),
      scale: this.scale(),
      domain: this.domain(),
      range: this.range(),
      config: this.config()
    };
  }
  /**
   * Returns the id of the axis.
   * @return {string} Unique identifier of the axis.
   */
  id() {
    return this._id;
  }
  scaleType() {
    return this._domainType;
  }
}
const Ul = {
  value: 0.0417,
  range: [2, 50],
  ordering: et({}, vo)
}, l6 = (e) => {
  const t = e;
  return { domain: e.map((n, s) => s / (e.length - 1)), uniqueVals: t, scaleDomain: [0, 1] };
}, c6 = (e) => ({ uniqueVals: e, domain: e }), g6 = (e, t) => {
  let i = [];
  return t instanceof Array ? i = t.slice().sort((s, A) => s - A) : i = rr(e, t), { uniqueVals: i, domain: i, nice: !0 };
}, Yh = (e, t) => {
  let i = Ul.value;
  e === 0 && (e = 1e-3);
  let n;
  return e < i ? (n = e / i, t !== void 0 && (n = 0)) : t !== void 0 ? n = t : n = 1 + (e - i), n;
}, h6 = (e, t, i, n, s) => {
  const A = (e - i[0]) / (i[i.length - 1] - i[0]);
  if (n !== void 0) {
    let l = A ? A * Yh(n) : Yh(n, 1e-3);
    return l = Math.min(1, l), parseFloat(s(l).toFixed(2));
  }
  const o = Yd()(...t.range());
  return fc(
    e,
    o(A),
    o(i[0])
  );
}, d6 = (e, t, i, n, s, A) => {
  const o = A.findIndex((l) => K.isInvalid(l) ? l.value() === e : l === e), a = i[o];
  if (n !== void 0) {
    let c = a ? a * Yh(n) : Yh(n, 1e-3);
    return c = Math.min(1, c), parseFloat(s(c).toFixed(2));
  }
  return Jd()(Yd(), [...t.range()])(a);
}, u6 = (e, t, i) => fc(e, t(e), t(i[0])), f6 = {
  [`${De}-${Oe}`]: {
    scale: be,
    domain: l6,
    range: d6
  },
  [`${Oe}-${Oe}`]: {
    scale: be,
    domain: c6,
    range: u6
  },
  [`${Oe}-${De}`]: {
    scale: JE,
    domain: g6,
    range: h6
  }
}, I6 = (e, t) => f6[`${e}-${t}`], C6 = {
  config: {
    sanitization: (e, t) => {
      e._userRange = t.range;
      const i = et(
        {},
        Ul,
        e._config || {},
        t
      );
      return i.ordering = Go(
        i.ordering,
        Ul.ordering
      ), i;
    }
  },
  domain: {
    sanitization: (e, t) => (e.scale().domain(t), t)
  },
  range: {},
  scale: {},
  uniqueValues: {},
  isGlobal: {}
};
class Y_ extends Iu {
  /**
   * Creates an instance of SimpleAxis.
   * @param {Object} config input parameters.
   * @memberof SizeAxis
   */
  constructor(t, i) {
    super(i), ve(this, C6), this._id = Zt(), this.config(this.constructor.defaultConfig()), this.config(t), this._domainType = this._config.type === "linear" ? Oe : De, this._config.range = this._userRange ? this._userRange : this._config.range, this._config.stops = d4(this._config.stops), this._rangeType = this._config.type === "linear" && this._config.stops ? De : Oe, this._sizeStrategy = this.setStrategy(this._domainType, this._rangeType), this._scale = this.createScale(this._sizeStrategy), this._scaleSize = this.createScale({ scale: "linear" }), this._range = this._config.range, this.updateDomain(t.domain), this.emitSelfHooks(mt.INITIALIZED);
  }
  associatedHookComponentPaths() {
    return [
      [Ht.AXIS, "size"],
      [Ht.AXIS]
    ];
  }
  /**
   *
   *
   * @param {*} domainType
   * @param {*} rangeType
   * @param {*} schemeType
   *
   * @memberof ColorAxis
   */
  setStrategy(t, i) {
    return I6(t, i);
  }
  /**
   *
   *
   *
   * @memberof SizeAxis
   */
  createScale(t) {
    const { range: i } = this.config();
    return Ks({
      type: t.scale,
      range: i
    });
  }
  /**
   *
   *
   * @static
   *
   * @memberof ColorAxis
   */
  static defaultConfig() {
    return Ul;
  }
  /**
   *
   *
   * @static
   *
   * @memberof ColorAxis
   */
  static type() {
    return TY;
  }
  /**
   *
   *
   * @param {*} domainVal
   *
   * @memberof SizeAxis
   */
  getSize(t = 0, i, n) {
    const s = this._scaleSize;
    if (i !== void 0 && !n) {
      let c = s(i);
      return c = parseFloat(c.toFixed(2)), c;
    }
    let A = 1, { value: o, as: a } = this.config();
    o = parseFloat(s(o).toFixed(2));
    const r = this.scale(), l = this.domain() || [1, 1];
    if (this.config().metaInfo?.isTotalsAxis) {
      const { range: c } = this.config();
      return c[c.length - 1];
    }
    if (!r || l[0] === l[1] || l.length === 1 || t === null || t === void 0 || a === ft.CONTINUOUS && K.isInvalid(t))
      i !== void 0 ? (A = s(i), A = parseFloat(A.toFixed(2))) : A = o;
    else {
      const c = K.getActualValue(t);
      return a === "discrete" && this.uniqueValues().findIndex(
        (g) => K.getActualValue(g) === c
      ) === -1 ? 0 : this._sizeStrategy.range(
        c,
        r,
        this.domain(),
        i,
        s,
        this.uniqueValues()
      );
    }
    return A;
  }
  /**
   * This method is used to assign a domain to the axis.
   *
   * @param {Array} domain the domain of the scale
   * @memberof SizeAxis
   */
  updateDomain(t) {
    if (t) {
      const i = this._sizeStrategy.domain, n = i(this.sortValues(t), this.config().stops);
      this.domain(n.domain), this.uniqueValues(n.uniqueVals), this.scale().domain(n.scaleDomain || this.domain());
    }
    return this;
  }
  /**
   * This method returns an object that can be used to
   * reconstruct this instance.
   *
   * @return {Object} the serializable props of axis.
   * @memberof ShapeAxis
   */
  serialize() {
    return {
      type: this.constructor.type(),
      scale: this.scale(),
      domain: this.domain(),
      range: this.range(),
      config: this.config()
    };
  }
  /**
   * Returns the id of the axis.
   * @return {string} Unique identifier of the axis.
   */
  id() {
    return this._id;
  }
  scaleType() {
    return this._domainType;
  }
}
const Jh = {
  generator: null,
  value: "circle",
  range: ["circle", "diamond", "star", "cross", "square", "wye", "triangle"],
  ordering: et({}, vo)
}, E6 = (e, t) => {
  const i = {};
  return e.forEach((n) => {
    i[n] = t(n);
  }), i;
}, B6 = {
  config: {
    sanitization: (e, t) => {
      const i = et(
        {},
        Jh,
        e.config(),
        t
      );
      return i.ordering = Go(
        i.ordering,
        Jh.ordering
      ), i;
    }
  },
  domain: {},
  scale: {},
  uniqueValues: {},
  generator: {},
  isGlobal: {}
};
class m6 extends Iu {
  /**
   * Creates an instance of SimpleAxis.
   * @param {Object} params input parameters.
   * @param {Object | undefined} params.range Type of color scheme.
   * @memberof ShapeAxis
   */
  constructor(t, i) {
    super(i), ve(this, B6), this._id = Zt(), this._config = Object.assign({}, this.constructor.defaultConfig()), this._config = et(this._config, t), this._scale = Ks({
      type: "ordinal",
      range: this._config.range
    }), this.updateDomain(t.domain), this.emitSelfHooks(mt.INITIALIZED);
  }
  associatedHookComponentPaths() {
    return [
      [Ht.AXIS, "shape"],
      [Ht.AXIS]
    ];
  }
  /**
   *
   *
   * @static
   *
   * @memberof ColorAxis
   */
  static defaultConfig() {
    return Jh;
  }
  /**
   *
   *
   * @static
   *
   * @memberof ColorAxis
   */
  static type() {
    return vY;
  }
  /**
   *
   *
   * @param {*} value
   *
   * @memberof ShapeAxis
   */
  getShape(t) {
    if (!this.scale() || !this.domain() || !t || K.isInvalid(t))
      return this.config().value;
    if (this._generatedShapes)
      return this._generatedShapes[t];
    const i = this.scale()(t);
    return i === "string" ? cc(i) : i;
  }
  /**
   * This method is used to assign a domain to the axis.
   *
   * @param {Array} domain the domain of the scale
   * @memberof ShapeAxis
   */
  updateDomain(t = []) {
    if (t.length) {
      const i = this.config().generator;
      this.uniqueValues(t), this.domain(t), this.scale().domain(t), i && (this._generatedShapes = E6(t, i));
    }
    return this;
  }
  /**
   * This method returns an object that can be used to
   * reconstruct this instance.
   *
   * @return {Object} the serializable props of axis
   * @memberof ShapeAxis
   */
  serialize() {
    return {
      type: this.constructor.type(),
      scale: this.scale(),
      domain: this.domain(),
      range: this.config().range,
      config: this.config()
    };
  }
  /**
   * Returns the id of the axis.
   * @return {string} Unique identifier of the axis.
   */
  id() {
    return this._id;
  }
}
const J_ = {
  config: {
    sanitization: (e, t) => et(e.config(), t),
    preset: (e, t) => {
      const { range: i, domain: n } = t;
      i && e.range(i), n && e.domain(n);
    }
  },
  domain: {},
  range: {}
}, { pie: p6 } = fn, TQ = (e) => {
  const t = e._angleFn(e._domain);
  t.forEach((i) => {
    i.startAngle -= Math.PI / 2, i.endAngle -= Math.PI / 2;
  }), e._angleValues = t.reduce((i, n) => {
    const s = n.data;
    return !i[s] && (i[s] = []), i[s].push(n), i;
  }, {});
};
class Q6 {
  /**
   * Creates an instance of AngleAxis.
   * @param {Object} config input parameters.
   * @memberof AngleAxis
   */
  constructor(t = {}) {
    this._id = Zt(), ve(this, J_), this._config = et({}, this.constructor.defaultConfig()), this.config(t), this._range = [0, 360];
    const { angle: i, fieldInst: n } = this._config;
    this._angleFn = p6().value((s) => n && n.subtype() === zi || i && i.as === De ? 1 : K.isInvalid(s) ? 0 : s).sortValues(null), this._angleValues = {};
  }
  static defaultConfig() {
    return {};
  }
  createScale(t) {
    const { range: i } = this.config();
    return Ks({
      type: t.scale,
      range: i
    });
  }
  getScaleValue(t) {
    return this._angleValues[t];
  }
  padAngle(t) {
    this._angleFn = this._angleFn.padAngle(t);
  }
  domain(...t) {
    if (t.length) {
      const { domain: i } = this.config(), n = t[0].length ? t[0] : PY;
      return this._domain = Nh(i, n, this), TQ(this), this;
    }
    return this._domain;
  }
  range(...t) {
    if (t.length) {
      const { range: i } = this.config();
      this._range = Nh(i, t[0], this);
      const n = this.domain(), [s, A] = this._range;
      return this._angleFn.startAngle(s / 180 * Math.PI).endAngle(Math.PI * A / 180), n && n.length && TQ(this), this;
    }
    return this._range;
  }
}
const GQ = (e) => {
  const t = e.config().minOuterRadius, i = e._domain;
  if (e._range.length) {
    const n = e._scale, s = n.invert(t) - n.invert(0);
    e._domain = [i[0] - s, i[1]], n.domain(e._domain);
  }
};
class y6 {
  /**
   * Creates an instance of RadiusAxis.
   * @param {Object} config input parameters.
   * @memberof RadiusAxis
   */
  constructor(t = {}) {
    this._id = Zt(), ve(this, J_), this._range = [], this._radiusFactor = 1, this._config = et({}, this.constructor.defaultConfig()), this.config(t), this._scale = this.createScale({
      scale: iB
    });
  }
  static defaultConfig() {
    return {
      padding: [0, 1],
      minOuterRadius: 10
    };
  }
  config(...t) {
    if (t.length) {
      const i = et(this.config(), t[0]);
      return this._config = i, this;
    }
    return this._config;
  }
  createScale(t) {
    return Ks({
      type: t.scale,
      range: this.range()
    });
  }
  domain(...t) {
    if (t.length) {
      const { domain: i } = this.config();
      let n = Nh(i, t[0], this);
      n = rc(n), this._scale.domain(n), this._domain = n, GQ(this);
    }
    return this._domain;
  }
  getInnerRadius(t) {
    return t === void 0 ? this.range()[0] : this._scale(t);
  }
  getOuterRadius(t) {
    return t === void 0 ? this.range()[1] : this._scale(t) * this._radiusFactor;
  }
  range(...t) {
    if (t.length) {
      const { padding: i, range: n } = this.config(), s = t[0].map(
        (o, a) => o + (a ? -i[a] : i[a])
      ), A = Nh(n, s, this);
      this._range = A, this._scale.range(A), GQ(this);
    }
    return this._range;
  }
  setRadiusFactor(t) {
    return this._radiusFactor = t, this;
  }
}
class Cu {
  _data;
  _sourceDm;
  _config;
  _domain;
  constructor(t, i) {
    this._sourceDm = t, t.isEmpty() ? this._data = [
      {
        values: [],
        keys: []
      }
    ] : this._data = [
      {
        values: t.getData().data,
        keys: []
      }
    ], this._config = i, this._domain = {};
  }
  getDomain(t, i) {
    const { field: n, fieldAs: s } = t, A = this._sourceDm.getDomain(
      n,
      s.toString()
    );
    if (i) {
      const { field: o, fieldAs: a } = i, r = this._sourceDm.getDomain(
        o,
        a.toString()
      );
      return [
        Math.min(
          A[0],
          r[0]
        ),
        Math.max(
          A[1],
          r[1]
        )
      ];
    }
    return A;
  }
  getData() {
    return this._data;
  }
  getUniqueValues() {
    return this._data.filter((t) => t.keys).map((t) => t.keys.join(","));
  }
  isSortedDomain() {
    return !1;
  }
}
const w6 = "group", D6 = "stack100percent", x6 = "A retinal or detail dimension encoding is required to stack the mark", K_ = "Either rows or columns must contain a measure field to stack the mark", LQ = (e, t, i) => {
  const n = e.getData().data, s = e.getSchema().findIndex((l) => l.name === t), A = e.getSchema().findIndex((l) => l.name === i), o = {};
  n.forEach((l) => {
    const c = l[s];
    o[c] || (o[c] = 0), o[c] += K.isInvalid(l[A]) ? 0 : l[A];
  });
  const a = is(Object.values(o));
  return [Hs(Object.values(o)), a];
};
class aB extends Cu {
  _sortedValues;
  constructor(t, i) {
    super(t, i);
    const {
      uniqueField: n,
      value: s,
      sortConfig: A
    } = i, o = n?.field, a = n?.as, r = s?.field;
    if (t.isEmpty())
      this._data = [
        {
          values: []
        }
      ], this._domain[o] = [];
    else {
      if (!i.groupBy.length)
        throw new Gn(x6);
      if (!r)
        throw new Gn(K_);
      const { DataWranglers: l } = t.constructor.DataModel(), c = A.fields.map(({ field: E }) => E), g = Z(
        A.fields,
        "0",
        "values"
      );
      let h = t, d = !1;
      if (i.groupBy.length > 2) {
        const E = i.groupBy.map((B) => [B, "asc"]);
        h = h.sort(E), d = !0;
      }
      const u = l.stackBy(
        h.model,
        o,
        c[0],
        r,
        null,
        g,
        // @todo make it generalized
        c[1],
        Z(A.fields, "1", "values"),
        ""
      ), f = /* @__PURE__ */ new Map(), C = h.getUidMap(), { data: I } = h.getData();
      u.y0.forEach((E, B) => {
        const m = u.id[B], p = C[m], w = h.getValueAtIndex(o, p), Q = i.groupBy.reduce(
          (D, _) => (D[_] = h.getValueAtIndex(_, p), D),
          {}
        ), y = Object.values(Q).join("-");
        f.has(y) ? f.get(y).values.push({
          values: [u.y0[B], u.y1[B]],
          rowId: m,
          data: I[p],
          uniqueVal: w
        }) : f.set(y, {
          values: [
            {
              values: [u.y0[B], u.y1[B]],
              rowId: m,
              data: I[p],
              uniqueVal: w
            }
          ],
          key: y,
          keys: Object.values(Q),
          groupKey: Q
        });
      }), this._data = [...f.values()], this._domain[o] = h.getDomain(
        o,
        a.toString()
      ), this._domain[r] = [
        Math.min(Hs(u.y0), Hs(u.y1)),
        Math.max(is(u.y0), is(u.y1))
      ], this._sortedValues = g, d && h.dispose();
    }
  }
  getDomain({ field: t }) {
    return this._domain[t];
  }
  isSortedDomain() {
    return !!this._config.sort;
  }
  getSortedGroupByValues() {
    return this._sortedValues;
  }
  getSortField() {
    return Z(this._config.sortConfig, "fields", "0", "field");
  }
  static getFieldDomainFromData(t, i, n) {
    const s = t.select({
      field: n,
      operator: Ui.LESS_THAN_EQUAL,
      value: 0
    }), A = t.select({
      field: n,
      operator: Ui.GREATER_THAN_EQUAL,
      value: 0
    }), o = A.isEmpty() ? [] : LQ(A, i, n), a = s.isEmpty() ? [] : LQ(s, i, n);
    return s.dispose(), A.dispose(), [
      Math.min(...a, ...o),
      Math.max(...a, ...o)
    ];
  }
  static getStackSumFromData(t, i, n, s) {
    const A = t.getData().data, o = t.getSchema().findIndex((c) => c.name === i), a = t.getSchema().findIndex((c) => c.name === n), r = t.getSchema().findIndex((c) => c.name === s), l = /* @__PURE__ */ new Map();
    return A.forEach((c) => {
      let g = c[o];
      K.isInvalid(g) && (g = g.value()), l.has(g) || l.set(g, {
        posStackSum: 0,
        negStackSum: 0,
        textFieldPosStackSum: 0,
        textFieldNegStackSum: 0
      });
      let h = l.get(g).posStackSum, d = l.get(g).negStackSum, u = l.get(g).textFieldPosStackSum, f = l.get(g).textFieldNegStackSum;
      +c[a] > 0 ? l.set(g, {
        posStackSum: h += K.isInvalid(
          c[a]
        ) ? 0 : c[a],
        negStackSum: d,
        textFieldPosStackSum: u += K.isInvalid(
          c[r]
        ) ? 0 : c[r],
        textFieldNegStackSum: f
      }) : l.set(g, {
        posStackSum: h,
        negStackSum: d += K.isInvalid(
          c[a]
        ) ? 0 : c[a],
        textFieldPosStackSum: u,
        textFieldNegStackSum: f += K.isInvalid(
          c[r]
        ) ? 0 : c[r]
      });
    }), l;
  }
}
class Eu extends Cu {
  _sortedValues;
  constructor(t, i) {
    super(t, i);
    const {
      uniqueField: n,
      value: s,
      sortConfig: A
    } = i, o = n?.field, a = n?.as, r = s?.field;
    if (t.isEmpty())
      this._data = [
        {
          values: []
        }
      ], this._domain[o] = [];
    else {
      if (!r)
        throw new Gn(K_);
      const { DataWranglers: l } = t.constructor.DataModel(), c = A.fields.map(({ field: E }) => E), g = Z(
        A.fields,
        "0",
        "values"
      );
      let h = t, d = !1;
      if (i.groupBy.length > 2) {
        const E = i.groupBy.map((B) => [B, "asc"]);
        h = h.sort(E), d = !0;
      }
      const u = l.stackBy(
        h.model,
        o,
        c[0],
        r,
        null,
        g,
        // @todo make it generalized
        c[1],
        Z(A.fields, "1", "values"),
        "normalize"
      ), f = /* @__PURE__ */ new Map(), C = h.getUidMap(), { data: I } = h.getData();
      u.y0.forEach((E, B) => {
        const m = u.id[B], p = C[m], w = h.getValueAtIndex(o, p), Q = i.groupBy.reduce(
          (D, _) => (D[_] = h.getValueAtIndex(_, p), D),
          {}
        ), y = Object.values(Q).join("-");
        f.has(y) ? f.get(y).values.push({
          values: [u.y0[B], u.y1[B]],
          rowId: m,
          data: I[p],
          uniqueVal: w
        }) : f.set(y, {
          values: [
            {
              values: [u.y0[B], u.y1[B]],
              rowId: m,
              data: I[p],
              uniqueVal: w
            }
          ],
          key: y,
          keys: Object.values(Q),
          groupKey: Q
        });
      }), this._data = [...f.values()], this._domain[o] = h.getDomain(
        o,
        a.toString()
      ), this._domain[r] = [
        Math.min(Hs(u.y0), Hs(u.y1)),
        Math.max(is(u.y0), is(u.y1))
      ], this._sortedValues = g, d && h.dispose();
    }
  }
  getDomain({ field: t }) {
    return this._domain[t];
  }
  isSortedDomain() {
    return !!this._config.sort;
  }
  getSortedGroupByValues() {
    return this._sortedValues;
  }
  getSortField() {
    return Z(this._config.sortConfig, "fields", "0", "field");
  }
  static getFieldDomainFromData() {
    return [0, 1];
  }
  static getStackSumFromData(t, i, n, s) {
    const A = t.getData().data, o = t.getSchema().findIndex((c) => c.name === i), a = t.getSchema().findIndex((c) => c.name === n), r = t.getSchema().findIndex((c) => c.name === s), l = /* @__PURE__ */ new Map();
    return A.forEach((c) => {
      let g = c[o];
      K.isInvalid(g) && (g = g.value()), l.has(g) || l.set(g, {
        posStackSum: 0,
        textFieldPosStackSum: 0
      });
      let h = l.get(g).posStackSum, d = l.get(g).textFieldPosStackSum;
      l.set(g, {
        posStackSum: h += K.isInvalid(c[a]) ? 0 : Math.abs(c[a]),
        textFieldPosStackSum: d += K.isInvalid(
          c[r]
        ) ? 0 : Math.abs(c[r])
      });
    }), l;
  }
}
class S6 extends Cu {
  _sortedValues;
  constructor(t, i) {
    if (super(t, i), t.isEmpty())
      this._data = [
        {
          values: []
        }
      ];
    else {
      const n = i.groupBy instanceof Array ? i.groupBy : [i.groupBy], s = t.getSchema();
      if (n.map(
        (c) => s.findIndex((g) => g.name === c)
      ).find((c) => c === -1) !== void 0)
        throw new Error(`Groupby field ${n} not found in schema`);
      const o = t.splitByRow(n), a = Z(
        i.sortConfig.fields,
        "0",
        "field"
      ), r = i.groupBy.includes(a) ? a : null;
      this._data = o.map((c) => {
        const g = c.getData().data, h = i.groupBy.map(
          (f) => c.getValueAtIndex(f, 0)
        );
        g.keys = h.map((f) => K.getActualValue(f));
        let d;
        i.groupBy.length && (d = c.getValueAtIndex(i.groupBy[0], 0), g.key = K.getActualValue(d));
        const u = r ? c.getValueAtIndex(r, 0) : null;
        return c.dispose(), {
          keys: h,
          // @todo: Use "keys" instead of "key".
          key: d,
          values: g,
          sortKey: u
        };
      });
      const l = i.sortConfig;
      if (r) {
        const c = l.fields[0].values.reduce(
          (g, h, d) => (g[h] = d, g),
          {}
        );
        this._data.sort((g, h) => c[g.sortKey] - c[h.sortKey]), this._sortedValues = l.fields[0].values;
      }
    }
  }
  getSortedGroupByValues() {
    return this._sortedValues;
  }
  getSortField() {
    return Z(this._config.sortConfig.fields, "0", "field");
  }
}
class _6 extends Cu {
  getUniqueValues() {
    return [0];
  }
  getSortedGroupByValues() {
    return null;
  }
  getSortField() {
    return null;
  }
}
var da = /* @__PURE__ */ ((e) => (e.IDENTITY = "identity", e.GROUP = "group", e.STACK = "stack", e.STACK100PERCENT = "stack100percent", e.FRACTURE = "fracture", e))(da || {});
const b6 = {
  [da.IDENTITY]: _6,
  [da.GROUP]: S6,
  [da.STACK]: aB,
  [da.STACK100PERCENT]: Eu
};
function M6(e, t, i) {
  const n = b6[e];
  if (typeof n != "function")
    throw new Error("Invalid transform type supplied.");
  return new n(t, i);
}
const { BAND: Bc, LINEAR: N6, TIME: rB } = YS, { DISCRETE: F6 } = ft, R6 = (e, t, i, n, s) => {
  const A = t.meta, o = wt(
    A.currentState[s][i],
    A.originalState[i]
  ), a = e.transformColor(o, n);
  return A.currentState[s][i] = a.hsla, a;
}, V_ = (e, t, i) => {
  const n = {};
  return i.forEach((s) => {
    const A = Z(e, s, "field"), o = Z(e, s, "as"), a = A && t.getField(A);
    n[`${s}Field`] = A, n[`${s}FieldAs`] = o, n[`${s}FieldIndex`] = t.getFieldIndex(A), n[`${s}FieldType`] = a && a.type(), n[`${s}FieldSubType`] = a && a.subtype();
  }), n;
}, W_ = (e, t) => {
  const i = [
    Gt.X,
    Gt.Y,
    Gt.X0,
    Gt.Y0,
    Gt.RADIUS,
    Gt.RADIUS0,
    Gt.ANGLE,
    Gt.ANGLE0,
    NE,
    FE,
    kE,
    ME,
    vE,
    RE
  ];
  return V_(e, t, i);
}, mc = (e, t, i) => {
  const { connectNullData: n } = t, {
    type: s,
    groupBy: A,
    sort: o,
    offset: a,
    orderBy: r,
    value: l,
    uniqueField: c,
    sortField: g,
    sortedValues: h
  } = i;
  return M6(s, e, {
    groupBy: A,
    sortConfig: o,
    offset: a,
    orderBy: r,
    uniqueField: c,
    connectNullData: n,
    value: l,
    sortedValues: h,
    sortField: g
  });
}, Vs = (e, t, i, n) => {
  const s = n.config().individualClassName;
  let A = "";
  return s instanceof Function && (A = s(e, t, i, n)), A;
}, q_ = (e, t, i, n) => {
  const {
    xField: s,
    yField: A,
    xFieldIndex: o,
    yFieldIndex: a,
    x0FieldIndex: r,
    y0FieldIndex: l,
    radiusFieldIndex: c,
    angleFieldIndex: g,
    angleField: h,
    colorField: d,
    colorFieldIndex: u,
    radius0FieldIndex: f,
    angle0FieldIndex: C
  } = t, { type: I, uniqueField: E } = n, B = [
    [s, o, "x"],
    [A, a, "y"]
  ].find((Q) => Q[0] === (E && E.field)), m = Z(B, 1), p = Z(B, 2), w = i.getFieldNames();
  return e.getData().map((Q) => Q.values.map((y) => {
    let D, _ = {};
    if (I === Wt || I === Xt) {
      D = y.data || [];
      let S, b, R, G;
      const [T, v] = y.values;
      v >= T ? (S = G = v, R = b = T) : (S = G = T, R = b = v), p === "y" ? _ = {
        x: R,
        x0: G,
        y: D[m],
        y0: D[m]
      } : p === "x" && (_ = {
        x: D[m],
        x0: D[m],
        // @todo Removing this condition. This was done for null value handling. Check why this was required.
        // If we uncomment this line, negative values in bar chart gets positioned incorrectly.
        // y: y === 0 ? tuple[yFieldIndex] : y,
        y: S,
        y0: b
      }), _.source = D, _.rowId = y.rowId;
    } else
      D = y, _ = {
        x: y[o],
        x0: y[r],
        y: y[a],
        y0: y[l]
      }, _.source = y, _.rowId = y[y.length - 1];
    _ = {
      ..._,
      radius: y[c],
      angle: h ? y[g] : d ? y[u] : 1,
      radius0: y[f],
      angle0: y[C]
    }, [NE, FE, kE, ME, vE, RE].forEach((S) => {
      const b = D[t[`${S}FieldIndex`]];
      _[S] = b;
    });
    const x = _.source;
    return _.dataObj = w.reduce((S, b) => (S[b] = x[i.getFieldIndex(b)], S), {}), _;
  })).filter((Q) => Q.length);
}, j_ = (e, t) => {
  const i = t.encodingFieldsInf();
  return q_(
    e,
    i,
    t.data(),
    t._transformConfig,
    t.axes()
  );
}, z_ = (e, t) => {
  const i = t.encodingFieldsInf(), {
    xField: n,
    xFieldAs: s,
    yField: A,
    yFieldAs: o,
    x0Field: a,
    x0FieldAs: r,
    y0Field: l,
    y0FieldAs: c
  } = i, g = {};
  return n && (g.x = e.getDomain(
    { field: n, fieldAs: s },
    { field: a, fieldAs: r }
  )), A && (g.y = e.getDomain(
    { field: A, fieldAs: o },
    { field: l, fieldAs: c }
  )), g;
}, k6 = (e) => {
  const { x: t, y: i } = e.update;
  return {
    x: t,
    y: i
  };
}, pc = (e, t, i = k6) => {
  e.data(
    [].concat(...t).map((n) => {
      const { x: s, y: A } = i(n);
      return {
        x: s,
        y: A,
        data: n
      };
    })
  );
}, Kh = (e, t, i) => {
  for (const n in t)
    ({}).hasOwnProperty.call(t, n) && e.style(n, i ? null : t[n]);
}, v6 = (e, t) => {
  let i, n;
  const { transition: s, groupAnimateStyle: A } = t, { duration: o, effect: a, disabled: r } = s;
  A && (vt(e.node(), A.enter), n = A.update, r ? i = e : i = e.transition().ease(lc[a]).duration(o).on("end", function() {
    Kh(X(this), n, !0);
  }), Kh(i, n));
}, Uo = (e, t) => {
  const i = e.encodingTransform();
  return i ? i(t, e, {
    smartLabel: e._dependencies.smartLabel
  }) : t;
}, lB = (e, t) => {
  let i;
  const n = e instanceof qi ? e.getBinWidth() : e.getUnitWidth(), s = e.scale(), A = s.range(), o = s.domain();
  return n ? i = n : i = Math.abs(A[1] - A[0]) / (Math.abs(o[1] - o[0]) || o[0]) * t, Math.max(i, 1);
}, RI = (e, t) => {
  const i = e.encodingFieldsInf(), n = e.axes(), s = e.transformType(), A = e.config(), { TEMPORAL: o } = K.FieldSubtype, a = [n.x, n.y].filter((r) => r instanceof Zn).length === 1;
  return ["x", "y"].map((r) => {
    let l = 0, c = 0, g = 0, h = [];
    if (n[r] && n[r].constructor.type() === ps || i[`${r}FieldSubType`] === o || i[`${r}FieldSubType`] === ot.BINNED) {
      let d;
      const f = i[`${r}FieldSubType`] === o ? e.dataProps().timeDiffs[r] : 0, C = n[r], I = A[`pad${r.toUpperCase()}`], E = A.innerPadding, B = t, m = C.scale();
      c = lB(C, f);
      const p = C.constructor.type() === Bc, w = C.config().padding || 0, Q = a ? A.outerPadding : 0;
      if (s === "group") {
        const y = e.getBandScale();
        C instanceof Zn ? g = Q : g = p ? 0 : w * c;
        const D = C instanceof qi || p ? 0 : g * c / 2;
        y.range([D, c - D]).domain(B).paddingInner(E), l = y.bandwidth(), d = c - g, h = B.map((_) => y(_) - (p ? 0 : C instanceof qi ? -c / 2 : c / 2));
      } else if (I !== void 0) {
        let y;
        if (p) {
          const D = m.step();
          y = m.padding() * D, l = m.bandwidth() + y;
        } else
          l = c;
        C instanceof qi ? h = B.map(() => 0) : h = B.map(
          () => p ? -(y / 2) : -(l / 2)
        );
      } else
        C instanceof Zn ? g = Q : g = p ? 0 : w * c, l = c - g, d = l, C instanceof qi ? h = B.map(() => 0) : h = B.map(() => p ? 0 : -(l / 2));
      c = d, g = p ? w * C.scale().step() : w * c;
    }
    return {
      span: l,
      offsetValues: h,
      groupSpan: c,
      padding: g
    };
  });
}, kI = (e, t) => {
  const i = e.encodingFieldsInf(), n = e.axes(), s = e.reducedDataMap(), A = e.transformType(), o = e.config(), { TEMPORAL: a } = K.FieldSubtype, r = [n.x, n.y].filter((l) => l instanceof Zn).length === 1;
  return ["x", "y"].map((l) => {
    let c = 0, g = 0, h = 0, d = [];
    if (n[l] && n[l].constructor.type() === ps || i[`${l}FieldSubType`] === a || i[`${l}FieldSubType`] === ot.BINNED) {
      let u;
      const C = i[`${l}FieldSubType`] === a ? e.dataProps().timeDiffs[l] : 0, I = n[l], E = o[`pad${l.toUpperCase()}`];
      let B = o.innerPadding;
      const m = t, p = I.scale();
      g = lB(I, C);
      const w = I.constructor.type() === Bc, Q = I.config().padding || 0, y = r || A === "group" ? o.outerPadding : 0;
      if (A === "group") {
        let D;
        d = /* @__PURE__ */ new Map();
        const _ = e.getBandScale();
        I instanceof Zn ? (h = y, B = 0) : h = w ? 0 : Q * g, u = g - h;
        let x = Number.MIN_VALUE;
        Array.from(s.values()).forEach((b) => {
          x = Math.max(x, b[0]);
        });
        const S = (u - (x - 1) * B) / x;
        s.forEach((b, R) => {
          const G = Array.from(b[1]);
          b[0] % 2 === 0 ? D = (b[0] * (B + S) - B) / 2 : D = b[0] * S / 2 + Math.floor(S / 2) * B, _.range([u / 2 - D, u / 2 + D]).domain(G).paddingInner(B), c === 0 && (c = _.bandwidth()), c = Math.min(c, _.bandwidth());
          let T;
          G.map((v) => {
            w ? T = 0 : I instanceof qi ? T = -g / 2 : T = u / 2;
            let H = _(v) - T;
            if (d.has(R))
              d.get(R).set(v, H);
            else {
              const N = /* @__PURE__ */ new Map();
              d.set(R, N.set(v, H));
            }
          });
        }), c = Math.max(1, c);
      } else if (E !== void 0) {
        let D;
        if (w) {
          const _ = p.step();
          D = p.padding() * _, c = p.bandwidth() + D;
        } else
          c = g;
        I instanceof qi ? d = m.map(() => 0) : d = m.map(
          () => w ? -(D / 2) : -(c / 2)
        );
      } else
        I instanceof Zn ? h = y : h = w ? 0 : Q * g, c = g - h, u = c, I instanceof qi ? d = m.map(() => 0) : d = m.map(() => w ? 0 : -(c / 2));
      g = u, h = w ? Q * I.scale().step() : Q * g;
    }
    return {
      span: c,
      offsetValues: d,
      groupSpan: g,
      padding: h
    };
  });
}, $_ = (e) => {
  const t = e.mount();
  t && e.render(t);
}, T6 = (e, t, i, n) => {
  const { DIMENSION: s } = K.FieldType, {
    xField: A,
    yField: o,
    xFieldAs: a,
    yFieldAs: r,
    xFieldType: l,
    yFieldType: c,
    sizeField: g
  } = e, h = ["xField", "yField"].find(
    (f) => e[`${f}Type`] === s
  ), d = g && e.sizeFieldType === s, u = !!(Array.isArray(n) && n.length);
  return [
    !A,
    !o,
    !(i || d || u),
    !!(i && t.data().isMeasure(i)),
    l === s && c === s,
    h && e[h] === i,
    h && e[h] === g && d,
    [a, r].every((f) => f === F6)
  ];
}, cB = (e) => {
  const t = e.config(), i = e.encodingFieldsInf(), n = t.transform.groupBy, s = e.resolveDetailEncodingFields();
  return T6(
    i,
    e,
    n,
    s
  ).some((A) => A) ? ns : null;
}, X_ = (e) => cB(e) || e.config().transform.type, gB = (e) => {
  const t = cB(e);
  if (t)
    return t;
  const { xField: i, yField: n, xFieldType: s, yFieldType: A } = e.encodingFieldsInf(), { MEASURE: o } = K.FieldType, a = e.config().transform.groupBy, r = !!Z(
    e._customConfig,
    "transform",
    "type"
  );
  let l = e.config().transform.type;
  if (!r && a && s !== A) {
    const c = s === o ? i : n, { [c]: g } = hc(
      e.data(),
      [c]
    );
    l = g === TE ? Wt : jn;
  }
  return l;
}, Z_ = (e, t) => {
  const { DIMENSION: i } = K.FieldType;
  return e.filter((n, s) => t[s] && t[s].type === i).join();
}, Qs = (e, t) => {
  const { translatedValues: i, datum: n, datumIdx: s, groupData: A, groupIdx: o, layerData: a } = t, r = {};
  for (const l in i)
    r[l] = hB(e, {
      translatedValue: i[l],
      datum: n,
      datumIdx: s,
      groupData: A,
      groupIdx: o,
      layerData: a,
      encodingName: l
    });
  return r;
}, hB = (e, t) => {
  const {
    translatedValue: i,
    datum: n,
    datumIdx: s,
    groupData: A,
    groupIdx: o,
    layerData: a,
    encodingName: r
  } = t, { encoding: l } = e.config(), c = Z(l, r, "value");
  if (typeof c == "function") {
    const g = {
      translatedValue: i,
      datum: n,
      datumIdx: s,
      groupData: A,
      groupIdx: o,
      layerData: a
    }, h = { context: e, encoding: r };
    if (r !== "size")
      return c(g, h);
    let d = c(g, h);
    d = Math.min(1, Math.max(0, d));
    const u = Ho(e, n);
    let f;
    return l.size.field ? f = u.getSize(n.size, d, !0) : f = u.getSize(n.size, d, !1), f;
  } else
    return i;
}, Qo = (e, t, i, n) => {
  const s = n.config().encoding.text.rotation;
  let A;
  return typeof s == "function" ? A = s(
    {
      x: e.x,
      y: e.y,
      text: e.text
    },
    t,
    i,
    n
  ) : s === LE ? A = n.getTextAutoRotationAngle() : A = s, A;
}, ys = (e, t = {}) => ({
  originalStyle: Object.assign(
    {},
    {
      styles: { ...e, ...t }
    }
  ),
  currentState: /* @__PURE__ */ new Map(),
  lastInteraction: []
}), UQ = (e, t, i, n) => e * Math[t](i) + n, mf = (e, t, i, n) => ({
  x: UQ(e, "cos", t, i),
  y: UQ(e, "sin", t, n)
}), G6 = (e, t, i = !1) => {
  const n = t.width / 2, s = t.height / 2;
  for (let A = 0, o = e.length; A < o; A++) {
    const a = e[A], { angle: r, radius: l, radius0: c, angle0: g } = a.update;
    if (a.update = mf(l, r, n, s), i) {
      const h = a.update = mf(
        c,
        g,
        n,
        s
      ), { x: d, y: u } = mf(
        l,
        r,
        n,
        s
      );
      h.x0 = d, h.y0 = u;
    }
  }
  return e;
}, HQ = (e) => e.constructor.type() === Bc, OQ = (e) => e.constructor.type() === rB, L6 = ({ x: e, y: t }) => {
  let i = e, n = "x";
  return (HQ(t) && !HQ(e) || OQ(t) && !OQ(e) || t.isBinnedAxis()) && (i = t, n = "y"), { sortAxis: i, sortCoord: n };
}, Qc = (e, t, i = {}) => {
  const { sortAxis: n, sortCoord: s } = i.sortAxis && i.sortCoord ? i : L6(t);
  if (n.constructor.type() === Bc) {
    const A = n.domain().reduce((o, a, r) => (o[a] = r, o), {});
    e.sort((o, a) => A[o[s]] - A[a[s]]);
  } else (n.constructor.type() === N6 || n.constructor.type() === rB) && e.sort((A, o) => {
    const a = Number.parseFloat(A[s]), r = Number.parseFloat(o[s]);
    return a !== a ? -r : r !== r ? a : a - r;
  });
  return e;
}, dB = (e) => e.map((t) => {
  const { x: i, y: n } = t.update, s = t.data;
  return {
    minX: i,
    maxX: i,
    minY: n,
    maxY: n,
    data: s
  };
}), gl = (e, t, i) => {
  const { width: n, height: s } = i.getOriSize(e);
  if (!t)
    return { width: n, height: s };
  const A = t * (Math.PI / 180), o = Math.abs(Math.cos(A)), a = Math.abs(Math.sin(A)), r = s * o + n * a;
  return { width: s * a + n * o, height: r };
}, Bu = (e, t, i) => {
  const n = i || X(
    t.sourceEvent ? t.sourceEvent.target : t.target
  ).data()[0];
  if (ke(n) && Z(n, "meta", "layerId") === e.id()) {
    const s = n && n.source;
    let A = null;
    return s && (A = e.getIdentifiersFromData(s, n.rowId)), {
      point: n,
      id: A,
      layerId: e.id()
    };
  }
  return null;
}, U6 = (e) => e.update.y === null || e.update.x === null, uB = (e, t = {}) => {
  const i = t.isNull || U6;
  return e.filter((n, s) => n.isLine ? !0 : !e[s] || i(e[s]) ? !1 : s === 0 ? !!(!e[s + 1] || i(e[s + 1])) : s === e.length - 1 ? !!(!e[s - 1] || i(e[s - 1])) : !!(i(e[s + 1]) && i(e[s - 1])));
}, H6 = [
  "stroke-width",
  "stroke",
  "stroke-opacity",
  "opacity",
  "fill-opacity",
  "fill"
], yc = (e, t) => H6.reduce((i, n) => (n in e && !t.includes(n) && (i[n] = Z(e, n, "value")), i), {}), mu = (e, t) => {
  if (!e || typeof e == "object" && !e.enable) return {};
  const i = typeof e == "object", n = {
    stroke: i && e.strokeColor ? e.strokeColor : t,
    fill: i && e.fill ? t : "none"
  };
  return i && e.width !== void 0 && (n["stroke-width"] = +e.width), n;
}, yo = (e, t, i) => {
  const n = [0, 0], s = e.constructor.type() === Bc, A = e.constructor.type() === rB;
  if (!s && !A && t) {
    const o = e.range(), a = e.domain(), r = o[0] > o[1];
    let l = e.invert(o[0] + i[0]) - a[0], c = e.invert(o[0] + i[1]) - a[0];
    r && (l = -l, c = -c), t[0] - l < a[0] && a[0] !== 0 && (n[r ? 1 : 0] = Math.abs(
      o[0] - e.scale()(t[0] - l)
    )), t[1] + c > a[1] && a[1] !== 0 && (n[r ? 0 : 1] = Math.abs(
      o[1] - e.scale()(t[1] + c)
    ));
  }
  return n;
}, tb = new ir({
  type: "discrete",
  value: "black"
}), ts = (e, t) => {
  const i = e.axes().color, s = e.config().encoding.color.splitBy, A = e.metaInf(), o = Object.values(t.dataObj).some(
    (r) => r === A.rowTotalString || A.colTotalString
  ), a = e.metaInf().totalsAxis?.color;
  return o && a ? a : s ? i instanceof ir ? i : i[t.dataObj[s]] || tb : i;
}, eb = (e, t) => {
  const i = e.axes().backgroundColor, s = e.config().encoding.backgroundColor.splitBy, A = e.metaInf(), o = Object.values(t.dataObj).some(
    (r) => r === A.rowTotalString || A.colTotalString
  ), a = e.metaInf().totalsAxis?.backgroundColor;
  return o && a ? a : s ? i instanceof ir ? i : i[t.dataObj[s]] || tb : i;
}, Ho = (e, t) => {
  const i = e.axes().size, n = e.metaInf(), s = Object.values(t.dataObj).some(
    (o) => o === n.rowTotalString || n.colTotalString
  ), A = e.metaInf().totalsAxis?.size;
  return s && A ? A : i;
}, ws = (e, t) => {
  const i = e.axes().opacity, n = e.metaInf(), s = Object.values(t.dataObj).some(
    (o) => o === n.rowTotalString || n.colTotalString
  ), A = e.metaInf().totalsAxis?.opacity;
  return s && A ? A : i;
}, O6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  animateGroup: v6,
  attachDataToVoronoi: pc,
  dataNormalizers: q_,
  domainCalculator: z_,
  encodingFieldInfRetriever: W_,
  getAxisRangeDiffs: yo,
  getBackgroundColorAxis: eb,
  getBarPlotMeasurement: kI,
  getBoundBoxes: dB,
  getColorAxis: ts,
  getColorMetaInf: ys,
  getDataFromEvent: Bu,
  getDisconnectedPoints: uB,
  getGroupSpan: lB,
  getIndividualClassName: Vs,
  getMarkId: Z_,
  getNormalizedData: j_,
  getOpacityAxis: ws,
  getPlotMeasurement: RI,
  getSizeAxis: Ho,
  getStylesFromEncoding: yc,
  getTextBounds: gl,
  getValidTransform: X_,
  getValidTransformForAggFn: gB,
  positionPoints: Uo,
  renderLayer: $_,
  resolveEncodingValues: Qs,
  resolveInvalidTransformType: cB,
  resolveRotation: Qo,
  resolveSingleEncodingValue: hB,
  retrieveEncodingInf: V_,
  setStroke: mu,
  sortData: Qc,
  toCartesianCoordinates: G6,
  transformColor: R6,
  transformData: mc,
  updateStyle: Kh
}, Symbol.toStringTag, { value: "Module" })), pu = {
  baseTextStyle: {
    "stroke-width": 0,
    "fill-opacity": 1
  },
  textColor: "black"
}, Oo = {
  value: "",
  formatter: (e) => e.formattedValue,
  filter: () => !0,
  background: {
    padding: 10
  },
  rotation: 0,
  alignmentBaseline: "middle",
  textAnchor: "middle",
  labelPlacement: {
    anchors: [Si, As]
  },
  charsAcross: {
    min: 7,
    max: 18
  },
  removeCollision: !0,
  hyperlink: {
    enabled: !1,
    sanitizeHyperlink: !0,
    encode: !0,
    defaultClassName: `${On}-hyperlink-text`,
    generateHref: (e) => ({
      target: bo,
      rel: Mo,
      url: e.formattedValue,
      styles: No,
      classNames: Fo
    })
  }
}, P6 = (e, t, i, n, s, A, o, a) => {
  if (!i)
    return e;
  const r = a._dependencies.canvasActions.getRootData(), l = r.getField(i).subtype();
  if (o === tr)
    return Number.isInteger(e) ? `${t(String(e))}%` : `${t(String(e.toFixed(2)))}%`;
  const { TEMPORAL: c, CONTINUOUS: g, BINNED: h } = K.FieldSubtype, { useUTC: d } = s;
  let u = A.getField(i), f = u.schema(), C = f.subtype, I = f.format;
  if (K.isInvalid(e)) {
    let E = t(e);
    return !A.isMeasure(i) && K.isInvalid(E) && (E = K.getActualValue(E)), E;
  }
  if (l !== C && C === ot.CATEGORICAL && (l === ot.TEMPORAL ? (e = us(e), C = ot.TEMPORAL, u = r.getField(i)) : l === ot.BINNED && (e = us(e), C = ot.BINNED, u = r.getField(i)), f = r.getField(i).schema()), C === c) {
    const E = n.x || n.y;
    return E ? pA(Number(e), E, { useUTC: d }) : To(e, f.format, { useUTC: d });
  } else {
    if (C === g)
      return I(Y6(e));
    if (C === h) {
      if (typeof e == "string")
        return e;
      const E = u.getBinSize();
      return Co([e, e + E]);
    } else
      return t(String(e));
  }
}, PQ = (...e) => {
  const t = P6(...e);
  return Zi(t);
}, Y6 = (e) => e == null ? "" : `${e === 0 || e % e.toFixed(0) === 0 ? e : e.toFixed(2)}`, ib = (e, t) => {
  const [i, n, s, A] = px(
    ...e.getRawColor(t)
  ), [o, a, r] = [i, n, s].map((c) => (c = c / 255, c <= 0.03928 ? c = c / 12.92 : c = (c + 0.055) / 1.055 ^ 2.4, c)), l = 0.2126 * o + 0.7152 * a + 0.0722 * r;
  return (l + 0.05) / (0 + 0.05) > (1 + 0.05) / (l + 0.05) ? `rgba(0, 0, 0, ${A})` : `rgba(255, 255, 2555, ${A})`;
}, YQ = (e) => !(typeof e == "number" && !Number.isNaN(e)), vI = (e) => !e || !e.labelPlacement || !e.labelPlacement.anchors ? As : e.labelPlacement.anchors[0], nb = (e) => !e || !e.labelPlacement || !e.labelPlacement.anchors || e.labelPlacement.anchors.length === 0 ? [Si, As] : e.labelPlacement.anchors, fB = (e) => UE.includes(e), TI = (e) => HE.includes(e), Po = (e, t, i, n, s, A = { show: !0 }) => {
  if (YQ(t.x) || YQ(t.y))
    return null;
  const { text: o } = e.config().encoding, {
    background: a,
    alignmentBaseline: r,
    rotation: l,
    textAnchor: c
  } = o, g = a.padding, h = a.value;
  let d, u, f;
  typeof r == "function" ? d = r(
    t,
    n,
    s,
    e
  ) : d = r, typeof l == "function" ? u = l(t, n, s, e) : l === LE ? u = e.getTextAutoRotationAngle() : u = l, typeof c == "function" ? f = c(t, n, s, e) : f = c;
  let C = t.formattedText;
  if (t.maxWidth !== void 0 && t.maxHeight !== void 0) {
    const { smartLabel: E } = e._dependencies, B = E.getSmartText(
      C,
      t.maxWidth,
      t.maxHeight,
      !0
    );
    C = B.isTruncated && !B.text.endsWith("...") ? "" : B.text;
  }
  const I = {
    enter: {},
    update: {
      x: t.x,
      y: t.y
    },
    text: A.show ? C : "",
    color: t.color,
    opacity: t.opacity,
    backgroundColor: t.backgroundColor,
    background: {
      value: h instanceof Function ? h(i, n, s, e) : null,
      padding: g
    },
    alignmentBaseline: d,
    rotation: u,
    textAnchor: f,
    meta: {
      layerId: e.id(),
      ...ys({
        fill: t.color,
        opacity: t.opacity,
        backgroundColor: t.backgroundColor,
        "border-color": t["border-color"]
      })
    },
    style: {},
    source: i.source,
    rowId: i.rowId,
    data: i.dataObj,
    hyperlinkInfo: i.hyperlinkInfo,
    ...A
  };
  return I.className = Vs(i, n, s, e), I;
}, sb = (e, t, i, n) => {
  const s = X(t).selectAll("g").data(i), {
    encoding: {
      text: { hyperlink: A }
    }
  } = e.config(), { smartLabel: o } = e._dependencies, a = {}, r = s.enter().append("g").each(function(g) {
    hA(this, g.enter), n.groupClassName && X(this).attr("class", n.groupClassName(g));
  }).merge(s), l = e.cssStyle();
  o.setStyle(l);
  const c = parseInt(l.fontSize, 10);
  return r.each(function(g) {
    const h = X(this);
    a[g.rowId] = h;
    const {
      update: d,
      text: u,
      labelSmartText: f,
      color: C,
      opacity: I,
      textAnchor: E,
      background: B
    } = g, m = f || u, p = Object.assign(
      {},
      pu.baseTextStyle,
      g.style
    );
    let w;
    if (w = B.value) {
      const _ = B.padding;
      let x;
      const { width: S, height: b } = o.getOriSize(m), R = z(h, "rect", [1]);
      E === "end" ? x = S : E === "start" ? x = 0 : x = S / 2, hA(R.node(), {
        x: d.x - x - _ / 2,
        y: d.y - c - _ / 2,
        width: S + _,
        height: b + _
      }), B && vt(R, {
        background: w
      });
    }
    let Q = h;
    A.enabled && (Q = z(h, "a", (_) => [_]), uc(Q, g, A));
    const y = z(Q, "text", (_) => [_]).text(
      m
    ), D = y.node();
    p && vt(D, p), C && vt(D, {
      fill: C,
      opacity: I
    }), g.className && y.classed(g.className, !0), hA(D, d), y.attr("text-anchor", E), y.attr("alignment-baseline", g.alignmentBaseline), y.attr(
      "transform",
      `rotate(${g.rotation} ${d.x} ${d.y})`
    );
  }), s.exit().remove(), {
    selection: s,
    elems: a
  };
}, IB = (e, t, i, n) => {
  const { positionAt: s, rotation: A, mirror: o } = i, a = o !== void 0 ? J6(s, o) : s;
  return n.getLabelPosition(
    e,
    t,
    a,
    A
  );
}, J6 = (e, t) => {
  const i = t.vertical ? K6(e) : e;
  return t.horizontal ? V6(i) : i;
}, K6 = (e) => {
  switch (e) {
    case Si:
      return Ps;
    case Ps:
      return Si;
    case za:
      return Xa;
    case Xa:
      return za;
    default:
      return e;
  }
}, V6 = (e) => {
  switch (e) {
    case vn:
      return Wi;
    case Wi:
      return vn;
    case Za:
      return $a;
    case $a:
      return Za;
    default:
      return e;
  }
}, W6 = (e, t) => {
  const i = fB(e) ? UE : HE.slice(1);
  let n = i.indexOf(e) + 1;
  return n = n < 0 ? i.length - 1 : n >= i.length ? 0 : n, i[n];
}, js = 5;
class CB {
  constructor(t) {
    this._smartLabel = t;
  }
  getLabelPosition(t, i, n, s) {
    let A, o;
    const { x: a, y: r, width: l, height: c } = this.getAsRectangle(i), { width: g, height: h } = gl(
      t,
      s,
      this._smartLabel
    );
    switch (n) {
      case Si:
        A = a + l / 2, o = r - h / 2 - (s ? js : 0);
        break;
      case Wi:
        A = a + l + js + g / 2, o = r + c / 2;
        break;
      case vn:
        A = a - js - g / 2, o = r + c / 2;
        break;
      case Ps:
        A = a + l / 2, o = r + c + h / 2 + (s ? js : 0);
        break;
      case za:
        A = a + l / 2, o = r + h / 2 + js;
        break;
      case $a:
        A = a + l - g / 2 - js, o = r + c / 2;
        break;
      case Za:
        A = a + g / 2 + js, o = r + c / 2;
        break;
      case Xa:
        A = a + l / 2, o = r + c - h / 2 - js;
        break;
      case As:
      default:
        A = a + l / 2, o = r + c / 2;
        break;
    }
    return { xPos: A, yPos: o };
  }
  getAsRectangle(t) {
    const { x: i, y: n, width: s, height: A, size: o } = t;
    return s === void 0 && A === void 0 && o === void 0 ? { x: i - 0.5, y: n - 0.5, width: 1, height: 1 } : o !== void 0 ? { x: i - o, y: n - o, width: 2 * o, height: 2 * o } : s !== void 0 && A !== void 0 ? { x: i, y: n, width: s, height: A } : { x: i, y: n, width: 0, height: 0 };
  }
}
const dA = ({
  yField: e,
  xField: t,
  yFieldAs: i,
  xFieldAs: n,
  dm: s,
  transformConf: A
}) => {
  if (A.type === Wt || A.type === Xt)
    return A.value?.field === e;
  const o = s.getField(e) && s.getField(e).type(), a = s.getField(t) && s.getField(t).type(), r = s.getField(t) && s.getField(t).subtype(), l = s.getField(e) && s.getField(e).subtype();
  return i === ft.CONTINUOUS && o === Ct.MEASURE || n === ft.CONTINUOUS && (a === Ct.DIMENSION || r === ot.TEMPORAL) && i === ot.CONTINUOUS && l == ot.CONTINUOUS || n === ft.DISCRETE && i === ft.CONTINUOUS;
}, q6 = {
  center: () => ({
    M: { x: 0, y: 0 },
    L1: { x: 0, y: 0 },
    L2: { x: 0, y: 0 },
    L3: { x: 0, y: 0 }
  }),
  inside: (e) => ({
    M: { x: +e, y: +e },
    L1: { x: -e, y: +e },
    L2: { x: -e, y: -e },
    L3: { x: +e, y: -e }
  }),
  outside: (e) => ({
    M: { x: -e, y: -e },
    L1: { x: +e, y: -e },
    L2: { x: +e, y: +e },
    L3: { x: -e, y: +e }
  })
}, j6 = ({ width: e, position: t }) => {
  const i = e / 2;
  return q6[t](i);
}, z6 = (e, t, i, n, s) => {
  let A = [], o;
  const a = e.config().encoding, r = e.axes(), l = e.transformedData();
  a.size;
  const { x0Field: c, y0Field: g, textField: h } = e.encodingFieldsInf(), d = e.encodingFieldsInf(), u = e.config().outline;
  e.measurement();
  const f = e.transformType(), C = dA({
    yField: a.y.field,
    yFieldAs: a.y.as,
    xField: a.x.field,
    xFieldAs: a.x.as,
    dm: e.data(),
    transformConf: e._transformConfig
  }), I = e._stackedSum.size;
  for (let E = 0, B = t.length; E < B; E++) {
    const m = t[E], p = ts(e, m), w = ws(e, m);
    f === jn ? o = $6(
      d,
      C,
      m,
      l,
      n,
      i
    ) : o = i;
    const Q = e.config().encoding.size;
    let y;
    if (Q && typeof Q.value == "function") {
      const { size: M } = Qs(e, {
        translatedValues: {
          size: m.size
        },
        datum: m,
        datumIdx: E,
        groupData: t,
        groupIdx: n,
        layerData: s
      });
      y = M;
    }
    const D = e5({
      data: m,
      config: {
        sizeConfigModified: o
      },
      axes: r,
      encoding: a,
      context: e,
      sizeValue: y
    });
    let _ = p.getColor(m.color), x;
    w && (x = w.getOpacity(m.opacity));
    const S = D.update, b = Qs(e, {
      translatedValues: {
        x: S.x,
        y: S.y,
        width: S.width,
        height: S.height,
        color: _,
        opacity: x,
        text: m.text,
        formattedText: m.formattedText
      },
      datum: m,
      datumIdx: E,
      groupData: t,
      groupIdx: n,
      layerData: s
    });
    _ = b.color, x = b.opacity;
    const { x: R, y: G, width: T, height: v } = b;
    typeof a.opacity.value != "function" && !a.opacity.field && (x = a.opacity.value);
    const H = {
      ...yc(a, [e._mainColorProp]),
      fill: _,
      opacity: x,
      ...mu(u, _)
    }, N = {
      strokePosition: Z(a, "strokePosition", "value")
    };
    if (!isNaN(R) && !isNaN(G)) {
      const M = Qo(
        { x: R, y: G, text: b.text },
        E,
        m,
        e
      ), F = e.resolveBestLabelAnchor(
        e.createKey(m, C),
        {
          width: b.width,
          height: b.height,
          text: m.formattedText
        },
        M
      ), k = C ? m.y0 === void 0 && m.y < 0 || m.y0 < 0 : m.x0 === void 0 && m.x < 0 || m.x < 0;
      let O = b.formattedText, P, L;
      if (TI(F) && JQ(C, M))
        P = C ? Math.max(0, v - 8) : Math.max(0, T - 8), L = C ? T : v;
      else if (fB(F) && JQ(C, M)) {
        const V = (C ? r.y : r.x).range(), Y = 8;
        if (C) {
          const nt = k ? b.y + b.height : b.y, tt = k ? V[0] - nt - Y : nt - V[1] - Y;
          L = Math.max(T, 20), P = tt;
        } else {
          const nt = k ? b.x : b.width + b.x;
          P = k ? nt - V[0] - Y : V[1] - nt - Y, L = Math.max(v, 20);
        }
      }
      if (P !== void 0 && L !== void 0) {
        const { smartLabel: J } = e._dependencies, V = J.getSmartText(
          O,
          P,
          L,
          !0
        );
        O = V.isTruncated && !V.text.endsWith("...") ? "" : V.text;
      }
      const { xPos: q, yPos: $ } = ob(
        O,
        e,
        b,
        F !== void 0 ? F : As,
        M,
        k
      );
      let W;
      h && !I && (W = Po(
        e,
        {
          x: q,
          y: $,
          text: b.text,
          formattedText: O,
          color: ib(p, m.color)
        },
        m,
        E,
        t
      ), W && (W.text = F === void 0 ? "" : W.text));
      const U = {
        enter: D.enter,
        update: {
          x: R,
          y: G,
          width: T,
          height: v
        },
        text: W,
        source: m.source,
        rowId: m.rowId,
        data: m.dataObj,
        style: H,
        meta: Object.assign(
          {
            layerId: e.id()
          },
          ys(H, N)
        )
      };
      U.className = Vs(m, E, t, e), A.push(U), e.cachePoint(m.rowId, U);
    }
  }
  return A = Uo(e, A), A;
}, $6 = (e, t, i, n, s, A) => {
  let o;
  const a = n[s].keys.join(",");
  e.xFieldAs === "discrete" && e.yFieldAs === "discrete" || e.xFieldSubType === "binned" && e.yFieldSubType === "binned" ? o = K.getActualValue(i.x) + "-" + K.getActualValue(i.y) : t ? o = K.getActualValue(i.x) : o = K.getActualValue(i.y);
  const r = A.barWidthOffset instanceof Map ? A.barWidthOffset?.get(o)?.get(a) : 0, l = A.barHeightOffset instanceof Map ? A.barHeightOffset?.get(o)?.get(a) : 0;
  return {
    barWidth: A.barWidth,
    barWidthOffset: r,
    barHeightOffset: l,
    barHeight: A.barHeight
  };
}, JQ = (e, t) => e && Math.abs(t) === 90 || !e && (t === 0 || Math.abs(t) === 180), X6 = (e, t, i) => ([ps, QA].includes(
  e.x ? e.x.constructor.type() : null
) || t) && ([ps, QA].includes(
  e.y ? e.y.constructor.type() : null
) || i), Ab = (e, t, i, n, s, { data: A, context: o }) => {
  let a, r;
  const { x: l, y: c } = e, g = Ho(o, A), h = i.orientation;
  r = i.offset;
  const d = h === "x" ? l : c, u = e.x instanceof Zn, f = e.y instanceof Zn, C = u && f, I = X6(
    e,
    u,
    f
  );
  let E;
  if (g.scaleType() === ft.DISCRETE ? E = K.isInvalid(t) ? t.value() : t : E = K.isInvalid(t) ? 0 : t, n.size.field && [QA, ps].includes(d.constructor.type())) {
    a = g.getSize(E);
    const B = i.size - a;
    r += B / 2;
  } else if (u ^ f && n.size.field) {
    s ? a = h === "x" ? g.getSize(E) : 0 : a = h === "x" ? 0 : g.getSize(E);
    const B = i.size - a;
    r += B / 2;
  } else if (C && n.size.field) {
    a = g.getSize(E);
    const B = i.size - a;
    r += B / 2;
  } else
    I || C ? a = i.size || n.size.value : s ? a = h === "x" ? i.size || n.size.value : 0 : a = h === "x" ? 0 : i.size || n.size.value;
  return {
    offset: r,
    span: a
  };
}, Z6 = (e, t, i, n, s, { data: A, context: o }) => Ab(
  e,
  t,
  {
    offset: i.barWidthOffset,
    size: i.barWidth,
    orientation: "x"
  },
  n,
  s,
  {
    data: A,
    context: o
  }
), t5 = (e, t, i, n, s, { data: A, context: o }) => Ab(
  e,
  t,
  {
    offset: i.barHeightOffset,
    size: i.barHeight,
    orientation: "y"
  },
  n,
  s,
  {
    data: A,
    context: o
  }
), e5 = ({
  data: e,
  sizeValue: t,
  config: i,
  axes: n,
  encoding: s,
  context: A
}) => {
  const o = i.sizeConfigModified, a = dA({
    yField: s.y.field,
    yFieldAs: s.y.as,
    xField: s.x.field,
    xFieldAs: s.x.as,
    dm: A.data(),
    transformConf: A._transformConfig
  }), r = Z6(
    n,
    e.size,
    o,
    s,
    a,
    {
      data: e,
      context: A
    }
  ), l = t5(
    n,
    e.size,
    o,
    s,
    a,
    {
      data: e,
      context: A
    }
  );
  let c = i5(n.x, {
    d: e,
    ...r,
    measurement: A.measurement()
  }), g = n5(n.y, {
    d: e,
    ...l,
    measurement: A.measurement()
  });
  const h = A5(n, {
    d: e,
    ...l,
    measurement: A.measurement(),
    isVertical: a
  }), d = s5(n, {
    d: e,
    ...r,
    measurement: A.measurement(),
    isVertical: a
  });
  let u = Math.abs(c - d), f = Math.abs(g - h);
  if (t) {
    const I = (t - (a ? u : f)) / 2;
    a ? (c = c - I, u = t) : (g = g - I, f = t);
  }
  return c = Math.min(c, d), g = Math.min(g, h), {
    enter: {
      x: a ? c : n.x ? n.x.getScaleValue(n.x.domain()[0]) : 0,
      y: a ? n.y ? n.y.getScaleValue(n.y.domain()[0]) : 0 : g,
      width: a ? u : 0,
      height: a ? 0 : f
    },
    update: {
      x: c,
      y: g,
      width: u,
      height: f
    }
  };
}, i5 = (e, t) => {
  if (!e)
    return 0;
  const { d: i, offset: n } = t;
  return e.getScaleValue(i.x) + n;
}, n5 = (e, t) => {
  const { d: i, offset: n } = t;
  return e ? e instanceof qi ? e.getScaleValue(i.y + e.binSize()) + n : e.getScaleValue(i.y) + n : 0;
}, s5 = (e, t) => {
  if (!e.x)
    return t.measurement.width;
  const { d: i, isVertical: n } = t;
  let s = i.x0, { span: A, offset: o } = t;
  return s == null && (n ? s = i.x : s = e.x.constructor.type() === be && !(e.x instanceof Zn) ? 0 : i.x), e.x.getScaleValue(s) + A + o;
}, A5 = (e, t) => {
  if (!e.y)
    return t.measurement.height;
  const { d: i, isVertical: n } = t;
  let s = i.y0, { span: A, offset: o } = t;
  return s == null && (n && e.y.constructor.type() === be && !(e.y instanceof qi) ? s = 0 : s = i.y), e.y instanceof qi && (s = i.y + e.y.binSize()), e.y.getScaleValue(s) + A + o;
}, ob = (e, t, i, n, s, A) => {
  const o = t.config().encoding, { smartLabel: a } = t._dependencies, r = new CB(a), l = dA({
    yField: o.y.field,
    yFieldAs: o.y.as,
    xField: o.x.field,
    xFieldAs: o.x.as,
    dm: t.data(),
    transformConf: t._transformConfig
  });
  return IB(
    e,
    i,
    {
      positionAt: n,
      rotation: s,
      mirror: {
        vertical: l && A,
        horizontal: !l && A
      }
    },
    r
  );
}, o5 = (e, t, i) => {
  const { originalStyle: n, currentState: s } = e, A = {};
  for (let o in i) {
    for (let a = t.length - 1; a >= 0; a--) {
      const r = s.get(t[a]).styles;
      if (o in r) {
        A[o] = r[o];
        break;
      }
    }
    o in A || (A[o] = wt(
      n.styles[o],
      ""
    ));
  }
  return A;
}, a5 = (e, { datumStyle: t, colorMap: i }, n) => {
  let s = e;
  if (typeof e == "object") {
    if (t === "none")
      return "none";
    const A = CA(t);
    return s = _x(A, e, n, i), s;
  }
  return s;
}, so = (e, t, i, n) => {
  const { interactionType: s, apply: A } = n, o = t.data()[0], { currentState: a, lastInteraction: r } = o.meta, l = a.get(s);
  if (A === !!l)
    return !1;
  let c = {};
  const { style: g, strokePosition: h, className: d } = i;
  if (e.colorMap || (e.colorMap = /* @__PURE__ */ new Map()), A) {
    const u = {
      styles: {},
      strokePosition: h,
      className: d
    };
    for (const f in g) {
      const C = t.style(f), I = a5(
        g[f],
        {
          datumStyle: C,
          colorMap: e.colorMap
        },
        A
      );
      u.styles[f] = I;
    }
    a.set(s, u), r.push(s), c = u;
  } else {
    const u = a.get(s);
    a.delete(s), r.splice(r.indexOf(s), 1), c = {
      styles: o5(
        o.meta,
        r,
        u.styles
      ),
      className: u.className
    };
  }
  e.applyStyles(
    {
      styleObj: c,
      elem: t,
      datum: o
    },
    n
  );
}, sg = (e, t) => {
  const { x: i, y: n } = e.axes(), s = Z(t, "axisDomainRanges") || {};
  let A, o;
  return i ? A = i.config().orientation === "bottom" ? Z(s, "x", 0) || null : Z(s, "x", 1) || null : A = null, n ? o = n.config().orientation === "left" ? Z(s, "y", 0) || null : Z(s, "y", 1) || null : o = null, { xRange: A, yRange: o };
}, wc = ({
  dm: e,
  valueField: t,
  uniqueField: i,
  fieldAs: n
}) => e.isEmpty() ? [] : aB.getFieldDomainFromData(
  e,
  i,
  t,
  n
), Vh = (e) => {
  const t = Math.abs(e[0] - e[1]);
  return t === 0 ? [e[0] - 1, e[1] + 1] : [e[0] - 0.01 * t, e[1] + 0.01 * t];
}, Hl = (e) => [
  Math.min(e[0], 0),
  Math.max(0, e[1])
], EB = ({ dm: e }) => e.isEmpty() ? [] : Eu.getFieldDomainFromData(), r5 = (e, t, i) => {
  const {
    encoding: {
      text: { hyperlink: n }
    }
  } = e.config();
  let s = n.generateHref(
    {
      formattedValue: t.formattedText,
      rawValue: t.text
    },
    {
      context: e,
      dataPoint: t,
      dataPointIdx: i
    }
  );
  const [A, o, a] = n.sanitizeHyperlink ? e.data().sanitiseStrings([
    s.target,
    s.rel,
    s.url
  ]) : [s.target, s.rel, s.url], r = a || t.formattedText;
  return {
    target: A || bo,
    rel: o || Mo,
    url: n.encode ? encodeURI(r) : r,
    classNames: s.classNames ? s.classNames : Fo,
    styles: s.styles ? s.styles : No
  };
}, Tr = (e) => {
  const { field: t } = e.config().encoding.color, { field: i } = e.config().encoding.backgroundColor, n = [];
  return t && e.data().getField(t).type() === Ct.DIMENSION && n.push(t), i && e.data().getField(i).type() === Ct.DIMENSION && n.push(i), n;
}, pf = (e, t, i) => {
  const {
    encoding: {
      text: { formatter: n, showStackSum: s, displayAs: A }
    },
    mark: o
  } = e.config(), { type: a, originalType: r } = e._transformConfig, c = o === GE && (r || a) === Xt && A === tr, g = { ...t.dataObj }, h = () => g, d = () => {
    const { getGrandTotalsInfo: p } = e._dependencies.canvasActions, { unitRowIndex: w, facets: Q } = e.metaInf(), {
      dataStore: y,
      rowFacets: D = [],
      colFacets: _ = [],
      discreteColumnProjections: x = [],
      discreteRowProjections: S = [],
      splitFieldInfo: b = {}
    } = p("rowGrandTotals", w, Q), R = [
      ...D,
      ..._,
      ...x,
      ...S
    ].map((P) => `${P}`), G = e.encodingFieldsInf(), T = [], { yField: v, y0Field: H } = G, N = Tr(e);
    [v, H, ...N].forEach((P) => {
      P && t.dataObj[P] && T.push({
        field: P,
        value: t.dataObj[P],
        operator: "eq"
      });
    }), b.field && T.push({
      field: b.field,
      value: t.dataObj[b.field],
      operator: "eq"
    });
    const M = (T.length ? y.select({
      operator: "and",
      conditions: T
    }) : y).groupBy(R), { data: F, schema: k } = M.getData();
    return k.reduce((P, L, q) => (P[L.name] = F?.[0]?.[q] ?? null, P), {});
  }, u = () => {
    const { getGrandTotalsInfo: p } = e._dependencies.canvasActions, { unitColIndex: w, facets: Q } = e.metaInf(), {
      dataStore: y,
      rowFacets: D = [],
      colFacets: _ = [],
      discreteColumnProjections: x = [],
      discreteRowProjections: S = [],
      splitFieldInfo: b = {}
    } = p("columnGrandTotals", w, Q), R = [
      ...D,
      ..._,
      ...x,
      ...S
    ].map((P) => `${P}`), G = e.encodingFieldsInf(), T = [], { xField: v, x0Field: H } = G, N = Tr(e);
    [v, H, ...N].forEach((P) => {
      P && t.dataObj[P] && T.push({
        field: P,
        value: t.dataObj[P],
        operator: "eq"
      });
    }), b.field && T.push({
      field: b.field,
      value: t.dataObj[b.field],
      operator: "eq"
    });
    const M = (T.length ? y.select({
      operator: "and",
      conditions: T
    }) : y).groupBy(R), { data: F, schema: k } = M.getData();
    return M.dispose(), k.reduce((P, L, q) => (P[L.name] = F?.[0]?.[q] ?? null, P), {});
  }, f = () => {
    const { getGrandTotalsInfo: p } = e._dependencies.canvasActions, { facets: w } = e.metaInf(), {
      dataStore: Q,
      rowFacets: y = [],
      colFacets: D = [],
      discreteColumnProjections: _ = [],
      discreteRowProjections: x = [],
      splitFieldInfo: S = {}
    } = p("greatGrandTotals", null, w), b = [
      ...y,
      ...D,
      ..._,
      ...x
    ].map((M) => `${M}`), R = [];
    Tr(e).forEach((M) => {
      R.push({
        field: M,
        value: t.dataObj[M],
        operator: "eq"
      });
    }), S.column?.field && R.push({
      field: S.column.field,
      value: t.dataObj[S.column.field],
      operator: "eq"
    }), S.row?.field && R.push({
      field: S.row.field,
      value: t.dataObj[S.row.field],
      operator: "eq"
    });
    const T = Q.select({
      operator: "and",
      conditions: R
    }).groupBy(b), { data: v, schema: H } = T.getData();
    return T.dispose(), H.reduce((M, F, k) => (M[F.name] = v?.[0]?.[k] ?? null, M), {});
  }, C = () => {
    const { getSubTotalsInfo: p } = e._dependencies.canvasActions, w = e.metaInf(), {
      dataStore: Q,
      rowFacets: y = [],
      colFacets: D = [],
      discreteColumnProjections: _ = [],
      discreteRowProjections: x = [],
      selectRequiredOnDataStore: S,
      colSubTotalsSplitField: b,
      columnTotalString: R
    } = p("column", w, t), G = [
      ...y,
      ...D,
      ..._,
      ...x
    ].map((L) => `${L}`), T = e.encodingFieldsInf(), v = [], { xField: H, x0Field: N } = T, M = Tr(e);
    [H, N, ...M].forEach((L) => {
      L && t.dataObj[L] && v.push({
        field: L,
        value: t.dataObj[L],
        operator: "eq"
      });
    }), S && x.forEach((L) => {
      L && t.dataObj[L] && v.push({
        field: L,
        value: L === b ? t.dataObj[L] : R,
        operator: "eq"
      });
    });
    const F = (v.length ? Q.select({
      operator: "and",
      conditions: v
    }) : Q).groupBy(G), { data: k, schema: O } = F.getData();
    return O.reduce((L, q, $) => (L[q.name] = k?.[0]?.[$] ?? null, L), {});
  }, I = () => {
    const { getSubTotalsInfo: p } = e._dependencies.canvasActions, w = e.metaInf(), {
      dataStore: Q,
      rowFacets: y = [],
      colFacets: D = [],
      discreteColumnProjections: _ = [],
      discreteRowProjections: x = [],
      selectRequiredOnDataStore: S,
      rowSubTotalsSplitField: b,
      rowTotalString: R
    } = p("row", w, t), G = [
      ...y,
      ...D,
      ..._,
      ...x
    ].map((L) => `${L}`), T = e.encodingFieldsInf(), v = [], { yField: H, y0Field: N } = T, M = Tr(e);
    [H, N, ...M].forEach((L) => {
      L && t.dataObj[L] && v.push({
        field: L,
        value: t.dataObj[L],
        operator: "eq"
      });
    }), S && _.forEach((L) => {
      L && t.dataObj[L] && v.push({
        field: L,
        value: L === b ? t.dataObj[L] : R,
        operator: "eq"
      });
    });
    const F = (v.length ? Q.select({
      operator: "and",
      conditions: v
    }) : Q).groupBy(G), { data: k, schema: O } = F.getData();
    return O.reduce((L, q, $) => (L[q.name] = k?.[0]?.[$] ?? null, L), {});
  }, E = () => {
    if (!s)
      throw new Gn(
        "Stacked sum labels are not supported when showStackSum is false",
        {
          cause: "Unsupported Layer Config: showStackSum must be true"
        }
      );
    return g;
  }, B = c ? e.formatTextLabelWithDisplayAsFormatter(t.percentageText * 100) : e.formatTextLabelWithDefaultFormatter(t.text);
  return n(
    {
      formattedValue: B,
      rawValue: t.text,
      getRowData: h,
      getStackSumData: E,
      getColumnGrandTotalsData: u,
      getRowGrandTotalsData: d,
      getGreatGrandTotalsData: f,
      getColumnSubTotalData: C,
      getRowSubTotalData: I
    },
    {
      context: e,
      dataPoint: t,
      dataPointIdx: i
    }
  );
}, l5 = ({
  dm: e,
  valueField: t,
  uniqueField: i,
  textField: n,
  transformType: s
}) => e.isEmpty() ? [] : (s === Wt ? aB : Eu).getStackSumFromData(
  e,
  i,
  t,
  n
), c5 = (e) => Object.keys(e).reduce((t, i) => {
  let n;
  return typeof e[i] == "string" ? n = { [i]: "" } : typeof e[i] == "number" ? n = { [i]: -1 } : typeof e[i] == "object" ? n = { [i]: {} } : n = { [i]: null }, t = { ...t, ...n }, t;
}, {}), KQ = (e, t, i, n, s, A) => {
  const o = e.config().encoding.text.formatter, a = e.config().encoding.text.showStackSum, r = e.config().encoding.text.displayAs, l = n === Xt && r === tr, c = () => {
    if (a)
      throw new Gn(
        "Individual labels are not supported when showStackSum is true",
        {
          cause: "Unsupported Layer Config: showStackSum must be false"
        }
      );
    return { ...t.dataObj };
  }, g = () => {
    if (!a)
      throw new Gn(
        "Stacked sum labels are not supported when showStackSum is false",
        {
          cause: "Unsupported Layer Config: showStackSum must be true"
        }
      );
    const f = e.isVerticalBar() ? "x" : "y";
    let C = [];
    return A.forEach((I) => {
      I[f] === t[f] && C.push({ ...t.dataObj });
    }), C;
  }, h = l ? e.formatTextLabelWithDisplayAsFormatter(t.percentageText * 100) : e.formatTextLabelWithDefaultFormatter(t[s]);
  return o(
    {
      formattedValue: h,
      rawValue: t[s],
      getRowData: c,
      getStackSumData: g
    },
    {
      context: e,
      dataPoint: c5(t),
      dataPointIdx: i
    }
  );
}, zo = (e, t) => e === null || t.length > e.length ? t : e, $o = (e, t) => e === null || t.length < e.length ? t : e, Wh = (e, t, i, n, s) => {
  const { textField: A } = e.encodingFieldsInf(), o = e.axes(), a = n ? o.y : o.x, r = s === "posStackSum", l = r ? t.formattedTextPosSum : t.formattedTextNegSum, c = t.update.x, g = t.update.y, h = t.update.width, d = t.update.height, u = r ? n ? Si : Wi : n ? Ps : vn, f = Qo({ x: c, y: g, text: t.text }, i, t, e), C = e._transformType;
  let I = 1, E = t.stackSumLabelCoords;
  E ? I = r ? E.pos : E.neg : C === Wt ? I = a.getScaleValue(t[s]) : I = a.getScaleValue(r ? 1 : 0);
  let B;
  if (A && t[s]) {
    const { xPos: p, yPos: w } = ob(
      l,
      e,
      n ? { x: c, y: I, height: 0, width: h } : { x: I, y: g, height: d, width: 0 },
      u,
      f,
      !1
    );
    B = Po(
      e,
      {
        x: p,
        y: w,
        text: t.text,
        formattedText: l
      },
      t,
      i,
      e._normalizedData
    );
  }
  const m = {
    enter: t.enter,
    update: t.update,
    text: B,
    source: t.source,
    rowId: -1,
    data: t.dataObj,
    style: t.style,
    meta: t.meta
  };
  return m.className = Vs(t, i, t, e), m;
}, g5 = (e, t, i) => {
  if (e.legend[t] && e.legend[t].fields && e.legend[t].fields[i]) {
    const n = e.legend[t].fields[i].step, s = e.legend[t].step, A = typeof stepInField == "boolean" ? n : typeof s == "boolean" ? s : !1, { stops: o } = e.legend[t].fields[i];
    return A && Array.isArray(o) && o.length ? { domain: o } : e.legend[t].fields[i];
  }
  return {};
}, ab = (e, t, i = {
  field: null,
  fieldAs: null,
  uniqueField: null,
  isIndependentEncoding: !0
}) => {
  const { field: n, fieldAs: s, uniqueField: A, isIndependentEncoding: o } = i;
  if (!n || !s || !A || !((h) => h === !0 || h === !1)(o) || t.every((h) => h === null))
    return [0, 1];
  let r = wc({
    dm: e,
    fieldAs: s,
    valueField: n,
    uniqueField: A.field
  });
  o ? r = Vh(r) : r = Hl(r);
  let l = Math.min(...r), c = Math.max(...r);
  const g = Eu.getFieldDomainFromData().map((h) => h);
  for (let h = 0; h < t.length; h++) {
    const d = t[h];
    if (d !== null) {
      const u = c - l, f = (d - l) / u;
      g[h] = f;
    }
  }
  return g;
}, rb = (e) => Array.isArray(e) && e.length > 1, BB = "drag", ba = "hover", hl = "selectiondrag", Ol = "click", dl = "longtouch", lb = "touchdrag", qh = "contextmenu", h5 = "*", d5 = (e, t) => {
  const i = e._sideEffects;
  return t = t instanceof Array ? t : Object.values(t), t.forEach((n) => {
    const s = n.formalName(), A = n.target() instanceof Array ? n.target() : [n.target()];
    if (A.includes(e.target()) || A.includes("all")) {
      const o = i[s];
      i[s] = o || new n(e);
    }
  }), i;
}, u5 = (e, t) => {
  const i = {};
  return t = t instanceof Array ? t : Object.values(t), t.forEach((n) => {
    const s = n.formalName();
    i[s] = new n(e), e.registerPropagationBehaviourMap({
      [s]: [s]
    });
  }), i;
}, f5 = (e, t) => {
  const i = {};
  for (const n in t)
    ({}).hasOwnProperty.call(n, t) || (i[n] = t[n](e));
  return i;
}, Cs = (e, t) => {
  let i;
  t[0] instanceof Set || t[0] instanceof Array ? i = t : i = [t], e = Bn(e);
  const n = i.map(
    (A) => A instanceof Set ? A : new Set(A)
  ), s = /* @__PURE__ */ new Set();
  return e.forEach((A) => {
    for (const o of A)
      n.every((a) => !a.has(o)) && s.add(o);
  }), s;
}, I5 = (e, t) => {
  const i = {};
  return Object.keys(t.actions().behavioural).forEach((s) => {
    const A = wt(e[s], e["*"]);
    A && (i[s] = A);
  }), i;
}, C5 = (e, t) => {
  const i = {};
  return Object.keys(t.sideEffects()).forEach((s) => {
    const A = wt(e[s], e["*"]);
    A && (i[s] = A);
  }), i;
}, E5 = (e, { behaviours: t, sideEffects: i }) => {
  const n = I5(t, e);
  for (const A in n)
    e.getBehaviouralAction(A).setApplyChecker({
      [A]: n[A],
      "*": t["*"]
    });
  const s = C5(i, e);
  for (const A in s)
    e.getSideEffectInstance(A).setApplyChecker({
      [A]: s[A],
      "*": i["*"]
    });
}, mB = ({ action: e, sourceCanvas: t, targetActions: i }, n) => {
  let s;
  return t === n.sourceCanvas() ? s = Z(i, "layer", e, "sideEffects") || {} : s = Z(
    i,
    "interCanvas",
    n.sourceCanvas(),
    e,
    "sideEffects"
  ) || {}, Object.keys(s || {}).map((o) => ({
    name: o,
    ...s[o]
  })).filter((o) => o.enabled !== !1);
}, B5 = (e, t) => {
  const i = e[0], n = i.reduce((r, l, c) => (r[l] = c, r), {}), s = /* @__PURE__ */ new Set(), A = i, o = i.find(
    (r) => r === pt.ROW_ID
  ), a = t(A);
  for (let r = 1, l = e.length; r < l; r++) {
    const c = e[r];
    if (o)
      s.add(c[n[o]]);
    else {
      const g = A.map((d) => c[n[d]]), h = a[g];
      h && h.forEach((d) => {
        s.add(d);
      });
    }
  }
  return [...s];
}, m5 = (e, t) => {
  if (e) {
    const i = t.data();
    let n = [];
    const { range: s, dimensions: A, uids: o } = e;
    if (o)
      n = o;
    else if (s) {
      const a = i.getFilterRangeQuery(s), r = i.select(a);
      n = r.getUids(), r.dispose();
    } else A && (n = B5(A, t._dimsMapGetter));
    return n;
  }
  return null;
}, p5 = (e, t, i) => {
  const n = i._actionBehaviourMap;
  for (const s in n)
    if (s === t) {
      const A = n[s];
      A.behaviours = A.behaviours.filter(
        (o) => o !== e
      );
    }
}, Q5 = (e, t, i) => {
  const n = i._behaviourEffectMap;
  n[t] = n[t].filter(
    (s) => (s.name || s) !== e
  );
};
class Yo {
  constructor(t, i, n, s) {
    this.context = t, this._childFirebolts = [], this._onMatrixCreated = [], this._sideEffectDefinitions = {}, this._sideEffects = {}, this._actions = {
      behavioural: {},
      physical: {},
      physicalActionDefs: {},
      behaviourDefs: {}
    }, this._propagationBehaviourMap = {}, this._actionBehaviourMap = {}, this._propagationInf = {}, this._config = {}, this._behaviourEffectMap = {}, this._queuedSideEffects = {}, this._handlers = {}, this._payloadGenerators = {}, this._propagationHandler = null, this._lastInteraction = /* @__PURE__ */ new Map(), this._metaData = {}, this.mapSideEffects(s), this.registerBehaviouralActions(i.behavioural), this.registerSideEffects(n), this.registerPhysicalBehaviouralMap(i.physicalBehaviouralMap), this.registerPhysicalActions(i.physical);
    const A = {};
    for (const o in this._actions.behavioural)
      A[o] = [o];
    this.registerPropagationBehaviourMap(A);
  }
  config(...t) {
    return t.length ? (this._config = et(this._config, t[0]), this) : this._config;
  }
  mapSideEffects(t, i = !0) {
    const n = this._behaviourEffectMap;
    for (const s in t) {
      let A = t[s] || [];
      A = A.map(
        (o) => ke(o) ? et({}, o) : { name: o }
      ), !n[s] && (n[s] = []), n[s] = [
        ...new Set(
          i ? Bh(
            [...n[s], ...A],
            (o) => o.name || o
          ) : A
        )
      ];
    }
    return this._childFirebolts.forEach((s) => {
      s.mapSideEffects(t);
    }), this;
  }
  registerBehaviouralActions(t) {
    Object.assign(this._actions.behaviourDefs, t);
    const i = u5(this, t);
    return Object.assign(this._actions.behavioural, i), this;
  }
  registerSideEffects(t) {
    for (const i in t)
      this._sideEffectDefinitions[t[i].formalName()] = t[i];
    return this.initializeSideEffects(), this;
  }
  isVisible() {
    return !0;
  }
  applySideEffects(t, i, n) {
    return t.forEach((s) => {
      const A = s.name;
      this.dispatchSideEffect(A, i, n, s);
    }), this;
  }
  dispatchSideEffect(t, i, n, s) {
    const o = this.sideEffects()[t], { setTransform: a } = s, r = wt(
      a,
      o.setTransform()
    );
    i = r ? r(i, n, o) : i, o.apply(i, n, s);
  }
  disposeSelectionSets() {
    const t = this._actions.behavioural;
    for (const i in t)
      t[i].dispose();
  }
  dispose() {
    this.disposeSelectionSets(), Object.entries(this._sideEffects).forEach(([t, i]) => {
      (t === "tooltip" || t === "fragmented-tooltip") && i.dispose();
    });
  }
  registerPropagationBehaviourMap(t) {
    const i = this._propagationBehaviourMap;
    for (const n in t)
      if (n in i) {
        const s = t[n] instanceof Array ? t[n] : [t[n]];
        i[n] = [
          .../* @__PURE__ */ new Set([...i[n], ...s])
        ];
      } else
        i[n] = t[n];
    return this;
  }
  dispatchBehaviour(t, i, n = {}, s = !1) {
    const A = n.propagate !== void 0 ? n.propagate : !0, o = this.getBehaviouralAction(t);
    return this._propagationInf = n, o && (o.shouldApply(i, n) || s) ? (i.action = t, o.dispatch(i), A && o.propagate() && this.propagate(t, i, o.propagationIdentifiers()), this.dispatchSideEffects(
      t,
      i,
      n,
      s
    ), this._lastInteraction.set(t, {
      behaviour: t,
      sideEffects: i.sideEffects
    }), !0) : !1;
  }
  dispatchSideEffects(t, i, n, s) {
    const A = this._behaviourEffectMap[t] || [], o = this.getApplicableSideEffects(
      A,
      i,
      n,
      s
    );
    this.applySideEffects(
      o,
      this.getEntryExitSet(t),
      i,
      t
    );
  }
  saveInteractionState({ action: t, payload: i, propagationInf: n, forceDispatch: s }) {
    return t !== "highlight" && this._interactionStates.set(t, {
      action: t,
      payload: i,
      propagationInf: n,
      forceDispatch: s
    }), this;
  }
  removeInteractionState({ action: t }) {
    this._interactionStates.delete(t);
  }
  clearInteractionState() {
    this._interactionStates.clear();
  }
  propagate() {
    return this;
  }
  sideEffects(...t) {
    return t.length ? (this._sideEffects = t[0], this) : this._sideEffects;
  }
  dissociateBehaviour(...t) {
    return t.forEach((i) => {
      p5(...i, this);
    }), this._childFirebolts.forEach((i) => {
      i.dissociateBehaviour(...t);
    }), this;
  }
  dissociateSideEffect(...t) {
    return t.forEach((i) => {
      Q5(...i, this);
    }), this._childFirebolts.forEach((i) => {
      i.dissociateSideEffect(...t);
    }), this;
  }
  getApplicableSideEffects(t = [], i, n, s) {
    const A = this.sideEffects();
    return (i.sideEffects ? i.sideEffects : t).filter(
      (a) => A[a.name] && (s ? A[a.name]._enabled : A[a.name].shouldApply(i, n))
    );
  }
  attachPropagationListener(t, i = this.onDataModelPropagation()) {
    return t.unsubscribe(this._propagationHandler), t.onPropagation(i), this._propagationHandler = i, this;
  }
  onDataModelPropagation() {
    return (t) => {
      const i = t.payload, n = i.action;
      this.dispatchBehaviour(n, i, {
        propagate: !1
      });
    };
  }
  createSelectionSet(t) {
    const i = this._actions.behavioural;
    for (const n in i)
      i[n].createSelectionSet(t);
    return this;
  }
  initializeSideEffects() {
    const t = this._sideEffectDefinitions;
    return this.sideEffects(d5(this, t)), this;
  }
  target() {
    return "all";
  }
  registerPhysicalActions(t, i = this) {
    Object.assign(this._actions.physicalActionDefs, t);
    const n = f5(i, t);
    return Object.assign(this._actions.physical, n), this;
  }
  /**
   * Allows to propagate the datamodel with only the supplied fields. When propagation is done, then the fields
   * which are supplied for the specified behavioural action is propagated.
   *
   * @public
   *
   * @param {string} action Name of behavioural action. If '*' is specified, then for all behavioural actions it is
   * applied.
   * @param {Array} fields Array of field names which will be propagated.
   * @param {boolean} append If true, then it is appended to the existing propagation data model fields else only
   * those fields are projected from propagation data model and propagated.
   *
   * @return {Firebolt} Instance of firebolt
   */
  setPropagationFields(t, i, n = !1) {
    const s = this._actions.behavioural;
    if (t === h5)
      for (const A in s)
        s[A].propagateWith(i, n);
    else
      s[t].propagateWith(i, n);
    return this;
  }
  propagateWith(t, i, n = !1) {
    const s = this._childFirebolts;
    this.setPropagationFields(t, i, n), s.forEach((A) => {
      A.propagateWith(t, i, n);
    });
  }
  /**
   * Map actions and behaviours
   * @return {Firebolt} Firebolt instance
   */
  mapActionsAndBehaviour(t, i) {
    const n = this._actions.physical, s = i || this._actionBehaviourMap;
    for (const A in s)
      if (!{}.hasOwnProperty.call(A, s) && A === (t || A)) {
        let o;
        const a = s[A];
        o = a.target;
        const r = a.touch;
        o || (o = this.context.getDefaultTargetContainer()), (bE() ? r === !0 || r === void 0 : !r) && this.bindActionWithBehaviour(
          n[A],
          o,
          a.behaviours
        );
      }
    return this.registerPhysicalActionHandlers(), this;
  }
  registerPhysicalBehaviouralMap(t) {
    return this._actionBehaviourMap = et(this._actionBehaviourMap, t), this._childFirebolts.forEach((i) => {
      i.registerPhysicalBehaviouralMap(t);
    }), this;
  }
  /**
   * Binds a target element with an action.
   *
   * @param {Function} action Action method
   * @param {string} target Class name of element
   * @param {Array} behaviourList Array of behaviours
   * @return {FireBolt} Instance of firebolt
   */
  bindActionWithBehaviour(t, i, n) {
    return typeof i == "string" && (i = [i]), i.forEach((s) => {
      const A = this.context.mount(), o = s.node instanceof Function ? s : X(A).selectAll(s);
      o.empty() || (o instanceof Array ? o.forEach((a) => {
        t(X(a), n);
      }) : t(o, n));
    }), this;
  }
  getPropagationInf() {
    return this._propagationInf;
  }
  getAddSetFromCriteria(t, i = {}) {
    return t === null ? {
      model: null,
      uids: null
    } : Z(t, "uids", "length") === 0 ? {
      model: i.data,
      uids: []
    } : {
      model: i.data ? i.data : null,
      uids: m5(t, this)
    };
  }
  getFullData() {
    return this.context.data();
  }
  data() {
    return this.context.data();
  }
  currentData() {
    return this.data();
  }
  triggerPhysicalAction(t, i) {
    const n = this._handlers[t] || [], s = this._handlers["*"];
    return [
      ...Object.values(n),
      ...Object.values(s)
    ].forEach((o) => {
      o(t, i);
    }), this;
  }
  onPhysicalActionTrigger({ payload: t, behaviours: i }) {
    i.forEach((n) => {
      this.dispatchBehaviour(n, t);
    });
  }
  onPhysicalAction(t, i, n) {
    return !this._handlers[t] && (this._handlers[t] = {}), this._handlers[t][n] = i, this;
  }
  registerPhysicalActionHandlers() {
    this.onPhysicalAction("*", (t, i) => {
      const n = this._actionBehaviourMap[t];
      if (n) {
        const { behaviours: s } = n;
        this.onPhysicalActionTrigger({
          event: t,
          payload: i,
          behaviours: s
        }), this._criteria = i.criteria;
      }
    });
  }
  beforeDispatchBehaviour() {
    return this;
  }
  id() {
    return this.context.id();
  }
  payloadGenerators(...t) {
    return t.length && Object.assign(this._payloadGenerators, t[0]), this._payloadGenerators;
  }
  getPayloadGeneratorFor(t) {
    const i = this._payloadGenerators.__default, n = this._payloadGenerators[t];
    return wt(n, i);
  }
  getPayload(t) {
    return this._actions.behavioural[t].getPayload();
  }
  actions() {
    return this._actions;
  }
  getBehaviouralAction(t) {
    return this._actions.behavioural[t];
  }
  getSideEffectInstance(t) {
    return this._sideEffects[t];
  }
  getEntryExitSet(t) {
    return this.getBehaviouralAction(t).entryExitSet();
  }
  getSelectionSet(t) {
    return this.getBehaviouralAction(t).getSelectionSet();
  }
  onPropagationDone(t) {
    this._onPropagationDone = t;
  }
  applyPropagationPolicy({ behaviours: t, sideEffects: i }) {
    E5(this, { behaviours: t, sideEffects: i }), this._childFirebolts.forEach((n) => {
      n.applyPropagationPolicy({ behaviours: t, sideEffects: i });
    });
  }
  sourceCanvas() {
    return this.context.sourceCanvas();
  }
  metaData(...t) {
    return t.length && (this._metaData = et(this._metaData, t[0])), this._metaData;
  }
}
const VQ = (e, t) => {
  if (Array.isArray(e))
    e.forEach(t);
  else
    for (const n of e)
      t(n);
};
class Qu {
  /**
   * Creates an instance of selection set
   *
   * @param {Array.<string>} completeSet Set of unique ids.
   */
  constructor({ keys: t, entrySet: i, exitSet: n }) {
    this._set = t instanceof Set ? t : new Set(t), this._entrySet = i || /* @__PURE__ */ new Set(), this._exitSet = n || /* @__PURE__ */ new Set(), this._resetted = !1;
  }
  /**
   * Adds a set of ids to the selection set. This also moves the other rows to exit set.
   *
   * @public
   * @param {Array.<number|string>} ids Array of unique ids.
   *
   * @return {SelectionSet} Instance of selection set.
   */
  add(t) {
    const i = this._entrySet, n = this._exitSet;
    return VQ(t, (s) => {
      i.add(s), n.has(s) && n.delete(s);
    }), this;
  }
  updateEntrySet() {
    const [t, i] = this._entrySet;
    for (const n of i)
      i.delete(n), t.add(n);
  }
  updateExitSet() {
    const [t, i] = this._exitSet;
    for (const n of i)
      t.add(n), i.delete(n);
  }
  getEntrySet() {
    return this._entrySet;
  }
  getExitSet() {
    return this._exitSet;
  }
  /**
   * Removes an array of ids from the selection set. It also moves the remaining row ids to entry set.
   *
   * @public
   * @param {Array.<string>} ids Array of unique ids
   *
   * @return {SelectionSet}  Instance of selection set
   */
  remove(t) {
    const i = this._exitSet, n = this._entrySet;
    return VQ(t, (s) => {
      i.add(s), n.has(s) && n.delete(s);
    }), this;
  }
  /**
   * Resets an array of ids in the selection set to initial state. It sets the value of every unique id value to
   * null in the selection set which means they are neither in entry set nor in exit set. If no ids are passed,
   * then it resets all the ids to null.
   *
   * @public
   *
   * @param {Array} ids Array of unique ids.
   * @return {SelectionSet} Instance of selection set.
   */
  reset() {
    return this._entrySet.clear(), this._exitSet.clear(), this;
  }
  resetted() {
    return !this.getEntrySetLength() && !this.getExitSetLength();
  }
  getEntrySetLength() {
    return this._entrySet.size;
  }
  getExitSetLength() {
    return this._exitSet.size;
  }
  /**
   * Gets all the ids which are either in exit or entry set.
   *
   * @public
   * @return {Array} Array of unique ids
   */
  getCompleteSet() {
    return this._set;
  }
  getCompleteSetLength() {
    return this._set.size;
  }
  clone({ entrySet: t, exitSet: i }) {
    return new Qu({ keys: new Set(this._set), entrySet: t, exitSet: i });
  }
}
const WQ = (e, t, i) => {
  if (e = e.filter((g) => g && g.getRowsCount()), !e.length)
    return null;
  const n = /* @__PURE__ */ new Map();
  let s;
  for (let g = 0; g < e.length; g++)
    e[g].getSchema().forEach((u) => {
      u.name !== pt.ROW_ID && n.set(u.name, u);
    });
  const A = [];
  for (let g = 0; g < e.length; g++) {
    const h = e[g];
    s = { ...h._model._config };
    const d = h.getRowsCount();
    for (let u = 0; u < d; u++) {
      let f = [];
      n.forEach((C, I) => {
        const E = h.getValueAtIndex(I, u);
        f.push(E);
      }), A.push(f);
    }
  }
  const o = A.length ? Ye(A) : [[]], a = [...n.values()], r = [], l = [];
  if (o.forEach((g, h) => {
    g.every((u) => u === null) || (r.push(a[h]), l.push(g));
  }), t && l.length) {
    const g = l[0].length;
    for (let h in t.data)
      r.find((d) => d.name === h) || (l.push(
        new Array(g).fill().map(() => t.data[h])
      ), r.push(t.schema.find(({ name: d }) => d === h)));
  }
  const c = new K(
    {
      data: l.length ? l : [[]],
      schema: r
    },
    s
  );
  return c.model._alias = i, c;
}, y5 = (e, t) => e.size === t.size && [...e].every((i) => t.has(i)), qQ = (e) => {
  const t = /* @__PURE__ */ new Set();
  return e.forEach((i) => {
    i.forEach((n) => {
      t.add(n);
    });
  }), t;
}, jQ = (e, t) => e.reduce((i, n) => i + t(n), 0);
class cb {
  constructor({ data: t, uids: i, length: n }) {
    this._uids = i, this._model = t, this._length = n;
  }
  get uids() {
    return typeof this._uids == "function" && (this._uids = this._uids()), this._uids;
  }
  get model() {
    if (typeof this._model == "function") {
      const t = this._model();
      return this._model = t, this._model;
    }
    return this._model;
  }
  get length() {
    return this._length;
  }
  get aggFns() {
    return hc(this._model);
  }
  dispose() {
    this._model && !(this._model instanceof Function) && this._model.dispose(!1);
  }
  intersect(t) {
    return {
      uids: BE(t.uids, this.uids)
    };
  }
  difference(t) {
    return {
      uids: qd(t.uids, this.uids)
    };
  }
}
class pB {
  constructor({ entrySet: t, exitSet: i, completeSet: n, context: s }, A = {}) {
    this._context = s, this._id = Zt(), this._name = A.name, this._sets = {
      entrySet: this.createAtomicSet({
        uids: t.uids instanceof Function ? t.uids : new Set(t.uids),
        model: t.data,
        length: t.uids.size
      }),
      exitSet: this.createAtomicSet({
        uids: i.uids instanceof Function ? i.uids : new Set(i.uids),
        model: i.data,
        length: i.uids.size
      }),
      completeSet: this.createAtomicSet({
        uids: n.uids,
        model: n.data,
        length: n.uids.size
      })
    };
  }
  createAtomicSet({ uids: t, model: i, length: n }) {
    return new cb({
      uids: t,
      data: i,
      length: n
    });
  }
  get entrySet() {
    return this._sets.entrySet;
  }
  get exitSet() {
    return this._sets.exitSet;
  }
  get completeSet() {
    return this._sets.completeSet;
  }
  dispose() {
    this._disposed = !0, this._sets.entrySet.dispose(), this._sets.exitSet.dispose(), this._sets = null;
  }
  filter(t) {
    const [i, n] = this.entrySet.model.select(t, {
      mode: "all"
    }), s = i.getUids(), A = /* @__PURE__ */ new Set([n.getUids(), ...this.entrySet.uids]), o = new Qu({
      keys: this.completeSet.uids,
      entrySet: new Set(s),
      exitSet: new Set(A)
    }), a = (r, l, c) => () => {
      const g = c.data();
      return r === "complete" ? g : r === "entrySet" ? i : g.select(t, {
        mode: "all"
      })[1];
    };
    return new pB({
      entrySet: {
        uids: o.getEntrySet(),
        data: () => a("entrySet", o.getEntrySet(), this._context)
      },
      exitSet: {
        uids: o.getExitSet(),
        data: () => a("exitSet", o.getExitSet(), this._context)
      },
      completeSet: {
        uids: o.getCompleteSet(),
        data: this._context.data()
      },
      context: this._context
    });
  }
}
class gb {
  constructor(t, { extraData: i, name: n }) {
    this._entryExitSets = t, this._entrySet = null, this._exitSet = null, this._extraData = i, this._name = n, this._id = Zt();
  }
  composeSet(t) {
    const i = this._entryExitSets.map((a) => a[t].uids), n = i.length === 2 ? y5(i[0], i[1]) : !1, s = qQ(i), A = jQ(
      this._entryExitSets.map((a) => a[t]),
      (a) => a.length
    ), o = WQ(
      this._entryExitSets.map((a) => a[t].model),
      this._extraData
    );
    return o && (o.model._alias = this._alias), new cb({
      uids: s,
      data: s.size && n && Array.isArray(this._entryExitSets) ? this._entryExitSets.find((a) => a[t].model)[t].model : WQ(
        this._entryExitSets.map((a) => a[t].model),
        this._extraData,
        this._alias
      ),
      length: A
    });
  }
  get entrySet() {
    return this._entrySet || (this._entrySet = this.composeSet("entrySet", this._extraData)), this._entrySet;
  }
  get exitSet() {
    return this._exitSet || (this._exitSet = this.composeSet("exitSet", this._extraData)), this._exitSet;
  }
  get completeSet() {
    const t = "completeSet";
    return this._completeSet || (this._completeSet = {
      uids: qQ(this._entryExitSets.map((n) => n[t].uids)),
      length: jQ(
        this._entryExitSets.map((n) => n[t]),
        (n) => n.length
      )
    }), this._completeSet;
  }
  dispose() {
    this._disposed = !0, this._entrySet && this._entrySet.model && this._entrySet.model.dispose(!1), this._exitSet && this._exitSet.model && this._exitSet.model.dispose(!1), this._entryExitSets.length = 0, this._entrySet = null, this._exitSet = null;
  }
}
class sn {
  constructor(t, i) {
    this.formalName(wt(i, this.constructor.formalName())), this.context = t, this._selectionSet = null, this._applyChecker = {}, this._appendPropFields = !1, this._propagationIdentifiers = null, this._entryExitSet = null, this._prevEntryExitSet = null, this.propagate(!0), this._enabled = !0, this.setApplyChecker({
      source: () => !0
    });
  }
  shouldResetOtherActionsOnTrigger() {
    return !0;
  }
  isImplicit() {
    return !1;
  }
  static formalName() {
    throw new Error("Method not implemented");
  }
  formalName(...t) {
    return t.length ? (this._formalName = t[0], this) : this._formalName;
  }
  /**
   * Returns entry and exit set information. This method is called by firebolt when ```dispatchBehaviour``` is called
   * dynamically or when any physical action is triggered on the chart.
   *
   * @param {Object} payload Payload information.
   * @param {Object|Array} payload.criteria Identifiers of data interacted with.
   *
   * @return {Array} Entry and exit set information.
   */
  dispatch(t) {
    const i = t.criteria, n = this.context, s = this.getSelectionSet(), A = n.getPropagationInf(), { model: o, uids: a } = this.getAddSetFromCriteria(
      i,
      n.getPropagationInf(),
      t
    );
    this._payload = t, t.uids = a || [], this.setSelectionSet(a, s, {
      filteredDataModel: o,
      payload: t
    }), A.propagate !== !1 && this.propagationIdentifiers(s, t), s.resetted() && (this._propagationIdentifiers = null), this.entryExitSet(s, o, t);
  }
  getSelectionSet() {
    return this._selectionSet;
  }
  createSelectionSet(t) {
    return this._selectionSet = new Qu(t), this;
  }
  getAddSetFromCriteria(...t) {
    return this.context.getAddSetFromCriteria(...t);
  }
  /**
   * Updates the selection set by adding uids to the instance of {@link SelectionSet} or removing them.
   * {@link SelectionSet} keeps the information of which rows are in the entry set and exit set.
   *
   * @public
   * @param {Array} addSet Array of row ids which got affected during interaction.
   * @param {SelectionSet} selectionSet Instance of selection set.
   *
   * @return {GenericBehaviour} Instance of behaviour.
   */
  setSelectionSet() {
    return this;
  }
  entryExitSet(...t) {
    if (t.length) {
      const [i, n] = t, s = Z(
        this.context.getPropagationInf(),
        "propPayload",
        "sourceId"
      ), A = (l, c, g) => () => {
        const h = g.data();
        let d = null;
        if (l === "complete")
          return h;
        if (l === "entrySet" && s)
          [...c].length ? d = n ? n.replica() : null : d = n ? n.createEmptyDm() : null;
        else {
          const u = [...c];
          d = u.length ? h.select({
            field: pt.ROW_ID,
            value: u,
            operator: "in"
          }) : h.createEmptyDm(), d && h.removeChild(d);
        }
        return d;
      }, o = this.context, a = o.data(), r = Z(this._entryExitSet, "entrySet", "_model");
      return this._entryExitSet && ![n, a].includes(r) && this._entryExitSet.dispose(), this._entryExitSet = new pB(
        {
          entrySet: {
            uids: i.getEntrySet(),
            data: A("entrySet", i.getEntrySet(), o)
          },
          exitSet: {
            uids: i.getExitSet(),
            data: A("exitSet", i.getExitSet(), o)
          },
          completeSet: {
            uids: i.getCompleteSet(),
            data: o.data()
          },
          context: {
            data: () => this.context.data()
          }
        },
        {
          name: `visual-layer:${this._payload.action}`
        }
      ), this;
    }
    return this._entryExitSet;
  }
  propagationIdentifiers(...t) {
    if (t.length) {
      let i = null;
      const [n, s] = t, { criteria: A } = s, o = this._propagationFields;
      if (A === null || n.resetted())
        i = null;
      else if (A.range)
        i = {
          interpolated: !0,
          identifiers: A.range,
          fields: Object.keys(A.range)
        };
      else {
        let a = s.fields;
        o && (a = this._appendPropFields ? [...s.fields, ...o] : o);
        const r = [...n.getEntrySet()];
        i = {
          fields: a,
          identifiers: r
        };
      }
      return this._propagationIdentifiers = i, this;
    }
    return this._propagationIdentifiers;
  }
  static mutates() {
    return !1;
  }
  propagateWith(t, i) {
    return this._appendPropFields = !!i, this._propagationFields = t, this;
  }
  propagate(...t) {
    return t.length ? (this._propagate = t[0], this) : this._propagate;
  }
  runApplyChecker(t, i) {
    const n = this._applyChecker[t];
    return n(
      {
        ...i.sourceInfo,
        fields: i.fields
      },
      {
        canvasId: this.context.sourceCanvas(),
        unitId: this.context.sourceUnit ? this.context.sourceUnit() : null,
        layerId: this.context.id(),
        fields: this.context.data() ? this.context.data().getFieldNames() : null
      },
      i
    );
  }
  shouldApply(t) {
    let i = !0;
    const n = this._applyChecker;
    for (const s in n)
      i = i && this.runApplyChecker(s, t);
    return i && this._enabled;
  }
  setApplyChecker(t) {
    return Object.assign(this._applyChecker, t), this;
  }
  removeApplyChecker(t) {
    delete this._applyChecker[t];
  }
  getPayload() {
    return this._payload;
  }
  reset() {
    return this.getSelectionSet().reset(), this._propagationIdentifiers = null, this;
  }
  dispose() {
    this._selectionSet && this._selectionSet.reset();
    const t = this._entryExitSet;
    return t && (t.dispose(), this._entryExitSet = null), this;
  }
  getDiffSet(t, i) {
    return Cs(t, i);
  }
  disposeEntryExitSet() {
    this._entryExitSet && this._entryExitSet.dispose();
  }
  isReactionBehaviour(...t) {
    return t.length ? (this._isReactionBehaviour = t[0], this) : this._isReactionBehaviour;
  }
  generatePayloadFromPropagationInf({ propagationData: t, propPayload: i }) {
    let n;
    return t ? n = {
      criteria: {
        uids: t.getUids()
      }
    } : n = {
      criteria: null
    }, Object.assign({}, i, n);
  }
  enable() {
    this._enabled = !0;
  }
  disable() {
    this._enabled = !1;
  }
  getInteractedSet() {
    return this.entryExitSet().entrySet.uids;
  }
}
class Dc extends sn {
  setSelectionSet(t, i) {
    const n = i.getEntrySet();
    if (t === null)
      i.reset();
    else if (t.length) {
      let s = Cs(n, [t]);
      i.remove(s), i.add(t), s = Cs(
        [i.getCompleteSet()],
        [i.getEntrySet(), i.getExitSet()]
      ), i.remove(s);
    } else {
      const s = Cs(
        [i.getCompleteSet()],
        [i.getExitSet()]
      );
      i.remove(s);
    }
  }
}
const Pl = "brush", QB = "highlight", w5 = "filter", GI = "select", hb = "contextMenu";
let db = class extends Dc {
  constructor(...t) {
    super(...t), this.setApplyChecker({
      source: (i, n, s) => {
        const A = this._payload ? this._payload.criteria : null, o = this._payload ? this._payload.target : null, a = this._payload ? this._payload.metaData : null, r = this._payload && this._payload.metaData && s.metaData ? s.metaData.borderId === a.borderId : !0;
        return !(_l(A, s.criteria) && _l(o, s.target) && r);
      }
    });
  }
  static formalName() {
    return QB;
  }
  shouldResetOtherActionsOnTrigger() {
    return !1;
  }
};
function D5(e, t) {
  return class extends t {
    static formalName() {
      return e;
    }
  };
}
const ub = D5(Pl, Dc);
class x5 extends Dc {
  static formalName() {
    return w5;
  }
  static mutates() {
    return !0;
  }
  isImplicit() {
    return !0;
  }
}
class xc extends sn {
  setSelectionSet(t, i) {
    return t === null ? i.reset() : t.length ? (this.context.getPropagationInf().sourceId && i.reset(), i.add(t)) : i.remove(i.getCompleteSet()), this;
  }
}
let S5 = class extends xc {
  constructor(...t) {
    super(...t), this._applyChecker = {
      source: () => !0
    };
  }
  static formalName() {
    return GI;
  }
  setSelectionSet(t, i) {
    const n = this._payload;
    if (Z(n, "sourceInfo", "layerId") !== this.context.id() && t !== null && i.getEntrySetLength())
      return this.getTotalEntrySetLength() || (i.reset(), this.resetGlobalState()), this;
    if (t === null)
      i.reset(), this.resetGlobalState();
    else if (t.length) {
      const s = i.getEntrySet(), A = t.filter((a) => s.has(a));
      if (A.length)
        i.remove(A);
      else if (i.add(t), !i.getExitSetLength()) {
        const a = Cs(
          [i.getCompleteSet()],
          [i.getEntrySet(), i.getExitSet()]
        );
        i.remove(a);
      }
      this.updateGlobalState(), this.getTotalEntrySetLength() || (i.reset(), this.resetGlobalState());
    } else
      i.remove(i.getCompleteSet()), this.updateGlobalState(), this.getTotalEntrySetLength() || (i.reset(), this.resetGlobalState());
    return this;
  }
  resetGlobalState() {
    const t = this.context.store();
    t.commit("interactions.select.entrySet", null), t.commit("interactions.select.exitSet", null);
  }
  updateGlobalState() {
    const t = this.context.store(), i = this.getSelectionSet(), n = i.getEntrySetLength(), s = i.getExitSetLength(), A = this.context.getStateKey();
    t.commit("interactions.select.entrySet", (o) => ({ ...o, [A]: n })), t.commit("interactions.select.exitSet", (o) => ({ ...o, [A]: s }));
  }
  getTotalEntrySetLength() {
    const t = this.context.store().get("interactions.select.entrySet");
    return Object.values(t || {}).reduce((i, n) => i + n, 0);
  }
  getAddSetFromCriteria(t, i, n) {
    if (n.sourceInfo && n.sourceInfo.layerId && n.sourceInfo.layerId !== this.context.id()) {
      const s = this.entryExitSet();
      return s && s.entrySet.length ? {
        model: s.entrySet.model,
        uids: n.criteria === null ? null : [...s.entrySet.uids]
      } : {
        model: null,
        uids: n.criteria === null ? null : []
      };
    }
    return this.context.getAddSetFromCriteria(t, i, n);
  }
}, fb = class extends xc {
  static formalName() {
    return "inverse-select";
  }
  setSelectionSet(t, i) {
    if (t === null)
      i.reset();
    else if (t.length) {
      const n = this.context.getPropagationInf(), s = i._exitSet, A = t.filter((o) => s.has(o));
      if (n.sourceId)
        i.reset(), i.add(t);
      else {
        if (A.length)
          i.add(A);
        else if (i.remove(t), !i.getEntrySetLength()) {
          const a = Cs(
            [i.getCompleteSet()],
            [i.getEntrySet(), i.getExitSet()]
          );
          i.add(a);
        }
        const o = i.getCompleteSetLength();
        (i.getExitSetLength() === o || i.getEntrySetLength() === o) && i.reset();
      }
    } else
      i.remove(i.getCompleteSet());
    return this;
  }
  getInteractedSet() {
    const t = this.entryExitSet().exitSet.uids;
    return t.size ? t : null;
  }
}, _5 = class extends Dc {
  static formalName() {
    return hb;
  }
  static mutates() {
    return !1;
  }
  isImplicit() {
    return !0;
  }
};
const yB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BrushBehaviour: ub,
  ContextMenuBehaviour: _5,
  FilterBehaviour: x5,
  HighlightBehaviour: db,
  InverseSelectBehaviour: fb,
  SelectBehaviour: S5
}, Symbol.toStringTag, { value: "Module" })), Ib = (e, t, i, n) => {
  let s = {}, A = {}, o;
  const a = hr();
  let r;
  e.call(
    a().on("start", () => {
      const l = bt();
      s = {
        x: l.x,
        y: l.y
      }, i.context.isCanvasDisposed() !== !0 && (o = i.context.getDrawingContext(), r = (/* @__PURE__ */ new Date()).getTime());
    }).on("drag", () => {
      const l = bt();
      if (A = {
        x: l.x,
        y: l.y
      }, n && Math.abs(s.x - A.x) <= 5)
        return;
      A.x = Math.max(0, Math.min(A.x, o.width)), A.y = Math.max(0, Math.min(A.y, o.height));
      const c = Object.assign({}, s), g = Object.assign({}, A);
      if (s.x > A.x && (c.x = A.x, g.x = s.x), s.y > A.y) {
        const d = s.y;
        c.y = A.y, g.y = d;
      }
      if (i.context.isCanvasDisposed() === !0)
        return;
      const h = i.getPayloadFromEvent(
        "drag",
        {
          startPos: c,
          endPos: g
        },
        {
          event: l,
          isDragging: !0
        }
      );
      i.triggerPhysicalAction(t, h);
    }).on("end", () => {
      if (i.context.isCanvasDisposed() === !0)
        return;
      const l = bt();
      A = {
        x: l.x,
        y: l.y
      };
      const c = (/* @__PURE__ */ new Date()).getTime() - r;
      if (n && c > 100 && Math.abs(s.x - A.x) <= 5)
        return;
      if (A.x = Math.max(0, Math.min(A.x, o.width)), A.y = Math.max(0, Math.min(A.y, o.height)), s.x > A.x) {
        const h = s.x;
        s.x = A.x, A.x = h;
      }
      if (s.y > A.y) {
        const h = s.y;
        s.y = A.y, A.y = h;
      }
      const g = i.getPayloadFromEvent(
        "drag",
        {
          startPos: s,
          endPos: A
        },
        {
          event: l,
          dragEnd: !0
        }
      );
      g.target && g.dragDiff === 0 || i.triggerPhysicalAction(t, g);
    })
  );
}, b5 = (e) => (t) => {
  Ib(t, BB, e);
}, M5 = (e) => (t) => {
  const i = function(n) {
    const s = bt(), A = e.context, o = io(A.getDrawingContext().svgContainer, s), a = e.getPayloadFromEvent(ba, o, {
      data: n,
      event: s
    });
    e.triggerPhysicalAction(ba, a);
  };
  t.on("mouseover", i).on("mousemove", i).on("mouseout", () => {
    e.triggerPhysicalAction(ba, {
      criteria: null
    });
  });
}, Cb = function(e, t, i, n) {
  const s = i.context, A = io(s.getDrawingContext().svgContainer, t.touches ? t.touches[0] : t);
  return i.getPayloadFromEvent(n, A, {
    data: e,
    event: t
  });
}, N5 = (e) => (t) => {
  let i, n;
  const s = function(A) {
    const o = Cb(
      A,
      i,
      e,
      dl
    );
    e.triggerPhysicalAction(dl, o);
  };
  n = !1, i = bt(), t.on("touchstart", (A) => {
    i = bt(), n = !1, setTimeout(() => {
      n ? e.triggerPhysicalAction(dl, {
        criteria: null
      }) : s(A);
    }, 100);
  }).on("touchend", () => {
    n = !0;
  });
}, F5 = (e) => (t, i) => {
  Ib(t, i, e, !0);
}, Eb = (e) => (t) => {
  let i, n;
  const s = e.context, A = (a) => {
    e.triggerPhysicalAction(hl, a);
  }, o = hr();
  t.call(
    o().on("start", () => {
      const a = bt();
      n = s.getDrawingContext(), i = a.subject;
    }).on("drag", () => {
      const a = bt();
      i.x += a.dx, i.y += a.dy;
      const r = n.width, l = n.height, c = Math.min(r - i.width, Math.max(i.x, 0)), g = Math.min(l - i.height, Math.max(i.y, 0)), h = g + i.height, d = c + i.width;
      if (c >= 0 && d <= r && g >= 0 && h <= l) {
        const u = e.getPayloadFromEvent(
          hl,
          {
            startPos: {
              x: c,
              y: g
            },
            endPos: {
              x: d,
              y: h
            }
          },
          {
            event: a,
            isDragging: !0
          }
        );
        A(u);
      }
    }).on("end", () => {
      const a = n.width, r = n.height, l = Math.min(a - i.width, Math.max(i.x, 0)), c = Math.min(r - i.height, Math.max(i.y, 0)), g = c + i.height, h = l + i.width;
      if (l >= 0 && h <= a && c >= 0 && g <= r) {
        const d = e.getPayloadFromEvent(
          hl,
          {
            startPos: {
              x: l,
              y: c
            },
            endPos: {
              x: h,
              y: g
            }
          },
          {
            event,
            dragEnd: !0
          }
        );
        A(d);
      }
    })
  );
}, R5 = (e) => (t) => {
  const i = function(n) {
    const s = bt();
    if (s.metaKey)
      return;
    s.preventDefault();
    const A = Cb(
      n,
      s,
      e,
      Ol
    );
    A.uniquePropagationId = Zt(), e.triggerPhysicalAction(Ol, A);
  };
  t.on("click", i);
}, k5 = (e) => (t) => {
  t.on("contextmenu", function(i) {
    const n = e.context, A = n._canvasHelpers.getCanvasConfig()?.interaction?.contextMenu;
    if (!A || !A.enabled)
      return;
    const a = A.hook;
    if (!a)
      return;
    const r = bt();
    r.preventDefault();
    const l = io(
      n.getDrawingContext().svgContainer,
      r
    ), c = e.getPayloadFromEvent(
      qh,
      l,
      {
        data: i,
        event: r
      }
    );
    e.triggerPhysicalAction(qh, c);
    const { targetData: g, metaInfo: h } = c, d = h?.colFacets || [], u = h?.rowFacets || [];
    a({ type: "geom", event: r, colFacets: d, rowFacets: u, targetPoint: g || null });
  });
}, Bb = {
  [BB]: b5,
  [ba]: M5,
  [Ol]: R5,
  [dl]: N5,
  [lb]: F5,
  [hl]: Eb,
  [qh]: k5
}, v5 = "tooltip", T5 = "crossline", G5 = "fragmented-tooltip", wB = "axis-label-highlighter", L5 = "show-context-menu", U5 = {
  valueParser: {
    defaultValue: (e) => e
  }
};
class yu {
  constructor(t) {
    this.firebolt = t, this._strategy = "default", this._config = {}, this._id = Zt(), this._strategies = {}, this._enabled = !0, ve(this, U5), this.config(this.constructor.defaultConfig()), this._applyChecker = {}, this.setApplyChecker({
      source: () => !0
    });
  }
  /**
   * Returns the default configuration of the side effect.
   *
   * @public
   * @return {Object} Default configuration of side effect.
   */
  static defaultConfig() {
    return {};
  }
  /**
   * Returns the formal name of a side effect. This method must be implemented by all side effects which changes
   * or adds any element in the visualization.
   *
   * @return {string} Formal name of side effect.
   */
  static formalName() {
    return "generic";
  }
  static target() {
    return "all";
  }
  /**
   * Returns true if the side effects mutates the data of chart.
   *
   * @public
   *
   * @return {boolean} If the side effect mutates the data of chart.
   */
  static mutates() {
    return !1;
  }
  /**
   * Sets or gets the configuration of side effect.
   *
   * When setter,
   * @param {Object} config Configuration of side effect.
   * @return {GenericSideEffect} Side effect instance.
   *
   * When getter,
   * @return {Object} Side effect configuration.
   */
  config(...t) {
    return t.length ? (this._config = et(this._config, t[0]), this) : this._config;
  }
  /**
   * Applies the interaction effect on the chart. This is where the implemntation of the side effect is defined.
   *
   * @param {Object} selectionSet Contains the entry and exit set of data which got affected during interaction.
   * @param {Object} selectionSet.mergedEnter Combined previous entry and new entry set.
   * @param {DataModel} selectionSet.mergedEnter.model Instance of data model containing all rows which got
   * affected during interaction.
   * @param {Array} selectionSet.mergedEnter.uids Ids of all rows which were affected during interaction.
   * @param {Object} selectionSet.mergedExit Combined previous exit and new exit set.
   * @param {DataModel} selectionSet.mergedExit.model Instance of data model containing rows which were not affected
   * during interaction.
   * @param {Array} selectionSet.mergedExit.uids Ids of all rows which were not affected during interaction.
   * @param {Object} selectionSet.entrySet Entry set information.
   * @param {Array} selectionSet.entrySet[0].uids All row ids which got affected during previous interaction.
   * @param {Array} selectionSet.entrySet[1].uids All row ids which got affected during current interaction.
   * @param {Array} selectionSet.exitSet[0].uids All row ids which were not affected during previous interaction.
   * @param {Array} selectionSet.exitSet[1].uids All row ids which were not affected during current interaction.
   * @param {Object} payload Payload information of the behavioural action on trigger of which this side effect
   * is applied.
   * @param {Object} options Optional information for side effect like strategy, etc.
   */
  apply() {
    return this;
  }
  /**
   * Adds a new strategy method for this side effect. The strategy method is implemented by side effect class.
   *
   * @param {string} name Name of the strategy.
   * @param {Function} fn Strategy method.
   *
   * @return {GenericSideEffect} Instance of side effect.
   */
  setStrategy(t, i) {
    return i && (this._strategies[t] = i), this;
  }
  enable() {
    this._enabled = !0;
  }
  disable() {
    this._enabled = !1;
  }
  sourceInfo() {
    return this.firebolt.getSourceInfo();
  }
  layers() {
    return this.firebolt.layers();
  }
  plotPointsFromIdentifiers(...t) {
    return this.firebolt.getPlotPointsFromIdentifiers(...t);
  }
  shouldApply(t) {
    let i = !0;
    const n = this._applyChecker;
    for (const s in n) {
      const A = n[s];
      i = i && A(
        {
          ...t.sourceInfo,
          fields: t.fields
        },
        {
          canvasId: this.firebolt.sourceCanvas(),
          unitId: this.firebolt.id(),
          layerId: this.firebolt.id(),
          fields: this.firebolt.data() ? this.firebolt.data().getFieldNames() : null
        },
        t
      );
    }
    return i && this._enabled;
  }
  setApplyChecker(t) {
    return Object.assign(this._applyChecker, t), this;
  }
  removeApplyChecker(t) {
    delete this._applyChecker[t];
  }
  setLayerData(t, i) {
    const s = this.layers().find((A) => A.alias() === i);
    return t ? (s && s.enableCaching().data(t), this) : (this.resetLayerData(i), this);
  }
  resetLayerData(t) {
    const n = this.layers().find((s) => s.alias() === t);
    n && n.resetData();
  }
  setTransform() {
    return null;
  }
  shouldApplyOnRenderAfterScrolling() {
    return !0;
  }
  dispose() {
    return this;
  }
}
class pe extends yu {
  /**
   * Applies or removes interaction styles from plot elements. An array of row ids needs to be passed
   * which identifies the plot elements and applies styles to them.
   *
   * To apply the interaction style,
   * ```
   *      const entryRowIds = entrySet[0].uids;
   *      const interactionStyle = [{
   *          type: 'fill',
   *          intensity: [0, 0, 15, 0] // hsla configuration
   *      }];
   *
   *      this.applyInteractionStyle(entryRowIds, interactionStyle, 'brighten', true);
   * ```
   * @public
   * @param {Array} set Array of row ids.
   * @param {Array} config Style configuration.
   * @param {Object} config[0] fill or stroke configuration.
   * @param {string} config[0].type Type of style - fill or stroke.
   * @param {Array} config[0].intensity hsla configuration.
   * @param {string} interactionType Type of interaction. This is needed for storing the styles for
   * each type of interaction in the plot elements.
   * @param {boolean} apply Whether to apply or remove the interaction style.
   *
   * @return {SurrogateSideEffect} Instance of surrogate side effect.
   */
  applyInteractionStyle(t, i = {}) {
    const n = this.firebolt.context;
    return n.config().interactive !== !1 && n.applyInteractionStyle(i, t.uids), this;
  }
}
class Ir extends yu {
  /**
   * Creates a html or svg element in the container.
   *
   * @public
   * @param {SVGElement|HTMLElement} container Container where the dom element will be rendered.
   * @param {string} elemType Type of dom element.
   * @param {Array} data Array of objects with which the dom elements will be binded.
   * @param {string} className class name of the element.
   *
   * @return {Selection} D3 Selection of the element.
   */
  createElement(t, i, n, s, A) {
    return z(t, i, n, s, A);
  }
  /**
   * Returns the drawing information for side effect like svg container, dimensions of the visual unit.
   *
   * @public
   * @return {Object} Drawing information for side effect.
   * ```
   *      sideEffectGroup: // svg container where the side effect needs to be appended.
   *      svgContainer: // svg container of the {@link VisualUnit}.
   *      htmlContainer: // html div container of the {@link VisualUnit}.
   *      width: // Width of the {@link VisualUnit}
   *      height: // Height of the {@link VisualUnit}
   * ```
   */
  drawingContext() {
    return this.firebolt.getDrawingContext();
  }
  show() {
    return this;
  }
  hide() {
    return this;
  }
  static target() {
    return ["visual-group", "visual-unit"];
  }
}
const Pg = "muze", H5 = "binned", mb = "stack", pb = "group", oe = 5, O5 = { width: "95%" }, P5 = { width: "95%" }, zQ = {
  overflow: "hidden",
  "white-space": "nowrap",
  "text-overflow": "ellipsis"
}, Y5 = (e, t, i) => {
  let n, s, A, o;
  const a = e.criteria, r = e.dimensions || {}, { x: l, y: c } = r;
  if (!a) return null;
  if (t.x && t.y) {
    let g, h;
    const d = `${i.x[0]}`, u = `${i.y[0]}`, f = a.range, C = t.x[0], I = t.y[0], E = C.constructor.type() === "linear", B = I.constructor.type() === "linear", m = C.constructor.type() === "band", p = C.constructor.type() === "band", w = a.dimensions;
    if (w) {
      let Q = w[0].findIndex((y) => y === d);
      Q !== -1 && (g = w.slice(1, w.length).map((y) => y[Q])), Q = w[0].findIndex((y) => y === u), Q !== -1 && (h = w.slice(1, w.length).map((y) => y[Q]));
    } else
      g = f[d], h = f[u];
    if (g && g.length) {
      const Q = C.domain();
      let y = g[0], D = g[g.length - 1];
      if (m) {
        let _ = Q.indexOf(g[0]), x = Q.indexOf(g[g.length - 1]);
        [_, x] = [_, x].sort((S, b) => S - b), y = Q[_], D = Q[x];
      }
      n = C.getScaleValue(y), s = C.getScaleValue(D), s += m ? C.getUnitWidth() : 0;
    }
    if (h && h.length) {
      const Q = I.domain();
      let y = h[0], D = h[h.length - 1];
      if (p) {
        let _ = Q.indexOf(h[0]), x = Q.indexOf(h[h.length - 1]);
        [_, x] = [_, x].sort((S, b) => b - S), y = Q[_], D = Q[x];
      }
      A = I.getScaleValue(y), o = I.getScaleValue(D), o += p ? I.getUnitWidth() : 0;
    }
    (B && E || !e.dragEnd) && (l && ([n, s] = l), c && ([A, o] = c));
  }
  return {
    dimension: {
      x1: n,
      x2: s,
      y1: A,
      y2: o
    }
  };
}, $Q = (e, t, i) => {
  const n = e.config(), s = n.defClassName, A = n.classPrefix;
  X(t).selectAll(`.${A}-${s}`).style("display", i ? "block" : "none");
};
let J5 = class extends Ir {
  constructor(...t) {
    super(...t), this.setApplyChecker(() => !0);
  }
  /**
   * It returns the default configuration needed by selectionbox.
   * @return {Object} Default configuration of the selection box.
   */
  static defaultConfig() {
    return {
      defClassName: "selection-box-group",
      className: "",
      classPrefix: Pg,
      box: {
        defClassName: "selection-box",
        className: ""
      },
      transition: {
        duration: 200
      },
      brush: "xy",
      persistent: !1
    };
  }
  static formalName() {
    return "selectionBox";
  }
  static target() {
    return "visual-unit";
  }
  /**
   * Draws the selectionbox with the specified dimensions.
   * @param {Object} dimension Dimensions of the selection box.
   * @param {number} dimension.x1 Starting x position
   * @param {number} dimension.x2 Ending x position
   * @param {number} dimension.y1 Starting y position
   * @param {number} dimension.y2 Ending y position
   * @param {Object} conf Configuration needed to draw the selection box
   * @param {number} unitWidth Width of the visual unit.
   * @param {number} unitHeight Height of the visual unit.
   */
  apply(t, i) {
    let n = 0, s = 0, A, o;
    const a = this._config, r = a.box, l = this.firebolt, c = this.drawingContext(), g = c.sideEffectGroup, h = c.width, d = c.height, u = a.classPrefix, f = a.defClassName, C = a.brush, I = i.criteria;
    if (A = h, o = d, !Z(I, "range") && !Z(I, "dimensions") || i.hideSelBox && !a.persistent || i.dragEnd)
      return this.hide(c), this;
    const E = this.sourceInfo(), { dimension: B } = Y5(
      i,
      E.axes,
      E.fields
    ), m = i.dragEnd && a.transition;
    C === "xy" ? (n = Math.min(B.x1, B.x2), s = Math.min(B.y1, B.y2), A = Math.abs(B.x2 - B.x1), o = Math.abs(B.y2 - B.y1)) : C === "x" ? (n = Math.min(B.x1, B.x2), s = 0, A = Math.abs(B.x2 - B.x1), o = d) : (n = 0, s = Math.min(B.y1, B.y2), A = h, o = Math.abs(B.y2 - B.y1)), this.show(c);
    const p = [
      {
        x: n,
        y: s,
        width: A,
        height: o
      }
    ], w = z(
      X(g),
      "g",
      [1],
      `.${u}-${f}`
    ), Q = this, y = w.selectAll("rect").data(p), D = y.enter().append("rect").each(function() {
      l.registerPhysicalBehaviouralMap({
        [hl]: {
          target: [X(this)],
          behaviours: [Pl]
        }
      }), Eb(l)(X(this), ["brush"], Q);
    }).merge(y).each(function(x) {
      let S = X(this);
      m && (S = S.transition().duration(m.duration));
      for (const b in x)
        ({}).hasOwnProperty.call(x, b) && yx(x[b]) && S.attr(b, x[b]);
    }), _ = ms(
      r.defClassName,
      this._id,
      u
    );
    return D.classed(_.join(" "), !0), D.classed(r.className, !0), this;
  }
  hide(t) {
    $Q(this, t.sideEffectGroup, !1);
  }
  show(t) {
    $Q(this, t.sideEffectGroup, !0);
  }
};
const K5 = "muze", V5 = "left", W5 = "right", q5 = "bottom", j5 = "top", XQ = "table", ZQ = {
  margin: "2px 0px"
}, LI = {
  classPrefix: K5,
  defClassName: "tooltip-box",
  parentClassName: "tooltip-parent-container",
  connectorClassName: "tooltip-connectors",
  pointerArrow: "tooltip-arrow-box",
  className: "",
  row: {
    margin: 0
  },
  spacing: 5,
  content: {
    spacing: 5,
    iconContainerSize: 10,
    iconScale: 1,
    iconShape: "circle",
    iconColor: "#ff0000",
    rowMargin: "4px 0 4px 0",
    // rowPadding: "6px 0px",
    // firstRowPadding: "0px 0px 6px 0px",
    // firstRowMargin: "4px 0px 0px 0px",
    // lastRowPadding: "6px 0px 6px 0px",
    // lastRowMargin: "0px 0px 4px 0px",
    margin: 5,
    separator: ":",
    className: "tooltip-content-container",
    parentClassName: "tooltip-content-parent-container"
  },
  arrow: {
    size: 10,
    disabled: !1,
    defClassName: "tooltip-arrow",
    className: "",
    color: "rgba(195,195,195,0.85)"
  }
}, z5 = (e, t) => {
  e.selectAll(t).sort((i, n) => i - n);
}, $5 = (e = { entryExitSetsByLayerId: {} }) => (e.layers || []).map((t) => {
  const { entryExitSetsByLayerId: i } = e;
  if (i) {
    const n = i[t.id()], s = t.getAllEncodingFields();
    if (Object.keys(i).length && n)
      return n.entrySet.model.project(s);
  }
  return null;
}).filter((t) => !!t);
let X5 = class {
  /**
   * Creates an instance of content.
   */
  constructor() {
    this._model = null, this._secondaryModels = [], this._formatter = null, this._config = this.constructor.defaultConfig();
  }
  /**
   * Returns the default configuration of tooltip
   * @return {Object} Configuration of tooltip.
   */
  static defaultConfig() {
    const t = LI.content;
    return t.classPrefix = LI.classPrefix, t;
  }
  config(...t) {
    return t.length > 0 ? (this._config = et(this._config, t[0]), this) : this._config;
  }
  /**
   * Update model. The format contains presentation strategy which determines how to show the content.
   * If no strategy is mentioned then default is to show key value pair
   */
  update(t) {
    return this._model = t.model, this._formatter = t.formatter, this._secondaryModels = t.secondaryModels, this;
  }
  context(t) {
    return this._context = t, this;
  }
  hide() {
    this._mount && this._mount.style("visiblity", "hidden");
  }
  render(t) {
    let i;
    const n = this._config, s = t.container(), A = this._formatter, o = this._model, { classPrefix: a } = n;
    o instanceof Array ? i = o : i = A(
      { dataModel: this._model, secondaryDatamodels: this._secondaryModels },
      {
        context: this._context,
        metaInfo: this.config(),
        tooltipInst: t
      }
    );
    const { rowMargin: r } = n, l = { margin: r };
    if (i instanceof Function)
      z(
        s,
        "div",
        [1],
        `${a}-tooltip-html-container`
      ).html(i());
    else {
      let c = i, g = "default";
      ke(i) && (c = i.content, g = i.displayFormat);
      let h = t.getBody();
      if (g === XQ) {
        const d = z(
          h,
          "table",
          [1],
          `${a}-tooltip-table`
        ), u = z(
          d,
          "tbody",
          [1],
          `${a}-tooltip-table-tbody`
        ), f = z(
          u,
          "tr",
          c,
          `${a}-tooltip-table-row`
        );
        f.each(function(I, E) {
          X(this).classed(
            `${a}-tooltip-table-row-${E}`,
            !0
          );
        }), z(
          f,
          "td",
          (I) => I,
          `${a}-tooltip-table-cell`
        ).each(function(I) {
          X(this).html(I);
        });
      } else {
        const d = (u, f, C) => {
          u[1].html(f), u[2].html(C);
        };
        if (c.length === 1) {
          let u = z(
            s,
            "div",
            [g],
            `${a}-tooltip-content`,
            {},
            (I) => I
          );
          const f = z(u, "div", c[0].data, "", {
            update: (I, E) => {
              I.attr("class", E.className), vt(this, l);
            }
          }), C = z(
            f,
            "span",
            (I) => I.data,
            `${a}-tooltip-content`
          );
          C.attr("class", `${a}-tooltip-content`), vt(C, {
            display: "inline-block"
          }), C.each(function(I) {
            const E = X(this);
            I instanceof Object ? (E.node().textContent = I.value, I.className && E.classed(I.className, !0), vt(E, I.style)) : E.node().textContent = I;
          });
        } else {
          c = i instanceof Array ? i : i.content;
          const u = t.getBody();
          let f = t.getFacetsData(), C = t.getHeader(), I = t.getTotalValue();
          vt(I[0], { display: "none" });
          let E = 0;
          if (c[E].className.includes("facets-data")) {
            const y = z(
              f,
              "div",
              c[E].data,
              `${a}-tooltip-row-content`,
              {
                update: (_, x) => {
                  _.attr("class", x.className), vt(_, {
                    ...x.style
                  });
                }
              }
            ), D = z(
              y,
              "div",
              (_) => _.data,
              `${a}-tooltip-cell-content`,
              {
                update: (_, x) => {
                  _.attr("class", x.className), _.node().textContent = x.value, vt(_, {
                    ...x.style
                  });
                }
              },
              (_) => _.value
            );
            z(
              D,
              "span",
              (_) => _.data ? _.data : [],
              `${a}-tooltip-value-content`,
              {
                update: (_, x) => {
                  _.attr("class", x.className), _.node().textContent = x.value, vt(_, { ...x.style });
                }
              },
              (_) => _.value
            ), E += 1;
          }
          c[E].className.includes("row-content") && (d(
            C,
            c[E]?.data[0]?.value,
            c[E]?.data[1]?.data[0]?.value
          ), vt(C[0], {
            ...c[E]?.data[0]?.style
          }), E += 1);
          let B = c.slice(E);
          c[E].className.includes("total-value-content") && (d(
            I,
            c[E]?.data[0]?.value,
            c[E]?.data[1]?.data[0]?.value
          ), vt(I[0], {
            ...c[E]?.data[0]?.style,
            display: "grid"
          }), E += 1, B = c.slice(E));
          const m = B[0].className, p = z(
            u,
            "div",
            B,
            m,
            {
              update: (y, D) => {
                vt(
                  y,
                  D.color ? {
                    "border-left": `4px solid ${D.color}`,
                    ...ZQ
                  } : {
                    "border-left": "0px solid white",
                    ...ZQ
                  }
                ), D.className.includes("total-value") && vt(y, {
                  ...D.style
                });
              }
            }
          ), w = z(
            p,
            "div",
            (y) => y.data,
            `${a}-tooltip-row-content`,
            {
              update: (y, D) => {
                y.attr("class", D?.className), vt(y, {
                  ...D?.style
                });
              }
            }
          ), Q = z(
            w,
            "div",
            (y) => y?.data,
            `${a}-tooltip-cell-content`,
            {
              update: (y, D) => {
                y.attr("class", D?.className), y.node().textContent = D?.value, vt(y, { ...D?.style });
              }
            },
            (y) => y?.value
          );
          z(
            Q,
            "span",
            (y) => y.data ? y.data : [],
            `${a}-tooltip-value-content`,
            {
              update: (y, D) => {
                y.attr("class", D.className), y.node().textContent = D.value, vt(y, { ...D.style });
              }
            },
            (y) => y.value
          );
        }
      }
    }
  }
  renderSelectionSummary(t) {
    let i;
    const n = this._config, s = n.iconContainerSize, A = this._formatter, {
      rowMargin: o,
      rowPadding: a,
      firstRowPadding: r,
      firstRowMargin: l,
      lastRowPadding: c,
      lastRowMargin: g
    } = n, h = this._model, { classPrefix: d } = n;
    if (this._mount = t, h instanceof Array ? i = h : i = A(
      { dataModel: this._model, secondaryDatamodels: this._secondaryModels },
      { context: this._context, metaInfo: this.config() }
    ), i instanceof Function)
      z(
        t,
        "div",
        [1],
        `${d}-tooltip-html-container`
      ).html(i());
    else {
      let u = i, f = "default";
      ke(i) && (u = i.content, f = i.displayFormat);
      const C = z(
        t,
        "div",
        [f],
        `${d}-tooltip-content`,
        {},
        (I) => I
      );
      if (f === XQ) {
        const I = z(
          C,
          "table",
          [1],
          `${d}-tooltip-table`
        ), E = z(
          I,
          "tbody",
          [1],
          `${d}-tooltip-table-tbody`
        ), B = z(
          E,
          "tr",
          u,
          `${d}-tooltip-table-row`
        );
        B.each(function(p, w) {
          X(this).classed(
            `${d}-tooltip-table-row-${w}`,
            !0
          );
        }), z(
          B,
          "td",
          (p) => p,
          `${d}-tooltip-table-cell`
        ).each(function(p) {
          X(this).html(p);
        });
      } else {
        const I = z(C, "div", u, "", {
          update: (p, w) => p.attr("class", w.className)
        }), E = z(
          I,
          "span",
          (p) => p.data,
          `${d}-tooltip-content`
        );
        E.attr("class", `${d}-tooltip-content`);
        const B = I.size() - 1, m = { margin: o };
        if (!a)
          vt(I, m);
        else {
          const p = {
            padding: r,
            margin: l
          }, w = {
            padding: c,
            margin: g
          }, Q = {
            padding: a
          };
          I.each(function(y, D) {
            y.className === `${d}-tooltip-stacked-row` ? vt(this, m) : D === 0 ? vt(
              this,
              D === B ? m : p
            ) : D === B ? vt(this, w) : vt(this, Q);
          });
        }
        vt(E, {
          display: "inline-block"
          // 'margin-right': `${config.spacing}px`
        }), E.each(function(p) {
          const w = X(this);
          if (p instanceof Object)
            if (p.type === "icon") {
              const Q = z(w, "svg", [1]), y = z(Q, "path", [1]), D = p.shape instanceof Function ? p.shape : cc(p.shape);
              hA(Q, {
                x: 0,
                y: 0,
                width: s,
                height: s
              }), hA(y, {
                d: D.size(p.size * p.size * Math.PI)(),
                transform: `translate(${s / 2}, ${s / 2})`
              }), vt(y, {
                fill: p.color
              }), vt(Q, {
                width: `${s}px`,
                height: `${s}px`
              });
            } else
              w.node().textContent = p.value, p.className && w.classed(p.className, !0), vt(w, p.style);
          else
            w.node().textContent = p;
        });
      }
    }
    return this;
  }
  clear() {
    return this._model = null, this;
  }
  remove() {
    this._mount && this._mount.remove();
  }
}, nr = class {
  /**
   * Initializes the tooltip with the container element and configuration
   * @param {HTMLElement} container container where the tooltip will be mounted.
   * @param {string} className Class name for the tooltip.
   * @param {object}  options consist different configuration options for tooltip
   */
  constructor(t, { creatorName: i = "content-tooltip" } = {}, n = {}) {
    this._id = Zt(), this._config = {}, this.config({});
    const s = this._config, A = s.classPrefix, o = s.content.parentClassName, { showPointerArrow: a } = n, r = Array.isArray(i) ? i : [i], l = r.map(
      (I) => `${A}-${I}-container`
    ), c = r.map(
      (I) => `${A}-${I}-box`
    );
    this._tooltipContainer = z(
      t,
      "div",
      [1],
      `${A}-tooltip-container ${A}-group-container ${l.join(
        " "
      )}`
    ), this._tooltipContainerNode = this._tooltipContainer.node(), this._contentContainer = this._tooltipContainer.append("div").attr(
      "class",
      `${A}-${s.defClassName} ${A}-${o}
            ${s.className} ${c.join(" ")}`
    ), i === "content-tooltip" && vt(this._contentContainer, {
      "min-width": "150px"
    }), this._tooltipType = n && n.action ? n.action.map((I) => I.name).join("-") : "";
    const g = n?.action?.[0]?.name, h = s.content.className, d = `${A}-${h}-${g}`;
    if (g === "highlightSummary") {
      const I = n?.config?.highlightSummary;
      this._container = z(
        this._contentContainer,
        "div",
        [I?.order],
        d
      );
      const E = I?.className;
      this._container.attr(
        "class",
        `${A}-${h} ${d} ${E}`
      ), this.createTemplate(this._container);
    }
    a && (this._tooltipArrowBox = this._tooltipContainer.append("div").attr("class", `${A}-${s.pointerArrow}`)), this._contentContainerNode = this._contentContainer.node(), this._contents = {};
    const u = this._id, f = s.parentClassName, C = ms(
      f,
      u,
      s.classPrefix
    );
    this.addClass(C.join(" ")), this.hide();
  }
  /**
   * Sets the configuration of tooltip.
   * @param {Object} config Configuration of tooltip
   * @return {Tooltip} Instance of tooltip
   */
  config(...t) {
    if (t.length > 0) {
      const i = et({}, this.constructor.defaultConfig());
      return this._config = et(i, t[0]), this;
    }
    return this._config;
  }
  /**
   * Returns the default configuration of tooltip
   * @return {Object} Configuration of tooltip.
   */
  static defaultConfig() {
    return LI;
  }
  /**
   * Sets the class name of tooltip
   * @param {string} className tooltip class name
   * @return {Tooltip} Instance of tooltip.
   */
  addClass(t) {
    return this._tooltipContainer.classed(t, !0), this;
  }
  context(...t) {
    return t.length ? (this._context = t[0], this) : this._context;
  }
  createTemplate(t) {
    const i = this._config, { classPrefix: n } = i;
    this._body = z(
      t,
      "div",
      [1],
      `${n}-tooltip-content`
    ), this._facetsData = z(
      this._body,
      "div",
      [1],
      `${n}-tooltip-facets-data`
    ), this._header = this.createRow(this._body, "header", n, "H"), this._totalValue = this.createRow(this._body, "total", n, "T");
  }
  container() {
    return this._container;
  }
  contentContainer() {
    return this._contentContainer;
  }
  tooltipContainer() {
    return this._tooltipContainer;
  }
  getBody() {
    return this._body;
  }
  getFacetsData() {
    return this._facetsData;
  }
  getHeader() {
    return this._header;
  }
  getTotalValue() {
    return this._totalValue;
  }
  getTooltipType() {
    return this._tooltipType;
  }
  setTooltipType(t) {
    this._tooltipType = t;
  }
  createRow(t, i, n, s) {
    let A, o = `${n}-tooltip-row-content`;
    i === "header" && (o = `${n}-tooltip-header`), i === "total" && (o = `${n}-tooltip-total-value-content`);
    const a = z(
      t,
      "div",
      [{ id: s }],
      o,
      {},
      (c) => c.key
    ), r = z(
      a,
      "span",
      [1],
      ["header", "total"].includes(i) ? `${n}-tooltip-${i}-key` : `${n}-tooltip-row-key`
    ), l = z(
      a,
      "span",
      [1],
      ["header", "total"].includes(i) ? `${n}-tooltip-${i}-value` : `${n}-tooltip-row-value`
    );
    return i === "row" && (A = z(
      l,
      "span",
      [1],
      `${n}-tooltip-stacked-percentage`
    )), ["header", "total"].includes(i) ? [a, r, l] : [r, A, l];
  }
  content(t, i, n = {}) {
    const s = this.config(), { classPrefix: A } = s, o = s.content.className, a = `${A}-${o}-${t}`, r = n.className ? `${A}-${n.className}` : "", l = this._contents[t] = this._contents[t] || new X5();
    let c;
    ["selectionSummary", "tooltip"].includes(t) && (c = z(
      this._contentContainer,
      "div",
      [n.order],
      a
    ), c.attr(
      "class",
      `${A}-${o} ${a} ${r}`
    )), z5(
      this._contentContainer,
      `.${A}-${o}`
    );
    const g = s.content;
    n.classPrefix = this._config.classPrefix, l.config(g);
    const h = n.formatter || s.formatter, d = this.context();
    if (i === null)
      l.clear(), l.remove(), delete this._contents[t];
    else {
      const u = $5({
        ...d
      });
      l.update({
        model: i,
        formatter: h,
        secondaryModels: u
      }), l.context(this._context), ["selectionSummary", "tooltip"].includes(t) ? l.renderSelectionSummary(c) : l.render(this);
    }
    return Object.keys(this._contents).length || this.hide(), this;
  }
  hideContent(t) {
    const i = this._contents[t];
    i && i.hide();
  }
  getContents() {
    return Object.values(this._contents);
  }
  /**
   * Positions the tooltip at the given x and y position.
   * @param {number} x x position
   * @param {number} y y position
   * @return {Tooltip} Instance of tooltip.
   */
  position(t, i) {
    if (!Object.keys(this._contents).length)
      return this.hide(), this;
    this.show();
    const n = this._offset || {
      x: 0,
      y: 0
    };
    let s = 0;
    const A = this.tooltipDim();
    return n.y + i + A?.height > this.chartHeight && (s = n.y + i + A.height - this.chartHeight), this._tooltipContainer.style(
      "transform",
      `translate(${n.x + t}px,${n.y + i - s}px`
    ), this.tooltipPosition = { xPos: n.x + t, yPos: n.y + i - s }, this;
  }
  tooltipDim() {
    return this._tooltipDim;
  }
  getOffset() {
    return this._offset;
  }
  /**
   * Positions the tooltip relative to a rectangular box. It takes care of tooltip overflowing the
   * boundaries.
   * @param {Object} dim Dimensions of the plot.
   */
  positionRelativeTo(t, i = {}) {
    let n;
    const s = i.orientation, A = i.priority;
    if (!t)
      return this.hide(), this;
    const o = this._extent, a = this._contentContainerNode, r = a.offsetWidth + 4, l = a.offsetHeight + 4, c = this._config, g = this._offset, h = c.spacing + (this._tooltipArrowBox ? 3 : 0), d = i.draw !== void 0 ? i.draw : !0, u = t.y, f = t.x + t.width + g.x, C = o.width - f, I = t.x + g.x - o.x, E = o.height - (t.y + t.height + g.y), B = h, m = l + B, p = r + B, { classPrefix: w } = this.config();
    this._tooltipDim = { width: p, height: m };
    const Q = [
      {
        position: "top",
        value: u - m
      },
      {
        position: "right",
        value: C - p
      },
      {
        position: "left",
        value: I - p
      },
      {
        position: "bottom",
        value: E - m
      }
    ], y = (b) => {
      let R, G = t.x + t.width, T = t.y;
      return b === "right" ? (R = V5, G += B) : b === "left" && (G = t.x - r, R = W5, G -= B), t.height < l && (T = Math.max(0, t.y + t.height / 2 - l / 2)), {
        position: R,
        x: G,
        y: T
      };
    }, D = (b) => {
      let R, G, T = t.x - r / 2 + t.width / 2;
      return o.width - (t.x + g.x) < r ? T = o.width - r - g.x : T + g.x < o.x && (T = o.x), b === "top" ? (G = t.y - l - B, R = q5, this._tooltipArrowBox?.classed(`${w}-tooltip-arrow-top`, !0).classed(`${w}-tooltip-arrow-bottom`, !1)) : (G = t.y + t.height + B + (this._tooltipArrowBox ? 3 : 0), R = j5, this._tooltipArrowBox?.classed(`${w}-tooltip-arrow-top`, !1).classed(`${w}-tooltip-arrow-bottom`, !0)), {
        position: R,
        x: T,
        y: G
      };
    }, _ = (b, R) => {
      const G = b[0].value > b[1].value ? b[0] : b[1], T = b.filter((v) => v.position === R)[0];
      return T && T.value > 0 ? T : G;
    };
    this._target = t;
    const x = _(
      Q.filter((b) => b.position === "left" || b.position === "right"),
      A
    ), S = _(
      Q.filter((b) => b.position === "top" || b.position === "bottom"),
      A
    );
    if (s)
      if (s === "horizontal") {
        const b = x.position;
        n = y(b);
      } else {
        const b = S.position;
        n = D(b);
      }
    else if (x.value > 0) {
      const b = x.position;
      n = y(b);
    } else {
      const b = S.position;
      n = D(b);
    }
    return this._position = {
      x: n.x,
      y: n.y
    }, this._tooltipArrowBox?.style(
      "left",
      `${t.x + t.width / 2 - this._position.x}px`
    ), this._orientation = n.position, d && this.position(n.x, n.y), this;
  }
  /**
   * Hides the tooltip element.
   * @return {Tooltip} Instance of tooltip.
   */
  hide() {
    return this._tooltipContainer.style("visibility", "hidden"), this;
  }
  /**
   * Shows the tooltip element.
   * @return {Tooltip} Instance of tooltip.
   */
  show() {
    return this._tooltipContainer.style("visibility", "visible"), this;
  }
  extent(t) {
    return this._extent = t, this;
  }
  offset(t) {
    return this._offset = t, this;
  }
  remove() {
    return this._tooltipContainer.remove(), this;
  }
  dispose() {
    return this.remove(), this;
  }
};
const Qb = "muze", Z5 = "left", tJ = "right", eJ = "bottom", iJ = "top", t0 = "invoke-menu-item-callback", yb = {
  classPrefix: Qb,
  padding: 5,
  iconSize: 10
}, nJ = {
  classPrefix: Qb,
  contextName: null,
  containerClassName: null,
  spacing: 5,
  arrow: {
    size: 10,
    disabled: !1,
    defClassName: "dropdown-arrow",
    className: "",
    color: "rgba(195,195,195,0.85)"
  },
  content: yb
};
class sJ {
  /**
   * Initializes the Content.
   *
   * @param {Object} data - The data to render.
   * @param {Array<Object>} data.menuItems - The menu items to render.
   * @param {string} data.activeMenuItem - The key of the active menu item.
   * @param {string} data.disabledMenuItems - List of keys which are disabled.
   * @param {Object} config - The config.
   */
  constructor(t, i) {
    this._menuItems = t.menuItems || [], this._activeMenuItem = t.activeMenuItem || null, this._disabledMenuItems = t.disabledMenuItems || [], this.config(i);
  }
  static defaultConfig() {
    return yb;
  }
  config(...t) {
    return t.length > 0 ? (this._config = et(
      {},
      this.constructor.defaultConfig(),
      this._config,
      t[0]
    ), this) : this._config;
  }
  /**
   * It updates the content data.
   *
   * @param {Object} data - The content.
   * @param {Array<Object>} data.menuItems - The list of menu items. Here each menu item contains these props:
   *  1. key: The key identifier
   *  2. label: The text label
   *  3. icon: The icon
   *  4. onClick: The onClick listener
   * @param {string} data.activeMenuItem - The key for the active menu item.
   * @param {string} data.disabledMenuItems - List of keys which are disabled.
   */
  updateData(t) {
    "menuItems" in t && (this._menuItems = t.menuItems || []), "activeMenuItem" in t && (this._activeMenuItem = t.activeMenuItem || null), "disabledMenuItems" in t && (this._disabledMenuItems = t.disabledMenuItems || []);
  }
  render(t) {
    const i = this._menuItems, n = this._activeMenuItem, s = this._disabledMenuItems, { classPrefix: A } = this.config(), o = `${A}-dropdown-content`, a = z(
      t,
      "div",
      [1],
      `${o}-wrapper`
    ), r = i.map((g) => ({
      ...g,
      isActive: g.key === n,
      isDisabled: s.includes(g.key)
    })), l = z(
      a,
      "div",
      r,
      `${o}-menu-item`,
      {},
      (g) => g.key
    );
    l.each(function(g) {
      const h = X(this);
      h.classed("active", g.isActive), h.classed("disabled", g.isDisabled);
    }), z(
      l,
      "div",
      (g) => [
        {
          type: "icon",
          key: `${g.key}-icon`,
          data: g.isActive ? l4 : g.icon
        },
        { type: "label", key: `${g.key}-label`, data: g.label }
      ],
      `${o}-menu-item-cell`,
      {
        enter: c,
        update: c
      },
      (g) => g.key
    );
    function c(g, h) {
      const { type: d, data: u } = h;
      d === "icon" ? (g.classed(`${o}-menu-item-icon-holder`, !0), z(
        g,
        "img",
        u ? [u] : [],
        `${o}-menu-item-icon`
      ).attr("src", (f) => f).style("width", "6px")) : d === "label" && (g.classed(`${o}-menu-item-label-holder`, !0), z(
        g,
        "span",
        [u],
        `${o}-menu-item-label`
      ).text((f) => f));
    }
  }
}
const AJ = (e) => (t) => {
  t.selectAll(".muze-dropdown-box .muze-dropdown-content-menu-item").on("click", oJ.bind(void 0, e));
}, oJ = (e) => {
  const t = bt(), n = X(t.currentTarget).datum(), s = e.context.metaInfo();
  e.triggerPhysicalAction("menuItemClick", {
    data: n,
    metaInfo: s
  });
};
class aJ {
  /**
   * Initializes the Dropdown with the container element and configurations.
   *
   * @param {HTMLElement} htmlContainer - The container where the Dropdown will be mounted.
   * @param {string} config - The config.
   * @param {string} config.contextName - The context name where this Dropdown is being created.
   * @param {Object} content - The context name where this Dropdown is being created.
   */
  constructor(t, i, n) {
    this._id = Zt(), this.config(i), this._content = new sJ(n, this._config.content), this._firebolt = new Yo(
      this,
      {
        behavioural: {
          menuItemSelect: DJ
        },
        physical: {
          menuItemClick: AJ
        },
        physicalBehaviouralMap: {
          menuItemClick: {
            behaviours: ["menuItemSelect"]
          }
        }
      },
      {
        [t0]: xJ
      },
      {}
    ), this.mount(t), this.mapSideEffects();
  }
  mount(...t) {
    return t.length > 0 ? (this._mount = t[0], this.init(), this.render(), this) : this._mount;
  }
  init() {
    const t = this.mount(), { classPrefix: i, contextName: n, containerClassName: s } = this.config();
    let A = `${i}-dropdown-container ${i}-dropdown-container-${this._id} ${i}-group-container`;
    n && (A += ` ${i}-${n}-container`), s && (A += ` ${i}-${s}`), this._dropdownContainer = z(
      t,
      "div",
      [1],
      A
    ), this._dropdownBox = this._dropdownContainer.append("div").attr("class", `${i}-dropdown-box`), this._dropdownContentContainer = this._dropdownBox.append("div").attr("class", `${i}-dropdown-content-container`), this.hide();
  }
  static defaultConfig() {
    return nJ;
  }
  content(...t) {
    return t.length > 0 ? (this._content.updateData(t[0]), this.render(), this) : this._content;
  }
  render() {
    this._content.render(this._dropdownContentContainer), this.mapActionsAndBehaviour();
  }
  config(...t) {
    return t.length > 0 ? (this._config = et(
      {},
      this.constructor.defaultConfig(),
      this._config,
      t[0]
    ), this._content && this._content.config(this._config.content), this) : this._config;
  }
  addClass(t) {
    return this._dropdownContainer.classed(t, !0), this;
  }
  position(t, i) {
    this.show();
    const n = this._offset || {
      x: 0,
      y: 0
    };
    return this._dropdownContainer.style(
      "transform",
      `translate(${n.x + t}px,${n.y + i}px`
    ), this;
  }
  /**
   * Positions the Dropdown relative to a rectangular box. It takes care of Dropdown overflowing the
   * boundaries.
   * @param {Object} dim - Dimensions of the relative box.
   */
  positionRelativeTo(t, i) {
    i = i || {};
    const { orientation: n, draw: s } = i || {};
    let A;
    if (!t)
      return this.hide(), this;
    const o = this._extent, a = this._dropdownBox.node(), r = a.offsetWidth + 4, l = a.offsetHeight + 4, c = this._config, g = this._offset, h = c.spacing, d = s !== void 0 ? s : !0, u = t.y, f = t.x + t.width + g.x, C = o.width - f, I = t.x + g.x - o.x, E = o.height - (t.y + t.height + g.y), B = h, m = l + B, p = r + B, w = [
      {
        position: "top",
        value: u - m
      },
      {
        position: "right",
        value: C - p
      },
      {
        position: "left",
        value: I - p
      },
      {
        position: "bottom",
        value: E - m
      }
    ], Q = (x) => {
      let S, b = t.x + t.width, R = t.y;
      return x === "right" ? (S = Z5, b += B) : x === "left" && (b = t.x - r, S = tJ, b -= B), t.height < l && (R = Math.max(0, t.y + t.height / 2 - l / 2)), {
        position: S,
        x: b,
        y: R
      };
    }, y = (x) => {
      let S, b, R = t.x - r / 2 + t.width / 2;
      return o.width - (t.x + g.x) < r ? R = o.width - r - g.x : R + g.x < o.x && (R = o.x), x === "top" ? (b = t.y - l - B, S = eJ) : (b = t.y + t.height + B, S = iJ), {
        position: S,
        x: R,
        y: b
      };
    };
    this._target = t;
    const D = gI(
      w.filter((x) => x.position === "left" || x.position === "right"),
      "value"
    ), _ = gI(
      w.filter((x) => x.position === "top" || x.position === "bottom"),
      "value"
    );
    if (n)
      if (n === "horizontal") {
        const x = D.position;
        A = Q(x);
      } else {
        const x = _.position;
        A = y(x);
      }
    else if (D.value > 0) {
      const x = D.position;
      A = Q(x);
    } else {
      const x = _.position;
      A = y(x);
    }
    return this._position = {
      x: A.x,
      y: A.y
    }, this._orientation = A.position, d && this.position(A.x, A.y), this;
  }
  extent(t) {
    return this._extent = t, this;
  }
  offset(t) {
    return this._offset = t, this;
  }
  hide() {
    return this._dropdownContainer.style("visibility", "hidden"), this;
  }
  show() {
    return this._dropdownContainer.style("visibility", "visible"), this;
  }
  isVisible() {
    return this._dropdownContainer.style("visibility") === "visible";
  }
  getDefaultTargetContainer() {
    const { classPrefix: t } = this.config();
    return `.${t}-dropdown-container-${this._id}`;
  }
  mapActionsAndBehaviour() {
    const t = this._firebolt._actionBehaviourMap, i = {};
    for (let n in t) {
      const s = t[n].behaviours, A = this._firebolt._actions.behavioural;
      s.some(
        (a) => A[a]._enabled
      ) && (i[n] = {
        ...t[n],
        behaviours: []
      });
    }
    this._firebolt.mapActionsAndBehaviour(null, i);
  }
  sourceCanvas() {
    return "canvas0";
  }
  id() {
    return this._id;
  }
  data() {
    return null;
  }
  mapSideEffects() {
    const t = {
      menuItemSelect: [
        {
          name: t0
        }
      ]
    };
    this._firebolt.mapSideEffects(t, !1);
  }
  metaInfo(...t) {
    return t.length > 0 ? (this._metaInfo = t[0], this) : this._metaInfo;
  }
  dispose() {
    this._dropdownContainer && this._dropdownContainer.remove();
  }
}
const rJ = "selectionSummary", DB = "highlightSummary", Qf = (e) => {
  const t = e % e.toFixed(0) === 0 ? e : e.toFixed(2), i = Intl.NumberFormat().format(t);
  return K.isInvalid(e) ? `${e}` : `${i}`;
}, UI = (e, t, i, n, s = {}, A, o) => {
  const { TEMPORAL: a, CONTINUOUS: r, CATEGORICAL: l } = K.FieldSubtype, c = n?.payload?.targetData, g = c?.[0].indexOf("__id__"), h = c?.[1][g], u = n?.targetLayer?._pointMap?.[h]?.data, f = e?.[o] instanceof Function || typeof e?.[o] == "function";
  return {
    [a]: (C) => {
      const I = us(C);
      return typeof I == "string" ? f ? e[o](
        {
          formattedValue: I,
          rawValue: I,
          getRowData: () => u
        },
        o
      ) : I : K.isInvalid(C) ? i(C) : f ? e[o](
        {
          formattedValue: pA(Number(C), t, {
            useUTC: s.useUTC
          }),
          rawValue: C,
          getRowData: () => u
        },
        o
      ) : pA(Number(C), t, {
        useUTC: s.useUTC
      });
    },
    [r]: (C) => {
      const I = us(C);
      return typeof I == "string" ? f ? e[o](
        {
          formattedValue: Qf(I),
          rawValue: I,
          getRowData: () => u
        },
        o
      ) : I : K.isInvalid(C) ? i(C) : f ? e[o](
        {
          formattedValue: Qf(C),
          rawValue: C,
          getRowData: () => u
        },
        o
      ) : Qf(C);
    },
    [l]: (C) => {
      const I = us(C);
      return typeof I == "string" ? f ? e[o](
        {
          formattedValue: I,
          rawValue: I,
          getRowData: () => u
        },
        o
      ) : I : K.isInvalid(C) ? i(C) : f ? e[o](
        {
          formattedValue: C,
          rawValue: C,
          getRowData: () => u
        },
        o
      ) : i(C);
    },
    [H5]: (C) => {
      const I = us(C);
      return typeof I == "string" ? f ? e[o](
        {
          formattedValue: I,
          rawValue: I,
          getRowData: () => u
        },
        o
      ) : I : K.isInvalid(C) ? i(C) : f ? e[o](
        {
          formattedValue: Co([
            I,
            I + A.getBinSize()
          ]),
          rawValue: [I, I + A.getBinSize()],
          getRowData: () => u
        },
        o
      ) : Co([I, I + A.getBinSize()]);
    }
  };
}, ae = (e) => {
  const {
    field: t,
    value: i,
    classPrefix: n,
    margin: s,
    isSelected: A = !1,
    stackPercent: o = null,
    fontWeight: a = "normal",
    isTotal: r = !1,
    typeOfValue: l = "number",
    hasEllipsisInKey: c = !0
  } = e, g = {
    value: t,
    className: `${n}-tooltip-row-key`
  }, h = {
    value: i,
    className: `${n}-tooltip-value`
  }, d = {
    data: [h],
    className: `${n}-tooltip-row-value`
  };
  if (o) {
    let I = {
      value: o,
      className: `${n}-tooltip-stacked-percentage`
    };
    d.data.push(I);
  }
  g.style = {}, h.style = { "white-space": "nowrap" };
  let u = {};
  const f = {
    ...O5,
    ...zQ
  };
  a && (g.style = {
    "font-weight": a
  }, h.style = {
    "font-weight": a
  }), c && (g.style = { ...g.style, ...f }), u = { "grid-template-columns": "auto auto" }, l !== "number" && l !== "object" && (h.style = {
    ...h.style,
    ...P5,
    ...zQ
  }), s && (g.style = {
    ...g.style,
    margin: `2px ${s}px`
  }, h.style = o ? {
    ...h.style,
    margin: "2px 1px 2px 5px"
  } : {
    ...h.style,
    margin: "2px 5px 2px 5px"
  });
  let C = `${n}-tooltip-row-content`;
  return A ? C = `${n}-tooltip-selected-row` : r && (C = `${n}-tooltip-total-value-content`), {
    className: C,
    style: u,
    data: [g, d]
  };
}, hs = (e, t, i = (n) => n) => {
  const n = t.getRowsCount();
  let s = 0;
  for (let A = 0; A < n; A++) {
    const o = t.getValueAtIndex(e, A);
    s += typeof o == "number" && i(o) ? o : 0;
  }
  return s;
}, jh = (e) => {
  const {
    dimensionEncodings: t,
    secondaryField: i,
    measureEncodings: n,
    row: s,
    target: A,
    fieldInf: o,
    colorFieldValue: a
  } = e, r = 1, l = 0, c = Object.keys(s)[0];
  let g, h, d;
  if (t.length === 0)
    if (n.length === 0) {
      const u = s[c], { fn: f } = c ? o[c] : { fn: void 0 };
      return u !== void 0 && (h = f ? f(u) : u, h = K.getActualValue(h)), g = A && A[r][A[l].indexOf(c)], g !== void 0 && (d = f ? f(g) : g, d = K.getActualValue(d)), h === d;
    } else {
      const u = s[i], { fn: f } = i ? o[i] : { fn: void 0 };
      return u !== void 0 && (h = f ? f(u) : u, h = K.getActualValue(h)), g = A && A[r][A[l].indexOf(i)], g !== void 0 && (d = f ? f(g) : g, d = K.getActualValue(d)), h === d;
    }
  else {
    const u = [], f = [];
    let C, I, E, B;
    for (const m in t) {
      const p = t[m];
      if (p in s) {
        const w = s[p], { fn: Q } = o[p];
        w !== void 0 && (h = Q ? Q(w) : w, f.push(K.getActualValue(h)));
      } else if (a !== void 0) {
        const { fn: w } = o[p];
        C = w ? w(a) : a, C = K.getActualValue(C);
      }
    }
    E = f.join(",");
    for (const m in t) {
      const p = t[m], w = A && A[r][A[l].indexOf(p)];
      if (w == null)
        return !1;
      if (p in s) {
        const { fn: Q } = o[p];
        let y = Q ? Q(w) : w;
        y = K.getActualValue(y), u.push(y);
      } else {
        const { fn: Q } = o[p];
        I = Q ? Q(w) : w, I = K.getActualValue(I);
      }
    }
    return B = u.join(","), E !== B ? !1 : !(a !== void 0 && I !== C);
  }
}, lJ = (e) => e === ot.TEMPORAL || e === ot.BINNED || e === ot.CONTINUOUS, wu = (e, t, i) => {
  const n = i.targetLayer._dependencies.canvasActions.getRootData(), { CATEGORICAL: s, TEMPORAL: A } = K.FieldSubtype, { valueParser: o, timeDiffs: a, useUTC: r } = i, l = UI(null, null, o)[s], c = i.fieldFormatters;
  return e.reduce((g, h) => {
    let { subtype: d, name: u } = h, f = d === A ? a[u] : 0;
    const I = n.getField(u).subtype();
    let E;
    I !== d && d === ot.CATEGORICAL && lJ(I) ? (E = n.getField(u), d = I, f = d === A ? a[u] : 0) : E = t.getField(u);
    const B = c?.[u] ? c : E.schema().format;
    return g[u] = {
      fn: wt(
        UI(
          B,
          f,
          o,
          i,
          { useUTC: r },
          E,
          u
        )[d],
        l
      ),
      displayName: `${dc(t, u)}`
    }, g;
  }, {});
}, hn = (e, t) => e.find((i) => i.name === t), wb = (e) => {
  const t = {};
  return [
    "angle",
    "color",
    "opacity",
    "backgroundColor",
    "shape",
    "size",
    "detail",
    "text"
  ].forEach((n) => {
    let s;
    if (n === "detail" && typeof e[n].field[0] == "object")
      return;
    s = e[n];
    const A = Z(s, "field");
    if (A) {
      const o = Bn(A);
      o.length !== 0 && (t[n] = o);
    }
  }), t;
}, Db = (e, t, i = {}) => {
  const n = e.getRowsCount(), s = [];
  for (let A = 0; A < n; A++) {
    const o = {};
    t.forEach((a) => {
      o[a] = e.getValueAtIndex(a, A);
    }), s.push(o);
  }
  if (i.sortedValues) {
    const A = i.sortedValues.reduce(
      (o, a, r) => (o[a] = r, o),
      {}
    );
    s.sort(
      (o, a) => A[o[i.sortField]] - A[a[i.sortField]]
    );
  }
  return s;
};
let JA = [], Ag = 0;
const xb = (e) => {
  const { seriesData: t, sortField: i, secondaryField: n } = e;
  let s = [], A = null;
  return t.forEach((o) => {
    A !== o[i] && (A !== null && JA.push(Ag), Ag = 0, A = o[i], s.push({ [i]: A }));
    const a = { ...o };
    Ag += o[n], delete a[i], s.push(a);
  }), JA.push(Ag), s;
}, Sb = (e, t, i) => {
  const n = [
    "angle",
    "color",
    "backgroundColor",
    "detail",
    "opacity",
    "shape",
    "size",
    "text"
  ];
  let s = /* @__PURE__ */ new Map(), A = 0;
  const o = [];
  if (i) {
    const a = i.field;
    i.as === "discrete" || i.type === "dimension" ? s[a] = ++A : o.push(a);
  }
  return n.forEach((a) => {
    e[a] && !s[e[a]] ? s[e[a]] = ++A : t[a] && o.push(t[a]);
  }), o.forEach((a) => {
    s[a] || (s[a] = ++A);
  }), s;
}, _b = (e) => {
  const {
    headerField: t,
    secondaryField: i,
    rowFacets: n,
    columnFacets: s,
    colorSplitField: A,
    retinalAndDetailFieldsObj: o
  } = e, a = [
    t,
    i,
    ...n,
    ...s,
    A
  ].filter((r) => r);
  Object.entries(o).forEach(([r, l]) => {
    a.includes(l[0]) && delete o[r];
  });
}, og = (e) => {
  const { startIndex: t, endIndex: i, fieldName: n, seriesData: s, fn: A = (a) => a } = e;
  let o = 0;
  for (let a = t; a < i + 1; a++) {
    let r = s[a][n];
    o += typeof r == "number" && A(r) ? r : 0;
  }
  return o;
}, bb = (e) => e._renderer === "html", me = (e, t) => !t?.[e]?.[0], cJ = (e, t = {}, i, n) => {
  const s = e.getSchema({
    excludeFields: [pt.ROW_ID, ht]
  });
  if (s.length === 0)
    return {
      content: [],
      displayFormat: "normal"
    };
  const A = i.targetLayer, o = A.axes(), { classPrefix: a, separator: r } = t, l = A.config().encoding, c = A._transformConfig, g = A.transformType(), h = [mb, pb, Xt].includes(
    g
  ), { showStackSum: d = !0 } = i.config || {}, u = wu(s, e, i), f = wb(l), C = e.getRowsCount(), I = l.color.splitBy, E = i.payload.target, B = 26, m = Math.floor(
    0.6 * i.chartHeight / B
  );
  let p = 0, w = 0, Q = 0;
  const y = Array.from(Object.keys(i.payload.metaData.rowFacets)) || [];
  let D = Array.from(Object.keys(i.payload.metaData.colFacets)) || [];
  D = D.filter((It) => !y.includes(It));
  let _;
  const x = i.config.splitFields;
  x && (_ = Object.keys(x));
  let S = [];
  _.forEach((It) => {
    S.push(x[It].splitBy.field);
  });
  const b = bb(A), R = (It, dt, Jt) => {
    let { displayName: gt, fn: xt } = u[It];
    return gt || (gt = It), ae({
      field: `${gt}${r}`,
      value: xt ? xt(dt) : dt,
      classPrefix: a,
      margin: oe,
      fontWeight: Jt,
      hasEllipsisInKey: !1
    });
  }, { x: G, y: T } = l, v = hn(s, G.field) ? G.field : null, H = hn(s, T.field) ? T.field : null, N = G.as, M = T.as;
  let k = jd({
    yField: H,
    xField: v,
    yFieldAs: M,
    xFieldAs: N,
    dm: e,
    transformConf: c
  }) ? G.field : T.field;
  k = hn(s, k) ? k : null;
  let O = {}, P = {}, L = [], q = {}, $, W = !1;
  k && ((y.includes(k) || D.includes(k)) && b && (!y.includes(l.x.field) && !D.includes(l.x.field) ? k = l.x.field : !D.includes(l.y.field) && !y.includes(l.y.field) ? k = l.y.field : k = null), k === l.x.field ? (q.field = l.y.field, $ = hn(s, q.field) ? q.field : null, $ && (q.as = l.y.as, q.type = e.getField(q.field).type())) : (q.field = l.x.field, $ = hn(s, q.field) ? q.field : null, $ && (q.as = l.x.as, q.type = e.getField(q.field).type()))), $ && b && ($ === k || y.includes($) || D.includes($)) && ($ = null), b && _b({
    headerField: k,
    secondaryField: $,
    rowFacets: y,
    columnFacets: D,
    colorSplitField: I,
    retinalAndDetailFieldsObj: f
  });
  const U = Z(f, "color", 0);
  Object.entries(f).forEach(([It, dt]) => {
    l[It]?.as === "discrete" || e.getField(dt[0])?.type() === "dimension" ? O[It] = dt[0] : P[It] = dt[0];
  });
  const J = !!Object.entries(O).length, V = Object.values(
    f
  ).flat(), Y = i.config.filter.mode === "include", nt = i.config.filter.fields, tt = (It) => !!(Y && nt?.includes(It) || !Y && !nt?.includes(It) || Y && !nt), st = Db(
    e,
    [...V, $, I].filter(
      (It) => It
    ),
    {
      sortedValues: A._transformedData.getSortedGroupByValues(),
      sortField: A._transformedData.getSortField()
    }
  );
  let lt = {
    className: `${a}-tooltip-facets-data`,
    data: []
  };
  const at = {};
  if ([
    .../* @__PURE__ */ new Set([
      ...y,
      ...D,
      k,
      ...Array.from(Object.keys(st[0]))
    ])
  ].forEach((It) => {
    _.includes(It) ? at[x[It].splitBy.field] = [!0, It] : It in at || (at[It] = [!1]);
  }), y.length && y.forEach((It) => {
    const dt = e.getValueAtIndex(It, 0);
    let { displayName: Jt, fn: gt } = u?.[It] ?? {};
    tt(It) && me(It, at) && (It in x && tt(x[It].splitBy.field) && (Jt = e.getValueAtIndex(
      x[It].splitBy.field,
      0
    )), Q++, Jt && lt.data.push(
      ae({
        field: `${Jt}${r}`,
        value: gt ? gt(dt) : dt,
        classPrefix: a,
        margin: oe,
        hasEllipsisInKey: !1
      })
    ));
  }), D.length && D.forEach((It) => {
    const dt = e.getValueAtIndex(It, 0);
    let { displayName: Jt, fn: gt } = u?.[It] ?? {};
    if (tt(It) && me(It, at)) {
      It in x && tt(x[It].splitBy.field) && (Jt = e.getValueAtIndex(
        x[It].splitBy.field,
        0
      )), Q++;
      const xt = ae({
        field: `${Jt}${r}`,
        value: gt ? gt(dt) : dt,
        classPrefix: a,
        margin: oe,
        hasEllipsisInKey: !1
      });
      b ? lt.data.unshift(xt) : lt.data.push(xt);
    }
  }), L.push(lt), tt(k) && me(k, at)) {
    const It = b || Object.entries(f).length === 0 && y.length === 0 && D.length === 0 && (C === 1 || st.length === 1);
    let dt = k;
    if (k in x && tt(x[k].splitBy.field) && (dt = e.getValueAtIndex(
      x[k].splitBy.field,
      0
    )), k) {
      Q++;
      const Jt = R(
        dt,
        e.getValueAtIndex(k, 0),
        It ? "normal" : 620
      );
      L.push(Jt);
    }
  }
  const Qt = Sb(
    O,
    P,
    $ ? q : null
  );
  let St = $ ? Qt[$] - 1 : null, At = [];
  Object.values(f).forEach((It) => {
    At.push(It[0]);
  }), At = [...new Set(At)];
  const [Vt, _t] = EE(
    At,
    (It) => It && e.getField(It)?.type() === "dimension"
  ), zt = U != null && Vt.includes(O.color) && Vt.length > 1;
  if ($ && q.type === "measure" && C > 1 && (J || h) && d) {
    let It = hs($, e), { displayName: dt, fn: Jt } = u[$];
    const gt = x[$]?.splitBy?.field;
    let xt;
    tt($) && me($, at) && ($ in x && tt(gt) ? (zt ? (Q++, dt = "", xt = `Total ${dt}${r}`) : gt !== k && gt !== $ ? (xt = "", It = "") : (Q++, dt = e.getValueAtIndex(gt, 0), xt = `Total ${dt}${r}`), L.push(
      ae({
        field: xt,
        value: Jt ? Jt(It) : It,
        classPrefix: a,
        margin: oe,
        fontWeight: 620,
        isTotal: !0,
        hasEllipsisInKey: !1
      })
    )) : (xt = `Total ${dt}${r}`, Q++, L.push(
      ae({
        field: xt,
        value: Jt ? Jt(It) : It,
        classPrefix: a,
        margin: oe,
        fontWeight: 620,
        isTotal: !0,
        hasEllipsisInKey: !1
      })
    )));
  }
  let te, ei = -1, ki = /* @__PURE__ */ new Set();
  if (U != null && Vt.includes(O.color) && Vt.length > 1) {
    W = !0;
    const It = xb({
      seriesData: st,
      sortField: A._transformedData.getSortField() || U,
      secondaryField: $
    });
    let dt, Jt, gt, xt;
    It.forEach((Ft, se) => {
      if (Ft[U]) {
        tt(U) && me(U, at) && p++, Jt = Ft[U], se !== 0 && L.push(dt);
        let Te;
        const Ge = Ft[U], Lt = o.color;
        if (l.color.splitBy) {
          const fe = Ft[l.color.splitBy];
          Te = Lt[fe] || Lt;
        } else
          Te = Lt;
        const Pt = Ge && Te.getColor(Ge);
        let { displayName: An, fn: yn } = u[U];
        if (!me(U, at) && !ki.has(Ft[U]) && (ei += 1, me($, at))) {
          const { fn: fe } = u[$];
          if (ei === 0) {
            let Me = L.findIndex(
              ($t) => $t.className.includes("total-value-content")
            );
            const on = JA[0];
            JA.shift(), Me !== -1 && (L[Me].data[0].value = L[Me].data[0].value.slice(0, -1) + `${Ft[U]}:`, L[Me].data[1].data[0].value = fe ? fe(on) : on);
          } else {
            const Me = {
              className: `${a}-tooltip-series-data`,
              color: void 0,
              data: [
                ae({
                  field: `Total ${Ft[U]}${r}`,
                  value: fe ? fe(JA[0]) : JA[0],
                  classPrefix: a,
                  margin: oe,
                  fontWeight: 620,
                  hasEllipsisInKey: !1
                })
              ]
            };
            JA.shift(), L.push(Me);
          }
        }
        tt(U) && me(U, at) && U in x && tt(x[U].splitBy.field) && (An = e.getValueAtIndex(
          x[U].splitBy.field,
          0
        )), dt = {
          className: `${a}-tooltip-series-data`,
          color: b ? void 0 : Pt,
          data: tt(U) && me(U, at) ? [
            ae({
              field: `${An}${r}`,
              value: yn ? yn(Ft[U]) : Ft[U],
              classPrefix: a,
              margin: oe,
              fontWeight: b ? "normal" : 600,
              typeOfValue: typeof Ft[U]
            })
          ] : []
        };
      } else {
        const Te = new Array(Object.entries(Ft).length);
        w = Te.length, Object.entries(Ft).forEach(([Lt, Pt]) => {
          const An = Qt[Lt];
          let { displayName: yn, fn: fe } = u[Lt], Me = null;
          if (h && $ && Lt === $ && (q.as === "continuous" || q.type === "measure")) {
            const $t = hs(
              Lt,
              e,
              (Mt) => Mt >= 0
            ), ut = hs(Lt, e, (Mt) => Mt < 0);
            Me = `(${(Pt >= 0 ? Pt * 100 / $t : Pt * 100 / ut).toFixed(2)} %)`;
          }
          C > 1 && (gt = jh({
            dimensionEncodings: Vt,
            secondaryField: $,
            measureEncodings: _t,
            row: Ft,
            target: E,
            fieldInf: u,
            colorFieldValue: Jt
          })), gt && (xt = !0);
          let on;
          tt(Lt) && me(Lt, at) && (Lt in x && tt(x[Lt].splitBy.field) && (yn = Jt), on = ae({
            field: `${yn}${r}`,
            value: fe ? fe(Pt) : Pt,
            classPrefix: a,
            margin: oe,
            isSelected: gt,
            stackPercent: Me,
            typeOfValue: isNaN(Pt) ? typeof fe(Pt) : typeof Pt
          }), Te[An - 1] = on);
        });
        const Ge = Te.filter(
          (Lt) => Lt !== void 0
          //  &&
          // showConfigFields(val.data[0].value.slice(0, -1)),
        );
        xt && (te = p, xt = !1), p += Ge.length, dt.data.push(...Ge);
      }
    }), L.push(dt);
  } else
    st.forEach((It, dt) => {
      let Jt, gt = !1;
      const xt = It[U], Ft = o.color;
      if (l.color.splitBy) {
        const Lt = It[l.color.splitBy];
        Jt = Ft[Lt] || Ft;
      } else
        Jt = Ft;
      const se = xt && Jt.getColor(xt), Te = Object.entries(It).length;
      C > 1 && (gt = jh({
        dimensionEncodings: Vt,
        secondaryField: $,
        measureEncodings: _t,
        row: It,
        target: E,
        fieldInf: u
      })), gt && (w = Te, te = Object.entries(It).length * dt);
      let Ge = {
        className: `${a}-tooltip-series-data`,
        color: b ? void 0 : se,
        data: new Array(Te)
      };
      Object.entries(It).forEach(([Lt, Pt]) => {
        const An = Qt[Lt];
        if (An === void 0)
          return;
        let yn = null;
        if (h && $ && Lt === $ && (q.as === "continuous" || q.type === "measure")) {
          const $t = hs(Lt, e, (Mt) => Mt >= 0), ut = hs(Lt, e, (Mt) => Mt < 0);
          yn = `(${(Pt >= 0 ? Pt * 100 / $t : Pt * 100 / ut).toFixed(2)} %)`;
        }
        let { displayName: fe, fn: Me } = u?.[Lt] ?? {}, on;
        tt(Lt) && me(Lt, at) && (Lt in x && tt(x[Lt].splitBy.field) && (It[x[Lt].splitBy.field] ? fe = It[x[Lt].splitBy.field] : fe = e.getValueAtIndex(
          x[Lt].splitBy.field,
          dt
        )), on = ae({
          field: `${fe}${r}`,
          value: Me ? Me(Pt) : Pt,
          classPrefix: a,
          margin: oe,
          isSelected: gt,
          stackPercent: yn,
          typeOfValue: isNaN(Pt) ? typeof Me(Pt) : typeof Pt
        }), Ge.data[An - 1] = on);
      }), Ge.data = Ge.data.filter(
        (Lt) => Lt !== void 0
        // && showConfigFields(val.data[0].value.slice(0, -1)),
      ), p += Ge.data.length, L.push(Ge);
    });
  const ue = [Q, p];
  return ue[0] + ue[1] > m ? Mb({
    seriesData: st,
    content: L,
    context: i,
    config: t,
    divContentHeight: B,
    headRowsCount: ue[0],
    countOfRows: ue[1],
    rowsCountOfEachSeriesData: w,
    selectedDataIndex: te,
    isColorSplitByDimension: W,
    fieldInf: u,
    secondaryField: $,
    secondaryFieldIndex: St,
    classPrefix: a,
    separator: r,
    percentage: 0.6,
    isDualAxisTooltip: !1
  }) : (i.config.includeContent && Yl(L, i, t, e, n), {
    content: L,
    displayFormat: "normal"
  });
}, Yl = (e, t, i, n, s) => {
  const A = t.config.includeContent, { classPrefix: o, separator: a } = i;
  A.forEach((r) => {
    let l = {
      className: `${o}-tooltip-series-data`,
      color: void 0
    };
    const c = t?.payload?.targetData, g = c?.[0].indexOf("__id__"), h = c?.[1][g], u = t?.targetLayer?._pointMap?.[h]?.data, f = r.displayName, C = r.value, I = C(
      { getRowData: () => u },
      { dataModel: n, tooltipInst: s, formatterFn: UI }
    ), E = ae({
      field: `${f}${a}`,
      value: I,
      classPrefix: o,
      margin: oe,
      typeOfValue: typeof I
    });
    l.data = [E], e.push(l);
  });
}, Mb = (e) => {
  const {
    seriesData: t,
    content: i,
    context: n,
    config: s,
    divContentHeight: A,
    headRowsCount: o,
    countOfRows: a,
    rowsCountOfEachSeriesData: r,
    selectedDataIndex: l,
    isColorSplitByDimension: c,
    fieldInf: g,
    secondaryField: h,
    secondaryFieldIndex: d,
    classPrefix: u,
    separator: f,
    percentage: C,
    displayTotals: I,
    isDualAxisTooltip: E = !0,
    isCompositeFunction: B,
    arrayOfPrevTotals: m,
    arrayOfNextTotals: p,
    isLastSharedAxes: w = !0,
    displayTotalsForShared: Q
  } = e;
  let y = [], D = i.findIndex((k) => k.className.includes("series-data"));
  (Q || I) && !i[0].className.includes("total-value-content") && D++;
  const _ = n.config.filter.mode === "include", x = n.config.filter.fields, S = (k) => !!(_ && x?.includes(k) || !_ && !x?.includes(k) || _ && !x), b = i.slice(D), R = C * n.chartHeight - A * o, G = a - 1;
  y = [...i.slice(0, D)];
  let T = 0;
  n.config.includeContent && (T = n.config.includeContent.length);
  let v = Math.floor(R / A) - T, H, N, M;
  if (l !== void 0) {
    v -= r;
    let k = Math.ceil(v / 2), O = Math.floor(v / 2);
    const P = l, L = l + r - 1;
    P - k === 0 ? (H = 0, N = L + O) : P - k > 0 ? (L + O > G ? (N = G, M = k + (L + O - G)) : (N = L + O, M = k), H = P - M) : (M = O + Math.abs(P - k), N = L + M, H = 0);
  } else if (H = Math.floor(a / 2), H + v > G) {
    N = G;
    const k = H + v - G;
    H -= k, H < 0 && (H = 0);
  } else
    N = H + v;
  const F = g[h].fn;
  if (c) {
    let k = 0, O, P, L, q, $ = 0, W, U = 0, J, V = 0, Y = !1, nt = !1;
    for (let st = 0; st < b.length && !(W !== void 0 && J !== void 0); st++)
      q = k + (b[st].data.length - 1), H >= k && H <= q && (W = $, V = U, O = k), N >= k && N <= q && (J = $, P = k, L = U), $++, k = k + b[st].data.length, U += Math.floor(b[st].data.length / r);
    let tt = U;
    if (h) {
      let st = 0;
      if (W !== 0 && (st += og({
        startIndex: 0,
        endIndex: V - 1,
        fieldName: h,
        seriesData: t
      }), V === 1)) {
        const at = t[0][h];
        typeof at != "number" && !F(at) && (nt = !0);
      }
      let lt = Math.floor(
        (H - O - 1) / r
      );
      for (let at = 0; at < lt; at++) {
        let Dt = t[V][h];
        typeof Dt == "number" && F(Dt) ? st += Dt : nt = !0, V++;
      }
      if ((H - O - 1) % r > d - 1) {
        let at = t[V][h];
        typeof at == "number" && F(at) ? st += at : nt = !0, V++;
      }
      if (V > 0) {
        V === 1 && nt === !0 && (st = NaN), m && w && S(h) && m.push(F(st));
        let at = `Total of previous ${V}${f}`;
        !S(h) && (m === void 0 || m.length === 0) && (at = `Previous ${V}`, st = "");
        const Dt = {
          className: `${u}-tooltip-series-data`,
          data: [
            ae({
              field: at,
              value: m && w ? m.join(" , ") : F(st),
              classPrefix: u,
              margin: oe,
              hasEllipsisInKey: !1
            })
          ]
        };
        !E && !w && S(h) && st !== "" && m.push(F(st)), y.push(Dt);
      }
    }
    if (W === J ? y.push({
      className: b[W].className,
      color: b[W].color,
      data: [
        ...b[W].data.slice(
          H - O,
          N - P
        )
      ]
    }) : (y.push({
      className: b[W].className,
      color: b[W].color,
      data: [
        ...b[W].data.slice(
          H - O
        )
      ]
    }), y.push(
      ...b.slice(
        W + 1,
        J
      )
    ), y.push({
      className: b[J].className,
      color: b[J].color,
      data: [
        ...b[J].data.slice(
          0,
          N - P
        )
      ]
    })), h) {
      let st = 0, lt = 0;
      if (J !== b.length - 1 && (lt += og({
        startIndex: tt,
        endIndex: t.length - 1,
        fieldName: h,
        seriesData: t
      }), st = t.length - tt, st === 1)) {
        const Qt = t[t.length - 1][h];
        Y = !(typeof Qt == "number" && F(Qt));
      }
      let at = Math.floor(
        (N - P - 1) / r
      ), Dt = Math.floor(
        b[J].data.length / r
      );
      for (let Qt = at + 1; Qt < Dt; Qt++) {
        let St = t[at + L][h];
        st++, typeof St == "number" && F(St) ? lt += St : Y = !0;
      }
      if ((N - P - 1) % r <= d - 1) {
        let Qt = t[L + at][h];
        typeof Qt == "number" && F(Qt) ? lt += Qt : Y = !0, st++;
      }
      if (st > 0) {
        st === 1 && Y && (lt = NaN), p && w && S(h) && lt !== "" && p.push(F(lt));
        let Qt = `Total of next ${st}${f}`;
        !S(h) && (p === void 0 || p.length === 0) && (Qt = `Next ${st}`, lt = "");
        const St = {
          className: `${u}-tooltip-series-data`,
          data: [
            ae({
              field: Qt,
              value: p && w ? p.join(" , ") : F(lt),
              classPrefix: u,
              margin: oe,
              hasEllipsisInKey: !1
            })
          ]
        };
        !E && !w && S(h) && lt !== "" && p.push(F(lt)), y.push(St);
      }
    }
    return n.config.includeContent && Yl(y, n, s, n.data), B ? y : {
      content: y,
      displayFormat: "normal"
    };
  } else {
    let k = Math.floor(
      H / r
    ), O = Math.floor(
      N / r
    ), P = 0, L = 0, q = 0, $ = 0, W = !1, U = !1, J = N % r, V = H % r;
    if (h) {
      if (J < d) {
        let Y = t[O][h];
        typeof Y == "number" && F(Y) ? P = Y : W = !0, $++;
      }
      if (V > d) {
        let Y = t[k][h];
        typeof Y == "number" && F(Y) ? L = Y : U = !0, q++;
      }
    }
    if (h) {
      if (k !== 0 && (L += og({
        startIndex: 0,
        endIndex: k - 1,
        fieldName: h,
        seriesData: t
      }), q += k, k === 1)) {
        const Y = t[0][h];
        typeof Y != "number" && !F(Y) && (U = !0);
      }
      if (q > 0) {
        q === 1 && U === !0 && (L = NaN), m && w && S(h) && m.push(F(L));
        let Y = `Total of previous ${q}${f}`;
        !S(h) && (m === void 0 || m.length === 0) && (Y = `Previous ${q}`, L = "");
        const nt = {
          className: `${u}-tooltip-series-data`,
          data: [
            ae({
              field: Y,
              value: m && w ? m.join(" , ") : F(L),
              classPrefix: u,
              margin: oe,
              hasEllipsisInKey: !1
            })
          ]
        };
        !E && !w && S(h) && L !== "" && m.push(F(L)), y.push(nt);
      }
    }
    if (y.push({
      className: b[k].className,
      color: b[k].color,
      data: [
        ...b[k].data.slice(
          V
        )
      ]
    }), y.push(
      ...b.slice(k + 1, O)
    ), y.push({
      className: b[O].className,
      color: b[O].color,
      data: [
        ...b[O].data.slice(
          0,
          J + 1
        )
      ]
    }), h) {
      if (O != b.length - 1) {
        if (P += og({
          startIndex: O + 1,
          endIndex: b.length - 1,
          fieldName: h,
          seriesData: t
        }), $ += b.length - O + 1, b.length - O + 1 === 1) {
          const Y = t[b.length - 1][h];
          W = !(typeof Y == "number" && F(Y));
        }
        $ += b.length - O + 1;
      }
      if ($ > 0) {
        $ === 1 && W && (P = NaN), p && w && S(h) && p.push(F(P));
        let Y = `Total of next ${$}${f}`;
        !S(h) && (p === void 0 || p.length === 0) && (Y = `Next ${$}`, P = "");
        const nt = {
          className: `${u}-tooltip-series-data`,
          data: [
            ae({
              field: Y,
              value: p && w ? p.join(" , ") : F(P),
              classPrefix: u,
              margin: oe,
              hasEllipsisInKey: !1
            })
          ]
        };
        !E && !w && S(h) && P !== "" && p.push(F(P)), y.push(nt);
      }
    }
    return n.config.includeContent && Yl(y, n, s, n.data), B ? y : {
      content: y,
      displayFormat: "normal"
    };
  }
}, gJ = (e, t = {}, i, n) => {
  let s = [], A = [], o = [], a = 0;
  const { classPrefix: r, separator: l } = t;
  let c = {
    className: `${r}-tooltip-facets-data`,
    data: []
  }, g = null;
  const h = i.layers;
  let d, u, f = 0, C, I, E, B = [], m = [];
  const p = i.config.filter.mode === "include", w = i.config.filter.fields, Q = (x) => !!(p && w?.includes(x) || !p && !w?.includes(x) || p && !w);
  let y;
  const D = i.config.splitFields;
  D && (y = Object.keys(D));
  for (let x = 0; x < e.length; x++) {
    const S = e[x];
    let b = !1, R = !1;
    if (S._disposed)
      return {
        content: [],
        displayFormat: "normal"
      };
    const G = S.getSchema({
      excludeFields: [pt.ROW_ID, ht]
    });
    if (G.length === 0 || x > h.length)
      return {
        content: [],
        displayFormat: "normal"
      };
    const T = h[x], v = T.config().encoding, H = T.axes(), N = !!H.y._config.fieldInstance._vars, M = !!H.x._config.fieldInstance._vars;
    let F = M || N;
    const k = bb(T);
    F && f >= 0 && (f += 1);
    let O = !1;
    if (x + 1 < h.length && F) {
      const ut = h[x + 1].axes(), Rt = !!ut.y._config.fieldInstance._vars, Mt = !!ut.x._config.fieldInstance._vars;
      let Ut = !1;
      (Rt && N || M && Mt) && (Ut = !0), Ut && (O = !0);
    }
    const P = i.payload.target, L = T._transformConfig, q = T.transformType(), $ = [mb, pb, Xt].includes(
      q
    ), { showStackSum: W = !0 } = i.config || {}, U = v.color.splitBy, J = 26, V = Math.floor(
      0.3 * i.chartHeight / J
    ), Y = Array.from(Object.keys(i.payload.metaData.rowFacets)) || [];
    let nt = Array.from(Object.keys(i.payload.metaData.colFacets)) || [];
    nt = nt.filter((ut) => !Y.includes(ut));
    const tt = wu(G, S, i), st = (ut, Rt, Mt) => {
      let { displayName: Ut, fn: Ne } = tt[ut];
      return Ut || (Ut = ut), ae({
        field: `${Ut}${l}`,
        value: Ne ? Ne(Rt) : Rt,
        classPrefix: r,
        margin: oe,
        fontWeight: Mt,
        typeOfValue: typeof Rt,
        hasEllipsisInKey: !1
      });
    };
    let lt = {}, at = 0, Dt = 0, Qt = 0, St = !1;
    const { x: At, y: Vt } = v, _t = hn(G, At.field) ? At.field : null, zt = hn(G, Vt.field) ? Vt.field : null, te = At.as, ei = Vt.as;
    let ue = jd({
      yField: zt,
      xField: _t,
      yFieldAs: ei,
      xFieldAs: te,
      dm: S,
      transformConf: L
    }) ? At.field : Vt.field;
    ue = hn(G, ue) ? ue : null, (ue && Y.includes(ue) || nt.includes(ue)) && k && (!Y.includes(v.x.field) && !nt.includes(v.x.field) ? ue = v.x.field : !nt.includes(v.y.field) && !Y.includes(v.y.field) ? ue = v.y.field : ue = null);
    const It = S.getRowsCount();
    if (!g) {
      const ut = S.getValueAtIndex(ue, 0);
      ut && (g = st(ue, ut, 620));
    }
    let dt;
    g && (ue === v.x.field ? (lt.field = v.y.field, dt = hn(G, lt.field) ? lt.field : null, dt && (lt.as = v.y.as, lt.type = S.getField(lt.field).type())) : (lt.field = v.x.field, dt = hn(G, lt.field) ? lt.field : null, dt && (lt.as = v.x.as, lt.type = S.getField(lt.field).type()))), dt && k && (dt === ue || Y.includes(dt) || nt.includes(dt)) && (dt = null);
    const Jt = wb(v);
    k && _b({
      headerField: ue,
      secondaryField: dt,
      rowFacets: Y,
      columnFacets: nt,
      colorSplitField: U,
      retinalAndDetailFieldsObj: Jt
    });
    const gt = Z(Jt, "color", 0), xt = Object.values(
      Jt
    ).flat();
    f > 1 && u.toString() !== xt.toString() && (F = !1, o.length !== 0 ? A.push(...o) : A.push(...s)), u = xt, (!F || F && f === 1) && (s = []);
    let Ft = {}, se = {};
    Object.entries(Jt).forEach(([ut, Rt]) => {
      v[ut]?.as === "discrete" || S.getField(Rt[0]).type() === "dimension" ? Ft[ut] = Rt[0] : se[ut] = Rt[0];
    });
    const Te = Db(
      S,
      [...xt, dt, U].filter(
        (ut) => ut
      ),
      {
        sortedValues: T._transformedData.getSortedGroupByValues(),
        sortField: T._transformedData.getSortField()
      }
    ), Ge = Sb(
      Ft,
      se,
      dt ? lt : null
    );
    let Lt = dt ? Ge[dt] - 1 : null;
    const Pt = {};
    [
      .../* @__PURE__ */ new Set([
        ...Y,
        ...nt,
        ue,
        ...Array.from(Object.keys(Te[0]))
      ])
    ].forEach((ut) => {
      y.includes(ut) ? Pt[D[ut].splitBy.field] = [!0, ut] : Pt[ut] = [!1];
    }), Y.length && Y.forEach((ut) => {
      const Rt = S.getValueAtIndex(ut, 0);
      let { displayName: Mt, fn: Ut } = tt[ut];
      Q(Mt) && me(ut, Pt) && (ut in D && Q(D[ut].splitBy.field) && (Mt = S.getValueAtIndex(
        D[ut].splitBy.field,
        0
      )), c.data.push(
        ae({
          field: `${Mt}${l}`,
          value: Ut ? Ut(Rt) : Rt,
          classPrefix: r,
          margin: oe,
          typeOfValue: "number",
          hasEllipsisInKey: !1
        })
      ));
    }), nt.length && nt.forEach((ut) => {
      const Rt = S.getValueAtIndex(ut, 0);
      let { displayName: Mt, fn: Ut } = tt[ut];
      Q(Mt) && me(ut, Pt) && (ut in D && Q(D[ut].splitBy.field) && (Mt = S.getValueAtIndex(
        D[ut].splitBy.field,
        0
      )), c.data.push(
        ae({
          field: `${Mt}${l}`,
          value: Ut ? Ut(Rt) : Rt,
          classPrefix: r,
          margin: oe,
          typeOfValue: "number",
          hasEllipsisInKey: !1
        })
      ));
    });
    const yn = !!Object.entries(
      Ft
    ).length;
    if (dt && lt.type === "measure" && It > 1 && (yn || $) && W) {
      const ut = hs(dt, S);
      let { displayName: Rt, fn: Mt } = tt[dt], Ut;
      if (Q(dt) && me(dt, Pt) ? (dt in D && Q(D[dt].splitBy.field) && (Rt = S.getValueAtIndex(
        D[dt].splitBy.field,
        0
      )), at++, a > 0 && (b = !0), Ut = ae({
        field: `Total ${Rt}${l}`,
        value: Mt ? Mt(ut) : ut,
        classPrefix: r,
        margin: oe,
        fontWeight: 620,
        isTotal: !(x > 0),
        typeOfValue: typeof value,
        hasEllipsisInKey: !1
      })) : F && f === 1 && (Ut = ae({
        field: `Total ${l}`,
        value: "",
        classPrefix: r,
        margin: oe,
        fontWeight: 620,
        isTotal: !(x > 0),
        typeOfValue: typeof value,
        hasEllipsisInKey: !1
      })), x > 0)
        if (F && f > 1) {
          const ii = s[d].className.includes("total-value") ? s[d].data : s[d].data[0].data;
          if (Q(dt) && me(dt, Pt)) {
            dt in D && Q(D[dt].splitBy.field) && (Rt = S.getValueAtIndex(
              D[ii].splitBy.field,
              0
            ));
            const Le = ii[0].value.slice(0, -1), Ue = ii[1].data[0].value;
            ii[0].value = Le[Le.length - 1] === " " ? Le + `${Rt}:` : Le + `, ${Rt}:`, ii[1].data[0].value = Ue === "" ? Ue + `${Mt ? Mt(ut) : ut}` : Ue + ` , ${Mt ? Mt(ut) : ut}`;
          }
        } else
          s.push({
            className: `${r}-tooltip-series-data`,
            data: Q(dt) && me(dt, Pt) ? [Ut] : []
          }), R = !0, d = s.length - 1;
      else
        Ut && s.push(Ut), F && (d = s?.findLastIndex(
          (Ne) => Ne.className.includes("total-value")
        ));
    }
    let fe = [];
    Object.values(Jt).forEach((ut) => {
      fe.push(ut[0]);
    }), fe = [...new Set(fe)];
    const [Me, on] = EE(
      fe,
      (ut) => ut && S.getField(ut).type() === "dimension"
    );
    let $t;
    if (gt != null && Me.includes(Ft.color) && Me.length > 1) {
      St = !0;
      const ut = xb({
        seriesData: Te,
        sortField: T._transformedData.getSortField() || gt,
        secondaryField: dt
      });
      let Rt, Mt, Ut, Ne, ii = -1;
      ut.forEach((Le, Ue) => {
        if (Le[gt]) {
          ii += 1, Mt = Le[gt], Q(gt) && me(gt, Pt) ? (Ne = 1, Dt++) : Ne = 0, Ue !== 0 && (!F || F && f === 1) && s.push(Rt);
          let We;
          const ge = Le[gt], kt = H.color;
          if (v.color.splitBy) {
            const Fe = Le[v.color.splitBy];
            We = kt[Fe] || kt;
          } else
            We = kt;
          const Ie = ge && We.getColor(ge);
          let { displayName: os, fn: ee } = tt[gt];
          (!F || F && f === 1) && (Rt = {
            className: `${r}-tooltip-series-data`,
            color: Ie,
            data: Q(gt) && me(gt, Pt) ? [
              ae({
                field: `${os}${l}`,
                value: ee ? ee(Le[gt]) : Le[gt],
                classPrefix: r,
                margin: oe,
                fontWeight: 600,
                typeOfValue: typeof Le[gt],
                hasEllipsisInKey: !1
              })
            ] : []
          });
        } else {
          const We = new Array(Object.entries(Le).length);
          Qt = We.length, Object.entries(Le).forEach(([kt, Ie]) => {
            const os = Ge[kt];
            let { displayName: ee, fn: Fe } = tt[kt], an = !1, qe = null;
            if ($ && dt && kt === dt && (lt.as === "continuous" || lt.type === "measure")) {
              const je = hs(
                kt,
                S,
                (rt) => rt >= 0
              ), Et = hs(kt, S, (rt) => rt < 0);
              qe = `(${(Ie >= 0 ? Ie * 100 / je : Ie * 100 / Et).toFixed(2)} %)`;
            }
            It > 1 && (an = jh({
              dimensionEncodings: Me,
              secondaryField: dt,
              measureEncodings: on,
              row: Le,
              target: P,
              fieldInf: tt,
              colorFieldValue: Mt
            })), an && (Ut = !0);
            let wn = s.findIndex(
              (je) => je.className.includes("series-data")
            );
            if (kt === dt && F && f > 1) {
              s[wn]?.data[0]?.data[0]?.value.includes("Total") && (wn += 1);
              const je = wn !== 0 ? s.slice(wn)[ii]?.data[Ne + Lt]?.data : s[ii]?.data[Ne + Lt]?.data;
              Ne += Lt + 1;
              const Et = je?.[0];
              let j;
              if (Q(kt) && je && me(kt, Pt)) {
                kt in D && Q(D[kt].splitBy.field) && (ee = S.getValueAtIndex(
                  D[kt].splitBy.field,
                  0
                ));
                const rt = Et?.value.slice(0, -1);
                Et.value = rt === "" ? rt + `${ee}:` : rt + `, ${ee}:`, j = ae({
                  field: `${ee}${l}`,
                  value: Fe ? Fe(Ie) : Ie,
                  classPrefix: r,
                  margin: oe,
                  isSelected: an,
                  stackPercent: qe,
                  typeOfValue: isNaN(Ie) ? typeof Fe(Ie) : typeof Ie
                });
                const Bt = je[1];
                if (j.data[1].data[0].style["margin-left"] = "0px", Bt.data.length > 1) {
                  const he = Bt.data.length;
                  Bt.data[he - 1].value += ",";
                } else
                  Bt.data[0].value !== "" && (Bt.data[0].value += " , ");
                Bt.data.push(...j.data[1].data);
              }
            } else if (!F || F && f === 1) {
              let je;
              Q(kt) && me(kt, Pt) ? (kt in D && Q(D[kt].splitBy.field) && (ee = S.getValueAtIndex(
                D[kt].splitBy.field,
                0
              )), je = ae({
                field: `${ee}${l}`,
                value: Fe ? Fe(Ie) : Ie,
                classPrefix: r,
                margin: oe,
                isSelected: an,
                stackPercent: qe,
                typeOfValue: isNaN(Ie) ? typeof Fe(Ie) : typeof Ie
              })) : ee === dt && O && (je = ae({
                field: `${l}`,
                value: "",
                classPrefix: r,
                margin: oe,
                isSelected: an,
                // stackPercent: stackPercent,
                typeOfValue: typeof Ie == "number" ? typeof Ie : typeof Fe(Ie)
              })), We[os - 1] = je;
            }
          });
          const ge = We.filter(
            (kt) => kt !== void 0 && Q(kt.data[0].value.slice(0, -1))
          );
          Ut && ($t = Dt, Ut = !1), (!F || F && f === 1) && (Dt += ge.length, Rt.data.push(...We));
        }
      }), (!F || F && f === 1) && s.push(Rt);
    } else
      Te.forEach((ut, Rt) => {
        let Mt, Ut = !1;
        const Ne = ut[gt], ii = H.color;
        if (v.color.splitBy) {
          const ge = ut[v.color.splitBy];
          Mt = ii[ge] || ii;
        } else
          Mt = ii;
        const Le = Ne && Mt.getColor(Ne), Ue = Object.entries(ut).length;
        Qt = Ue, It > 1 && (Ut = jh({
          dimensionEncodings: Me,
          secondaryField: dt,
          measureEncodings: on,
          row: ut,
          target: P,
          fieldInf: tt
        })), Ut && ($t = Object.entries(ut).length * Rt);
        let We;
        (!F || F && f === 1) && (We = {
          className: `${r}-tooltip-series-data`,
          color: Le,
          data: new Array(Ue)
        }), Object.entries(ut).forEach(([ge, kt]) => {
          const Ie = Ge[ge];
          if (Ie === void 0)
            return;
          let os = null;
          if ($ && dt && ge === dt && (lt.as === "continuous" || lt.type === "measure")) {
            const qe = hs(
              ge,
              S,
              (Et) => Et >= 0
            ), wn = hs(ge, S, (Et) => Et < 0);
            os = `(${(kt >= 0 ? kt * 100 / qe : kt * 100 / wn).toFixed(2)} %)`;
          }
          let { displayName: ee, fn: Fe } = tt[ge], an = s.findIndex(
            (qe) => qe.className.includes("series-data")
          );
          if (ge === dt && F && f > 1) {
            s[an]?.data[0]?.data[0]?.value.includes("Total") && (an += 1);
            const qe = an !== 0 ? s.slice(an)[Rt]?.data[Lt]?.data : s[Rt]?.data[Lt]?.data, wn = qe?.[0];
            let je;
            if (Q(ge) && qe && me(ge, Pt)) {
              ge in D && Q(D[ge].splitBy.field) && (ee = S.getValueAtIndex(
                D[ge].splitBy.field,
                0
              ));
              const Et = wn?.value.slice(0, -1);
              wn.value = Et === "" ? Et + `${ee}:` : Et + `, ${ee}:`, je = ae({
                field: `${ee}${l}`,
                value: Fe ? Fe(kt) : kt,
                classPrefix: r,
                margin: oe,
                isSelected: Ut,
                stackPercent: os,
                typeOfValue: isNaN(kt) ? typeof Fe(kt) : typeof kt
              });
              const j = qe[1];
              if (je.data[1].data[0].style["margin-left"] = "0px", j.data.length > 1) {
                const rt = j.data.length;
                j.data[rt - 1].value += ",";
              } else
                j.data[0].value !== "" && (j.data[0].value += " , ");
              j.data.push(...je.data[1].data);
            }
          } else if (!F || F && f === 1) {
            let qe;
            Q(ge) && me(ge, Pt) ? (ge in D && Q(D[ge].splitBy.field) && (ee = S.getValueAtIndex(
              D[ge].splitBy.field,
              0
            )), qe = ae({
              field: `${ee}${l}`,
              value: Fe ? Fe(kt) : kt,
              classPrefix: r,
              margin: oe,
              isSelected: Ut,
              stackPercent: os,
              typeOfValue: typeof kt == "number" ? typeof kt : typeof Fe(kt)
            })) : ee === dt && O && (qe = ae({
              field: `${l}`,
              value: "",
              classPrefix: r,
              margin: oe,
              isSelected: Ut,
              // stackPercent: stackPercent,
              typeOfValue: typeof kt == "number" ? typeof kt : typeof Fe(kt)
            })), We.data[Ie - 1] = qe;
          }
        }), (!F || F && f === 1) && (Dt += We.data.length, s.push(We));
      });
    if (f === 1 && (C = at, E = Dt, I = $t), at = F ? C : at, Dt = F ? E : Dt, $t = F ? I : $t, at + Dt > V) {
      let ut = JSON.parse(JSON.stringify(s)), Rt = ut.findIndex(
        (Ut) => Ut.className.includes("series-data")
      );
      (s[Rt]?.data.length === 0 || s[Rt]?.data[0]?.data[0]?.value.includes("Total")) && (Rt += 1);
      const Mt = ut.slice(0, Rt)[0]?.data[0];
      Mt?.value === "Total :" && (Mt.value = ""), ut.slice(Rt).forEach(
        (Ut) => Ut.data = Ut.data.filter(
          (Ne) => Ne !== null && Ne?.data[0]?.value !== ":"
        )
      ), o = Mb({
        seriesData: Te,
        content: ut,
        context: i,
        config: t,
        divContentHeight: J,
        headRowsCount: at,
        countOfRows: Dt,
        rowsCountOfEachSeriesData: Qt,
        selectedDataIndex: $t,
        isColorSplitByDimension: St,
        fieldInf: tt,
        secondaryField: dt,
        secondaryFieldIndex: Lt,
        classPrefix: r,
        separator: l,
        percentage: 0.3,
        displayTotals: b,
        isDualAxisTooltip: !F,
        isCompositeFunction: !0,
        arrayOfPrevTotals: B,
        arrayOfNextTotals: m,
        isLastSharedAxes: F && !O,
        displayTotalsForShared: R
      }), (!F || F && !O) && (A.push(...o), o = []);
    } else if (!F || F && !O) {
      let ut = s.findIndex((Mt) => Mt.className.includes("series-data"));
      (s[ut]?.data.length === 0 || s[ut]?.data[0]?.data[0]?.value.includes("Total")) && (ut += 1);
      const Rt = s.slice(0, ut)[0]?.data[0];
      Rt?.value === "Total :" && (Rt.value = ""), s.slice(ut).forEach(
        (Mt) => Mt.data = Mt.data.filter(
          (Ut) => Ut !== void 0 && Ut?.data[0]?.value !== ":"
        )
      ), A.push(...s);
    }
    a++;
  }
  const _ = g.data[0].value.slice(0, -1);
  return Q(_) && A.unshift(g), A.unshift(c), A.filter((x) => !!x), i.config.includeContent && Yl(s, i, t, e, n), {
    content: A,
    displayFormat: "normal"
  };
}, hJ = (e, t = {}, i, n) => {
  let s = null;
  const A = i.layers, o = i.config.filter.mode === "include", a = i.config.filter.fields, r = (d) => !!(o && a?.includes(d) || !o && !a?.includes(d) || o && !a);
  if (t.isCompositeTooltip)
    return gJ(
      e,
      t,
      i,
      n
    );
  const { classPrefix: l, separator: c } = t;
  let g = { className: `${l}-tooltip-series-data`, data: [] };
  for (let d = 0; d < e.length; d++) {
    const u = e[d];
    if (u._disposed)
      return {
        content: [],
        displayFormat: "normal"
      };
    const f = u.getSchema({
      excludeFields: [pt.ROW_ID, ht]
    });
    if (f.length === 0 || d > A.length)
      return {
        content: [],
        displayFormat: "normal"
      };
    const C = wu(f, u, i), I = (R, G) => {
      const { displayName: T, fn: v } = C[R];
      return ae({
        field: `${T}${c}`,
        value: v ? v(G) : G,
        classPrefix: l,
        margin: oe,
        typeOfValue: typeof G,
        hasEllipsisInKey: !1
      });
    }, E = i.targetLayer, B = E.config().encoding, m = E._transformConfig, { x: p, y: w } = B, Q = hn(f, p.field) ? p.field : null, y = hn(f, w.field) ? w.field : null, D = p.as, _ = w.as;
    let S = jd({
      yField: y,
      xField: Q,
      yFieldAs: _,
      xFieldAs: D,
      dm: u,
      transformConf: m
    }) ? p.field : w.field;
    if (S = hn(f, S) ? S : null, !s) {
      const R = u.getValueAtIndex(S, 0);
      R && (s = I(S, R));
    }
    const b = () => {
      const R = [];
      return f.filter(({ name: G }) => !S || G !== S).forEach(({ name: G }) => {
        R.push(
          I(G, u.getValueAtIndex(G, 0))
        );
      }), R;
    };
    g.data.push(...b());
  }
  g.data = [...g.data].filter((d) => !!d);
  const h = s.data[0].value.slice(0, -1);
  return i.config.includeContent && Yl(g, i, t, e, n), {
    content: r(h) ? [s, g] : [g],
    displayFormat: "normal"
  };
}, dJ = (e, t, { showMultipleMeasures: i, fields: n }) => {
  const s = e.getMeasures(), A = i ? s : n || s.slice(0, 1), o = {};
  if (A.length) {
    const a = e.groupBy([]);
    a.isEmpty() || A.forEach((r) => {
      const l = a.getValueAtIndex(r, 0);
      o[r] = l;
    }), a.dispose();
  }
  return o;
}, e0 = (e, t) => {
  const { TEMPORAL: i, CONTINUOUS: n, CATEGORICAL: s, BINNED: A } = K.FieldSubtype, o = e.targetLayer, a = Object.keys(o.metaInf().facets || {}), { encoding: r } = o.config(), l = Object.values(Gt).map((d) => Z(r, d, "field")).filter((d) => !!d).flat(), c = t.getSchema().reduce((d, u) => (d.set(u.name, u.subtype), d), /* @__PURE__ */ new Map()), g = [a, l].reduce(
    (d, u) => (u.forEach(
      (f) => c.get(f) === s && d.add(f)
    ), u.forEach(
      (f) => c.get(f) === i && d.add(f)
    ), u.forEach(
      (f) => c.get(f) === n && d.add(f)
    ), u.forEach(
      (f) => c.get(f) === A && d.add(f)
    ), d),
    /* @__PURE__ */ new Set()
  ), h = r.color.splitBy;
  return [...g, h].filter((d) => d);
}, uJ = {
  [rJ]: (e, t) => {
    const i = e.dataModel.project(
      e0(t.context, e.dataModel)
    ), n = i.getSchema({
      excludeFields: [pt.ROW_ID, ht]
    }), { selectionSet: s, config: A } = t.context, { classPrefix: o } = t.metaInfo, { showMultipleMeasures: a } = A, r = s.entrySet.length, l = dJ(
      i,
      s.entrySet,
      A
    ), c = [
      {
        className: `${o}-tooltip-row`,
        data: [
          {
            value: `${r}`,
            style: {
              "font-weight": "bold"
            }
          },
          "Items Selected"
        ]
      }
    ];
    return Object.keys(l).forEach((h) => {
      const { defAggFn: d } = i.getField(h).schema(), u = l[h], f = wu(n, i, t.context), { fn: C } = f[h], I = [
        `(${d.toUpperCase()})`,
        `${dc(i, h)}:`,
        {
          value: C(parseFloat(u)),
          style: {
            "font-weight": "bold"
          },
          className: `${o}-tooltip-value`
        }
      ];
      a ? c.push({
        className: `${o}-tooltip-row`,
        data: I
      }) : c[0].data.push(...I);
    }), c;
  },
  [DB]: (e, t) => {
    const { layers: i, includeDataFromAllLayers: n, hasPointsInBackground: s } = t.context, A = i.some(
      (o) => o._transformedData._config && o._transformedData._config.groupBy && o._transformedData._config.groupBy.length
    );
    if (n && (s || A))
      return hJ(
        e.secondaryDatamodels,
        { ...t.metaInfo, isCompositeTooltip: A },
        t.context,
        t.tooltipInst
      );
    {
      const o = e.dataModel.project(
        e0(t.context, e.dataModel)
      );
      return cJ(
        o,
        t.metaInfo,
        t.context,
        t.tooltipInst
      );
    }
  }
}, i0 = {
  [DB]: (e, t) => wt(e, t),
  default: (e) => wt(e, {})
}, fJ = (e) => [
  "formatter",
  "dataTransform",
  "order",
  "fields",
  "filter",
  "includeContent",
  "splitFields"
].reduce((t, i) => (i in e && (t[i] = e[i]), t), {}), IJ = (e, t) => {
  const i = t._strategies, n = Object.assign({}, e);
  for (const s in i)
    n[s] = wt(
      i0[s],
      i0.default
    )(e[s], e);
  return n.highlightSummary = et(
    n.highlightSummary,
    fJ(e)
  ), n;
};
class Nb extends Ir {
  constructor(...t) {
    super(...t), this._tooltips = {}, this._strategies = et({}, uJ), this._strategy = DB;
  }
  static defaultConfig() {
    return {
      padding: 5,
      offset: {
        x: 0,
        y: 0
      },
      highlightSummary: {
        order: 1,
        dataTransform: (t) => t,
        splitFields: {},
        filter: { mode: "include" }
      },
      selectionSummary: {
        order: 0,
        dataTransform: (t) => t
      },
      valueParser: (t) => t
    };
  }
  static formalName() {
    return v5;
  }
  config(...t) {
    if (t.length) {
      const i = this._config = et(
        this._config,
        IJ(t[0], this)
      ), n = this._strategies;
      for (const s in n) {
        const A = i[s].formatter;
        this.setStrategy(s, A);
      }
      return this;
    }
    return this._config;
  }
  apply(t, i, n) {
    const s = t && t.entrySet.model;
    return i.criteria === null || !s ? (this.hide(n, null), this) : (this.createTooltip(
      Object.assign(
        {},
        {
          payload: i,
          selectionSet: t,
          options: n
        }
      ),
      null,
      0
    ), this);
  }
  static target() {
    return "all";
  }
  hide(t) {
    const i = this._tooltips;
    for (const n in i)
      if ({}.hasOwnProperty.call(i, n)) {
        const s = i[n];
        t.contents.forEach(({ name: o }) => {
          s.content(o, null);
        }), Object.keys(s._contents).length || s.hide();
      }
  }
  getPlotPointsFromIdentifiers(t, i = {}) {
    const n = super.plotPointsFromIdentifiers(
      t,
      {
        getBBox: !0,
        target: this.firebolt.sourceCanvas() !== i.sourceInfo.canvasId ? null : i.target
      },
      i.sourceInfo.layerId
    );
    return n && n[0];
  }
  createTooltip(t = {}, i, n, s) {
    const A = this.drawingContext(), o = this.sourceInfo(), a = this.config(), { payload: r, selectionSet: l, options: c } = t, g = document.body, h = A.htmlContainer.getBoundingClientRect(), d = document.querySelector("html").offsetHeight, u = document.querySelector("html").clientWidth, f = document.querySelector("html").clientHeight, C = window.pageXOffset || document.documentElement.scrollLeft, I = window.pageYOffset || document.documentElement.scrollTop, E = h.left + C, B = h.top + I, { contents: m = [{ name: "highlightSummary" }] } = c;
    this._tooltips[n] ? this._tooltips[n].getTooltipType() === "selectionSummary" && m.length === 2 && (this._tooltips[n].dispose(), this._tooltips[n] = new nr(
      g,
      A.svgContainer,
      {
        action: m,
        config: a
      }
    )) : this._tooltips[n] = new nr(
      g,
      A.svgContainer,
      {
        action: m,
        config: a
      }
    );
    const p = this._tooltips[n];
    p.chartHeight = d;
    const { entrySet: w } = l, Q = w.uids, y = this.getPlotPointsFromIdentifiers(Q, r);
    i = wt(i, y, p._target);
    const D = a.padding, { showInPosition: _, position: x } = r;
    m.forEach(({ name: S, setTransform: b, formatter: R }) => {
      const {
        includeDataFromAllLayers: G,
        entryExitSetsByLayerId: T,
        hasPointsInBackground: v
      } = r.metaData || {}, { fields: H, dataTransform: N } = a[S], M = b ? b(l, r, this) : l;
      if (M && M.entrySet.model) {
        const F = s || M.entrySet.model, k = N(F, H, this), O = Object.assign({}, o, {
          payload: r,
          firebolt: this.firebolt,
          detailFields: [],
          timeDiffs: o.timeDiffs,
          selectionSet: M,
          config: a[S],
          valueParser: a.valueParser,
          useUTC: o.useUTC,
          hasPointsInBackground: v,
          entryExitSetsByLayerId: T,
          includeDataFromAllLayers: G,
          fieldFormatters: a.fieldFormatters,
          chartHeight: d
        }), P = R || this._strategies[S];
        p.context(O), p.content(S, k, {
          formatter: P,
          order: a[S].order,
          className: a[S].className,
          container: p.container()
        });
      } else
        p.content(S, null);
    }), p.config(this.config()).extent({
      x: 0,
      y: 0,
      width: u,
      height: f
    }).offset({
      x: E + (a.offset.x || 0),
      y: B + (a.offset.y || 0)
    }), _ ? p.position(x.x + D, x.y + D) : i ? p.positionRelativeTo(
      {
        x: i.x,
        y: i.y,
        width: i.width || 0,
        height: i.height || 0
      },
      {
        orientation: a.orientation
      }
    ) : p.hide();
  }
  dispose() {
    Object.values(this._tooltips).forEach((t) => t.remove());
  }
  shouldApplyOnRenderAfterScrolling() {
    return !1;
  }
}
const CJ = (e, t, i) => {
  let n, s, A, o, a;
  const l = e.length, c = (g, h, d) => {
    A = g.x, o = g.width, n = g.y, s = g.height;
    const u = n + s, f = A + o;
    i ? (d ? n < h.y + h.height : u > h.y) && (h.y = d ? g.y - h.height - 5 : u + 5) : (d ? A < h.x + h.width : f > h.x) && (h.x = d ? g.x - h.width - 5 : f + 5);
  };
  for (e.sort((g, h) => i ? g.y - h.y : g.x - h.x), a = 0, a = 0; a < l - 1; a++)
    c(e[a], e[a + 1]);
  if (e[a].y + e[a].height > t.height || e[a].x + e[a].width > t.width)
    for (i ? e[a].y -= e[a].height + e[a].y - t.height : e[a].x -= e[a].width + e[a].x - t.width, a = l - 1; a > 0; a--)
      c(e[a], e[a - 1], !0);
  return e;
};
class EJ extends Nb {
  static formalName() {
    return G5;
  }
  static target() {
    return "visual-unit";
  }
  createTooltip(t) {
    let i = 0, n = 0;
    const s = this.config(), { strategy: A = "highlightSummary", selectionSet: o, payload: a } = t, { DIMENSION: r } = K.FieldType, l = o.entrySet.model, c = this.firebolt.context, g = this.drawingContext(), h = this._tooltips, d = {
      width: g.width,
      height: g.height
    }, u = s.padding, f = [], I = c.getSourceInfo().fields, B = !!(I.x[0] ? I.x[0].type() === r : !1), m = [], p = l.getUids();
    f.push(
      ...p.map(
        (Q) => l.select({
          field: pt.ROW_ID,
          value: Q,
          operator: "eq"
        })
      )
    );
    const w = {};
    for (let Q = 0, y = f.length; Q < y; Q++) {
      const D = f[Q], _ = this.getPlotPointsFromIdentifiers(
        o.entrySet.uids,
        a
      );
      super.createTooltip(t, _, Q, D);
      const x = this._tooltips[Q];
      w[Q] = this._tooltips[Q];
      const S = x._position, b = x._tooltipContainer.node().getBoundingClientRect();
      if (i += b.height + u, n += b.width + u, B ? i > g.height : n > g.width)
        break;
      S && m.push({
        x: S.x,
        y: S.y,
        width: b.width,
        height: b.height,
        tooltip: x
      });
    }
    for (const Q in h)
      if (!w[Q]) {
        const y = h[Q];
        y.content(A, null), y.getContents().length || (y.remove(), delete h[Q]);
      }
    return m.length && CJ(m, d, B), m.forEach(
      (Q) => Q.tooltip.position(Q.x, Q.y, {
        repositionArrow: !0
      })
    ), this;
  }
  hide(t) {
    const i = this._tooltips;
    for (const n in i)
      if ({}.hasOwnProperty.call(i, n)) {
        const s = t.strategy || this._strategy;
        i[n].content(s, null), i[n].hide();
      }
  }
}
class BJ extends Ir {
  static defaultConfig() {
    return {
      className: `${Pg}-crossline-group`,
      bandClass: `${Pg}-crossband`,
      lineClass: `${Pg}-crossline`
    };
  }
  static formalName() {
    return T5;
  }
  apply(t, i) {
    let n, s, A, o;
    const { className: a, bandClass: r, lineClass: l } = this.config(), { DIMENSION: c } = K.FieldType, g = t.entrySet.length, h = t.entrySet.model, d = this.drawingContext();
    if (i.criteria === null || !g)
      return this.hide(), this;
    const u = this.firebolt.context.getSourceInfo(), f = u.axes, C = u.fields, I = Wd(i.fields, h.getFieldNames()), E = d.sideEffectGroup, B = h.getRowsCount(), m = [];
    if (I.forEach((p) => {
      const w = [];
      for (let y = 0; y < B; y++)
        w.push(h.getValueAtIndex(p, y));
      const Q = [
        ["x", 0],
        ["x", 1],
        ["y", 0],
        ["y", 1]
      ].find((y) => {
        const D = C[y[0]][y[1]];
        return D && D.type() === c && D.getMembers().indexOf(p) !== -1;
      });
      if (Q !== void 0 && w.length) {
        const y = Q[0], D = f[y][Q[1]], _ = w[0];
        s = D.getUnitWidth() || 0;
        const x = D.isYAxis() && D.constructor.type() === "linear" ? -(s / 2) : s / 2;
        A = D.getScaleValue(_) + x + d.xOffset;
        let S = this.firebolt.context.layers();
        if (S = S.filter((b) => !!b.config().crossline), S.length) {
          const b = Math.max(
            ...S.map((H) => H.getPlotSpan()[y])
          ), R = Math.max(
            ...S.map((H) => H.getPlotPadding()[y])
          );
          n = d.height, o = d.width;
          const G = A - b / 2 - R / 2, T = A + b / 2 + R / 2, v = {};
          y === "y" ? v.d = `M 0 ${G} L 0 ${T} L ${o} ${T} L ${o} ${G} Z` : v.d = `M ${G} 0 L ${T} 0 L ${T} ${n} L ${G} ${n} Z`, v.className = b ? r : l, !isNaN(A) && m.push(v);
        }
      }
    }), m.length) {
      const p = this.createElement(E, "g", [1], a);
      this.createElement(p, "path", m).attr("d", (Q) => Q.d).style("pointer-events", "none").attr("class", (Q) => Q.className);
    }
    return this;
  }
  hide() {
    const t = this.config().className, i = this.drawingContext();
    X(i.sideEffectGroup).selectAll(`.${t}`).remove();
  }
  static target() {
    return "visual-unit";
  }
}
class mJ extends pe {
  constructor(...t) {
    super(...t), this._entryModel = null;
  }
  static formalName() {
    return "filter";
  }
  static target() {
    return "visual-group";
  }
  static mutates() {
    return !0;
  }
  apply(t, i, n = {}) {
    const s = this.firebolt, A = s.getUnitDataModels(i.action), o = s.getLayerDataModels(i.action), a = t.entrySet.model;
    return this._entryModel === a ? this : (this._entryModel = a, a ? s.data(
      a,
      {
        unitDataModels: A,
        layerDataModels: o
      },
      n
    ) : s.resetData(n), this);
  }
  shouldApplyOnRenderAfterScrolling() {
    return !1;
  }
}
class pJ extends pe {
  static formalName() {
    return wB;
  }
  static target() {
    return "visual-unit";
  }
  apply(t, i) {
    const n = this.firebolt.context, s = t && t.entrySet.model, A = s && s.getData().data;
    let o = A && A.length ? A[0] : [];
    if (i.target) {
      const l = i.target, c = l[0], g = s && s.getRowsCount();
      for (let h = 0; h < g; h++)
        if (c.every((u, f) => K.getActualValue(
          s.getValueAtIndex(u, h)
        ) === K.getActualValue(l[1][f]))) {
          o = A[h];
          break;
        }
    }
    const { x: a = [], y: r = [] } = n.axes();
    return [...a, ...r].forEach((l) => {
      if (l.constructor.type() === "band") {
        const {
          useExternalCSS: c,
          ticks: {
            labels: {
              style: g,
              "&:highlight": { style: h }
            }
          }
        } = l.config();
        let d = null;
        s && (d = o[s.getFieldIndex(l.config().field)]);
        const { selectionSet: u, rejectionSet: f } = l.getTicksBasedOnData(d);
        if (u) {
          const I = u.selectAll("text");
          I.classed("muze-axis-ticks-highlight", !0), c || Object.entries(h).forEach(([E, B]) => {
            I.style(E, B);
          });
        }
        const C = f.selectAll("text");
        C.classed("muze-axis-ticks-highlight", !1), c || Object.entries(g).forEach(([I, E]) => {
          C.style(I, E);
        });
      }
    }), this;
  }
  shouldApplyOnRenderAfterScrolling() {
    return !1;
  }
}
const n0 = (e, t, i = "muze-facet-fadeout") => {
  e.forEach((n, s) => {
    const A = t[s];
    n.forEach((o) => {
      X(o.mount()).classed(
        i,
        !A.length
      );
    });
  });
}, ag = (e, t, i = "muze-axis-fadeout") => {
  e.forEach((n, s) => {
    const A = t[s], o = n.source().domain();
    n.source().constructor.type() === "band" ? o.forEach((a) => {
      n.source().getTicksBasedOnData(a).selectionSet?.each(function() {
        X(this).classed(
          i,
          !A.includes(a)
        );
      });
    }) : X(n.mount()).classed(
      i,
      !t[s].length
    );
  });
};
class QJ extends pe {
  static formalName() {
    return "facet-axis-highlighter";
  }
  static target() {
    return "visual-group";
  }
  apply(t, i, n) {
    const A = this.firebolt.context.composition().visualGroup.matrix(), o = A.geom().getXYDomains({
      unionAxisDomainPerPage: !0
    }), a = bl(o.x), r = a.map((d) => d[0]), l = a.map((d) => d[1]);
    n0(
      A.column()._matrices.headers._cells.top,
      r,
      n.className
    ), ag(A.column()._matrices.axes._cells.bottom, r), ag(A.column()._matrices.axes._cells.top, l);
    const c = bl(o.y), g = c.map((d) => d[0]), h = c.map((d) => d[1]);
    n0(
      A.row()._matrices.headers._cells.left,
      g,
      n.className
    ), ag(
      A.row()._matrices.axes._cells.left,
      g,
      n.className
    ), ag(
      A.row()._matrices.axes._cells.right,
      h,
      n.className
    );
  }
  shouldApplyOnRenderAfterScrolling() {
    return !0;
  }
}
class yJ extends pe {
  static formalName() {
    return L5;
  }
  static target() {
    return "visual-unit";
  }
  apply() {
    return this;
  }
  shouldApplyOnRenderAfterScrolling() {
    return !1;
  }
}
const xB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AxisLabelHighLighter: pJ,
  Crossline: BJ,
  FacetAxisHighlighter: QJ,
  FilterEffect: mJ,
  FragmentedTooltip: EJ,
  SHOW_CONTEXT_MENU: yJ,
  SelectionBox: J5,
  Tooltip: Nb
}, Symbol.toStringTag, { value: "Module" })), s0 = (e) => {
  const t = {};
  for (const i in e) {
    const n = e[i];
    t[n.formalName()] = n;
  }
  return t;
}, wJ = {
  behaviours: rl(s0(yB)),
  physicalActions: rl(Bb),
  sideEffects: rl(s0(xB))
};
class DJ extends sn {
  static formalName() {
    return "menuItemSelect";
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
class xJ extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return "invoke-menu-item-callback";
  }
  apply(t, { data: i, metaInfo: n }) {
    i.isDisabled || i.onClick(i, n);
  }
}
const SJ = (e, t) => {
  let i = e._cacheMap = {};
  return (n) => {
    if (i = e._cacheMap, !i[n]) {
      const s = t.getUids(), A = t.getRowsCount(), o = {};
      for (let a = 0; a < A; a++) {
        const r = n.map((l) => t.getValueAtIndex(l, a));
        !o[r] && (o[r] = []), o[r].push(s[a]);
      }
      i[n] = o;
    }
    return i[n];
  };
};
class _J extends Yo {
  constructor(...t) {
    super(...t);
    const i = this._actions.behavioural, n = [
      i.highlight,
      i.filter
    ];
    for (const s in i)
      i[s].isImplicit() || n.forEach((A) => {
        const o = `${s}:${A.formalName()}`;
        i[o] = new A.constructor(
          this,
          o
        ), i[o].isReactionBehaviour(!0);
      });
    this._sideEffects.tooltip.disable(), this._propagationDms = {}, this._interactionStates = /* @__PURE__ */ new Map(), this._appliedInteractions = /* @__PURE__ */ new Map();
  }
  target() {
    return "visual-layer";
  }
  createSelectionSet(...t) {
    return super.createSelectionSet(...t), this._dimsMapGetter = SJ(this, this.context.data()), this;
  }
  getStateKey() {
    const { unitRowIndex: t, unitColIndex: i } = this.context.metaInf();
    return `${t}-${i}-${this.context.id()}`;
  }
  getPropagationActions(t) {
    let i;
    return t.sourceInfo.canvasId === this.sourceCanvas() ? i = Z(t.targetActions, "layer") || {} : i = Z(t.targetActions, "interCanvas", this.sourceCanvas()) || {}, (Object.keys(i) || {}).map(
      (A) => ({
        actionName: t.sourceAction ? `${t.sourceAction}:${A}` : A,
        sideEffects: mB(
          {
            action: A,
            sourceCanvas: t.sourceInfo.canvasId,
            targetActions: t.targetActions
          },
          this
        )
      })
    );
  }
  onDataModelPropagation() {
    return (t, i) => {
      const n = Z(i, "applyOnVisibleUnits") ? this.isVisible() : !0;
      if (!t && !i.propagateDm && i.criteria !== null && i.sourcePropQuery && n) {
        const a = this.context.metaInf().facets;
        Object.keys(i.targetFacets).every(
          (r) => a[r] === i.targetFacets[r]
        ) ? t = this.data().select(i.sourcePropQuery) : t = this.data().createEmptyDm();
      }
      if (this._propagationDms[i.sourceAction] && this._propagationDms[i.sourceAction].dispose(!1), i.criteria === null && i.resetAllInteractions)
        return this.resetAllInteractions(i), this;
      this._propagationDms[i.sourceAction] = t;
      const s = this.getPropagationActions(i), A = t ? this.context.getAllAssociatedFields() : [], o = A.length && i.fields.length ? Wd(i.fields, A).length : !0;
      s.forEach(({ actionName: a, sideEffects: r }) => {
        const l = this.getBehaviouralAction(a);
        if (l) {
          const c = et(
            {},
            l.generatePayloadFromPropagationInf({
              propPayload: i,
              propagationData: t
            })
          );
          o || (c.criteria = {
            uids: []
          }), i.sourceId = i.propagationSourceId;
          const g = {
            propagate: !1,
            data: t,
            propPayload: i,
            sourceId: i.sourceId
          };
          (n ? this.dispatchBehaviour(
            a,
            Object.assign({}, c, { sideEffects: r }),
            Object.assign({}, g, {
              data: c.criteria === null ? null : g.data
            }),
            i.forceDispatch
          ) : !1) && (this.actions().behavioural[a].getSelectionSet().resetted() ? this.removeInteractionState({ action: a }) : this.saveInteractionState({
            action: a,
            payload: Object.assign({}, c, {
              sideEffects: r,
              action: a
            }),
            propagationInf: Object.assign({}, g, {
              data: c.criteria === null ? null : g.data
            }),
            forceDispatch: !1
          })), this._onPropagationDone(
            { ...i, action: a },
            t,
            g
          );
        }
      });
    };
  }
  applyExistingInteractions() {
    this._interactionStates.forEach(({ action: i, payload: n, propagationInf: s }) => {
      const A = n.sideEffects.filter((o) => this.sideEffects()[o.name] && this.sideEffects()[o.name].shouldApplyOnRenderAfterScrolling());
      this.actions().behavioural[i].entryExitSet() && this.dispatchSideEffects(
        i,
        { ...n, sideEffects: A },
        s,
        !0
      );
    });
  }
  resetAllInteractions(t) {
    const i = this._lastInteraction, n = [];
    i.forEach(({ behaviour: s, sideEffects: A }, o) => {
      if (s.includes("filter") && !t.resetFilterAction)
        return;
      const r = {
        action: s,
        criteria: null,
        sideEffects: A,
        forceDispatch: !0,
        sourceInfo: {},
        resetAllInteractions: !0,
        resetFilterAction: t.resetFilterAction
      }, l = {
        propagate: !1
      };
      this.dispatchBehaviour(s, r, l, !0), this._onPropagationDone(r, null, l), n.push(o);
    }), n.forEach((s) => i.delete(s));
  }
  remove() {
    return this.context._cachedData[0] && this.context._cachedData[0].unsubscribe(this._propagationHandler), this;
  }
  sourceCanvas() {
    return this.context.metaInf().canvasAlias;
  }
  sourceUnit() {
    return this.context.metaInf().unitId;
  }
  data(...t) {
    if (t.length) {
      const i = t[0];
      return this.context.enableCaching().data(i), this;
    }
    return this.context.data();
  }
  resetData() {
    return this.context.clearCaching(), this;
  }
  getTargetActions(t) {
    const i = this.context.config().interaction;
    return Z(i, t, "target") || {};
  }
  getSideEffectsForSourceAction({ action: t }) {
    const i = this.context.config().interaction, n = Z(i, t, "sideEffects") || {};
    return Object.keys(n).map((s) => ({
      name: s,
      ...n[s]
    })).filter((s) => s.enabled !== !1);
  }
  store() {
    return this.context.store();
  }
  isVisible() {
    const t = this.context.store(), i = this.context.metaInf(), { unitRowIndex: n, unitColIndex: s } = i, { rowStart: A, rowEnd: o, colStart: a, colEnd: r } = t.get(
      "virtualScrolling.viewport"
    );
    return Va(n, [A, o]) && Va(s, [a, r]);
  }
}
class bJ extends pe {
  constructor(...t) {
    super(...t), this._styles = /* @__PURE__ */ new Map();
  }
  static formalName() {
    return "plot-highlighter";
  }
  static target() {
    return "visual-layer";
  }
  setTransform() {
    return (t, i) => {
      const n = i.sourceInfo.layerId === this.firebolt.id(), s = (Z(i.target, 0) || []).filter(
        (a) => a !== pt.ROW_ID
      );
      let A = i.target;
      if (!n && A && (A = [
        s,
        i.target[1].filter((a, r) => i.target[0][r] !== pt.ROW_ID)
      ]), i.criteria === null || !n || i.action !== "highlight")
        return t;
      const o = lr(
        A,
        t.entrySet.model
      );
      return t.filter(o);
    };
  }
  apply(t, i, { rules: n }) {
    const s = (A) => {
      let o;
      return A instanceof Function ? o = A(
        {
          payload: i,
          entryExitSet: t
        },
        this.firebolt
      ) : typeof A == "string" && (o = A === "entrySet" ? t.entrySet : t.exitSet), o = this.firebolt.context._hasSingleElementForMultipleDataPoints ? this.firebolt.context.getTargetSet(o, A) : o, o;
    };
    n.forEach((A) => {
      const o = s(A.target);
      if (!o)
        return;
      const a = `${i.action}-${A.target instanceof Function ? A.key : A.target}`;
      if (i.criteria === null || !t.entrySet.length && !t.exitSet.length)
        this.applyInteractionStyle(t.completeSet, {
          apply: !1,
          interactionType: a,
          className: A.className,
          style: A.style
        }), this._styles.delete(a);
      else {
        const r = {
          apply: !0,
          interactionType: a,
          className: A.className,
          style: A.style,
          targetSet: A.target
        }, l = this._styles.get(a);
        l && this.applyInteractionStyle(
          {
            uids: qd(l.targetSet.uids, o.uids)
          },
          { ...l.config, apply: !1 }
        ), this.applyInteractionStyle(o, r), this._styles.set(a, {
          targetSet: o,
          config: r
        });
      }
    });
  }
}
const MJ = (e, t) => t.length > 1 ? t.slice(0, t.length - 1).every(({ field: i, value: n }) => e[i] === n) : !0;
class NJ extends pe {
  constructor(...t) {
    super(...t), this._styles = /* @__PURE__ */ new Map();
  }
  static formalName() {
    return "pivot-cell-highlighter";
  }
  static target() {
    return "visual-layer";
  }
  apply(t, i) {
    const n = i.data && i.data.contextData.data ? i.data.contextData.data.getDataPath() : null, s = this.firebolt.context, A = s.metaInf().facets;
    if (n && MJ(A, n)) {
      const o = n[n.length - 1].value, a = n[n.length - 1].field, r = s.axes().y.config().field === `${a}` ? "y" : "x", l = r === "y" ? s.axes().y.domain().length - 1 - s.axes().y.domain().indexOf(o) : s.axes()[r].domain().indexOf(o), c = X(s.mount()).selectAll(
        r === "y" ? `.muze-text-row-${l}` : `.muze-text-col-${l}`
      );
      this._interactedCells && this._interactedCells.classed("muze-pivot-cell-highlight", !1), c.classed("muze-pivot-cell-highlight", !0), this._interactedCells = c;
    } else
      this._interactedCells && this._interactedCells.classed("muze-pivot-cell-highlight", !1);
  }
}
class dn {
  static getUniquePositionedPoints(t, i) {
    const n = /* @__PURE__ */ new Set();
    return t.filter((A) => {
      const [o, a] = dn.getLabelPosition(A, i), r = `${o}_${a}`;
      return n.has(r) ? (A.isLabelThinned = !0, !1) : (n.add(r), !0);
    });
  }
  /**
   * Returns text label position.
   *
   * @static
   * @param {Object} point point
   * @param {String|undefined} location label location, one of: "point", "text", "sum"; or "sum" if undefined
   * @return {number[]} [ x, y ] coordinates, in pixels
   */
  static getLabelPosition(t, i = "sum") {
    return i === "point" ? [t.update.x, t.update.y] : i === "text" ? [t.text.update.x, t.text.update.y] : [t.update.x + t.text.update.x, t.update.y + t.text.update.y];
  }
  /**
   * Returns text label area.
   *
   * @static
   * @param {Object} point point
   * @param {String|undefined} location label location, one of: "point", "text", "sum"; or "sum" if undefined
   * @param {Object} smartLabel smart label
   * @return {number[]} [ x, y, width, height ] coordinates and dimensions, in pixels
   */
  static getLabelArea(t, i = "sum", n) {
    const [s, A] = this.getLabelPosition(t, i), { text: o, labelSmartText: a, textAnchor: r, rotation: l } = t.text && t.text.text ? t.text : t, c = n.getOriSize(a || o), g = c.width, h = 0.8 * c.height, d = h / 2, u = r === "start" ? 0 : r === "middle" ? g / 2 : g;
    return l === -90 ? [s - d, A - g + u, h, g] : [s - u, A - d, g, h];
  }
  /**
   * Returns whether two text labels intersect.
   *
   * @static
   * @param {number[]} r0 x, y, width, and height of first labels, in pixels
   * @param {number[]} r1 x, y, width, and height of second labels, in pixels
   * @return {boolean} true iff labels intersect
   */
  static isIntersect(t, i) {
    const [s, A, o, a] = t, [r, l, c, g] = i;
    return s + o >= r + 2 && s + 2 <= r + c && A + a >= l + 2 && A + 2 <= l + g;
  }
  /**
   * Shifts text labels as needed to keep them inside the drawing area.
   *
   * Shifting may cause label collisions.  After using this method, use the thinFinally method.
   *
   * @static
   * @param {number} width drawing area width, in pixels
   * @param {number} height drawing area height, in pixels
   * @param {Object} smartLabel smart label
   * @param {Object[]} points points containing text labels to be shifted
   * @param {String|undefined} location label location, one of: "point", "text", "sum"; or "sum" if undefined
   */
  static placeInside(t, i, n, s, A = "sum") {
    s.forEach((o) => {
      if (o && o.text && !o.isLabelThinned && !Number.isNaN(o.update.x) && !Number.isNaN(o.update.y) && (!o.text.update || !Number.isNaN(o.text.update.x) && !Number.isNaN(o.text.update.y))) {
        const { text: a, textAnchor: r, rotation: l, labelSmartText: c } = o.text && o.text.text ? o.text : o, { width: g, height: h } = n.getOriSize(
          c || a
        ), d = r === "start" ? 0 : r === "middle" ? g / 2 : g, u = 0.4 * h, f = 2, C = A === "point" || A === "text" ? { x: 0, y: 0 } : o.update, I = A === "point" ? o.update : o.text.update;
        l === 0 ? (I.x < d - C.x + f ? I.x = d - C.x + f : I.x > t - g + d - C.x && (I.x = t - g + d - C.x - f), I.y < h - u - C.y + f ? I.y = h - u - C.y + f : I.y > i - u - C.y && (I.y = i - u - C.y - f)) : l === -90 && (I.x < h - u - C.x + f ? I.x = h - u - C.x + f : I.x > t - u - C.x && (I.x = t - u - C.x - f), I.y < g - d - C.y + f ? I.y = g - d - C.y + f : I.y > i - d - C.y && (I.y = i - d - C.y - f));
      }
    });
  }
  /**
   * Flags points for text label thinning using Voronoi tiling.
   *
   * This method sets the "isLabelThinned" boolean in each point so that rendering code can omit it from the display.
   *
   * The Voronoi algorithm reduces collisions but does not eliminate them.  After using this method, use the thinFinally method.
   *
   * @static
   * @param {number} width drawing area width, in pixels
   * @param {number} height drawing area height, in pixels
   * @param {Object} smartLabel smart label
   * @param {Object[]} points points, containing text labels to be thinned (returned with "isLabelThinned: boolean" flag set)
   * @param {String|undefined} location label location, one of: "point", "text", "sum"; or "sum" if undefined
   * @param {Object|undefined} container container for drawing Voronoi diagram, for debugging; not drawn if undefined
   * @return {number[][]} Voronoi cells containing the specified points
   */
  static thinVoronoi(t, i, n, s, A = "sum", o = void 0) {
    const a = s.map((g) => this.getLabelPosition(g, A)), l = Pd.from(a).voronoi([0, 0, t, i]), c = a.map((g, h) => l.cellPolygon(h));
    if (o) {
      const g = Kd.path();
      l.render(g), X(o).append("path").attr("d", g).attr("stroke", "red").attr("stroke-width", 1);
    }
    return s.forEach((g, h) => {
      if (g.isLabelThinned = !0, g && g.text) {
        const d = c[h];
        if (d) {
          const { text: u, labelSmartText: f, rotation: C } = g.text && g.text.text ? g.text : g, { width: I, height: E } = n.getOriSize(f || u);
          if (Math.abs(nx(d)) >= 1e3)
            g.isLabelThinned = !1;
          else {
            const [B, m] = cI(d);
            let [p, w, Q, y] = d.reduce(
              (b, R, G, T) => {
                let [v, H, N, M] = b;
                const [F, k] = R, [O, P] = T[(G - 1 + T.length) % T.length];
                if (O <= B && B <= F || F <= B && B <= O) {
                  const L = P + (k - P) * (B - O) / (F - O);
                  N = Math.min(N, L), M = Math.max(M, L);
                }
                if (P <= m && m <= k || k <= m && m <= P) {
                  const L = O + (F - O) * (m - P) / (k - P);
                  v = Math.min(v, L), H = Math.max(H, L);
                }
                return [v, H, N, M];
              },
              [1 / 0, -1 / 0, 1 / 0, -1 / 0]
            );
            const D = w - p, _ = y - Q, x = 0.5, S = 0.2;
            C === 0 ? g.isLabelThinned = D < x * I || _ < S * E : C === -90 && (g.isLabelThinned = D < S * E || _ < x * I);
          }
        }
      }
    }), c;
  }
  /**
   * Places text labels using Voronoi tiling, minimizing overlap with associated points.
   *
   * When 'isCheckingAll' is false, only the object associated with the text label is checked for overlap,
   * and this algorithm is O( n * log( n )).  When 'isCheckingAll' is true, this method
   * checks all points for overlap, using an O( n**2 ) algorithm that performs well for small n.
   *
   * (There are better algorithms for this purpose.  This algorithm is a "quick fix" that could be replaced
   * by a real optimization algorithm, when time permits.  An alternative is to maintain this algorithm,
   * and supplement it with a direct manipulation user interface that enables the user to place the labels.)
   *
   * The Voronoi algorithm places labels inside the drawing area if they fit, but they may not always fit.
   * After using this method, use the thinFinally method.
   *
   * TODO: Place labels rotated at arbitrary angles.
   *
   * @static
   * @param {number} width drawing area width, in pixels
   * @param {number} height drawing area height, in pixels
   * @param {Object} smartLabel smart label
   * @param {Object[]} points points containing text labels (returned with "textAnchor" and "update" properties modified)
   * @param {number[][]} cells Voronoi cells containing points
   * @param {boolean} isCheckingAll true iff checking all points for overlap
   * @param {String|undefined} location label location, one of: "point", "text", "sum"; or "sum" if undefined
   * @param {Object|undefined} container container for drawing label area, for debugging; not drawn if undefined
   */
  static placeVoronoi(t, i, n, s, A, o = !1, a = "sum", r) {
    const l = n.getOriSize("X").height, c = 0.4 * l, g = 0, h = 1, d = 2, u = 3;
    s.forEach((f, C) => {
      const I = f.size === void 0 ? 0 : f.size;
      if (!f.isLabelThinned && I < l) {
        const [E, B] = this.getLabelPosition(f, a), [m, p] = cI(A[C]), w = (Math.round(Math.atan2(p - B, m - E) / Math.PI * 2) + 4) % 4;
        let Q;
        switch (w) {
          case g:
            Q = [g, u, h, d];
            break;
          case h:
            Q = [h, g, d, u];
            break;
          case d:
            Q = [d, u, h, g];
            break;
          default:
            Q = [u, g, d, h];
            break;
        }
        const y = f.text && f.text.text ? f.text : f, D = y.rotation, _ = y.update.x, x = y.update.y;
        let S = !1;
        for (let b = 0; b < Q.length && !S; b++) {
          switch (Q[b]) {
            case g:
              D === 0 ? (y.textAnchor = "start", y.update.x = _ + I + 2) : D === -90 && (y.textAnchor = "middle", y.update.x = _ + I + c), y.update.y = x;
              break;
            case h:
              D === 0 ? (y.textAnchor = "middle", y.update.y = x + I + c) : D === -90 && (y.textAnchor = "end", y.update.y = x + I + 2), y.update.x = _;
              break;
            case d:
              D === 0 ? (y.textAnchor = "end", y.update.x = _ - I - 2) : D === -90 && (y.textAnchor = "middle", y.update.x = _ - I - c), y.update.y = x;
              break;
            default:
              D === 0 ? (y.textAnchor = "middle", y.update.y = x - I - c) : D === -90 && (y.textAnchor = "start", y.update.y = x - I - 2), y.update.x = _;
              break;
          }
          const [R, G, T, v] = this.getLabelArea(
            f,
            a,
            n
          );
          if (S = R >= 0 && G >= 0 && R + T < t && G + v < i, o) {
            S = S && s.every((H) => {
              const N = H.size === void 0 ? 0 : H.size;
              return !this.isIntersect(
                [R, G, T, v],
                [
                  H.update.x - N,
                  H.update.y - N,
                  2 * N,
                  2 * N
                ]
              );
            });
            for (let H = 0; H < C && S; H++) {
              const N = s[H];
              if (!N.isLabelThinned) {
                const [M, F, k, O] = this.getLabelArea(N, a, n);
                M >= 0 && F >= 0 && M + k < t && F + O < i && (S = !this.isIntersect(
                  [R, G, T, v],
                  [M, F, k, O]
                ));
              }
            }
          }
        }
        if (r) {
          const b = X(r), [R, G, T, v] = this.getLabelArea(
            f,
            a,
            n
          );
          b.append("rect").attr("x", R).attr("y", G).attr("width", T).attr("height", v).attr("stroke", "blue").attr("stroke-width", 1).attr("fill", "none");
        }
      }
    });
  }
  /**
   * Flags points for text label thinning to remove label collisions and labels outside the drawing area.
   *
   * This method sets the "isLabelThinned" boolean in each point so that rendering code can omit it from the display.
   *
   * Collision detection is O( n ** 2 ).  The thinVoronoi method is O( n * log( n )).
   * Therefore, only use thinFinally with a small number of points, or after using thinVoronoi first.
   *
   * @static
   * @param {number} width drawing area width, in pixels
   * @param {number} height drawing area height, in pixels
   * @param {Object} smartLabel smart label
   * @param {Array.<Object>} points points containing text labels to be thinned (returned with "isLabelThinned: boolean" flag set)
   * @param {String|undefined} location label location, one of: "point", "text", "sum"; or "sum" if undefined
   */
  static thinFinally(t, i, n, s, A = "sum", o = { thinOverflowingLabels: !0 }) {
    let a = (l, c) => {
      l.forEach((g, h) => {
        if (g.isLabelThinned)
          return;
        let d = !1;
        const [u, f, C, I] = this.getLabelArea(
          g,
          A,
          n
        );
        for (let E = h + 1; E < l.length && !d; E++)
          if (!l[E].isLabelThinned) {
            const [B, m, p, w] = this.getLabelArea(
              l[E],
              A,
              n
            );
            this.isIntersect(
              [u, f, C, I],
              [B, m, p, w]
            ) ? l[E].isLabelThinned = !0 : d = c && B > u + C || !c && m > f + I;
          }
      });
    };
    s.forEach((l) => {
      if (l.isLabelThinned === void 0 ? l.isLabelThinned = !1 : (!l.update || Number.isNaN(l.update.x) || Number.isNaN(l.update.y) || A !== "point" && (!l.text || !l.text.update || Number.isNaN(l.text.update.x) || Number.isNaN(l.text.update.y))) && (l.isLabelThinned = !0), !l.isLabelThinned && o.thinOverflowingLabels) {
        const [c, g, h, d] = this.getLabelArea(
          l,
          A,
          n
        );
        (c < 0 || g < 0 || c + h > t || g + d > i) && (l.isLabelThinned = !0);
      }
    });
    let r = s.filter((l) => !l.isLabelThinned);
    r.sort(
      (l, c) => A === "point" ? l.update.x - c.update.x : A === "text" ? l.text.update.x - c.text.update.x : l.update.x + l.text.update.x - c.update.x - c.text.update.x
    ), a(r, !0), r = r.filter((l) => !l.isLabelThinned), r.sort(
      (l, c) => A === "point" ? l.update.y - c.update.y : A === "text" ? l.text.update.y - c.text.update.y : l.update.y + l.text.update.y - c.update.y - c.text.update.y
    ), a(r, !1);
  }
}
const FJ = `${ft.DISCRETE}-${ot.CATEGORICAL}${Ct.DIMENSION}`, Gr = `${ft.CONTINUOUS}-${ot.CONTINUOUS}${Ct.MEASURE}`, RJ = `${ft.DISCRETE}-${ot.CONTINUOUS}${Ct.MEASURE}`, kJ = `${ft.DISCRETE}-${ot.TEMPORAL}${Ct.DIMENSION}`, vJ = `${ft.CONTINUOUS}-${ot.TEMPORAL}${Ct.DIMENSION}`, TJ = `${ft.DISCRETE}-${ot.CONTINUOUS}${Ct.DIMENSION}`, yf = `${ft.CONTINUOUS}-${ot.CONTINUOUS}${Ct.DIMENSION}`, GJ = `${ft.DISCRETE}-${ot.BINNED}${Ct.DIMENSION}`, LJ = `${ft.CONTINUOUS}-${ot.BINNED}${Ct.DIMENSION}`, UJ = (e) => {
  let t = null, i = null;
  const n = `${e.x.as}-${e.x.subtype}${e.x.type}`, s = `${e.y.as}-${e.y.subtype}${e.y.type}`, A = [
    kJ,
    FJ,
    vJ,
    TJ,
    RJ,
    GJ,
    LJ
  ], o = [
    Gr,
    yf
  ];
  return A.includes(n) && o.includes(s) ? (t = "x", i = "y") : A.includes(s) && o.includes(n) ? (t = "y", i = "x") : n === yf && s === Gr ? (t = "x", i = "y") : n === Gr && s === yf ? (t = "y", i = "x") : n === Gr && s === Gr && (t = "x", i = "y"), {
    independentField: t ? e[t] : null,
    dependentField: i ? e[i] : null
  };
};
class SB extends sn {
  static formalName() {
    return Bo;
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
const Fb = (e) => class extends e {
  /**
   * Creates a layer using a configuration and data.
   *
   * @public
   * @constructor
   * @param {DataModel} data Instance of DataModel to be used. This DataModel instance serves as the data for a
   * layer.
   * @param {Object} axes Axes instances to be used for rendering the layer. Axes are used for mapping data from
   *      value to px.
   * @param {SimpleAxis} axes.x X axis of the layer. Based on the type of variable it gets instance of BandAxis,
   *      TimeAxis, ContinuousAxis
   * @param {SimpleAxis} axes.y X axis of the layer. Based on the type of variable it gets instance of BandAxis,
   *      TimeAxis, ContinuousAxis
   * @param {ColorAxis} axes.color Axis for coloring a layer using color interpolators
   * @param {ShapeAxis} axes.shape Axis for providing a shape
   * @param {SizeAxis} axes.size Axis for determining size of a mark using size interpolator
   * @param {LayerConfig} config Configuration of the layer
   * @param {Object} dependencies Dependencies of the layer
   * @param {SmartLabel} dependencies.smartLabel Smartlabel singleton instance
   */
  constructor(...t) {
    super(), this.eventManager(t[t.length - 1]);
    const i = Zt();
    this._axes = {}, this._alias = this.constructor.formalName() + i, this._points = [], this._pointMap = {}, this._cachedData = [], this._id = i, this._measurement = {}, this._graphicElems = {}, this._linkedElems = {}, this._customConfig = null, this._renderer = "svg", this._metaInf = null, this._largestTextLabel = "", this._shortestTextLabel = "", this._textPointsInfo = null, this._cellMaxCount = 0, this._normalizedData = null, this._viewableNormalizedData = null, this.emitSelfHooks(mt.INITIALIZED), this._stackedSum = /* @__PURE__ */ new Map();
  }
  associatedHookComponentPaths() {
    return [
      [Ht.LAYER, this.constructor.formalName()],
      [Ht.LAYER]
    ];
  }
  onAnimationEnd() {
    if (!this.eventManager())
      return Promise.resolve(this);
    let t;
    return this.eventManager().once(
      new $e({
        componentPath: [Ht.LAYER],
        modifier: ze.EACH,
        hookName: mt.ANIMATION_END
      }),
      (i) => {
        t(i);
      }
    ), new Promise((i) => {
      t = i;
    });
  }
  createFirebolt() {
    const t = this.interactionRegistry();
    this._firebolt = new _J(
      this,
      {
        physical: Object.assign({}, t.physicalActions),
        behavioural: Object.assign({}, t.behaviours, {
          [Bo]: SB
        }),
        physicalBehaviouralMap: Object.assign(
          {},
          t.physicalBehaviouralMap
        )
      },
      Object.assign({}, t.sideEffects, {
        PlotHighlighter: bJ,
        PivotCellHighlighter: NJ,
        ...this.getSideEffects()
      }),
      Object.assign({}, t.behaviourEffectMap)
    );
  }
  firebolt() {
    return this._firebolt;
  }
  getSideEffects() {
    return {};
  }
  store(...t) {
    return t.length ? (this._store = t[0], this) : this._store;
  }
  domain(...t) {
    return t.length ? (this._domain = t[0], this) : this._domain;
  }
  largestTextLabel(...t) {
    return t.length ? (this._largestTextLabel = t[0], this) : this._largestTextLabel;
  }
  shortestTextLabel(...t) {
    return t.length ? (this._shortestTextLabel = t[0], this) : this._shortestTextLabel;
  }
  /**
   * Creates a layer instance
   * @return {BaseLayer} Instance of a layer
   */
  static create(...t) {
    return new this(...t);
  }
  /**
   * Default configuration of the layer. This configuration gets merged to the user passed configuration using a
   * plolicy. Base layer only returns part of configuraion, any layer overridding base layer should return its own
   * configuration.
   *
   * @public
   * @static
   *
   * @return {Object} Default configuration
   */
  static defaultConfig() {
    return {
      transform: {
        type: "identity"
      }
    };
  }
  /**
   * Policy defines how user config gets merged to default config. The default policy here does a deep copy
   * operation.
   * Any policy which does more than deep copying should define the policy as a static member.
   *
   * @static
   * @public
   *
   * @param {LayerConfig} conf Configuration with which the user config will be merged
   * @param {LayerConfig} userConf Configuration given by the user
   *
   * @return {LayerConfig} Merged layer configuration
   */
  static defaultPolicy(t, i) {
    return et(t, i);
  }
  /**
   * Provides a alias for a layer. Like it's possible to have same layer (like bar) multiple times, but among
   * multiple layers of same type if one layer has to be referred, alias is used. If no alias is given then
   * `formalName` is set as the alias name.
   *
   *
   * If used as setter
   * @param  {string} alias Name of the alias
   * @return {BaseLayer} Instance of current base layer
   *
   * If used as getter
   * @return {string} Alias of the current layer
   *
   * @public
   */
  alias(...t) {
    return t.length ? (this._alias = t[0], this) : this._alias || this.constructor.formalName();
  }
  enableCaching() {
    return this._cacheEnabled = !0, this;
  }
  disableCaching() {
    return this._cacheEnabled = !1, this;
  }
  resetData() {
    return this._cacheEnabled = !1, this._cachedData[0] !== this.data() && this.data(this._cachedData[0]), this;
  }
  clearCaching() {
    this._cacheEnabled = !1, this.resetData();
  }
  /**
   * Serialize the schema. Merge config is used for serialization.
   *
   * @public
   *
   * @return {LayerConfig} Serialized schema
   */
  serialize() {
    return this.config();
  }
  /**
   * Returns the unique identifier of this layer. Id is auto generated during the creation proceess of a schema.
   *
   * @public
   *
   * @return {string} id of the layer
   */
  id(...t) {
    return t.length ? (this._id = t[0], this) : this._id;
  }
  /**
   * Returns the transformed data based on given transform type.
   * It first gets the transform method from transform factory based on type of transform. It then calls the
   * transform method with the data and passes the configuration parameters of transform such as
   * groupBy, value field, etc.
   *
   * @param {DataModel} dataModel Instance of DataModel
   * @param {Object} config Configuration for transforming data
   * @return {Array.<Array>} Transformed data.
   */
  getTransformedData(t, i, n, s) {
    return mc(
      t,
      i,
      n
    );
  }
  /**
   * Calculates the domain from the data.
   * It checks the type of field and calculates the domain based on that. For example, if it
   * is a quantitative or temporal field, then it calculates the min and max from the data or
   * if it is a categorical field then it gets all the values from the data of that field.
   * @param {Array} data DataArray
   * @param {Object} fieldsConfig Configuration of fields
   * @return {Array} Domain values array.
   */
  calculateDomainFromData(t) {
    let i = {};
    return this.data().isEmpty() || (i = z_(t, this)), i;
  }
  static shouldDrawAnchors() {
    return !1;
  }
  /**
   * Returns the domain for the axis.
   *
   * @param {string} encodingType type of encoding x, y, etc.
   * @return {Object} Axis domains
   */
  getDataDomain(t) {
    return t !== void 0 ? this._domain[t] || [] : this._domain;
  }
  /**
   * Normalizes the transformed data and returns it.
   *
   * @param {string} encodingType type of encoding x, y, etc.
   * @return {Object} Axis domains
   */
  getNormalizedData(t) {
    return j_(t, this);
  }
  isVerticalBar() {
    const { yFieldAs: t, yField: i, xField: n, xFieldAs: s } = this.encodingFieldsInf();
    return dA({
      yField: i,
      yFieldAs: t,
      xField: n,
      xFieldAs: s,
      dm: this.data(),
      transformConf: this._transformConfig
    });
  }
  normalizeText() {
    const { showStackSum: t, displayAs: i } = this.config().encoding.text, { type: n, originalType: s } = this._transformConfig;
    t ? this.normalizeTextStackSum() : (s || n) === Xt && i === tr ? this.normalizeTextInPercentage() : this.normalizeTextData();
  }
  normalizeTextStackSum() {
    const { displayAs: t } = this.config().encoding.text, { type: i, originalType: n, uniqueField: s, value: A } = this._transformConfig, o = n || i, a = this.data(), r = this.config().encoding.text.field;
    let l;
    a && r && (l = a.getField(r).type());
    const g = this.isVerticalBar() ? "x" : "y", h = o === Xt && t === tr;
    let d = null, u = null, f = null, C = null, I = null, E = null;
    if ((o === Wt || o === Xt) && l === Ct.MEASURE) {
      let B = /* @__PURE__ */ new Map();
      B = l5({
        dm: this.data(),
        valueField: A.field,
        uniqueField: s.field,
        textField: r,
        transformType: o
      });
      let m = [];
      this._normalizedData.flat().filter(
        (w) => B.get(
          K.isInvalid(w[g]) ? w[g].value() : w[g]
        )
      ).forEach((w) => {
        m.push({
          ...w,
          ...B.get(
            K.isInvalid(w[g]) ? w[g].value() : w[g]
          )
        });
      }), m.forEach((w) => {
        h && (w.percentageText = 1), w.formattedTextPosSum = KQ(
          this,
          w,
          -1,
          o,
          "textFieldPosStackSum",
          m
        ), w.formattedTextNegSum = o === Wt ? KQ(
          this,
          w,
          -1,
          o,
          "textFieldNegStackSum",
          m
        ) : 0, d = zo(
          d,
          w.formattedTextPosSum
        ), u = $o(
          u,
          w.formattedTextPosSum
        ), f = zo(
          f,
          w.formattedTextNegSum
        ), C = $o(
          C,
          w.formattedTextNegSum
        ), B.set(w[g], w);
      }), I = zo(
        d,
        f
      ), E = $o(
        u,
        C
      ), this._stackedSum = B, this.largestTextLabel(I || ""), this.shortestTextLabel(E || "");
    } else {
      const { textField: B } = this.encodingFieldsInf();
      if (!B)
        return;
      let m = null, p = null;
      this._normalizedData.forEach((w) => {
        w.forEach((Q, y) => {
          Q.formattedText = pf(this, Q, y), m = zo(
            m,
            Q.formattedText
          ), p = $o(
            p,
            Q.formattedText
          );
        });
      }), this.largestTextLabel(m || ""), this.shortestTextLabel(p || "");
    }
  }
  normalizeTextInPercentage() {
    const t = this.config().encoding.text.field, n = this.isVerticalBar() ? "x" : "y";
    let s = null, A = null, o = /* @__PURE__ */ new Map(), a = 0;
    this._normalizedData.flat().forEach((r) => {
      const l = K.isInvalid(r[n]) ? r[n].value() : r[n], c = r.dataObj[t];
      if (o.has(l)) {
        let g = o.get(l);
        g += isNaN(c) ? 0 : c, a = g;
      } else
        a = isNaN(c) ? 0 : c;
      o.set(l, a);
    }), this._normalizedData.forEach((r) => {
      r.forEach((l, c) => {
        const g = K.isInvalid(l[n]) ? l[n].value() : l[n], h = o.get(g);
        h !== 0 && !isNaN(l.text) && (g === l[n] || g === l[n].value()) ? l.percentageText = l.text / h : l.percentageText = 0, l.formattedText = pf(this, l, c), s = zo(
          s,
          l.formattedText
        ), A = $o(
          A,
          l.formattedText
        );
      });
    });
  }
  normalizeTextData() {
    const { textField: t } = this.encodingFieldsInf(), { hyperlink: i } = this.config().encoding.text;
    if (!t)
      return;
    let n = null, s = null;
    this._normalizedData.forEach((A) => {
      A.forEach((o, a) => {
        o.formattedText = pf(this, o, a), i.enabled && (o.hyperlinkInfo = r5(this, o, a)), n = zo(
          n,
          o.formattedText
        ), s = $o(
          s,
          o.formattedText
        );
      });
    }), this.largestTextLabel(n || ""), this.shortestTextLabel(s || "");
  }
  getTextPointsForStackSum() {
    const t = this.axes();
    let i = this._points.flat();
    const n = this.isVerticalBar(), s = n ? t.x.config().field : t.y.config().field, A = /* @__PURE__ */ new Map();
    i.forEach((a) => {
      const r = K.isInvalid(a) ? a.value() : a.data[s], l = this._stackedSum.get(r);
      A.has(r) || A.set(r, { ...a, ...l });
    });
    let o = [];
    return A.forEach((a, r) => {
      if (a && a.textFieldPosStackSum !== 0) {
        const l = Wh(
          this,
          a,
          r,
          n,
          "posStackSum"
        );
        o.push(l);
      }
      if (a && a.textFieldNegStackSum !== 0) {
        const l = Wh(
          this,
          a,
          r,
          n,
          "negStackSum"
        );
        o.push(l);
      }
    }), o;
  }
  getTextAutoRotationAngle() {
    return 0;
  }
  static getDomain(t, { field: i, encoding: n, layerEncodings: s, transform: A }) {
    if (!i || !t.getField(i))
      return [];
    let o;
    const a = s[n].as || t.getField(i).subtype(), r = t.getField(i)?.subtype(), l = A.type === Wt || A.type === Xt ? this.getStackConfig(t, {
      encoding: s
    }) : {};
    return A.type === Wt && a === ft.CONTINUOUS && l.value && l.value.field === i ? o = wc({
      dm: t,
      valueField: l.value.field,
      uniqueField: l.uniqueField.field,
      fieldAs: a
    }) : A.type === Xt && a === ft.CONTINUOUS && l.value && l.value.field === i ? o = EB({ dm: t }) : a === ft.DISCRETE ? o = r === zi ? t.getField(i)?.getAllBins() : t.getField(i)?.uniques() : o = t.getDomain(i, a), o;
  }
  /**
   * Gets the nearest point closest to the given x and y coordinate. If no nearest point is found, then it returns
   * null.
   *
   * @public
   *
   * @param {number} x X Coordinate.
   * @param {number} y Y Coordinate.
   *
   * @return {Object} Information of the nearest point.
   * ```
   *      {
   *          // id property contains the field names and their corresponding values in a 2d array. This is the
   *          data // associated with the nearest point.
   *          id: // Example data: [['Origin'], ['USA']],
   *          dimensions: // Physical dimensions of the point.
   *          layerId: // Id of the layer instance.
   *      }
   * ```
   */
  getNearestPoint() {
    return null;
  }
  getDataBoundary() {
    return null;
  }
  applyInteractionStyle(t, i) {
    const n = t;
    if (t)
      for (const s of i) {
        const A = this.getElementByRowId(s);
        A && so(this, A, n, t);
        const o = Z(this._linkedElems, "text", s);
        o && t.interactionType === "select:highlight-exitSet" && so(
          this,
          o.select("text"),
          n,
          t
        );
      }
  }
  getElementByRowId(t) {
    return this._graphicElems[t];
  }
  resolveTransformType() {
    return this._transformType = X_(this), this._transformType;
  }
  transformType() {
    return this._transformType;
  }
  /**
   * Renders the layer
   * @return {BaseLayer} Instance of the layer.
   */
  render() {
    return $_(this), this;
  }
  elemType() {
    return "g";
  }
  /**
   * Disposes the entire layer.
   *
   * @return {BaseLayer} Instance of layer.
   */
  remove() {
    return this._disposed = !0, X(this.mount()).remove(), this._prevMount && X(this._prevMount).remove(), this._prevMount = null, this._mount = null, this.firebolt() && (this.firebolt().remove(), this.firebolt().dispose()), this._data?.dispose(), this._data = null, this._alias = null, this._points = null, this._pointMap = null, this._cachedData = null, this._measurement = null, this._graphicElems = null, this._customConfig = null, this._metaInf = null, this._largestTextLabel = null, this._shortestTextLabel = null, this._textPointsInfo = null, this._encodingFieldsInf = null, this._normalizedData = null, this._viewableNormalizedData = null, this._store?.dispose && this._store?.dispose(), this._store = null, this;
  }
  /**
   * Stores point in an object with key as the categorical value or temporal value
   *
   * @param {string} key categorical value or temporal value
   * @param {Object} data Information of the data point
   * @return {BarLayer} Instance of bar layer
   */
  cachePoint(t, i) {
    if (t === null)
      return this;
    const n = this._pointMap;
    return n[t] = i, this;
  }
  addOverlayPathAndStyles() {
    return null;
  }
  getIdentifiersFromData(t, i) {
    const n = this.data(), s = n.getSchema(), A = [[], []], o = this.config().encoding, a = (r) => Object.keys(o).find((l) => Z(l, "field") === r);
    return s.forEach((r, l) => {
      const c = r.name;
      (n.isDimension(c) || a(c)) && (A[0].push(c), A[1].push(t[l]));
    }), A[0].push(pt.ROW_ID), A[1].push(i), A;
  }
  hasPlotSpan() {
    return !1;
  }
  getPlotSpan() {
    return {
      x: 0,
      y: 0
    };
  }
  getPlotPadding() {
    return {
      x: 0,
      y: 0
    };
  }
  /**
   * Returns the information of the marks corresponding to the supplied identifiers.
   * Identifiers are a set of field names and their corresponding values in an array.
   * It can also be an instance of datamodel.
   *
   * For example,
   * ```
   *  const identifiers = [
   *      ['Origin', 'Cylinders'],
   *      ['USA', '8']
   *  ];
   *  const points = barLayer.getPointsFromIdentifiers(identifiers);
   * ```
   * @public
   * @param {Array|DataModel} identifiers Identifiers of the marks.
   * @param {Object} config Optional configuration which describes how to get the information.
   * @param {boolean} config.getAllAttrs If true, then returns all the information of the points, else returns only
   * the positions of the points.
   * @param {boolean} config.getBBox If true, then returns the bounding box of all the marks.
   *
   * @return {Array} Array of points contains
   */
  getPointsFromIdentifiers(t, i = {}) {
    const n = i.getAllAttrs, s = i.getBBox, A = i.target;
    if (!this.data())
      return [];
    const o = this._pointMap, a = [];
    for (const r of t) {
      const l = o[r];
      if (l) {
        const c = l.data;
        if (A) {
          if (A[0].every(
            (h, d) => h in c ? c[h] === A[1][d] : !0
          )) {
            a.push(l);
            break;
          }
        } else {
          a.push(l);
          break;
        }
      }
    }
    return n ? a : a.map((r) => {
      const l = lE(r);
      return s ? this.getBoundBox(l) : l.update || l;
    }).sort((r, l) => r.y - l.y);
  }
  getBoundBox(t) {
    const i = this.measurement(), n = t.update || t;
    if (t.size !== void 0) {
      const s = Math.sqrt(t.size / Math.PI) * 2;
      n.width = s, n.height = s, n.x -= s / 2, n.y -= s / 2;
    } else
      n.width === void 0 && (n.width = 2), n.height === void 0 && (n.height = 2);
    return n.x = Math.min(i.width, Math.max(n.x, 0)), n.y = Math.min(i.height, Math.max(n.y, 0)), n;
  }
  isSortedDomain() {
    return this._transformedData.isSortedDomain();
  }
  getYfieldEncodingForTransformedData() {
    return "y";
  }
  getTransformedValueFromNormalizedData(t, i) {
    return t[i] || 0;
  }
  getTransformedDataFromIdentifiers(t, i = 0) {
    const { MEASURE: n } = K.FieldType, s = this.data(), { yField: A, xField: o, yFieldType: a, xFieldType: r } = this.encodingFieldsInf();
    let l, c;
    r === n ? (l = s.getFieldIndex(o), c = "x") : a === n && (l = s.getFieldIndex(A), c = this.getYfieldEncodingForTransformedData(i));
    const g = [], h = s.getFieldNames();
    h.forEach((u) => {
      const f = s.getFieldIndex(u);
      g[f] = [];
    });
    let d = 0;
    for (const u of t) {
      const f = this._pointMap[u];
      if (f) {
        const C = f.normalizedData, I = this.getTransformedValueFromNormalizedData(
          C,
          c
        ), E = C.source;
        h.forEach((B) => {
          const m = s.getFieldIndex(B);
          m === l ? g[m][d] = I : g[m][d] = E[m];
        }), d++;
      }
    }
    return [g, this.data().getSchema()];
  }
  /**
   * Returns the dom elements associated with the supplied set of row ids.
   * Each element in the layer is mapped with a row of the datamodel. When given an array of row ids,
   * it returns all the elements which is mapped with those row ids.
   *
   * @public
   * @param {Array} set Array of row ids
   *
   * @return {Selection} D3 Selection of dom elements.
   */
  getPlotElementsFromSet(t) {
    const i = this._graphicElems, n = [];
    for (const s of t) {
      const A = i[s];
      A && n.push(A);
    }
    return n;
  }
  createPolarAxes() {
    return this;
  }
  calculatePolarDomain(t) {
    const i = this.config(), { sort: n } = i;
    let s = t;
    n && (s = s.sort((o, a) => {
      const r = +o.radius, l = +a.radius;
      return n === BS ? r - l : l - r;
    }));
    const A = s.map((o) => +o.radius);
    return A.length === 1 && A.push(0), {
      radius: [Hs(A), is(A)],
      angle: s.map((o) => o.angle)
    };
  }
  setPolarAxesRange() {
    return this;
  }
  initializeFireboltSelectionSet() {
    const t = this.data();
    this.firebolt() && this.firebolt().createSelectionSet({ keys: t.getUids() }).attachPropagationListener(
      this._cachedData[0],
      this.firebolt().onDataModelPropagation()
    );
  }
  /**
   * Called when the layer datamodel is set.
   *
   * @param {Array} arr Old and new datamodel instance.
   * @param {DataModel} arr[0] Previous datamodel instance.
   * @param {DataModel} arr[1] Current datamodel instance.
   *
   * @return {BaseLayer} Instance of layer.
   */
  dataDidSet([, t]) {
    const i = this.config();
    if (t && i) {
      if (this._cacheEnabled ? this._cachedData.push(t) : this._cachedData = [t], i.encoding) {
        if (this.initializeFireboltSelectionSet(), this._transformedData = this.getTransformedData(
          t,
          i,
          this._transformConfig,
          this._encodingFieldsInf
        ), this._normalizedData = this.getNormalizedData(this._transformedData), this.createPolarAxes(), !this.domain()) {
          const s = {};
          [Gt.X, Gt.Y].forEach((A) => {
            const o = this.constructor.getDomain(t, {
              field: i.encoding[A].field,
              encoding: A,
              layerEncodings: i.encoding,
              transform: i.transform
            });
            o && o.length && (s[A] = o);
          }), this.domain(s);
        }
        this.normalizeText();
      }
      this.afterDataDidSet();
    }
    return this;
  }
  static shouldShowAxisTicksInPercentage() {
    return !1;
  }
  afterDataDidSet() {
  }
  createTransformConfig(t) {
    const i = this.config();
    if (!t || !i)
      return;
    const n = i.encoding;
    if (!n)
      return;
    const s = this.retrieveEncodingFields(
      n,
      t
    );
    this.encodingFieldsInf(s);
    const A = this.resolveTransformConfig(t), o = this.resolveOverrideTransformConfig(A);
    this._transformConfig = o, this._transformType = o.type;
  }
  resolveOverrideTransformConfig(t) {
    return t;
  }
  hasRangedValueAxis() {
    return !1;
  }
  static getOverrideTransformType(t) {
    return t;
  }
  static getTransformGroupByDimensions(t, i, n) {
    const { encoding: s } = t, A = [];
    for (let o in s) {
      let { field: a } = s[o];
      Bn(a).forEach((l) => {
        n.isDimension(l) && (i.includes(o) || A.push(l));
      });
    }
    return A;
  }
  static getStackConfig(t, i) {
    const {
      x: { field: n, as: s },
      y: { field: A, as: o }
    } = i.encoding, { independentField: a, dependentField: r } = UJ({
      x: {
        field: n,
        as: s,
        type: t.getField(n)?.type(),
        subtype: t.getField(n)?.subtype()
      },
      y: {
        field: A,
        as: o,
        type: t.getField(A)?.type(),
        subtype: t.getField(A)?.subtype()
      }
    });
    return {
      uniqueField: a,
      value: r
    };
  }
  static autoDetectTransformType(t, i, n) {
    if (!t.length)
      return ns;
    if (i.uniqueField && i.value) {
      const s = i.value.field, { [s]: A } = hc(n, [
        s
      ]);
      return A === TE ? Wt : jn;
    }
    return ns;
  }
  static getDefaultTransformConfig(t, i) {
    const { transform: n = {} } = t, s = this.getTransformGroupByDimensions(
      t,
      ["x", "y", "x0", "y0"],
      i
    );
    let A = n.type, o = {
      ...n,
      groupBy: wt(n.groupBy, s)
    };
    const a = this.getStackConfig(i, t);
    return A || (A = this.autoDetectTransformType(
      s,
      a,
      i
    )), (A === Wt || A === Xt) && (o = {
      ...o,
      ...a
    }), {
      type: A,
      ...o
    };
  }
  resolveTransformConfig(t) {
    const i = this.config().transform;
    let n = {
      fields: []
    };
    const s = [
      Gt.COLOR,
      Gt.OPACITY,
      Gt.SIZE,
      Gt.SHAPE,
      Gt.TEXT,
      Gt.DETAIL
    ], A = [Gt.COLOR, Gt.SIZE, Gt.SHAPE], o = /* @__PURE__ */ new Set();
    for (let a = 0; a < s.length; a++) {
      const r = s[a], { field: l } = this.config().encoding[r] || {}, c = Bn(l), g = c && c[0], h = t.getField(g);
      if (h && h.type() === "dimension" && wt(i.groupBy, []).includes(g) && !o.has(g)) {
        let d;
        A.includes(r) ? d = this.axes()[r].sortValues(h.uniques()) : d = h.uniques(), n.fields.push({
          field: g,
          values: d
        }), o.add(g);
      }
    }
    return { ...i, sort: n };
  }
  retrieveEncodingFields(t, i) {
    return W_(t, i);
  }
  applyStyles({ styleObj: t, elem: i }, n) {
    const { styles: s, className: A } = t;
    A && i.classed(A, n.apply), this.applyElementStyles(i, s);
  }
  applyElementStyles(t, i) {
    for (let n in i)
      t.style(n, i[n]);
  }
  getBoundBoxes() {
    return null;
  }
  getOverlayPathMount() {
    return this._overlayMount ? this._overlayMount : (this._overlayMount = X(this.mount()).select(".muze-overlay-paths").node(), this._overlayMount);
  }
  static getRetinalFieldsDomain(t, i, n = { config: {} }, s) {
    const { config: A } = n, o = {};
    return ["color", "opacity", "shape", "size", "backgroundColor"].forEach(
      (a) => {
        const { field: r } = i[a];
        let l = i[a].as;
        if (r) {
          const c = t.getField(r);
          if (c) {
            let g = i[a].splitBy, h;
            l || (l = bi(c));
            const d = g5(
              A,
              a,
              r
            );
            if (d && Array.isArray(d.domain) && d.domain.length ? g ? h = {
              splitDomains: t.splitByRow([g]).reduce((f, C) => (f[C.getField(g).data()[0]] = d.domain, f), {})
            } : h = d.domain : g ? h = {
              splitDomains: t.splitByRow([g]).reduce((f, C) => (f[C.getField(g).data()[0]] = C.getField(r).domain(), f), {})
            } : h = t.getDomain(r, l), h && ((l === ft.CONTINUOUS || l === ft.DISCRETE && n.totals == null) && (o[r] = Object.assign({}, o[r], {
              [l]: h
            })), s.getField(r).subtype() !== c.subtype() && c.subtype() === ot.CATEGORICAL))
              for (let f in o[r])
                o[r][f] = o[r][f].map(
                  (C) => us(C)
                );
          }
        }
      }
    ), o;
  }
  requiresExtendDomainDiffs() {
    return !1;
  }
  /**
   * Each layer can calculate how much domain(or domain padding for discrete axis)
   * it needs to extend so that its plot does not get clipped out.
   * The default values are zeros. Any corresponding layer can
   * extend this method with the respective logic.
   * The values should be in pixel format.
   */
  calculateExtendDomainDiffs() {
    return {
      x: [0, 0],
      // [extra left pixel, extra right pixel],
      y: [0, 0]
      // [extra top pixel, extra bottom pixel]
    };
  }
  /**
   * @todo: Replace with appropriate lifecycle manager APIs.
   */
  postLayout() {
  }
  emitAllRenderHooksWhenRenderSkipped(t) {
    const i = sg(this, t);
    this.emitSelfHooks(
      [
        mt.BEFORE_RENDERED,
        mt.AFTER_RENDERED,
        mt.ANIMATION_END
      ],
      {
        virtualScrolling: {
          viewportRange: Z(t, "viewportRange") || null,
          partialRange: {
            xRange: i.xRange,
            yRange: i.yRange
          }
        }
      }
    ), this._disposed && (this._axes = null, this._linkedElems = null);
  }
  emitAnimationEndHook(t) {
    const i = sg(this, t);
    this.emitSelfHooks(mt.ANIMATION_END, {
      virtualScrolling: {
        viewportRange: Z(t, "viewportRange") || null,
        partialRange: {
          xRange: i.xRange,
          yRange: i.yRange
        }
      }
    });
  }
  computeCssStyle() {
    return Ls(
      X(this.mount()),
      this.config().className
    );
  }
  cssStyle(...t) {
    return t.length ? (this._cssStyle = t[0], this) : this._cssStyle;
  }
  setSmartLabelStyleForRenderLayout() {
    const t = this.cssStyle();
    if (t) {
      const { smartLabel: i } = this.dependencies();
      i.setStyle(t);
    }
  }
  preRender(t, i = !0) {
    this.setSmartLabelStyleForRenderLayout();
    const n = sg(this, t);
    this.emitSelfHooks(mt.BEFORE_RENDERED, {
      virtualScrolling: {
        viewportRange: Z(t, "viewportRange") || null,
        partialRange: {
          xRange: n.xRange,
          yRange: n.yRange
        }
      }
    }), i && t && this.updateViewableNormalizedData(t);
  }
  postRender(t) {
    const i = sg(this, t);
    this.emitSelfHooks(mt.AFTER_RENDERED, {
      virtualScrolling: {
        viewportRange: Z(t, "viewportRange") || null,
        partialRange: {
          xRange: i.xRange,
          yRange: i.yRange
        }
      }
    });
  }
  data(...t) {
    if (t.length) {
      let i = t[0];
      i && this.createTransformConfig(i);
      let n = this._data;
      return this._cacheEnabled || (this._cachedData.splice(1, this._cachedData.length).forEach((A) => A.dispose()), n && n !== i && n.dispose()), this._data = i, this.dataDidSet([n, this._data]), this;
    }
    return this._data;
  }
  getBandScale() {
    return this._bandScale || (this._bandScale = dE.band()), this._bandScale;
  }
  axes(...t) {
    return t.length ? (this._axes = t[0], this) : this._axes;
  }
  measurement(...t) {
    return t.length ? (this._measurement = t[0], this) : this._measurement;
  }
  encodingFieldsInf(...t) {
    return t.length ? (this._encodingFieldsInf = t[0], this) : this._encodingFieldsInf;
  }
  encodingTransform(...t) {
    return t.length ? (this._encodingTransform = t[0], this) : this._encodingTransform;
  }
  dependencies(...t) {
    return t.length ? (this._dependencies = t[0], this) : this._dependencies;
  }
  dataProps(...t) {
    return t.length ? (this._dataProps = t[0], this) : this._dataProps;
  }
  reducedDataMap(...t) {
    return t.length ? (this._reducedDataMap = t[0], this) : this._reducedDataMap;
  }
  transformedData(...t) {
    return t.length ? (this._transformedData._data = t[0], this) : this._transformedData._data;
  }
  renderer(...t) {
    return t.length ? (this._renderer = t[0], this) : this._renderer;
  }
  interactionRegistry(...t) {
    return t.length ? (this._interactionRegistry = t[0], this) : this._interactionRegistry;
  }
  metaInf(...t) {
    return t.length ? (this._metaInf ? this._metaInf = Object.assign(this._metaInf, t[0]) : this._metaInf = t[0], this) : this._metaInf;
  }
  mount(...t) {
    if (t.length) {
      if (this._prevMount = this._mount, this._mount = t[0], this._mount !== this._prevMount && this.cssStyle(this.computeCssStyle()), this.data()) {
        const i = t[1];
        this.render(this._mount, i);
      }
      return this;
    }
    return this._mount;
  }
  getRenderableNormalizedData() {
    return this._viewableNormalizedData || this._normalizedData;
  }
  calculateViewableAxisDomains(t) {
    const { axisDomainRanges: i } = t, { x: n, y: s } = this.axes();
    let A = null, o = null;
    const a = n.config().orientation === "bottom" ? i.x[0] : i.x[1], r = s.config().orientation === "left" ? i.y[0] : i.y[1];
    if (a && (A = {
      domain: n.domain().slice(a.startIdx, a.endIdx + 1),
      range: a
    }), r) {
      const l = s.domain(), c = l.length - 1 - r.endIdx, g = l.length - 1 - r.startIdx;
      o = {
        domain: l.slice(c, g + 1),
        range: r
      };
    }
    return {
      x: A,
      y: o
    };
  }
  updateViewableNormalizedData(t) {
    if (!t.axisDomainRanges)
      return;
    const { x: i, y: n } = this.calculateViewableAxisDomains(t);
    let s = this._normalizedData;
    if (i) {
      const A = i.domain;
      s = s.map(
        (o) => o.filter((a) => uI(A, a.x))
      );
    }
    n && (s = s.map(
      (A) => A.filter((o) => uI(n.domain, o.y))
    )), this._viewableNormalizedData = s;
  }
  valueParser(...t) {
    return t.length ? (this._valueParser = t[0] || ((i) => i), this) : this._valueParser;
  }
  config(...t) {
    if (t.length) {
      const i = t[0];
      this._customConfig = i;
      const n = this.constructor, s = et({}, n.defaultConfig()), A = n.defaultPolicy(s, i);
      return this._config = A, this;
    }
    return this._config;
  }
  getPointsWithinRange(t) {
    return this._rtree.search(t);
  }
  cachedData() {
    return this._cachedData;
  }
  getPlotElementsByEffectKey(t) {
    const i = this._graphicElems, n = [];
    for (let s in i) {
      const { meta: A } = i[s].data()[0];
      A.lastInteraction.includes(t) && n.push(i[s]);
    }
    return n;
  }
  getAllEncodingFields() {
    const { encoding: t } = this.config();
    return Object.keys(t).map((n) => t[n].field).filter((n) => !!n).flat();
  }
  getAllAssociatedFields() {
    const t = this.getAllEncodingFields(), i = Object.keys(this.metaInf().facets || {});
    return [.../* @__PURE__ */ new Set([...t, ...i])];
  }
  getOverlayPathByEffectKey(t) {
    const i = this._overlayPath, n = this._graphicElems, s = [];
    for (let A in n) {
      const { meta: o, rowId: a } = n[A].data()[0];
      o.lastInteraction.includes(t) && i[a] && s.push(i[a]);
    }
    return s;
  }
  formatTextLabelWithDefaultFormatter(t) {
    const { textField: i } = this.encodingFieldsInf(), { useUTC: n } = this.config();
    return PQ(
      t,
      this.valueParser(),
      i,
      this.dataProps().timeDiffs,
      { useUTC: n },
      this.data(),
      null,
      this
    );
  }
  formatTextLabelWithDisplayAsFormatter(t) {
    const { textField: i } = this.encodingFieldsInf(), { useUTC: n } = this.config(), s = this.config().encoding.text.displayAs;
    return PQ(
      t,
      this.valueParser(),
      i,
      this.dataProps().timeDiffs,
      { useUTC: n },
      this.data(),
      s,
      this
    );
  }
  isUnivariate() {
    const t = this.encodingFieldsInf(), { xField: i, yField: n } = t;
    return i === ht && n === ht;
  }
  textPointsInfo(...t) {
    return t.length ? (this._textPointsInfo = t[0], this) : this._textPointsInfo;
  }
  hasTextEncodingField() {
    const { textField: t } = this.encodingFieldsInf();
    return !!t;
  }
  renderTextPoints(t, i) {
    const { classPrefix: n } = this.config(), { location: s } = i, A = this.filterTextPoints(i);
    A.forEach((r) => {
      const l = r.text, [c, g] = dn.getLabelPosition(r, s);
      l.originalPosition = {
        x: l.update.x,
        y: l.update.y
      }, l.update.x = c, l.update.y = g;
    });
    const o = A.map((r) => r.text), { elems: a } = sb(this, t.node(), o, {
      groupClassName: (r) => `${n}-layer-${this.constructor.formalName()}-label-${r.rowId}`
    });
    this.mergeTextLinkedElems(a), A.forEach((r) => {
      const l = r.text;
      l.originalPosition && (l.update.x = l.originalPosition.x, l.update.y = l.originalPosition.y, l.originalPosition = null);
    });
  }
  filterTextPoints(t) {
    const { points: i } = t;
    return i.filter((n) => !n.isLabelThinned && !!n.text && n.text.text !== "");
  }
  mergeTextLinkedElems(t) {
    this._linkedElems = {
      ...this._linkedElems,
      text: Object.assign({}, this._linkedElems.text, t)
    };
  }
  calculateOptimumTextLabelDimensions() {
    const { smartLabel: t } = this.dependencies(), { textFieldSubType: i } = this.encodingFieldsInf(), { style: n, encoding: s } = this.config(), { charsAcross: A } = s.text, o = mh(A.max, "W"), a = mh(A.min, "W");
    t.setStyle(n);
    const { width: r, height: l } = t.getOriSize(
      o
    ), c = this.largestTextLabel() || a, { width: g, height: h } = t.getOriSize(c);
    let d = g, u = h;
    return i === su && (d = Math.min(d, r), u = Math.min(u, l)), {
      width: d,
      height: u
    };
  }
  // calculateOptimumSingleCharDimensions() {
  //   const { smartLabel } = this.dependencies();
  //   const { textFieldType } = this.encodingFieldsInf();
  //   const { style } = this.config();
  //   const optimumChar = textFieldType === "measure" ? "9" : "W";
  //   smartLabel.setStyle(style);
  //   const { width, height } = smartLabel.getOriSize(optimumChar);
  //   return {
  //     width,
  //     height,
  //   };
  // }
  /**
   * It represents the maximum number of text values in a single cell
   * of a pivot table.
   */
  cellMaxCount(...t) {
    return t.length ? (this._cellMaxCount = t[0], this) : this._cellMaxCount;
  }
  getNeighbourPointIndexForContinuationInVirtualScroll(t) {
    return t;
  }
  isVertical() {
  }
  includeDataFromAllLayersInTooltip() {
    return !1;
  }
};
class Ws extends ci(US).with(
  Lo,
  Fb
) {
  /**
   * Determines a name for a layer. This name of the layer is used in the input data to refer to this layer.
   * ```
   *  .layers([
   *      mark: 'bar',
   *      encoding: { ... }
   *  ])
   * ```
   *
   * @static
   * @public
   *
   * @return {string} name of layer
   */
  static formalName() {
    return wS;
  }
}
const HJ = (e) => !!(/^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(e) && /[\dz]$/i.test(e) && e.length > 4), HI = function(e, t) {
  const { shape: i, size: n, update: s } = e;
  if (i instanceof Promise)
    i.then((A) => {
      e.shape = A, HI(e, t);
    });
  else if (i instanceof Element) {
    let A = i.cloneNode(!0);
    if (A.nodeName.toLowerCase() === "img") {
      const a = A.src || A.href;
      A = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "image"
      ), A.setAttribute("href", a);
    }
    const o = X(A);
    A.nodeName === "path" || A.nodeName === "image" ? o.attr("transform", `scale(${n / 100})`) : (o.attr("height", n), o.attr("width", n)), o.attr("x", -n / 2), o.attr("y", -n / 2), z(t, () => A, [1]);
  } else if (typeof i == "string") {
    let A;
    HJ(i) ? A = i : A = cc(i).size(n * n * Math.PI)(s), z(t, "path", (o) => [o]).attr("d", A);
  } else
    e.shape = "circle", HI(e, t);
}, A0 = (e, t) => {
  const i = e.config().encoding.text, { width: n, height: s } = e.measurement(), { smartLabel: A } = e.dependencies(), o = dn.getUniquePositionedPoints(
    t,
    "sum"
  ), a = dn.thinVoronoi(
    n,
    s,
    A,
    o,
    "sum"
  );
  if (!i.labelPlacement) {
    dn.placeInside(
      n,
      s,
      A,
      o,
      "sum"
    );
    const r = 100, l = A.getOriSize("X").height, c = o.length < r && o.every(
      (g) => (g.size === void 0 ? 0 : g.size) < l
    );
    dn.placeVoronoi(
      n,
      s,
      A,
      o,
      a,
      c,
      "sum"
    );
  }
  dn.thinFinally(
    n,
    s,
    A,
    o,
    "sum"
  );
}, Rb = (e) => {
  const {
    layer: t,
    container: i,
    points: n,
    transition: s,
    animationAggregator: A,
    className: o,
    saveGraphicElems: a = !0
    // drawText = true,
  } = e, { duration: r, effect: l, disabled: c } = s, g = X(i), h = t._graphicElems;
  if (g.attr("class", o), t.hasTextEncodingField())
    if (t._stackedSum.size) {
      const d = t.getTextPointsForStackSum();
      A0(t, n), t.textPointsInfo({
        points: d,
        location: "text"
      });
    } else
      A0(t, n), t.textPointsInfo({
        points: n,
        location: "sum"
      });
  else
    t.textPointsInfo(null);
  return z(
    g,
    "g",
    n,
    null,
    {
      enter: (d, u) => {
        const { enter: f } = u;
        d.attr("transform", `translate(${f.x},${f.y})`);
      },
      update: (d, u) => {
        HI(u, d), a && (h[u.rowId] = d);
        const { update: f, style: C } = u;
        cE(C, (I) => d.style(I, C[I])), d.attr("class", o), d.classed(u.className, !0), c || (d = d.transition().duration(s.duration).on("end", A.newCallback())), d.attr("transform", `translate(${f.x},${f.y})`).style("visibility", "visible");
      },
      exit: (d) => {
        c ? d.style("visibility", "hidden") : d.transition().ease(lc[l]).duration(r).on("end", () => d.style("visibility", "hidden")).style("fill-opacity", 0).style("stroke-opacity", 0), d.remove();
      }
    },
    e.keyFn
  );
}, OJ = fn.line, PJ = (e) => {
  const { update: t } = e;
  return t.y !== null && t.x !== null;
}, o0 = (e) => {
  const { x: t, y: i } = e ? e.update : {};
  return t === null || i === null;
}, YJ = (e, t, i) => {
  const n = o0(e[t - 1]), s = o0(e[t + 1]);
  !n && i.prevOfNull.push(t - 1), !s && i.nextOfNull.push(t + 1);
}, JJ = (e) => {
  const t = {
    prevOfNull: [],
    nextOfNull: []
  };
  return e.forEach((i, n) => {
    const { update: s } = i;
    (s.y === null || s.x === null) && YJ(e, n, t);
  }), t;
}, KJ = (e, t) => {
  const i = [], { prevOfNull: n, nextOfNull: s } = t, A = n.length;
  if (!A)
    return i;
  for (let o = 0; o < A; o++) {
    const a = [], r = e[n[o]], l = e[s[o]];
    r && a.push(r), l && a.push(l), i.push(a);
  }
  return i;
}, kb = (e) => {
  const t = JJ(e);
  return KJ(e, t);
}, tl = (e, t, i) => e.id() + "-gradient-" + t._gradientId + "-" + i._gradientId, a0 = (e) => e && !e.isNull && e.update.y !== e.update.y0, r0 = (e, t, i, n, s = {}) => {
  const { defsClassName: A } = s, a = z(
    i,
    "defs",
    [1],
    A || "linear-gradients-container"
  ), r = e.map(([l, c]) => {
    const g = tl(t, l, c), h = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "linearGradient"
    ), [d, u] = [l, c].map((I) => n(I)), [f, C] = [d, u].map((I, E) => {
      const B = document.createElement("stop");
      return B.setAttribute("stop-color", `${I}`), B.setAttribute("offset", `${E === 0 ? 0 : 100}%`), B;
    });
    return [f, C].forEach((I) => h.appendChild(I)), l.update.x && c.update.x && l.update.y && c.update.y ? `<linearGradient id="${g}" x1=${l.update.x} x2=${c.update.x} y1=${l.update.y} y2=${c.update.y} gradientUnits="userSpaceOnUse">` + h.innerHTML + "</linearGradient>" : "";
  });
  a.node().innerHTML = r.join(`
`);
}, l0 = (e) => {
  const {
    mount: t,
    data: i,
    className: n,
    layer: s,
    strokeStyle: A,
    linePathFn: o,
    transition: a,
    animationAggregator: r,
    updateFns: l
  } = e;
  let c = a.disabled;
  const g = s.config().encoding.size, h = g.field || typeof g.value == "function";
  let d = z(
    t,
    "path",
    i.length ? [i] : [],
    n,
    l
  );
  return d.attr("class", (f, C) => f[C].className), vt(d, { ...A, "fill-opacity": h ? 1 : 0 }), h && (c = !0), c || (d = d.transition().duration(a.duration), d.empty() || (d = d.on("end", r.newCallback()))), d.attr("d", o(i)), d;
}, VJ = (e) => {
  const {
    layer: t,
    containerSelection: i,
    mount: n,
    points: s,
    linePathFn: A,
    transition: o,
    animationAggregator: a,
    strokeStyle: r,
    connectNullData: l,
    className: c,
    nullDataLineClass: g
  } = e, h = t._graphicElems, d = {
    update: (C, I) => {
      I.forEach((E) => {
        h[E.rowId] = i;
      });
    }
  }, u = l0({
    mount: n,
    data: s,
    strokeStyle: void 0,
    layer: t,
    linePathFn: A,
    transition: o,
    animationAggregator: a,
    updateFns: d
  });
  return kb(s).map((C) => (l && C.length > 1 && l0({
    mount: n,
    data: C,
    strokeStyle: r,
    className: `.${c}-${g}`,
    layer: t,
    linePathFn: A,
    transition: o,
    animationAggregator: a,
    updateFns: d
  }), null)), u;
}, WJ = (e) => {
  const {
    layer: t,
    containerSelection: i,
    mount: n,
    points: s,
    style: A,
    linePathFn: o,
    connectNullData: a,
    getColorAxis: r
  } = e, l = [];
  s.map((d) => ({ ...d, _gradientId: Zt() })).forEach((d, u) => {
    const f = s[u + 1];
    a0(d) && a0(f) && l.push([d, f]);
  });
  const c = (d) => {
    const u = r(t, { dataObj: d.data }), { colorField: f } = t.encodingFieldsInf();
    return u.getColor(d.data[f]);
  };
  r0(l, t, n, c);
  const g = z(i, "g", [1], ".lines");
  if (z(
    g,
    "path",
    l,
    ".muze-gradient-line-path"
  ).attr("d", (d) => o(d)).attr("fill", (d) => `url(#${tl(t, d[0], d[1])})`).attr("stroke", (d) => `url(#${tl(t, d[0], d[1])})`).classed("muze-gradient-line-path", !0), a) {
    const d = z(
      i,
      "g",
      [1],
      ".sanitized-point-lines"
    ), u = kb(s).map(
      (C) => Array.isArray(C) ? C.map((I) => ({ ...I, _gradientId: Zt() })) : { ...C, _gradientId: Zt() }
    ), f = u.map((C) => C).filter((C) => C.length === 2);
    r0(f, t, n, c, {
      defsClassName: "linear-gradients-container-for-sanitized-points"
    }), u.forEach((C) => {
      C.length > 1 && d.selectAll().data(f).enter().append("path").attr("d", (I) => o(I)).attr("fill", (I) => `url(#${tl(t, I[0], I[1])})`).attr("stroke", (I) => `url(#${tl(t, I[0], I[1])})`).classed("muze-gradient-line-path", !0);
    });
  }
  return Kh(n, A), null;
}, qJ = (e, t = {}) => {
  const {
    layer: i,
    container: n,
    points: s,
    interpolate: A,
    className: o,
    style: a,
    disconnectedPointsGroupClassName: r
  } = e, l = X(n), c = i.config().nullDataLineStyle, g = i.config().nullDataLineClass, h = l.attr("class", o), d = gc[A], { isGradient: u } = t, f = uB(s).map((B) => ({
    ...B,
    enter: {
      ...B.update
    },
    style: a
  })), C = z(
    l,
    "g",
    [1],
    `.${r}`
  ).node();
  Rb({
    ...e,
    points: f,
    container: C,
    className: r,
    saveGraphicElems: !1
  });
  const I = i.config().encoding.size, E = I && (I.field || typeof I.value == "function") ? (B) => new jJ().x((p) => p.update.x).y((p) => p.update.y).size((p) => p.size).defined((p) => p.update.x && p.update.y).pathStr(B) : OJ().curve(d).x((B) => B.update.x).y((B) => B.update.y).defined(PJ);
  return u ? WJ({
    ...e,
    linePathFn: E,
    containerSelection: l,
    style: a,
    mount: h
  }) : VJ({
    ...e,
    linePathFn: E,
    containerSelection: l,
    nullDataLineClass: g,
    strokeStyle: c,
    mount: h
  });
};
class jJ {
  constructor() {
    this.xFn = () => 0, this.yFn = () => 0, this.sizeFn = () => 1, this.definedFn = () => !0;
  }
  x(t) {
    return this.xFn = t, this;
  }
  y(t) {
    return this.yFn = t, this;
  }
  size(t) {
    return this.sizeFn = t, this;
  }
  defined(t) {
    return this.definedFn = t, this;
  }
  point({ x1: t, y1: i, size1: n, x2: s, y2: A, size2: o, path: a }) {
    const r = n / 2, l = o / 2;
    let c = i - A, g = s - t;
    if (g || c) {
      const h = Math.sqrt(g * g + c * c), d = g / h, u = c / h, f = u * r, C = d * r, I = u * l, E = d * l, B = Math.atan2(g, c);
      a.moveTo(t - f, i - C), a.lineTo(s - I, A - E), a.arc(s, A, l, B - Math.PI, B), a.lineTo(t + f, i + C), a.arc(t, i, r, B, B + Math.PI);
    } else
      a.arc(s, A, l, 0, Math.PI * 2);
    return a.closePath(), a;
  }
  pathStr(t) {
    let i = Kd.path(), n, s, A, o = !1;
    return t.forEach((a, r) => {
      let l = !1;
      if (!this.definedFn(a, r, t) === o && (o = !o, o && (l = !0)), o) {
        let c = +this.xFn(a, r, t), g = +this.yFn(a, r, t), h = +this.sizeFn(a, r, t);
        i = l ? i : this.point({
          x1: n,
          y1: s,
          size1: A,
          x2: c,
          y2: g,
          size2: h,
          path: i
        }), n = c, s = g, A = h;
      }
    }), i.toString();
  }
}
const zJ = {
  classPrefix: On,
  defClassName: "layer-line",
  className: "",
  interpolate: "linear",
  transform: {},
  interaction: {
    select: {
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  {
                    target: "exitSet",
                    style: {
                      fill: { a: -0.5 }
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "exitSet",
              style: {
                stroke: { a: -0.8 }
              }
            },
            {
              target: "entrySet",
              style: {
                stroke: { a: 0.8 }
              }
            }
          ]
        },
        "persistent-line-anchors": {}
      }
    },
    highlight: {
      sideEffects: {
        "line-anchors": {}
      }
    },
    brush: {
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "exitSet",
              style: {
                stroke: { a: -0.5 }
              }
            }
          ]
        },
        "brush-line-anchors": {}
      }
    }
  },
  crossline: !0,
  nearestPointThreshold: 5,
  encoding: {
    color: {},
    opacity: {
      value: 1
    },
    x: {},
    y: {},
    size: {},
    text: {
      ...Oo,
      labelPlacement: {
        anchors: [Si, Ps, vn, Wi]
      }
    }
  },
  transition: {
    effect: "cubic",
    duration: 1e3
  },
  connectNullData: !1,
  nullDataLineStyle: {},
  nullDataLineClass: "null",
  highlightExactPoint: !1,
  detectHoverOnEmptyArea: !0,
  interactive: !0
}, $J = (e, t, i, n, s, A) => {
  t = t || { x: i.x, y: i.y }, n = n || { x: i.x, y: i.y };
  const { size: o = 0, text: a } = s, r = XJ(
    A,
    t,
    i,
    n,
    e
  ), { smartLabel: l } = e._dependencies, c = new CB(l), g = {
    positionAt: r,
    rotation: i.rotation
  }, { xPos: h, yPos: d } = IB(
    a,
    { x: i.x, y: i.y, size: o / 2 },
    g,
    c
  ), u = {
    x: h,
    y: d,
    textAnchor: "middle"
  }, { width: f } = e.measurement(), { width: C } = l.getOriSize(a), { x: I, textAnchor: E } = u;
  return E === "start" ? I + C > f && (u.textAnchor = "end") : E === "middle" ? I + C / 2 > f ? u.textAnchor = "end" : I - C / 2 < 0 && (u.textAnchor = "start") : E === "end" && I - C < 0 && (u.textAnchor = "start"), u;
}, XJ = (e, t, i, n, s) => {
  const A = [];
  let o = e.find((a) => {
    switch (a) {
      case As:
        return !0;
      case Si:
      case za: {
        if (i.y <= t.y && i.y <= n.y)
          return !0;
        break;
      }
      case Ps:
      case Xa: {
        if (i.y >= t.y && i.y >= n.y)
          return !0;
        break;
      }
      case vn:
      case Za: {
        if (i.x < t.x && i.x < n.x)
          return !0;
        A.push(vn);
        break;
      }
      case Wi:
      case $a: {
        if (i.x > t.x && i.x > n.x)
          return !0;
        A.push(Wi);
        break;
      }
      default:
        return !1;
    }
  });
  if (o === void 0 && A.length > 0) {
    if (!ZJ(A))
      return A[0];
    const { y: a } = s.axes(), r = Math.abs(
      (i.y - t.y) / (i.x - t.x)
    ), l = Math.abs(
      (n.y - i.y) / (n.x - i.x)
    );
    a instanceof xe || a instanceof Be ? o = l > r ? vn : Wi : o = r > l ? vn : Wi;
  }
  return o !== void 0 ? o : e[0];
}, ZJ = (e) => {
  let t = !1, i = !1;
  return e.every((n) => (t = t || n === vn, i = i || n === Wi, !(t && i))), t && i;
}, tK = (e, t, i, n) => {
  const s = n.getUnitWidth();
  let A = i[t];
  return (t === "x" && !e || t === "y" && e) && (A = i[t] > 0 ? i[t] : i[`${t}0`]), n.isYAxis() && n.constructor.type() === be ? n.getScaleValue(A) - s / 2 : n.getScaleValue(A) + s / 2;
}, eK = (e, t, i, n) => {
  const s = n.getUnitWidth();
  return n.isYAxis() && n.constructor.type() === be ? n.getScaleValue(i[t]) - s / 2 : n.getScaleValue(i[t]) + s / 2;
}, vb = (e, t, i, n) => {
  for (const s in t)
    if (Object.hasOwnProperty.call(t, s)) {
      let A, o;
      const a = t[s];
      ke(a) ? (e[s] = {}, vb(e[s], a, i, n)) : typeof a == "string" && (A = a.split(".")) && A[0] === n ? (o = Z(i, ...A.slice(1, A.length)), o !== void 0 && (e[s] = o)) : e[s] = a;
    }
}, wf = (e) => {
  for (const t in e) {
    const i = e[t];
    (typeof i == "string" || Array.isArray(i)) && (e[t] = {
      field: i
    });
  }
}, en = /* @__PURE__ */ (() => {
  const e = {}, t = {
    setLayerRegistry: (i) => {
      t._layerRegistry = i;
    },
    getSerializedConf: (i, n) => {
      let s;
      const A = e[i], o = et({}, n);
      if (A)
        s = A.map((a) => {
          const r = {};
          return vb(r, a, o, i), wf(r.encoding), r;
        });
      else {
        const a = o.encoding;
        wf(a), s = o;
      }
      return s;
    },
    getLayerInstance: (i, n, ...s) => {
      const A = t._layerRegistry;
      i = Array.isArray(i) ? i : [i];
      const o = i.map((a) => A[a.mark].create(
        ...s,
        n ? n() : null
      ));
      return o.length === 1 ? o[0] : o;
    },
    getLayerClass: (i) => t._layerRegistry[i],
    /**
     * Registers a new composite layer definition in the layer factory.
     *
     * @public
     *
     * @param {string} layerType Mark type of the new composite layer.
     * @param {Array} layerDefs Layer definitions of the composite layer.
     */
    composeLayers: (i, n) => {
      e[i] = n;
    },
    sanitizeLayerConfig: (i) => {
      const n = et({}, i);
      wf(n.encoding);
      const { encoding: s } = n;
      if (s) {
        const A = s.detail && s.detail.field ? s.detail.field : void 0;
        Array.isArray(A) ? n.encoding.detail = { field: A } : typeof A == "string" ? n.encoding.detail = { field: [A] } : n.encoding.detail = {};
      } else
        n.encoding = {};
      return n;
    }
  };
  return t;
})();
class Du extends Ir {
  constructor(...t) {
    super(...t), this._layerInstances = [], this.addAnchorLayers();
  }
  static target() {
    return "visual-layer";
  }
  static defaultConfig() {
    return {
      className: "muze-anchors-group"
    };
  }
  static formalName() {
    return "line-anchors";
  }
  addAnchorLayers() {
    const i = this.firebolt.context.config().encoding, n = {
      x: i.x,
      y: i.y,
      color: i.color,
      size: {
        field: Z(i, "size", "field"),
        as: i.size.as,
        value: () => this.defaultSizeValue()
      }
    }, s = this.constructor.defaultConfig().className, o = {
      name: `${this.constructor.formalName()}-upper`,
      mark: "point",
      className: `${s}-upper`,
      encoding: n,
      transform: {
        type: "identity"
      },
      transition: this.getTransitionConfig(),
      source: () => new K({ data: [[]], schema: [] }),
      interactive: !1
    };
    this._layerInstances = [this.createLayerInstance(o)];
  }
  createLayerInstance(t) {
    const i = en.getLayerInstance(t, null), n = this.firebolt.context, s = n.metaInf();
    return i.config(t).metaInf({
      unitRowIndex: s.rowIndex,
      unitColIndex: s.colIndex,
      namespace: `${s.parentNamespace}-${t.mark}-${Zt()}`,
      parentNamespace: s.parentNamespace
    }).dependencies(n._dependencies).store(n.store()), i;
  }
  getTransitionConfig() {
    return {
      disabled: !0
    };
  }
  /**
   * Returns the default area value of the anchor point.
   * @return { number } Default area value of anchor.
   */
  defaultSizeValue() {
    return 0.0625;
  }
  // Default offset by which anchor size is changed
  getAnchorSizeOnInteraction({ dragEnd: t }) {
    return t ? 0.0417 : 0;
  }
  apply(t, i, n) {
    const s = t.entrySet.model, A = s._model._config;
    if (s === null || i.criteria === null || !this.firebolt.context.mount())
      return this._layerInstances.forEach((c) => {
        c.mount() && (c.data() && c.data().dispose(), c.data(new K({ data: [[]], schema: [] })).mount(c.mount()));
      }), this;
    const o = this.constructor.formalName(), a = this.firebolt.context, { target: r } = i;
    let l = null;
    r && (l = r[1].reduce((c, g, h) => {
      const d = r[0][h];
      return c[d] = g, c;
    }, {})), this._layerInstances.forEach((c, g) => {
      const h = c.config(), d = a, u = d.constructor.formalName(), f = h.name, C = f === `${o}-upper`;
      let I = [], E = [];
      if ([I, E] = d.getTransformedDataFromIdentifiers(
        t.entrySet.uids,
        g
      ), u === "area" && r && n.behaviour === "highlight" && !C) {
        const Q = lr(r, s), y = s.select(Q);
        [I, E] = d.getTransformedDataFromIdentifiers(
          y.getUids(),
          g
        ), y.dispose();
      }
      c.data() && c.data().dispose();
      const B = new K(
        {
          data: I,
          schema: E.filter((Q) => Q.name !== pt.ROW_ID)
        },
        A
      );
      B._alias = "anchors";
      const m = {
        encoding: {
          size: {
            value: () => this.defaultSizeValue() + this.getAnchorSizeOnInteraction(i)
          },
          "stroke-width": {
            value: this.getAnchorStroke(i, l)
          },
          stroke: {
            value: "black"
          }
        }
      }, p = et(h, m), w = z(d.mount(), "g", [1], f);
      return c.axes(d.axes()).data(B).config(p).dataProps(d.dataProps()).mount(w.node()), this;
    });
  }
  getAnchorStroke(t, i) {
    return (n) => {
      const s = n.data;
      return (i ? Object.keys(i).filter((o) => o !== pt.ROW_ID).every((o) => s[o] === i[o]) : !1) ? "1px" : "0px";
    };
  }
}
class iK extends Du {
  static formalName() {
    return "persistent-line-anchors";
  }
  getAnchorSizeonInteraction() {
    return 50;
  }
  getAnchorStroke() {
    return "2px";
  }
}
class nK extends Du {
  static formalName() {
    return "brush-line-anchors";
  }
  getAnchorSizeonInteraction() {
    return 50;
  }
  getAnchorStroke(t) {
    return t.dragEnd ? "2px" : "1px";
  }
}
const c0 = fn.line, sK = (e, t) => {
  const i = `muze-${t.id()}-borders-container`, n = t.isVerticalArea(), s = n ? "y" : "x0", A = n ? "y0" : "x";
  let o = X(i);
  o.node() || (o = z(
    t.mount(),
    "g",
    [1],
    ".muze-area-borders-container"
  ), o.attr("id", i));
  const [a, r] = e, l = "positive", c = "negative", g = "upper", h = "lower", d = "area-borders", u = { [g]: s, [h]: A }, { interpolate: f } = t.config(), C = gc[f];
  [
    { points: a, id: l },
    { points: r, id: c }
  ].map(({ points: I = [], id: E }) => {
    [g, h].map((B) => {
      const m = `${t.id()}-${B}-${E}`, p = n ? c0().curve(C).x((Q) => Q.update.x).y((Q) => Q.update[u[B]]).defined((Q) => Q.includeInBorder) : c0().curve(C).x((Q) => Q.update[u[B]]).y((Q) => Q.update.y).defined((Q) => Q.includeInBorder);
      let w = X(`.muze-${m}`);
      w.node() || (w = z(
        o.node(),
        "path",
        I.length ? [I] : [],
        `.muze-${m}`
      ), w.attr("id", m)), w.classed(`${d}`, !0), w.classed(`${TS}`, !0), w.attr(
        "d",
        p(
          I.map((Q) => ({
            ...Q,
            includeInBorder: !Q.isNull
          }))
        )
      );
    });
  });
};
class xu extends Du {
  static formalName() {
    return "area-anchors";
  }
  addAnchorLayers() {
    super.addAnchorLayers();
    const t = this.constructor.formalName(), n = this.firebolt.context.config().encoding, s = {
      x: n.x,
      y: n.y,
      color: n.color,
      size: {
        field: Z(n, "size", "field"),
        as: n.size.as,
        value: () => this.defaultSizeValue()
      }
    }, A = this.constructor.defaultConfig().className, o = {
      name: `${t}-lower`,
      mark: "point",
      className: `${A}-lower`,
      encoding: s,
      transform: {
        type: "identity"
      },
      transition: this.getTransitionConfig(),
      source: () => new K({ data: [[]], schema: [] }),
      interactive: !1
    };
    this._layerInstances.push(this.createLayerInstance(o));
  }
}
class AK extends xu {
  static formalName() {
    return "persistent-area-anchors";
  }
  getAnchorSizeonInteraction() {
    return 50;
  }
  getAnchorStroke() {
    return "2px";
  }
}
class oK extends xu {
  static formalName() {
    return "brush-area-anchors";
  }
  getAnchorSizeonInteraction() {
    return 50;
  }
  getAnchorStroke(t) {
    return t.dragEnd ? "2px" : "1px";
  }
}
class aK extends xu {
  static formalName() {
    return "area-borders";
  }
  apply(t, i) {
    const { context: n } = this.firebolt, { metaData: s } = i;
    let A = [];
    return s && s.borderPoints && (s.layerId && s.layerId === n.id()) && A.push(s.borderPoints.data), sK(A, n), this;
  }
}
const _B = (e) => class extends e {
  /**
   * Creates an instance of LineLayer.
   *
   * @param {*} args
   * @memberof LineLayer
   */
  constructor(...t) {
    super(...t), this._voronoi = new gE(), this._rtree = null, this._mainColorProp = "stroke", this._hasSingleElementForMultipleDataPoints = !0, this._pathPoints = [];
  }
  static formalName() {
    return "line";
  }
  elemType() {
    return "path";
  }
  /**
   * Default configuration of line layer
   * @return {Object} Default configuration of layer
   */
  static defaultConfig() {
    return zJ;
  }
  // static defaultPolicy(conf, userConf) {
  //   const config = super.defaultPolicy(conf, userConf);
  //   const encoding = config.encoding;
  //   const transform = config.transform;
  //   const colorField = encoding.color && encoding.color.field;
  //   if (colorField && !transform.groupBy) {
  //     transform.groupBy = colorField;
  //   }
  //   return config;
  // }
  /**
   * Returns the draw method for line
   * @return {Function} Draw method of line layer
   */
  getDrawFn() {
    return qJ;
  }
  static shouldDrawAnchors() {
    return !0;
  }
  optimizeTextLabelPositions(t) {
    t = t.filter((s) => !!s.text);
    const i = this.config().encoding.text, n = nb(i);
    for (let s = 0; s < t.length; s++) {
      const A = t[s], o = t[s - 1], a = t[s + 1], { x: r, y: l, textAnchor: c } = $J(
        this,
        o ? { x: o.text.update.x, y: o.text.update.y } : null,
        { x: A.text.update.x, y: A.text.update.y },
        a ? { x: a.text.update.x, y: a.text.update.y } : null,
        {
          size: A.size,
          text: A.text.text
        },
        n
      );
      A.text.update.x = r, A.text.update.y = l, A.text.textAnchor = c;
    }
    return t;
  }
  /**
   * Generates the x and y positions for each point
   * @param {Array} data Data Array
   * @param {Object} encoding Visual Encodings of the layer
   * @param {Object} axes Contains the axis
   * @param {number} seriesIndex index of series
   * @return {Array} Array of points
   */
  translatePoints(t, i, n) {
    let s = [];
    const A = this.axes(), o = this.config().encoding, a = A.x, r = A.y;
    Qc(t, A);
    const l = A.x instanceof xe || A.x instanceof Be, c = A.y instanceof xe || A.y instanceof Be, g = this.isVerticalLine();
    let h;
    return this.transformType() === Wt ? h = tK : h = eK, t.forEach((d, u) => {
      const f = h(
        g,
        "x",
        {
          x: d.x,
          x0: d.x0
        },
        a
      ), C = h(
        g,
        "y",
        {
          y: d.y,
          y0: d.y0
        },
        r
      ), I = ts(this, d), E = Ho(this, d), B = ws(this, d), m = I.getColor(d.color), p = B.getOpacity(d.opacity), w = Qs(this, {
        translatedValues: {
          x: f,
          y: C,
          color: m,
          opacity: p,
          text: d.text,
          formattedText: d.formattedText,
          size: o.size ? E.getSize(d.size) : void 0
        },
        datum: d,
        datumIdx: u,
        groupData: t,
        groupIdx: i,
        layerData: n
      }), Q = {
        stroke: w.color,
        opacity: w.opacity
      };
      let y;
      this.hasTextEncodingField() && (y = Po(
        this,
        {
          x: w.x,
          y: w.y,
          text: w.text,
          formattedText: w.formattedText,
          color: pu.textColor
        },
        d,
        u,
        t
      ));
      const D = Qo(
        {
          x: w.x,
          y: w.y,
          text: w.text
        },
        u,
        d,
        this
      ), _ = {
        enter: {},
        update: {
          x: !l && K.isInvalid(d.x) ? null : w.x,
          y: !c && K.isInvalid(d.y) ? null : w.y
        },
        style: Q,
        rowId: d.rowId,
        source: d.source,
        data: d.dataObj,
        meta: ys(Q),
        normalizedData: d,
        size: w.size,
        text: y,
        rotation: D
      };
      _.className = Vs(d, u, t, this), s.push(_), this.cachePoint(d.rowId, _);
    }), this.hasTextEncodingField() && (s = this.optimizeTextLabelPositions(s)), s = Uo(this, s), s = s.filter((d) => {
      const { update: u } = d;
      return !isNaN(u.x) && !isNaN(u.y);
    }), s;
  }
  getTranslatedData(t, i, n) {
    const s = this._transformConfig.groupBy, A = t.filter((o) => o.length);
    return A.map((o, a) => {
      let r, l, c = o[0].color, g = o[0].opacity;
      const h = s.map(
        (E) => o[0].dataObj[E]
      ), d = h.length ? h : [this.id()];
      i ? r = i(o, a, t) : (c = K.getActualValue(c), r = ts(this, o[0]).getColor(c));
      const u = this.config().encoding, f = typeof u.opacity.value, C = this.encodingFieldsInf().opacityFieldAs === "continuous" || this.encodingFieldsInf().opacityFieldType === "measure";
      typeof n == "function" ? l = n(
        {
          datum: o[a],
          datumIdx: a,
          groupData: o,
          groupIdx: a,
          layerData: A
        },
        { context: this, encodingName: "opacity" }
      ) : f !== "function" && !u.opacity.field || f !== "function" && C ? l = u.opacity.value : (g = K.getActualValue(g), l = ws(this, o[0]).getOpacity(g));
      const I = this.getPathStyle(r, l);
      return {
        data: this.translatePoints(o, a, A),
        style: I,
        meta: ys(I),
        id: d
      };
    });
  }
  isGradientLine() {
    const {
      x: t,
      y: i,
      color: n
    } = this.config().encoding, { xFieldSubType: s, yFieldSubType: A, colorFieldSubType: o } = this.encodingFieldsInf();
    if (!n || n.value)
      return !1;
    const a = n.field, r = this.axes().color, l = r instanceof ir ? r.config().type : Object.values(r)[0].config().type, c = this.isVerticalLine(), g = c ? s : A, h = c ? t.field : i.field;
    return l === "linear" || a === h && o === g;
  }
  isPartialRenderingEnabled() {
    const { mark: t } = this.config();
    return t === "line" && this.isGradientLine();
  }
  /**
   * Renders the line plot
   * @param {SVGElement} container svg element
   * @return {LineLayer} instance of line layer
   */
  render(t, i) {
    this.preRender(i, this.isPartialRenderingEnabled());
    const n = Js(), s = this.config(), {
      encoding: A,
      interpolate: o,
      className: a,
      defClassName: r,
      transition: l
    } = s, c = this.getRenderableNormalizedData(), g = this.axes(), h = ms(
      r,
      this.id(),
      s.classPrefix
    ), d = X(t), u = wt(
      i.transition,
      l
    );
    this._points = [], this._pointMap = {}, d.attr(
      "class",
      `${h.join(" ")} ${a}`
    );
    const f = A.color.value, C = A.opacity.value, I = A.size ? A.size.field : void 0, E = this.isGradientLine(), B = this.getTranslatedData(
      c,
      f,
      C,
      g
    );
    this._translatedPoints = B, this._linkedElems = {}, this._pathPoints = [];
    const m = {
      isGradient: E
    };
    if (z(
      t,
      "g",
      B,
      null,
      {
        update: (D, _, x) => {
          const S = _.data, b = `${h[0]}-${x}`.toLowerCase(), R = _.style;
          this._points.push(
            S.filter(({ isSplitPoint: T }) => !T)
          ), vt(D, R);
          const G = this.getPathPoints(S);
          this.getDrawFn()(
            {
              layer: this,
              container: D.node(),
              interpolate: o,
              points: G,
              className: b,
              transition: u,
              animationAggregator: n,
              style: R || {},
              connectNullData: s.connectNullData,
              size: I,
              disconnectedPointsGroupClassName: `${h[0]}-disconnected-points`,
              getColorAxis: (...T) => ts(...T),
              validPointCount: _.validPointCount
            },
            m
          ), this._pathPoints.push(G);
        }
      },
      (D) => D.id
    ), this.hasTextEncodingField()) {
      let D = null;
      this._stackedSum.size ? D = this.getTextPointsForStackSum() : D = this._points.flat(), this.textPointsInfo({
        points: D,
        location: "text"
      });
    } else
      this.textPointsInfo(null);
    const { width: p, height: w } = this.measurement(), { smartLabel: Q } = this.dependencies(), y = this._points.flat();
    return this.config().encoding.text.field && dn.placeInside(p, w, Q, y, "text"), this.postRender(i), n.onAllCallbacksCalled().then(() => {
      this.emitAnimationEndHook(i);
    }), this;
  }
  getPathPoints(t) {
    return t;
  }
  postRender(t) {
    if (super.postRender(t), this.config().interactive) {
      pc(this._voronoi, this._points);
      const i = this.getBoundBoxes().flat().filter((n) => n !== null);
      this._rtree = new Io(), this._rtree.load(i);
    }
  }
  /**
   * Get the css styles need to be applied on the line path
   * @param {string} color Color value
   * @return {Object} Path styles
   */
  getPathStyle(t, i) {
    const n = this.config().encoding;
    return {
      ...yc(n, [this._mainColorProp]),
      stroke: t,
      fill: t,
      opacity: i
    };
  }
  /**
   * Gets the nearest point closest to the given position
   * @param {number} x x position
   * @param {number} y y position
   * @return {Object} Nearest point information
   */
  getNearestPoint(t, i, n) {
    let s = n.searchRadius;
    const A = this.data();
    if (!A || A && A.isEmpty())
      return null;
    s = s !== void 0 ? s : this.config().nearestPointThreshold;
    const o = this._voronoi.find(t, i, s), a = Z(o, "data", "data", "update");
    if (o) {
      const { source: r, rowId: l } = o.data.data;
      return {
        id: this.getIdentifiersFromData(r, l),
        dimensions: [
          {
            x: a.x,
            y: a.y,
            width: 2,
            height: 2
          }
        ],
        point: o.data.data,
        layerId: this.id()
      };
    }
    return null;
  }
  getBoundBoxes() {
    return dB(this._points.flat());
  }
  applyInteractionStyle(t, i) {
    const n = this._graphicElems, s = t;
    if (t) {
      const A = t.targetSet, o = {};
      for (const a of i) {
        const r = n[a];
        if (r) {
          const c = r.data()[0].id;
          let g = o[c];
          g || (o[c] = [0], g = o[c]), g[0] += 1, g[1] = r.data()[0].data.filter(({ isDummy: h }) => !h).length, g[2] = r;
        }
        const l = Z(this._linkedElems, "text", a);
        l && so(
          this,
          l.select("text"),
          s,
          t
        );
      }
      for (let a in o) {
        const r = o[a];
        (A === "entrySet" && r[0] >= 1 || A === "exitSet" && r[0] === r[1] || r[0] === r[1]) && r[2] && so(
          this,
          r[2],
          s,
          t
        );
      }
    }
  }
  getSideEffects() {
    return {
      LineAnchors: Du,
      PersistentLineAnchors: iK,
      BrushLineAnchors: nK
    };
  }
  static autoDetectTransformType(t) {
    return t.length ? w6 : ns;
  }
  static getTransformGroupByDimensions(t, i, n) {
    const { encoding: s, transform: A } = t, o = super.getTransformGroupByDimensions(
      t,
      i,
      n
    ), a = A && A.type === da.GROUP ? [] : i.map((r) => Z(s, r, "field")).filter((r) => r);
    return o.filter((r) => !a.includes(r));
  }
  getTargetSet(t, i) {
    const n = {};
    for (const A of t.uids) {
      const o = this._graphicElems[A];
      if (o) {
        const a = o.data()[0].id;
        let r = n[a];
        r || (n[a] = [[]], r = n[a]), r[0].push(A), r[1] = o.data()[0].data.filter(({ isDummy: l }) => !l).length, r[2] = o;
      }
    }
    let s = [];
    for (let A in n) {
      const o = n[A];
      (o[0].length === o[1] || i === "entrySet" && o[0].length > 0) && s.push(o[0]);
    }
    return t = { uids: new Set(s.flat()) }, t;
  }
  /**
   * @override
   */
  requiresExtendDomainDiffs() {
    return !0;
  }
  /**
   * @override
   */
  calculateExtendDomainDiffs() {
    const t = this.dependencies().smartLabel.getOriSize("X").height, i = yo(this.axes().x, this.domain().x, [
      t,
      t
    ]), n = yo(this.axes().y, this.domain().y, [
      t,
      t
    ]);
    return { x: i, y: n };
  }
  isVerticalLine() {
    const { yFieldAs: t, yField: i, xField: n, xFieldAs: s } = this.encodingFieldsInf();
    return dA({
      yField: i,
      yFieldAs: t,
      xField: n,
      xFieldAs: s,
      dm: this.data(),
      transformConf: this._transformConfig
    });
  }
  getNeighbourPointIndexForContinuationInVirtualScroll(t, i, n = (s) => s + 1) {
    const { connectNullData: s } = this.config();
    if (!s) {
      const l = n(t);
      return l > -1 && l < i.length ? l : t;
    }
    const A = this.isVerticalLine(), o = A ? "x" : "y", a = A ? "y" : "x", r = (l, c, g) => {
      if (!l[g])
        return -1;
      if (K.isInvalid(l[g])) {
        const h = n(c);
        return r(l, h, i[h]);
      }
      return c;
    };
    return this._normalizedData.map((l) => {
      const c = {};
      return l.forEach(
        (g) => c[g[o]] = g[a]
      ), r(c, n(t), i[n(t)]);
    });
  }
  static getDomain(t, { field: i, encoding: n, layerEncodings: s, transform: A }) {
    if (!i || !t.getField(i))
      return [];
    let o;
    const a = s[n].as || t.getField(i).subtype(), r = t.getField(i)?.subtype(), l = A.type === Wt ? this.getStackConfig(t, {
      encoding: s
    }) : {};
    return A.type === Wt && a === ft.CONTINUOUS && l.value && l.value.field === i ? (o = wc({
      dm: t,
      valueField: l.value.field,
      uniqueField: l.uniqueField.field,
      fieldAs: a
    }), o = Hl(o)) : a === ft.DISCRETE ? o = r === zi ? t.getField(i)?.getAllBins() : t.getField(i)?.uniques() : o = t.getDomain(i, a), o;
  }
  getTransformedValueFromNormalizedData(t, i) {
    return this.transformType() === Wt ? t[i] > 0 ? t[i] : t[`${i}0`] || 0 : t[i] || 0;
  }
}, rK = {
  classPrefix: On,
  defClassName: "layer-area",
  className: "",
  interpolate: "linear",
  transform: {},
  interaction: {
    select: {
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  {
                    target: "exitSet",
                    style: {
                      fill: { a: -0.5 }
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            // {
            //   target: "entrySet",
            //   style: {
            //     "fill-opacity": 0.7,
            //   },
            // },
            {
              target: "exitSet",
              style: {
                "fill-opacity": 0.2
              }
            }
          ]
        },
        "persistent-area-anchors": {}
      }
    },
    highlight: {
      sideEffects: {
        "area-anchors": {},
        "area-borders": {}
      }
    },
    brush: {
      sideEffects: {
        "brush-area-anchors": {}
      }
    }
  },
  crossline: !0,
  nearestPointThreshold: 10,
  encoding: {
    color: {},
    opacity: { value: 0.3 },
    x: {},
    x0: {},
    y: {},
    y0: {},
    text: { ...Oo }
  },
  transition: {
    effect: "cubic",
    duration: 1e3
  },
  connectNullData: !1,
  highlightExactPoint: !1,
  detectHoverOnEmptyArea: !0,
  interactive: !0
}, g0 = fn.area, lK = ({ mount: e, points: t = [], styles: i, selector: n, layer: s }) => {
  const [A, o] = ["enter", "update"].map((g) => {
    const h = Kd.path();
    return t.forEach((d) => {
      s.isVerticalArea() ? (h.moveTo(d[g].x, d[g].y), h.lineTo(d[g].x, d[g].y0)) : (h.moveTo(d[g].x0, d[g].y), h.lineTo(d[g].x, d[g].y));
    }), h.toString();
  }), a = z(e, "g", [1], n);
  Object.keys(i).map((g) => {
    a.style(g, i[g]);
  });
  const r = a.selectAll("path").data(t.length ? [t] : []), l = r.enter().append("path").attr("d", A);
  r.merge(l).attr("d", o), r.exit().remove();
}, cK = (e) => {
  const {
    layer: t,
    container: i,
    points: n,
    transition: s,
    animationAggregator: A,
    className: o,
    interpolate: a,
    connectNullData: r,
    style: l
  } = e;
  t.transformType() !== D6 && lK({
    mount: i,
    styles: {
      stroke: l.fill
    },
    points: r ? [] : uB(n, {
      isNull: (Q) => Q.isNull
    }),
    selector: `.${t.config().classPrefix}-area-disconnected-points`,
    layer: t
  });
  const c = t._graphicElems, { effect: g, duration: h, disabled: d } = s, u = X(i), f = gc[a], I = z(
    u,
    "g",
    [1],
    `.${t.config().classPrefix}-area-connected-points`
  ).selectAll("path").data(n.length ? [n] : []), [E, B] = ["enter", "update"].map((Q) => t.isVerticalArea() ? g0().curve(f).x((y) => y[Q].x).y1((y) => y[Q].y).y0((y) => y[Q].y0).defined(
    (y) => y.is100PercentNull || (y.isSplitPoint ? !1 : r ? !0 : !y.isNull)
  ) : g0().curve(f).x1((y) => y[Q].x).x0((y) => y[Q].x0).y((y) => y[Q].y).defined(
    (y) => y.is100PercentNull || (y.isSplitPoint ? !1 : r ? !0 : !y.isNull)
  ));
  u.attr("class", o);
  let m = n;
  const p = I.enter().append("path").attr("d", E(m)).each((Q) => {
    Q.forEach((y) => {
      y.rowId !== null && !y.isSplitPoint && (c[y.rowId] = u);
    });
  });
  let w = I.merge(p);
  d || w.node() && (w = w.transition().ease(lc[g]).duration(h).on("end", A.newCallback())), w.attr("d", B(m));
}, { CONTINUOUS: gK } = ft, { TIME: hK } = YS, { CATEGORICAL: dK } = MY, Df = ({
  yField: e,
  xField: t,
  yFieldAs: i,
  xFieldAs: n,
  dm: s,
  transformConf: A
}) => {
  if (A.type === Wt || A.type === Xt)
    return A.value?.field === e;
  const o = s.getField(e) && s.getField(e).type(), a = s.getField(t) && s.getField(t).type(), r = s.getField(t) && s.getField(t).subtype(), l = s.getField(e) && s.getField(e).subtype();
  return n === ft.DISCRETE && i === ft.DISCRETE ? !0 : i === ft.CONTINUOUS && o === Ct.MEASURE || n === ft.CONTINUOUS && (a === Ct.DIMENSION || r === ot.TEMPORAL) && i === ot.CONTINUOUS && l == ot.CONTINUOUS || n === ft.DISCRETE && i === ft.CONTINUOUS;
}, uK = (e, t) => {
  const { Y0: i } = bs(t);
  return !(e[i] < 0);
}, fK = (e, t) => e.reduce(
  (i, n) => {
    const s = [], A = [], o = i[0], a = i[1];
    return n.forEach((r) => {
      uK(r, t) ? s.push(r) : A.push(r);
    }), n.length === 1 ? [
      [...o],
      [
        ...a,
        n.map((r) => ({
          ...r,
          isLine: !0
        }))
      ]
    ] : [
      [...o, ...s.length ? [s] : []],
      [...a, ...A.length ? [A] : []]
    ];
  },
  [[], []]
).map((i) => i.reduce(
  (n, s) => {
    const A = n[0], o = n[1];
    return [[...A, s], [...o]];
  },
  [[], []]
).flat()).flat(), bs = (e) => {
  const t = e.isVerticalArea();
  return {
    X: t ? "x" : "y",
    X0: t ? "x0" : "y0",
    Y: t ? "y" : "x0",
    Y0: t ? "y0" : "x"
  };
}, OI = (e, t, i = !1, n) => {
  const { X: s, X0: A, Y: o, Y0: a } = bs(n), r = e[a] < 0, l = e.originalCoords ? e.originalCoords : {
    [o]: e[o],
    [a]: e[a],
    [s]: e[s],
    [A]: e[A]
  };
  return r ? {
    ...e,
    originalCoords: l,
    [o]: t,
    [a]: e[a] - e[o] + t,
    isDummy: i,
    isDuplicate: !0
  } : {
    ...e,
    originalCoords: l,
    [o]: e[o] - e[a] + t,
    [a]: t,
    isDummy: i,
    isDuplicate: !0
  };
}, rg = ({
  dataPoint: e,
  dataPointIndex: t,
  dataPointArr: i,
  indexOfXByXValues: n,
  context: s
}) => {
  const { X: A } = bs(s), o = s.isVerticalArea(), a = t > 0 && n[e[A].toString()] - 1 === n[i[t - 1][A].toString()], r = o ? "yField" : "xField";
  if (a) {
    const l = i[t - 1];
    if (!K.isInvalid(
      l.dataObj[s.encodingFieldsInf()[r]]
    ))
      return !0;
  }
  return !1;
}, lg = ({
  dataPoint: e,
  dataPointIndex: t,
  dataPointArr: i,
  indexOfXByXValues: n,
  context: s
}) => {
  const { X: A } = bs(s), o = s.isVerticalArea(), a = t < i.length - 1 && n[e[A].toString()] + 1 === n[i[t + 1][A].toString()], r = o ? "yField" : "xField";
  if (a) {
    const l = i[t + 1];
    if (!K.isInvalid(
      l.dataObj[s.encodingFieldsInf()[r]]
    ))
      return !0;
  }
  return !1;
}, IK = ({
  dataPoint: e,
  disconnectedPoints: t,
  context: i
}) => {
  const { X: n, Y: s, Y0: A } = bs(i);
  if (e.isLine)
    return { ...e };
  if (e.stackSumCalculated)
    return e;
  const o = e[A] < 0;
  let a = 0, r = 0, l = 0;
  t[e[n]] && (a = t[e[n]].filter(({ isRendered: h }) => h).reduce((h, d) => {
    const { [s]: u, [A]: f } = d, { [s]: C, [A]: I } = e;
    if (f < 0 !== o)
      return h;
    const B = Math.max(0, Math.min(u, C) - Math.max(f, I));
    return h + B;
  }, 0), r = t[e[n]].filter(({ isRendered: h }) => h).reduce((h, d) => {
    const { [s]: u, [A]: f } = d, { [s]: C, [A]: I } = e, E = f < 0;
    return E !== o ? h : Math.max(0, Math.min(u, C) - Math.max(f, I)) ? Math.max(h, Math.abs(E ? f : u)) : h;
  }, 0), l = t[e[n]].filter(({ isRendered: h }) => h).reduce((h, d) => {
    const { [s]: u, [A]: f } = d, { [s]: C, [A]: I } = e, E = f < 0;
    return E !== o ? h : !Math.max(0, Math.min(u, C) - Math.max(f, I)) && (E ? u < I : f > C) ? h + Math.abs(u - f) : h;
  }, 0));
  const g = Math.max(
    Math.abs(e[o ? [A] : [s]]),
    Math.abs(r + l)
  ) + a;
  return g ? o ? { ...e, [A]: -1 * g, stackSumCalculated: !0 } : { ...e, [s]: g, stackSumCalculated: !0 } : { ...e, stackSumCalculated: !0 };
}, CK = ({
  dataPoint: e,
  hasPointBefore: t,
  hasPointAfter: i,
  seriesDataAccumulator: n,
  maxAllocatedValueClockwise: s,
  maxAllocatedValueAntiClockwise: A,
  disconnectedPoints: o,
  context: a
}) => {
  const { Y: r } = bs(a), [l, c] = [
    OI(
      e,
      A,
      Math.abs(A - e[r]) > Math.abs(s - e[r]),
      a
    ),
    OI(
      e,
      s,
      Math.abs(A - e[r]) < Math.abs(s - e[r]),
      a
    )
  ].filter((g) => !!g).map((g) => IK({
    dataPoint: g,
    disconnectedPoints: o,
    context: a
  }));
  if (t && i)
    return n.length ? [
      ...n.slice(0, n.length - 1),
      [
        ...Array.isArray(
          n[n.length - 1]
        ) ? n[n.length - 1] : [n[n.length - 1]],
        l
      ],
      [c]
    ] : [[c]];
  if (t) {
    if (!i)
      return n.length ? [
        ...n.slice(0, n.length - 1),
        [
          ...Array.isArray(
            n[n.length - 1]
          ) ? n[n.length - 1] : [n[n.length - 1]],
          l
        ]
      ] : [[c]];
  } else return [...n, [c]];
  return [...n];
}, EK = ({
  dataPointsPair: e,
  splittedSeriesDataAccumulator: t,
  context: i
}) => {
  const { X: n, Y: s, Y0: A } = bs(i);
  if (Array.isArray(e) && t.length > 0 && Array.isArray(
    t[t.length - 1]
  ) && t.length) {
    const o = t[t.length - 1][t[t.length - 1].length - 1];
    if (e[0][n] === o[n] && e.length > 1 && e[0][s] === o[s] && e[0][A] === o[A])
      return [
        ...t.slice(
          0,
          t.length - 1
        ),
        [
          ...t[t.length - 1].slice(
            0,
            t[t.length - 1].length - 1
          ),
          ...e
        ]
      ];
  }
  return [...t, e];
}, Tb = ({
  uniqueFieldSubtype: e,
  uniqueAxisDomain: t,
  uniqueAxisUniqueValues: i
}) => {
  const n = (e === dK ? t : e === gK ? i.sort((s, A) => Number.isFinite(s) && Number.isFinite(A) ? s < A ? -1 : 1 : -1) : i).map((s) => s.toString());
  return e === hK && n.sort(
    (s, A) => t[0] - t[t.length - 1] > 0 ? A - s : s - A
  ), n;
}, Gb = (e, t, i) => e.map((n) => {
  const s = t.find((A) => A.dataObj);
  return s ? s.dataObj[n] : i.id();
}).join("-"), BK = (e, t) => {
  const { X: i, X0: n, Y: s, Y0: A } = bs(t), o = t.isVerticalArea();
  if (t.transformType() !== Xt || !t._transformedData._config.groupBy || !t._transformedData._sortedValues)
    return e;
  const a = t._transformedData._config.groupBy;
  if (a.length === 0)
    return e;
  const r = t._transformedData._config.groupBy[0], l = t._transformedData._sortedValues.slice().reverse().map((y) => y.toString()), c = t.encodingFieldsInf(), g = t.axes()[i], h = i === "x" ? c.xField : c.yField, d = g.domain().map((y) => y.toString()), u = t.data().getField(h).uniques(), f = {};
  l.map((y, D) => {
    f[y.toString()] = D;
  });
  const { xFieldSubType: C, yFieldSubType: I } = c, B = Tb({
    uniqueFieldSubtype: o ? C : I,
    uniqueAxisDomain: d,
    uniqueAxisUniqueValues: u
  }), m = {};
  B.forEach((y) => {
    m[y] = {
      cw: 0
    };
  });
  const p = {}, Q = e.filter((y) => y.length).sort((y, D) => f[y[0].dataObj[r].toString()] - f[D[0].dataObj[r].toString()]).map((y) => {
    const { x: D, y: _ } = t.axes(), x = o ? D : _, S = o ? "x" : "y";
    return Qc(y, t.axes(), { sortAxis: x, sortCoord: S });
  }).map((y) => {
    const D = Gb(a, y, t);
    return B.map((_, x) => {
      const S = y.findIndex((T) => T[i].toString() === _ || K.isInvalid(T[i]) && _.toString() === "null"), b = y[S];
      let R = null;
      if (b) {
        const T = m[_].cw + (y[S][s] - y[S][A]), v = m[_].cw;
        R = {
          ...y[S],
          [s]: Number.isNaN(T) ? 0 : T,
          [A]: Number.isNaN(v) ? 0 : v,
          dataObj: {},
          seriesId: D
        };
      } else
        R = {
          ...y[0],
          [i]: _,
          [n]: _,
          [s]: m[_].cw,
          [A]: m[_].cw,
          seriesId: D
        };
      R[s] === R[A] && (R.is100PercentNull = !0);
      const G = Math.max(
        m[_].cw,
        y[S] ? R[s] : 0
      );
      return m[_].cw = G, p[x] = G, R;
    });
  });
  return Q.forEach((y, D) => {
    Q[D] = y.filter(
      (_, x) => p[x] !== 0
    );
  }), Q;
}, mK = (e, t) => {
  const { X: i, Y: n, Y0: s } = bs(t), A = t.isVerticalArea();
  if (
    // !(context.transformType() === "stack") ||
    !t._transformedData._config.groupBy || !t._transformedData._sortedValues
  )
    return e;
  const o = t._transformedData._config.groupBy[0], a = t._transformedData._config.groupBy, r = t._transformedData._sortedValues.slice().reverse().map((b) => b.toString()), l = t.encodingFieldsInf(), c = t.axes()[i], g = i === "x" ? l.xField : l.yField, h = c.domain().map((b) => b.toString()), d = t.data().getField(g).uniques(), { xFieldSubType: u, yFieldSubType: f } = l, I = Tb({
    uniqueFieldSubtype: A ? u : f,
    uniqueAxisDomain: h,
    uniqueAxisUniqueValues: d
  }), E = {};
  I.forEach((b, R) => E[b.toString()] = R);
  const B = {}, m = {};
  I.forEach((b) => {
    B[b] = {
      cw: 0,
      aw: 0
    }, m[b] = {
      cw: 0,
      aw: 0
    };
  });
  const p = {}, w = {};
  I.forEach((b) => {
    p[b] = 0, w[b] = 0;
  });
  const Q = {};
  r.map((b, R) => {
    Q[b.toString()] = R;
  });
  const y = e.filter((b) => b.length).sort((b, R) => Q[b[0].dataObj[o].toString()] - Q[R[0].dataObj[o].toString()]).map((b) => {
    const { x: R, y: G } = t.axes(), T = A ? R : G, v = A ? "x" : "y";
    return Qc(b, t.axes(), { sortAxis: T, sortCoord: v });
  }), D = fK(
    y,
    t
  ), _ = {}, x = {};
  return D.forEach((b) => {
    const R = b[0][s] < 0;
    b.forEach((G, T, v) => {
      const H = lg({
        dataPoint: G,
        dataPointIndex: T,
        dataPointArr: v,
        indexOfXByXValues: E,
        context: t
      });
      if (!(rg({
        dataPoint: G,
        dataPointIndex: T,
        dataPointArr: v,
        indexOfXByXValues: E,
        context: t
      }) || H) && G[n] !== G[s]) {
        const M = {
          [n]: G[n],
          [s]: G[s],
          groupByValue: G.dataObj[o],
          rowId: G.rowId,
          isRendered: !1
        };
        G.isLine = !0, Array.isArray(
          (R ? x : _)[G[i]]
        ) ? (R ? x : _)[G[i]].push(M) : (R ? x : _)[G[i]] = [M];
      }
    });
  }), D.reduce((b, R) => {
    const G = R[0][s] < 0, T = Gb(
      a,
      R,
      t
    ), v = R.reduce((H, N, M, F) => {
      if (!N[i] && K.isInvalid(N[n]))
        return [...H];
      if (N.seriesId = T, N.isLine) {
        const { aw: q, cw: $ } = (G ? m : B)[N[i]], W = G ? Math.min(q, $) : Math.max(q, $), U = (G ? w : p)[N[i]], J = G ? Math.min(W, U) : Math.max(W, U), V = OI(
          N,
          J,
          !1,
          t
        );
        (G ? w : p)[N[i]] = G ? V[s] : V[n];
        const Y = (G ? x : _)[V[i]];
        if (Y && Y.length) {
          const nt = Y.findIndex((tt) => tt.rowId === V.rowId);
          nt >= 0 && ((G ? x : _)[V[i]][nt].isRendered = !0);
        }
        return [...H, V];
      }
      const k = lg({
        dataPoint: N,
        dataPointIndex: M,
        dataPointArr: F,
        indexOfXByXValues: E,
        context: t
      }), O = rg({
        dataPoint: N,
        dataPointIndex: M,
        dataPointArr: F,
        indexOfXByXValues: E,
        context: t
      }), { cw: P, aw: L } = (G ? m : B)[N[i].toString()];
      return CK({
        dataPoint: N,
        hasPointBefore: O,
        hasPointAfter: k,
        seriesDataAccumulator: H,
        maxAllocatedValueClockwise: P,
        maxAllocatedValueAntiClockwise: L,
        disconnectedPoints: G ? x : _,
        context: t
      });
    }, []).reduce((H, N) => EK({
      dataPointsPair: N,
      splittedSeriesDataAccumulator: H,
      context: t
    }), []).reduce((H, N, M, F) => Array.isArray(N) ? [...H, N.flat()] : M > 0 && Array.isArray(F[M - 1]) ? [...H, [N]] : H.length ? [
      ...H.map((k, O) => O === H.length - 1 ? [...k, N] : k)
    ] : [[N]], []).map((H) => H.filter((N, M, F) => {
      const { isLine: k } = N, O = lg({
        dataPoint: N,
        dataPointIndex: M,
        dataPointArr: F,
        indexOfXByXValues: E,
        context: t
      }), P = rg({
        dataPoint: N,
        dataPointIndex: M,
        dataPointArr: F,
        indexOfXByXValues: E,
        context: t
      });
      return k || P || O;
    })).filter((H) => H.length > 1 || H[0] && H[0].isLine);
    return v.forEach((H) => {
      H.forEach((N, M, F) => {
        const k = lg({
          dataPoint: N,
          dataPointIndex: M,
          dataPointArr: F,
          indexOfXByXValues: E,
          context: t
        }), O = rg({
          dataPoint: N,
          dataPointIndex: M,
          dataPointArr: F,
          indexOfXByXValues: E,
          context: t
        });
        N.hasPointAfter = k, N.hasPointBefore = k;
        const P = G ? s : n, L = (G ? m : B)[N[i].toString()].cw, q = (G ? m : B)[N[i].toString()].aw, $ = (G ? m : B)[N[i].toString()].groupedByValue;
        let W, U;
        if (W = L, U = q, O && k)
          W = N[P], U = N[P];
        else {
          if (!O && !k)
            return;
          O ? U = N[P] : k && (W = N[P]);
        }
        $ === T && Math.abs(W) < Math.abs(L) && (W = L), $ === T && Math.abs(U) < Math.abs(q) && (U = q), (G ? m : B)[N[i].toString()].cw = W, (G ? m : B)[N[i].toString()].aw = U, (G ? m : B)[N[i].toString()].groupedByValue = T;
      });
    }), [...b, v];
  }, []);
}, { CONTINUOUS: MA } = ft, Lb = (e) => class extends e {
  constructor(...t) {
    super(...t), this._dimensionMap = {}, this._mainColorProp = "fill";
  }
  /** Default configuration of area layer.
   *
   * @return {Object} Default configuration of layer
   */
  static defaultConfig() {
    return rK;
  }
  /**
   * Calculates the domain from data. It calls its parent class's method which is line layer
   * to get the domain and overwrites the domain according to its need.
   * @return {Array} Domain values
   */
  calculateDomainFromData(t, i) {
    const n = super.calculateDomainFromData(t), { MEASURE: s } = K.FieldType;
    return [Gt.X, Gt.Y].forEach((A) => {
      const { [`${A}FieldType`]: o } = i;
      o === s && Z(n[A], "length") && (n[A][0] = Math.min(n[A][0], 0), n[A][1] = Math.max(0, n[A][1]));
    }), n;
  }
  static getDomain(t, {
    field: i,
    encoding: n,
    layerEncodings: s,
    transform: A,
    userDomain: o,
    hasRangedEncodingInValueAxis: a = !1
  }) {
    if (!i || !t.getField(i))
      return [];
    const r = s[n].as || t.getField(i).subtype(), l = Df({
      yField: s.y.field,
      yFieldAs: s.y.as,
      xField: s.x.field,
      xFieldAs: s.x.as,
      dm: t,
      transformConf: A
    });
    if (!Number.isFinite(t.getFieldIndex(i)))
      return [];
    const c = t.getField(i).subtype(), g = l && n === "x" || !l && n === "y";
    let h;
    const { value: d, uniqueField: u } = A.type === Wt || A.type === Xt ? this.getStackConfig(t, {
      encoding: s
    }) : {}, f = this.getOverrideTransformType(A.type, {
      isRanged: a
    });
    if (f === Wt && r === MA && d && (a || d.field === i))
      h = wc({
        dm: t,
        valueField: d.field,
        uniqueField: u.field,
        fieldAs: r
      });
    else if (f === Xt && r === MA && d && (a || d.field === i)) {
      if (rb(o))
        return ab(
          t,
          o,
          { field: i, uniqueField: u, fieldAs: r, isIndependentEncoding: g }
        );
      h = EB({ dm: t });
    } else if (r === ft.DISCRETE)
      h = c !== sh ? t.getField(i).uniques() : t.getField(i).getAllBins();
    else {
      const C = s[`${n}0`];
      if (t.isEmpty())
        h = null;
      else if (Z(C, "field")) {
        const I = C.as, E = C.field, B = t.getDomain(i, r), m = t.getDomain(
          E,
          I
        );
        h = [
          Math.min(...B, ...m),
          Math.max(...B, ...m)
        ];
      } else
        h = t.getDomain(i, r);
    }
    return r === MA && c !== Au && c !== sh && Z(h, "length") && (Z(s[`${n}0`], "field") ? h.sort((C, I) => C - I) : g ? h = Vh(h) : h = Hl(h)), h;
  }
  static shouldShowAxisTicksInPercentage(t, i, n) {
    const s = n.def.encoding, A = n.def.transform;
    let o;
    if (s) {
      const a = Df({
        yField: s.y.field,
        yFieldAs: s.y.as,
        xField: s.x.field,
        xFieldAs: s.x.as,
        dm: t,
        transformConf: A
      });
      return ["x", "y"].forEach((r) => {
        !(a && r === "x" || !a && r === "y") && A.type === Xt && (o = s[r].field);
      }), i === o;
    }
    return !1;
  }
  resolveOverrideTransformConfig(t) {
    const i = this.hasRangedValueAxis();
    return i ? {
      ...t,
      originalType: t.type,
      type: this.constructor.getOverrideTransformType(
        t.type,
        { isRanged: i }
      )
    } : t;
  }
  hasRangedValueAxis() {
    const { x: t, y: i } = this.axes(), n = this.encodingFieldsInf(), { x0Field: s, x0FieldAs: A, xFieldAs: o, y0Field: a, y0FieldAs: r, yFieldAs: l } = n, c = a && (r === MA || l === MA) ? !0 : s && (A === MA || o === MA) ? !1 : null;
    if (c === null)
      return !1;
    const g = c ? i : t, { fieldInstance: h } = g.config();
    let d = !1;
    return cr(h) && (d = h.vars().map((f) => f.toString()).some(
      (f) => f === (c ? a : s)
    )), d;
  }
  static getOverrideTransformType(t, { isRanged: i }) {
    return t === Wt && i ? jn : t;
  }
  getTransformedData(t, i, n, s) {
    return mc(
      t,
      i,
      n
    );
  }
  requiresExtendDomainDiffs() {
    return !1;
  }
  /**
   * Returns the drawing method of this layer
   * @return {Function} Draw method
   */
  getDrawFn() {
    return cK;
  }
  // Compute map of the unique values for the given dimensional value
  getDimensionMap(t) {
    return this._dimensionMap[t] ? this._dimensionMap[t] : (this._dimensionMap[t] = Object.keys(this._pointMap).reduce(
      (i, n) => {
        const s = this._pointMap[n].data[t];
        return i[s] || (i[s] = []), i[s].push(this._pointMap[n]), i;
      },
      {}
    ), this._dimensionMap[t]);
  }
  postRender(t) {
    if (super.postRender(t), this.config().interactive) {
      pc(this._voronoi, this._points);
      const i = this.getBoundBoxes().flat().filter((n) => n !== null);
      this._rtree = new Io(), this._rtree.load(i);
    }
  }
  getNearestPoint(t, i, n) {
    let s = n.searchRadius;
    const A = this.data();
    if (!A || A && A.isEmpty())
      return null;
    s = s !== void 0 ? s : this.config().nearestPointThreshold;
    let o = this._voronoi.find(t, i, s), a, r = null;
    if (!o && n.dimValue && this._pointMap) {
      const c = n.dimValue[1][0], h = this.getDimensionMap(n.dimValue[0][0])[c] || [];
      for (let d = 0, u = h.length; d < u; d++) {
        const { y: f, y0: C } = h[d].update;
        if (f < i && i < C) {
          a = d, r = h[d];
          break;
        }
      }
      a !== void 0 && (o = {
        index: a,
        data: {
          x: t,
          y: i,
          data: r
        }
      });
    }
    const l = Z(o, "data", "data", "update");
    if (o) {
      const { source: c, rowId: g } = o.data.data;
      return {
        id: this.getIdentifiersFromData(c, g),
        dimensions: [
          {
            x: l.x,
            y0: l.y0,
            y: l.y,
            width: 2,
            height: 2
          }
        ],
        point: o.data.data,
        layerId: this.id()
      };
    }
    return null;
  }
  getDataBoundary(t, i) {
    let n = null;
    if (this._graphicElems)
      for (let A in this._graphicElems) {
        const o = this._graphicElems[A], a = o.node().ownerSVGElement;
        if (a) {
          const r = a.createSVGPoint();
          if (r.x = t, r.y = i, o.node().querySelector(".muze-area-connected-points path").isPointInFill(r)) {
            n = o.datum();
            break;
          }
        }
      }
    const s = n && n.data && n.data.length ? (n.data.find((A) => A.seriesId) || {
      seriesId: this.id()
    }).seriesId : this.id();
    return n ? {
      layerId: this.id(),
      points: n,
      id: s
    } : null;
  }
  getTextPointsCoords(t) {
    const i = this.isVerticalArea(), n = this.transformType(), { x: s, y: A, x0: o } = t;
    return !i && (n === Wt || n === Xt) ? {
      x: o,
      y: A
    } : {
      x: s,
      y: A
    };
  }
  /**
   * Generates the x and y positions for each point
   * @param {Array} data Data Array
   * @param {Object} encoding Visual Encodings of the layer
   * @param {Object} axes Contains the axis
   * @return {Array} Array of points
   */
  translatePoints(t, i, n) {
    let s = [];
    const A = this.transformType(), o = this.axes(), a = this.config(), { y0Field: r, x0Field: l, textField: c, yField: g, xField: h } = this.encodingFieldsInf(), { x: d, y: u } = o, f = a.individualClassName, C = d.domain()[0], I = u.domain()[0], E = C < 0 ? d.getScaleValue(0) : d.getScaleValue(C), B = I < 0 ? u.getScaleValue(0) : u.getScaleValue(I), m = this.isVerticalArea(), p = m ? o.x : o.y;
    Qc(t, o, { sortAxis: p, sortCoord: m ? "x" : "y" });
    const Q = /* @__PURE__ */ new Set();
    return s = t.map((y, D) => {
      let _, x, S, b, R;
      d.isBinnedAxis(), x = m ? d.getScaleValue(y.x) + d.getUnitWidth() / 2 : d.getScaleValue(y.x), b = l || A === Wt || A === Xt ? d.getScaleValue(y.x0) : E, u.isBinnedAxis() ? (S = m ? u.getScaleValue(y.y) : u.getScaleValue(y.y) + (u.constructor.type() === be ? -1 * u.getUnitWidth() / 2 : u.getUnitWidth() / 2), R = r || A === Wt || A === Xt ? u.getScaleValue(y.y0) + (u.constructor.type() === be ? -1 * u.getUnitWidth() / 2 : u.getUnitWidth() / 2) : B) : (S = m ? u.getScaleValue(y.y) : u.getScaleValue(y.y) + u.getUnitWidth() / 2, R = r || A === Wt || A === Xt ? u.getScaleValue(y.y0) : B);
      const G = ts(this, y);
      _ = G.getColor(K.getActualValue(y.color));
      const T = K.isInvalid(y.x), v = K.isInvalid(y.x0), H = K.isInvalid(y.y), N = K.isInvalid(y.y0), M = Qs(this, {
        translatedValues: {
          x,
          y: S,
          x0: b,
          y0: R,
          color: _,
          text: y.text,
          formattedText: y.formattedText
        },
        datum: y,
        datumIdx: D,
        groupData: t,
        groupIdx: i,
        layerData: n
      });
      _ = M.color;
      const F = {
        fill: _
      };
      let k;
      c && (k = Po(
        this,
        {
          ...this.getTextPointsCoords(M),
          text: M.text,
          formattedText: M.formattedText,
          color: ib(G, y.color)
        },
        y,
        D,
        t,
        {
          show: !y.isDummy
        }
      ));
      const O = m ? {
        x,
        x0: v ? null : E,
        y: H ? null : B,
        y0: N ? null : B
      } : {
        x: T ? null : E,
        x0: v ? null : E,
        y: S,
        y0: N ? null : B
      }, P = m ? {
        x,
        x0: v ? null : M.x0,
        y: H ? null : M.y,
        y0: N ? null : M.y0
      } : {
        x: T ? null : M.x,
        x0: v ? null : M.x0,
        y: S,
        y0: N ? null : M.y0
      }, L = {
        enter: O,
        update: P,
        source: y.source,
        rowId: y.rowId,
        data: y.dataObj,
        normalizedData: y,
        className: f ? f(y, D, t, this) : "",
        style: F,
        meta: ys(F),
        text: k,
        isNull: y.isSplitPoint || y.isLine || K.isInvalid(y.dataObj[m ? g : h]),
        isLine: y.isLine,
        isSplitPoint: y.isSplitPoint,
        isDummy: y.isDummy,
        is100PercentNull: y.is100PercentNull,
        includeInBorder: y.includeInBorder,
        seriesId: y.seriesId
      };
      return L.className = Vs(y, D, t, this), Q.add(y.rowId), !L.isSplitPoint && !L.is100PercentNull && this.cachePoint(y.rowId, L), L;
    }), c && (s = this.optimizeTextLabelPositions(s)), s = Uo(this, s), s = s.filter((y) => {
      const D = y.update;
      return m ? !isNaN(D.x) : !isNaN(D.y);
    }), {
      points: s,
      validPointCount: Q.size
    };
  }
  transformNormalizedDataForStack(t) {
    const { X: i, Y: n, X0: s, Y0: A } = bs(this), a = this.axes()[i].domain(), r = mK(
      t,
      this
    ), l = (c, g) => ({
      ...c,
      [n]: 0,
      [A]: 0,
      [i]: g,
      [s]: g,
      isNull: !0,
      isDummy: !0,
      isSplitPoint: !0
    });
    return r.reduce((c, g) => {
      let h = [];
      return g.length && Array.isArray(g[0]) ? g.forEach((d) => {
        if (h = h.concat(d), h.length && h[h.length - 1].hasPointAfter === !1) {
          const u = d[d.length - 1][i], f = u === a[a.length - 1] ? null : u;
          h.push(
            l(d[d.length - 1], f)
          );
        }
      }) : h = h.concat(g), [...c, h];
    }, []).filter((c) => c.length);
  }
  transformNormalizedDataFor100PercentStack(t) {
    return BK(t, this);
  }
  getTranslatedData(t, i, n) {
    const s = this._transformConfig.groupBy;
    let A;
    switch (this.transformType()) {
      case Xt:
        A = this.transformNormalizedDataFor100PercentStack(t);
        break;
      case Wt:
        A = this.transformNormalizedDataForStack(t);
        break;
      default:
        A = t;
        break;
    }
    return this._normalizedData = t, this._transformedNormalizedData = A, A.map((o, a) => {
      if (!o.length)
        return null;
      let r, l, c = o[0].color, g = o[0].opacity;
      const h = s.map(
        (E) => o[0].dataObj[E]
      ), d = h.length ? h + a : [this.id()];
      i ? r = i(o, a, t) : (c = K.getActualValue(c), r = ts(this, o[0]).getColor(c)), typeof n == "function" ? l = n(
        {
          datum: o[a],
          datumIdx: a,
          groupData: o,
          groupIdx: a,
          layerData: A
        },
        { context: this, encodingName: "opacity" }
      ) : (g = K.getActualValue(g), l = ws(this, o[0]).getOpacity(g));
      const u = this.config().encoding;
      typeof u.opacity.value != "function" && !u.opacity.field && (l = u.opacity.value);
      const f = this.getPathStyle(r, l), { points: C, validPointCount: I } = this.translatePoints(
        o,
        a,
        A
      );
      return {
        data: C,
        validPointCount: I,
        style: f,
        meta: ys(f),
        id: d
      };
    }).filter((o) => o !== null);
  }
  getPathPoints(t) {
    return t;
  }
  resolveTransformType() {
    return this._transformType = gB(this), this._transformType;
  }
  /**
   * Get the css styles need to be applied on the line path
   * @param {string} color Color value
   * @return {Object} Path styles
   */
  getPathStyle(t, i) {
    const n = this.config().encoding;
    return {
      fill: t,
      ...yc(n, [this._mainColorProp]),
      opacity: i
    };
  }
  getSideEffects() {
    return {
      AreaAnchors: xu,
      PersistentAreaAnchors: AK,
      BrushAreaAnchors: oK,
      AreaBorders: aK
    };
  }
  static autoDetectTransformType(t, i) {
    return i.value && t.length ? Wt : ns;
  }
  isVerticalArea() {
    const { yFieldAs: t, yField: i, xField: n, xFieldAs: s } = this.encodingFieldsInf();
    return Df({
      yField: i,
      yFieldAs: t,
      xField: n,
      xFieldAs: s,
      dm: this.data(),
      transformConf: this._transformConfig
    });
  }
  isVertical() {
    return this.isVerticalArea();
  }
  static getStackConfig(t, i) {
    const {
      y: { field: n, as: s },
      x: { field: A, as: o }
    } = i.encoding, a = t.getField(A)?.type(), r = t.getField(n)?.type(), l = t.getField(A)?.subtype(), c = t.getField(n)?.subtype();
    let g, h;
    const d = s === ft.CONTINUOUS && r === Ct.MEASURE || o === ft.CONTINUOUS && (a === Ct.DIMENSION || l === ot.TEMPORAL) && s === ot.CONTINUOUS && c == ot.CONTINUOUS || o === ft.DISCRETE && s === ft.CONTINUOUS, u = d ? A : n, f = d ? o : s, C = d ? n : A, I = d ? s : o, E = d ? c : l;
    return I === ft.CONTINUOUS && E !== ot.TEMPORAL && (g = {
      field: u,
      as: f,
      subtype: t.getField(u)?.subtype(),
      type: t.getField(u)?.type()
    }, h = {
      field: C,
      as: I,
      subtype: t.getField(C)?.subtype(),
      type: t.getField(C)?.type()
    }), {
      uniqueField: g,
      value: h
    };
  }
  static getDefaultTransformConfig(t, i) {
    const {
      transform: n,
      encoding: {
        x: { field: s },
        y: { field: A },
        color: { field: o }
      }
    } = t, a = s === o ? ["y", "y0"] : A === o ? ["x", "x0"] : ["x", "y", "x0", "y0"], r = this.getTransformGroupByDimensions(
      t,
      a,
      i
    );
    let l = n.type, c = {
      ...n,
      groupBy: wt(n.groupBy, r)
    };
    const g = this.getStackConfig(i, t);
    return l || (l = this.autoDetectTransformType(
      r,
      g,
      i
    )), (l === Wt || l === Xt) && (c = {
      ...c,
      ...g
    }), {
      ...c,
      type: l
    };
  }
  resolveTransformConfig(t) {
    const { transform: i } = this.config();
    let n = i.type, s = {
      fields: []
    };
    const A = [
      Gt.COLOR,
      Gt.SIZE,
      Gt.SHAPE,
      Gt.TEXT,
      Gt.DETAIL
    ], o = [Gt.COLOR, Gt.SIZE, Gt.SHAPE], a = /* @__PURE__ */ new Set();
    for (let r = 0; r < A.length; r++) {
      const l = A[r], { field: c } = this.config().encoding[l] || {}, g = Bn(c), h = g && g[0], d = t.getField(h);
      if (d && d.type() === "dimension" && i.groupBy.includes(h) && !a.has(h)) {
        let u;
        o.includes(l) ? u = this.axes()[l].sortValues(d.uniques()) : u = d.uniques(), s.fields.push({
          field: h,
          values: u
        }), a.add(h);
      }
    }
    return { ...i, type: n, sort: s };
  }
  applyInteractionStyle(t, i) {
    const n = this._graphicElems, s = t;
    if (t) {
      const A = t.targetSet, o = {};
      for (const a of i) {
        const r = n[a];
        if (r) {
          const l = r.data()[0].id;
          let c = o[l];
          c || (o[l] = [0], c = o[l]), c[0] += 1, c[1] = r.data()[0].validPointCount, c[2] = r;
        }
      }
      for (let a in o) {
        const r = o[a];
        A === "entrySet" && r[0] >= 1 ? r[2] && so(
          this,
          r[2],
          s,
          t
        ) : A === "exitSet" && r[0] === r[1] ? r[2] && so(
          this,
          r[2],
          s,
          t
        ) : r[0] === r[1] && r[2] && so(
          this,
          r[2],
          s,
          t
        );
      }
    }
  }
  getTargetSet(t, i) {
    const n = {};
    for (const A of t.uids) {
      const o = this._graphicElems[A];
      if (o) {
        const a = o.data()[0].id;
        let r = n[a];
        r || (n[a] = [[]], r = n[a]), r[0].push(A), r[1] = o.data()[0].validPointCount, r[2] = o;
      }
    }
    let s = [];
    for (let A in n) {
      const o = n[A];
      (o[0].length === o[1] || i === "entrySet" && o[0].length > 0) && s.push(o[0]);
    }
    return t = { uids: new Set(s.flat()) }, t;
  }
  getYfieldEncodingForTransformedData(t) {
    return t % 2 === 0 ? "y" : "y0";
  }
  transformType() {
    const { type: t } = this._transformConfig;
    return t;
  }
};
class Ub extends ci(Ws).with(
  _B,
  Lb
) {
  static formalName() {
    return mS;
  }
}
const pK = {
  classPrefix: On,
  defClassName: "layer-arc",
  padding: { top: 1, bottom: 1, left: 1, right: 1 },
  className: "",
  interaction: {
    highlight: {
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                "stroke-width": "1px",
                stroke: "black"
              }
            }
          ]
        }
      }
    },
    brush: {},
    select: {
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  {
                    target: "exitSet",
                    style: {
                      fill: { a: -0.5 }
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                "stroke-width": "1px",
                stroke: "black"
              }
            }
          ]
        }
      }
    }
  },
  height: 100,
  width: 100,
  sort: "",
  colors: ["#F44336", "blue", "green", "yellow", "orange", "purple"],
  transform: {
    type: "group"
  },
  encoding: {
    "stroke-width": {
      value: "0px"
    },
    stroke: {
      value: ""
    },
    "stroke-linejoin": {
      value: "round"
    },
    angle: {
      value: "1"
    },
    radius: {
      value: "1",
      range: (e) => e
    },
    opacity: {
      value: "1"
    },
    color: {
      value: "1"
    },
    shape: {
      value: "1"
    },
    size: {
      value: "1"
    },
    text: { ...Oo }
  },
  transition: {
    effect: "cubic",
    duration: 500
  }
}, QK = (e, t, i) => {
  const n = e[t - 1], s = e[t], [A, o] = i.angle.range();
  return n && s ? {
    update: {
      angle0: Z(n, "update", "angle"),
      angle: Z(s, "update", "angle0")
    }
  } : s ? {
    update: {
      angle0: (A - 90) * Math.PI * 2 / 360,
      angle: (A - 90) * Math.PI * 2 / 360
    }
  } : {
    update: {
      angle0: (o - 90) * Math.PI * 2 / 360,
      angle: (o - 90) * Math.PI * 2 / 360
    }
  };
}, yK = (e, t) => {
  const i = t[0];
  return function(n) {
    return e(Ex()(i._previousInfo, i)(n));
  };
}, Un = (e) => e + Math.PI / 2, wK = (e, t, i) => {
  const { handleTextLabelClipping: n, availableDimen: s } = i;
  if (t = t.filter((h) => !!h.text), !t.length)
    return;
  if (t.length === 1) {
    const h = t[0].text;
    h.update.x = 0, h.update.y = 0, h.textAnchor = "middle", h.isVisible = !0, h.connector = null;
    return;
  }
  const A = kK(t), { width: o, height: a } = e.dependencies().smartLabel.getOriSize("X"), r = _S, l = bS;
  for (let h = 0; h < A.length; h++) {
    const d = A[h];
    if (!d.length)
      continue;
    const u = Math.max.apply(
      void 0,
      d.map((B) => B.update.radius)
    ), f = Math.max(
      Math.min(u * FS, NS),
      MS
    ), C = u + f, I = C;
    RK({
      points: d,
      availableHeight: I,
      fontHeight: a,
      padding: r
    });
    const E = d.filter((B) => B.text.isVisible);
    SK({
      quadrantIdx: h,
      points: E,
      availableHeight: I,
      outerRadius: C,
      fontHeight: a,
      padding: r
    }), NK({
      qIdx: h,
      points: E,
      connectorCrookDistance: l
    }), FK({
      points: E,
      maxRadius: u
    });
  }
  const { shouldUpdateRadius: c, radiusChangeInPercentage: g } = DK(e, t, {
    handleTextLabelClipping: n,
    fontWidth: o,
    availableDimen: s
  });
  return {
    shouldUpdateRadius: c,
    radiusChangeInPercentage: g
  };
}, DK = (e, t, i) => {
  t.forEach((f) => {
    f.text.labelSmartText = null;
  });
  const { handleTextLabelClipping: n, fontWidth: s, availableDimen: A } = i, { width: o, height: a } = A, { x: r, y: l } = t[0].update, c = {
    leftX: r - o / 2,
    rightX: r + o / 2
  }, g = Math.max.apply(
    void 0,
    t.map((f) => f.update.radius)
  ), h = g * vS, u = t.filter((f) => f.text.isVisible).map((f) => {
    const C = f.update.x + f.text.update.x, I = f.update.y + f.text.update.y, E = e.dependencies().smartLabel.getOriSize(f.text.text), B = Un(f.update.angle0), m = Un(f.update.angle), p = B + (m - B) / 2;
    let w;
    return p >= 0 && p <= Math.PI ? w = "right" : w = "left", {
      absTextPosX: C,
      absTextPosY: I,
      dimens: E,
      halfType: w,
      point: f
    };
  });
  if (n) {
    const f = u.map((E) => {
      const { absTextPosX: B, dimens: m, halfType: p } = E;
      let w;
      if (p === "right") {
        const Q = B + m.width;
        w = Math.max(Q - c.rightX, 0);
      } else {
        const Q = B - m.width;
        w = Math.max(
          c.leftX - Q,
          0
        );
      }
      return Math.abs(w);
    }), C = Math.max.apply(void 0, f), I = Math.min(C, h);
    return {
      shouldUpdateRadius: I > 0,
      radiusChangeInPercentage: -(I / g)
    };
  } else
    return u.forEach((f) => {
      const { absTextPosX: C, dimens: I, halfType: E, point: B } = f;
      let m;
      E === "right" ? m = Math.max(
        c.rightX - C,
        0
      ) : m = Math.max(
        C - c.leftX,
        0
      );
      const p = xK({
        text: B.text.text,
        textDimen: I,
        availableWidth: m,
        fontWidth: s,
        minCharCount: 3
      });
      B.text.labelSmartText = p;
    }), {
      shouldUpdateRadius: !1,
      radiusChangeInPercentage: 0
    };
}, xK = ({
  text: e,
  textDimen: t,
  availableWidth: i,
  fontWidth: n,
  minCharCount: s
}) => {
  if (s = s || 0, i >= t.width)
    return e;
  const A = "...", o = n * 2, a = Math.floor(
    (i - o) / n
  );
  return `${e.slice(0, Math.max(a, s))}${A}`;
}, SK = (e) => {
  const {
    quadrantIdx: t,
    points: i,
    availableHeight: n,
    outerRadius: s,
    fontHeight: A,
    padding: o
  } = e;
  let a = !0, r = i.map((c) => {
    const g = c.update, h = Un(g.angle0), d = Un(g.angle), u = h + (d - h) / 2, f = s * Math.sin(u), C = -s * Math.cos(u), I = f, E = C - A / 2 - o;
    return {
      x: I,
      y: E,
      height: A + o * 2,
      points: [c]
    };
  }), l = 0;
  for (; a; ) {
    let { isOverlapping: c, groups: g } = _K({
      qIdx: t,
      groupedPoints: r,
      availableHeight: n
    });
    if (r = g, a = c, l++, l >= SS)
      break;
  }
  r.forEach((c) => {
    const { y: g, height: h, points: d } = c, u = h / d.length;
    d.forEach((f, C) => {
      const I = g + u * C + u / 2, E = MK(I, s, t);
      f.text.update.x = E, f.text.update.y = I, f.text.textAnchor = t === 0 || t === 1 ? "start" : "end";
    });
  });
}, _K = ({
  qIdx: e,
  groupedPoints: t,
  availableHeight: i
}) => {
  const n = [];
  let s = null, A = !1;
  for (let o = 0; o < t.length; o++) {
    const a = t[o];
    if (!s) {
      s = a;
      continue;
    }
    if (bK(a, s)) {
      A = !0, s.height += a.height, s.points = [...s.points, ...a.points];
      let l;
      e === 0 || e === 3 ? s.height > Math.abs(s.y) ? l = Math.abs(s.height - Math.abs(s.y)) : l = 0 : s.y + s.height > i ? l = s.y + s.height - i : l = 0, s.y -= l;
    } else
      n.push(s), s = a;
  }
  return s && n.push(s), {
    isOverlapping: A,
    groups: n
  };
}, bK = (e, t) => !(e.y + e.height > t.y) || t.y + t.height > e.y, MK = (e, t, i) => {
  const n = Math.abs(e / t);
  let s = Math.sqrt(1 - Math.pow(n, 2));
  return s = isNaN(s) ? 0 : s, t * s * (i === 0 || i === 1 ? 1 : -1);
}, NK = ({
  qIdx: e,
  points: t,
  connectorCrookDistance: i
}) => {
  for (let n = 0; n < t.length; n++) {
    const s = t[n], A = s.update, o = Un(A.angle0), a = Un(A.angle), r = o + (a - o) / 2, l = 180 / Math.PI * r;
    e === 0 || e === 1 ? (l >= 0 && l <= 5 || l >= 175 && l <= 180) && (s.text.update.x += 10) : (l > 180 && l <= 185 || l >= 355 && l <= 360) && (s.text.update.x -= 10);
    const { x: c, y: g } = s.text.update, h = A.radius * Math.sin(r), d = -A.radius * Math.cos(r), u = (A.radius + i) * Math.sin(r), f = -(A.radius + i) * Math.cos(r), C = e === 0 || e === 1 ? c - 5 : c + 5, I = g;
    s.text.connector = {
      start: [h, d],
      crook: [u, f],
      end: [C, I]
    };
  }
}, FK = ({ points: e, maxRadius: t }) => {
  for (let i = 0; i < e.length; i++) {
    const n = e[i], { crook: s, end: A } = n.text.connector, o = Math.sqrt(
      Math.pow(s[0] - A[0], 2) + Math.pow(s[1] - A[1], 2)
    ), a = TK(
      { x1: s[0], y1: -s[1], x2: A[0], y2: -A[1] },
      { cx: 0, cy: 0, radius: t }
    );
    o >= t * RS || a && o >= t * kS ? n.text.isVisible = !1 : n.text.isVisible = !0;
  }
}, RK = ({
  points: e,
  availableHeight: t,
  fontHeight: i,
  padding: n
}) => {
  if (e.forEach((r) => {
    r.text.isVisible = !1;
  }), e.length * (i + 2 * n) <= t) {
    e.forEach((r) => {
      r.text.isVisible = !0;
    });
    return;
  }
  const o = e.map((r, l) => {
    const c = Un(r.update.angle0);
    return {
      sliceAngle: Un(r.update.angle) - c,
      idx: l
    };
  }).sort(
    (r, l) => l.sliceAngle - r.sliceAngle
  );
  let a = 0;
  for (let r = 0; r < o.length; r++) {
    const l = o[r];
    if (a += i + 2 * n, a <= t)
      e[l.idx].text.isVisible = !0;
    else
      break;
  }
}, kK = (e) => {
  const t = e.reduce(
    (i, n) => {
      const s = n.update, A = Un(s.angle0), o = Un(s.angle), a = A + (o - A) / 2;
      let r;
      return a >= 0 && a <= Math.PI / 2 ? r = 0 : a > Math.PI / 2 && a <= Math.PI ? r = 1 : a > Math.PI && a <= Math.PI * 3 / 2 ? r = 2 : r = 3, i[r] || (i[r] = []), i[r].push(n), i;
    },
    new Array(4).fill(0).map(() => [])
  );
  return t.forEach((i, n) => {
    (n === 2 || n === 3) && i.reverse();
  }), t;
}, vK = (e, t) => {
  if (e.selectAll("path").remove(), !t.text || !t.text.isVisible || !t.text.connector)
    return;
  const { start: i, crook: n, end: s } = t.text.connector, A = z(e, "path", [1]);
  A.attr(
    "d",
    [
      "M",
      i[0],
      i[1],
      "L",
      n[0],
      n[1],
      "L",
      s[0],
      s[1]
    ].join(" ")
  ), A.style("stroke", t.color), A.style("fill-opacity", 0), A.style("stroke-width", "1px");
}, TK = (e, t) => {
  const { x1: i, y1: n, x2: s, y2: A } = e, { cx: o, cy: a, radius: r } = t, l = (A - n) / (s - i), c = l, g = -1, h = n - l * i;
  let d = Math.abs(c * o + g * a + h) / Math.sqrt(c * c + g * g);
  return r >= d;
}, h0 = {
  radiusDomain: [0, 50],
  radiusRange: [0, 24]
}, GK = fn.arc, Hb = (e) => class extends e {
  constructor(...t) {
    super(...t), this._prevPieData = {}, this._doneSettingPolarAxesRangeOnPostLayout = !1, this._mainColorProp = "fill";
  }
  /**
   * returns the default configuration of the layer
   *
   * @static
   * @return {Object} Default configuration for arc layer
   * @memberof ArcLayer
   */
  static defaultConfig() {
    return pK;
  }
  static formalName() {
    return "arc";
  }
  static defaultPolicy(t, i) {
    const n = et(t, i);
    let s = n.encoding.radius.range, A = s;
    return A || (A = (o) => o), typeof A != "function" && (A = () => s), n.encoding.radius.range = A, n;
  }
  elemType() {
    return "path";
  }
  resolveTransformType() {
    return this._transformType = jn, this._transformType;
  }
  getTransformedData(t, i, n, s) {
    const { xField: A, yField: o } = s, a = [];
    return A && a.push(A), o && a.push(o), this.config(i), mc(
      t,
      this.config(),
      { ...n, groupBy: a }
    );
  }
  getNearestPoint(t, i, n = {}) {
    let s = n.event;
    return s || (s = bt()), this.getDataFromEvent(s);
  }
  getDataFromEvent(t) {
    const i = t.sourceEvent ? t.sourceEvent.target : t.target, n = X(i).data()[0];
    if (ke(n) && n.source && this.mount().contains(i)) {
      const { source: s, rowId: A } = n;
      return {
        id: this.getIdentifiersFromData(s, A),
        layerId: this.id(),
        point: n
      };
    }
    return null;
  }
  translateSinglePoint(t, i, n, s, A, o, a) {
    const { x: r, y: l } = this.axes(), { angle: c, radius: g } = A;
    s = s || {};
    const h = c.getScaleValue(t.angle);
    if (h) {
      !s[t.angle] && (s[t.angle] = 0);
      const { startAngle: d, endAngle: u } = h[s[t.angle]++], f = ts(this, t), C = ws(this, t), I = Qs(this, {
        translatedValues: {
          x: r.getScaleValue(t.x),
          y: l.getScaleValue(t.y),
          radius: g.getOuterRadius(t.radius),
          radius0: g.getInnerRadius(t.radius0),
          color: f.getColor(t.color),
          opacity: C.getOpacity(t.opacity),
          angle0: d,
          angle: u,
          startAngle: d,
          endAngle: u,
          startAngle0: d,
          endAngle0: u,
          text: t.text,
          formattedText: t.formattedText
        },
        datum: t,
        datumIdx: i,
        groupData: n,
        groupIdx: o,
        layerData: a
      }), E = this.axes();
      return ["x", "y"].forEach((B) => {
        const m = E[B], p = m.getUnitWidth();
        m.isYAxis() && m.constructor.type() === be ? I[B] -= p / 2 : I[B] += p / 2;
      }), I;
    }
  }
  translatePoints(t, i, n, s, A) {
    n = et(
      {},
      {
        handleTextLabelClipping: !1
      },
      n
    );
    const { textField: o } = this.encodingFieldsInf(), a = {}, r = this._points[0] || [];
    let l = [];
    const c = {};
    if (this._prevPieData = {}, r.forEach((g, h) => {
      this._prevPieData[g.rowId] = [g, h], a[g.index] = g;
    }), t.forEach((g, h) => {
      const d = this.translateSinglePoint(
        g,
        h,
        t,
        c,
        i,
        s,
        A
      ), u = this.config().outline, f = d.color, C = d.opacity, I = {
        fill: f,
        opacity: C,
        ...mu(u, f)
      }, E = I["stroke-width"] ? I["stroke-width"] : this.config().encoding["stroke-width"].value, B = I.stroke ? I.stroke : this.config().encoding.stroke.value;
      if (d) {
        const m = g.rowId;
        let p;
        o && (p = Po(
          this,
          {
            x: d.x,
            y: d.y,
            text: d.text,
            formattedText: d.formattedText,
            color: pu.textColor
          },
          g,
          h,
          t
        ));
        const w = {
          source: g.source,
          index: h,
          enter: {},
          update: {
            x: d.x,
            y: d.y,
            angle0: d.angle0,
            angle: d.angle,
            radius0: d.radius0,
            radius: d.radius
          },
          color: f,
          opacity: C,
          style: I,
          text: p,
          meta: ys({
            fill: f,
            opacity: C,
            stroke: B,
            "stroke-width": E
          }),
          rowId: m,
          data: g.dataObj,
          _previousInfo: this._prevPieData[m] ? this._prevPieData[m][0] : QK(a, h, i)
        };
        l.push(w), this.cachePoint(m, w);
      }
    }), o) {
      let g;
      if (this.isUnivariate())
        g = this.measurement();
      else {
        const { x: d, y: u } = this.axes();
        (d instanceof xe || d instanceof Be) && (u instanceof xe || u instanceof Be) ? g = {
          width: d.getScaleBandwidth() + d.getScalePaddingInner(),
          height: u.getScaleBandwidth() + u.getScalePaddingInner()
        } : g = this.measurement();
      }
      const h = wK(this, l, {
        handleTextLabelClipping: n.handleTextLabelClipping,
        availableDimen: g
      });
      if (n.handleTextLabelClipping && h && h.shouldUpdateRadius) {
        const { radius: d } = i;
        d.range(
          d.range().map((u) => u + u * h.radiusChangeInPercentage)
        ), l = this.translatePoints(
          t,
          i,
          {
            handleTextLabelClipping: !1
          },
          s,
          A
        );
      }
    }
    return l;
  }
  render(t, i) {
    this.preRender(i, !0), this._doneSettingPolarAxesRangeOnPostLayout ? this._doneSettingPolarAxesRangeOnPostLayout = !1 : this.setPolarAxesRange();
    const {
      classPrefix: n,
      defClassName: s,
      className: A,
      cornerRadius: o,
      padAngle: a,
      padRadius: r,
      transition: l
    } = this.config(), c = ms(
      s,
      this.id(),
      n
    ), g = X(t);
    g.classed(c.join(" "), !0), g.classed(A, !0);
    const h = Js(), d = wt(
      i.transition,
      l
    ), u = ms(
      s,
      this.id(),
      n
    ), f = this._arcFn = GK().cornerRadius(o).startAngle((w) => Un(w.update.angle0)).endAngle((w) => Un(w.update.angle)).padAngle(a).padRadius(r).outerRadius((w) => w.update.radius).innerRadius((w) => w.update.radius0), C = this.getRenderableNormalizedData();
    this._points = C.map((w, Q) => this.translatePoints(
      w,
      this._polarAxes[Q],
      {
        // If it is an isUnivariate chart(single pie chart), then handle
        // text label clipping by reducing the radius, otherwise, just use
        // ellipsis.
        handleTextLabelClipping: this.isUnivariate()
      },
      Q,
      C
    )).reduce((w, Q) => {
      const y = Q.filter(
        (D) => !Number.isNaN(D.update.x) && !Number.isNaN(D.update.y)
      );
      return y.length ? [...w, y] : w;
    }, []);
    const I = this._graphicElems = {};
    this._linkedElems = {};
    const E = z(
      X(t),
      "g",
      this._points,
      `${u[0]}-group`
    ).classed(`${u[1]}-group`, !0).attr("transform", ([w]) => `translate(${w.update.x},${w.update.y})`), B = `${u[0]}-labels`, m = (w) => {
      let Q = z(
        w,
        "path",
        (y) => [y],
        `${u[0]}-path`
      ).each(function(y) {
        const D = X(this);
        vt(D, y.style), I[y.rowId] = D;
      });
      d.disabled ? Q.attr("d", f) : Q = Q.transition().duration(d.duration).on("end", h.newCallback()).attrTween("d", (...y) => yK(f, y)), Q.attr("class", (y, D) => {
        const _ = Vs(
          y,
          D,
          this._points,
          this
        );
        return `${u[0]}-path ${u[1]}-path-${y.index}
                        ${_}`;
      });
    }, p = z(E, "g", (w) => w, `${u[0]}`, {
      update: m
    }).attr(
      "class",
      (w, Q) => `${u[0]} ${u[1]}-${Q}`
    );
    if (this.onAnimationEnd().then(() => {
      p.each(function(w) {
        const Q = X(this), y = z(
          Q,
          "g",
          [1],
          `.${B}`
        );
        w.text && vK(y, w);
      });
    }), this.hasTextEncodingField())
      if (this._stackedSum.size) {
        const w = this.getTextPointsForStackSum();
        this.textPointsInfo({
          points: w,
          location: "text"
        });
      } else {
        const w = this._points.flat();
        this.textPointsInfo({
          points: w,
          location: "sum"
        });
      }
    else
      this.textPointsInfo(null);
    return this.postRender(i), h.onAllCallbacksCalled().then(() => {
      this.emitAnimationEndHook(i);
    }), this;
  }
  filterTextPoints(t) {
    const { points: i } = t;
    return this._stackedSum.size ? super.filterTextPoints(t) : i.filter((n) => !!n.text && n.text.isVisible);
  }
  getPointsFromIdentifiers(t) {
    if (!this.data())
      return [];
    const i = [];
    for (const s of t)
      this._pointMap[s] && i.push(this._pointMap[s]);
    const n = i[0];
    return n ? [this.getCartesianCoordinatesFromPointInfo(n)] : [];
  }
  getCartesianCoordinatesFromPointInfo(t) {
    const i = this._arcFn.centroid(t);
    return {
      x: i[0] + t.update.x,
      y: i[1] + t.update.y,
      width: 2,
      height: 2
    };
  }
  static autoDetectTransformType() {
    return jn;
  }
  /**
   * @override
   */
  postLayout() {
    this.setPolarAxesRange(), this._doneSettingPolarAxesRangeOnPostLayout = !0;
  }
  /**
   * @override
   */
  requiresExtendDomainDiffs() {
    return !0;
  }
  createPolarAxes() {
    const t = this._normalizedData, i = [], { radiusField: n } = this.encodingFieldsInf();
    t.forEach((s) => {
      const A = this.calculatePolarDomain(s);
      let o = new y6();
      n ? o.domain(A.radius) : o.domain(h0.radiusDomain);
      const a = this.config().encoding, r = wt(
        Z(a.angle, "field"),
        Z(a.color, "field")
      );
      let l = De;
      const c = this.data().getField(r);
      r && c && (l = c.subtype() === su || c.subtype() === zi ? De : "continuous");
      let g = new Q6({
        angle: { as: l, ...this.config().encoding.angle },
        fieldInst: c
      });
      g.domain(A.angle), i.push({
        radius: o,
        angle: g
      });
    }), this._polarAxes = i;
  }
  setPolarAxesRange() {
    const t = this.encodingFieldsInf(), i = this.axes();
    let s = this.config().encoding.radius.range;
    const { xField: A, yField: o, sizeField: a, sizeFieldType: r, textField: l } = t, { x: c, y: g, size: h } = i, d = c.scale().range()[1], u = g.scale().range()[0];
    this._normalizedData.forEach((f, C) => {
      const { radius: I } = this._polarAxes[C];
      if (!I)
        return;
      let E;
      if (A === ht && o === ht)
        E = l ? Math.min(d / 3, u / 3) : Math.min(d / 2, u / 2);
      else if (h && a) {
        const p = f.map((w) => w.size);
        r === K.FieldType.MEASURE ? E = h.getSize(Math.max(...p)) : E = h.getSize(p[0]);
      } else {
        const p = [c, g].map((w) => w instanceof xe ? w.getScaleBandwidth() - w.getScalePaddingInner() : w instanceof Be ? w.getUnitWidth() / 2 : h0.radiusRange[1]);
        E = Math.min(...p);
      }
      const m = [0, hB(this, {
        translatedValue: E,
        datum: f[0],
        datumIdx: 0,
        groupData: f,
        groupIdx: C,
        layerData: this._normalizedData,
        encodingName: "size"
      })];
      I.range(s(m));
    });
  }
  /**
   * @override
   */
  calculateExtendDomainDiffs() {
    const { x: t, y: i } = this.axes();
    if ((t instanceof xe || t instanceof Be) && (i instanceof xe || i instanceof Be))
      return {
        x: [0, 0],
        y: [0, 0]
      };
    const n = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, s = Math.abs(t.range()[1] - t.range()[0]), A = Math.abs(i.range()[1] - i.range()[0]), o = this._normalizedData;
    return o.forEach((a, r) => {
      const l = {}, c = this._polarAxes[r];
      a.forEach((g, h) => {
        const d = this.translateSinglePoint(
          g,
          h,
          a,
          l,
          c,
          r,
          o
        );
        if (d) {
          const { x: u, y: f, radius: C } = d, I = u - C;
          I < 0 && (n.left = Math.max(
            Math.abs(I),
            n.left
          ));
          const E = s - (u + C);
          E < 0 && (n.right = Math.max(
            Math.abs(E),
            n.right
          ));
          const B = f - C;
          B < 0 && (n.top = Math.max(Math.abs(B), n.top));
          const m = A - (f + C);
          m < 0 && (n.bottom = Math.max(
            Math.abs(m),
            n.bottom
          ));
        }
      });
    }), {
      x: [n.left, n.right],
      y: [n.top, n.bottom]
    };
  }
  getPointsWithinRange() {
    return [];
  }
};
class Ob extends ci(Ws).with(Hb) {
  static formalName() {
    return "arc";
  }
}
class Pb extends ci(Ws).with(_B) {
  static formalName() {
    return QS;
  }
}
const Yb = {
  name: "muze-light",
  className: "muze-light-theme",
  font: {
    fontSize: "12px",
    fontFamily: "'Source Sans Pro','Helvetica Neue', Helvetica, Arial, sans-serif",
    fontWeight: "400",
    fontStyle: "normal",
    components: {
      axis: {
        name: {
          fontSize: "14px",
          fontFamily: "'Source Sans Pro','Helvetica Neue', Helvetica, Arial, sans-serif",
          fontWeight: "400",
          fontStyle: "normal"
        }
      }
    }
  },
  loadCSS: () => {
  }
}, LK = {
  name: "mode-light",
  className: "mode-light-theme",
  font: {
    // As the ModeTheme uses `font-variant-numeric: tabular-nums`, so, here
    // the fontSize should be a little bit larger than the applied CSS style to make
    // the labelManager to work properly.
    fontSize: "14px",
    fontFamily: '"Graphik", Helvetica, sans-serif',
    fontWeight: "400",
    fontStyle: "normal",
    components: {
      axis: {
        name: {
          fontSize: "15px",
          fontFamily: '"Graphik", Helvetica, sans-serif',
          fontWeight: "400",
          fontStyle: "normal"
        }
      },
      facets: {
        fontSize: "12px"
      }
    }
  },
  loadCSS: () => {
  }
}, UK = {
  name: "dummy-light",
  className: "dummy-light-theme",
  font: {
    fontSize: "12px",
    fontFamily: "'Source Sans Pro','Helvetica Neue', Helvetica, Arial, sans-serif",
    fontWeight: "400",
    fontStyle: "normal",
    components: {
      axis: {
        name: {
          fontSize: "14px",
          fontFamily: "'Source Sans Pro','Helvetica Neue', Helvetica, Arial, sans-serif",
          fontWeight: "400",
          fontStyle: "normal"
        }
      }
    }
  },
  loadCSS: () => {
  }
}, d0 = /* @__PURE__ */ new Set();
function HK(e) {
  d0.has(e.name) || (e.loadCSS(e), d0.add(e.name));
}
function OK(e, t) {
  X(t).classed(String(e.className), !0);
}
function oA(e) {
  if (!e)
    return {};
  const t = {};
  return [
    ["font-size", "fontSize"],
    ["font-family", "fontFamily"],
    ["font-weight", "fontWeight"],
    ["font-style", "fontStyle"]
  ].forEach(([i, n]) => {
    e[n] && (t[i] = e[n]);
  }), t;
}
const PK = (e, t, i, n) => {
  const s = t.filter((a) => !!a && !a.isLabelThinned), { selection: A, elems: o } = sb(
    n,
    e,
    s,
    i
  );
  return n._graphicElems = o, n._linkedElems = {
    ...n._linkedElems,
    text: Object.assign({}, n._linkedElems.text, o)
  }, A;
}, YK = {
  defClassName: "layer-text",
  classPrefix: On,
  className: "",
  transform: {},
  interaction: {
    highlight: {
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                "text-decoration": "underline",
                // "font-weight": "bold",
                cursor: "pointer"
                // "border-color": "black",
              }
            }
          ]
        }
      }
    },
    select: {
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "1px",
                // "border-color": "black",
                "text-decoration": "underline"
                // "font-weight": "bold",
              }
            }
          ]
        }
      }
    },
    brush: {
      sideEffects: {}
    },
    [Bo]: {
      sideEffects: {
        [eu]: {}
      }
    }
  },
  crossline: !1,
  transition: {
    effect: "cubic",
    duration: 1e3
  },
  encoding: {
    color: {},
    size: {},
    radius: {},
    angle: {},
    text: { ...Oo },
    "border-color": {
      value: ""
    }
  },
  individualClassName: (e, t, i, n) => {
    const { columnTotalString: s, rowTotalString: A } = n.metaInf();
    return e.x === s || e.y === A ? "muze-totals-cell" : "";
  },
  align: As,
  style: {
    "font-size": "12px",
    "font-family": '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif',
    "font-weight": "400",
    "font-style": "normal",
    "font-variant": "tabular-nums"
  }
};
function JK(e, t, i, n) {
  const { width: s, height: A } = t, { textDistance: o, xIndex: a, yIndex: r } = n, { smartLabel: l } = e.dependencies(), { width: c, height: g } = e.calculateOptimumTextLabelDimensions(), h = Math.min(
    c,
    s - 2 * o
  ), d = Math.min(
    g,
    A - 2 * o
  ), u = d + 2 * o, f = Math.max(Math.floor(A / u), 1), C = "...", { width: I } = l.getOriSize(C);
  let E = [], B = s, m = 0;
  for (let p = 0; p < i.length; p++) {
    const w = i[p], { text: Q } = w, y = Q ? l.getOriSize(Q).width : 0, D = Math.min(y, h), _ = d, x = D + 2 * o, S = m === f - 1;
    if (x > B)
      if (S) {
        let b;
        I > B ? (E.pop(), b = i.slice(p - 1)) : b = i.slice(p), E.push({
          xIndex: a,
          yIndex: r,
          text: C,
          allocatedDimens: {
            text: { width: I, height: d },
            cell: {
              width: I + 2 * o,
              height: u
            }
          },
          moreData: b
        });
        break;
      } else
        m++, B = s;
    B -= x, w.allocatedDimens = {
      text: { width: D, height: _ },
      cell: { width: x, height: u }
    }, E.push(w);
  }
  return E;
}
class KK extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return eu;
  }
  apply(t, { target: i, isActive: n }) {
    i && (n ? i.classed("highlight", !0) : i.classed("highlight", !1));
  }
}
const u0 = (e, t, i, n, s, A) => {
  let o = [];
  const a = n.axes(), l = n.config().encoding.text, { field: c, value: g } = l, h = c ? n.data().getFieldIndex(c) : -1, d = Gt.X, u = Gt.Y, f = (C, I) => {
    if (!a[C])
      return 0;
    const E = a[C], { fieldSubtype: B, fieldAs: m } = E.config();
    let p = E.getScaleValue(I[C]);
    return C === Gt.Y && B === zi && m === ft.CONTINUOUS ? p -= E.getUnitWidth() / 2 : p += E.getUnitWidth() / 2, p;
  };
  for (let C = 0, I = e.length; C < I; C++) {
    const E = e[C], B = E.source, m = c ? B[h] : g, [p, w] = [d, u].map((T) => f(T, E)), Q = ts(n, E), y = ws(n, E), D = Q.getColor(E.color, Q), _ = y.getOpacity(E.opacity), S = eb(n, E).getColor(E.backgroundColor);
    let b = c ? E.formattedText : m;
    (b instanceof Function || typeof b == "function") && (b = b(
      {
        x: p,
        y: w,
        color: D,
        backgroundColor: S
      },
      C,
      e,
      n
    ));
    const R = Qs(n, {
      translatedValues: {
        x: p,
        y: w,
        text: m,
        formattedText: b,
        color: D,
        opacity: _,
        backgroundColor: S
      },
      datum: E,
      datumIdx: C,
      groupData: e,
      groupIdx: s,
      layerData: A
    }), G = Po(
      n,
      {
        x: R.x,
        y: R.y,
        color: R.color,
        opacity: R.opacity,
        backgroundColor: R.backgroundColor,
        text: R.text,
        formattedText: R.formattedText
      },
      E,
      C,
      e
    );
    G && !K.isInvalid(G.text) && (G.xIndex = a.x ? a.x.getIndex(
      E.x,
      i.x ? i.x.range : null
    ) : null, G.yIndex = a.y ? a.y.getIndex(
      E.y,
      i.y ? i.y.range : null
    ) : null, o.push(G), n.cachePoint(E.rowId, G));
  }
  return o = Uo(n, o), o = o.filter((C) => {
    const I = C.update;
    return !isNaN(I.x) && !isNaN(I.y);
  }), o;
}, Jb = (e) => class extends e {
  constructor(...t) {
    super(...t), this._rtree = new Io();
  }
  /**
   * Returns the default configuration of the text layer
   * @return {Object} Default configuration of the text layer
   */
  static defaultConfig() {
    return YK;
  }
  static defaultPolicy(t, i) {
    let n = et(t, i);
    return n = et(n, {
      style: et(
        {},
        oA(Z(n.theme, "font")),
        oA(
          Z(n.theme, "font", "components", "textLayer")
        )
      )
    }), n;
  }
  static formalName() {
    return "text";
  }
  getSideEffects() {
    return {
      [eu]: KK
    };
  }
  elemType() {
    return "text";
  }
  getPointTranslator() {
    return u0;
  }
  /**
   * Generates an array of objects containing x, y, width and height of the points from the data
   * @param  {Array.<Array>} data Data Array
   * @param  {Object} encoding  Config
   * @param  {Object} axes     Axes object
   * @return {Array.<Object>}  Array of points
   */
  translatePoints(t, i = {}, n, s, A) {
    return u0(
      t,
      i,
      n,
      this,
      s,
      A
    );
  }
  /**
   * Renders the plot in the given container
   * @param  {SVGElement} container SVGElement which will hold the plot
   * @return {textLayer} Instance of text layer
   */
  render(t, i) {
    this.preRender(i, !0);
    const n = this.dependencies().smartLabel, s = this.calculateViewableAxisDomains(i), A = this.getRenderableNormalizedData(), o = Js(), a = this.config(), {
      encoding: {
        text: { hyperlink: r }
      }
    } = a, l = a.className, c = ms(
      a.defClassName,
      this.id(),
      a.classPrefix
    ), g = X(t);
    if (g.attr("class", ""), g.classed(`${c.join(" ")} ${l}`, !0).style("width", "inherit").style("height", "inherit"), this._linkedElems = {}, this.renderer() === "html") {
      const u = A.length ? this.translatePoints(
        A[0],
        {},
        s,
        0,
        A
      ) : [];
      this._points = u;
      const { style: f } = this.config();
      n.setStyle(f), this.renderHTML(t, u, s, r);
    } else
      this._graphicElems = {}, this._points = [], _E({
        data: A,
        append: "g",
        selector: "g",
        container: t,
        each: (u, f, C) => {
          const I = f.node(), E = this.translatePoints(
            u,
            {},
            s,
            C,
            A
          );
          this._points.push(E), vt(I, {
            "text-anchor": ES
          }), PK(
            I,
            E,
            {
              className: c[0]
            },
            this
          );
        }
      });
    n.setStyle(
      Ls(X(t), c[0])
    );
    const d = this._points.flat().filter((u) => u !== null).map((u) => {
      const { x: f, y: C } = u.update, { width: I, height: E } = n.getOriSize(u.text), B = u.data;
      return {
        minX: f - I / 2,
        maxX: f + I / 2,
        minY: C - E / 2,
        maxY: C + E / 2,
        width: I,
        height: E,
        data: B,
        point: u,
        x: f,
        y: C
      };
    });
    return this._rtree = new Io(), this._rtree.load(d), this.postRender(i), o.onAllCallbacksCalled().then(() => {
      this.emitAnimationEndHook(i);
    }), this;
  }
  renderHTML(t, i, n, s) {
    const { enabled: A } = s, { textFieldSubType: o } = this.encodingFieldsInf();
    let a = n.x ? n.x.range.translate : 0, r = n.y ? n.y.range.translate : 0;
    const l = {}, { x: c, y: g } = this.axes(), { classPrefix: h, align: d, isBold: u, firstRowZebraType: f, style: C } = this.config(), { smartLabel: I } = this.dependencies();
    I.setStyle(C);
    const E = [];
    i.forEach((J) => {
      const { xIndex: V, yIndex: Y } = J;
      E[Y] || (E[Y] = []), E[Y][V] || (E[Y][V] = []), E[Y][V].push(J);
    });
    const B = this.cellMaxCount(), { field: m, value: p } = this.config().encoding.color, { field: w, value: Q } = this.config().encoding.backgroundColor, { field: y, value: D } = this.config().encoding.opacity, _ = n.y ? n.y.domain.length : g.domain().length, x = n.x ? n.x.domain.length : c.domain().length, S = c.getScaleStep(), b = g.getScaleStep();
    let R = n.x ? n.x.range.visibleCellDimension : x * S + c.getScalePaddingOuter(), G = n.y ? n.y.range.visibleCellDimension : _ * b + g.getScalePaddingOuter();
    const T = X(t);
    T.select(".muze-layer-text-grid-container").remove();
    const v = z(
      T,
      "div",
      [1],
      "muze-layer-text-grid-container"
    );
    v.style("width", `${R}px`).style("height", `${G}px`).style("display", "grid").style("grid-template-columns", `repeat(${x}, 1fr)`).style("grid-template-rows", `repeat(${_}, 1fr)`).style("transform", `translate(${a}px, ${r}px)`), v.classed("bold", u), I.useEllipsesOnOverflow(!0);
    const H = [];
    for (let J = 0; J < _; J++)
      for (let V = 0; V < x; V++) {
        const Y = E[J] && E[J][V];
        Y && Y.length ? H.push(Y) : H.push([
          {
            xIndex: V,
            yIndex: J
          }
        ]);
      }
    const N = `${h}-layer-text-outer-cell`, M = z(v, "div", H, N);
    M.style("display", "flex").style("flex-direction", "row").style("justify-content", d).style("flex-wrap", "wrap").style("align-content", "start").style("position", "relative"), B > 1 && (d === DS ? M.style(
      "padding-right",
      `${OA}px`
    ) : d === xS ? M.style(
      "padding-left",
      `${OA}px`
    ) : d === As && (M.style(
      "padding-left",
      `${OA / 2}px`
    ), M.style(
      "padding-right",
      `${OA / 2}px`
    )));
    const F = R / x, k = G / _, O = F - OA - 2 * vl, P = k - 2 * vl, L = `${h}-text-row-${f === "odd" ? "odd" : "even"}`, q = `${h}-text-row-${f === "odd" ? "even" : "odd"}`;
    this._graphicElems = {};
    const $ = this, W = `${h}-layer-text-inner-cell`, U = A ? "a" : "div";
    M.each(function(J) {
      const V = X(this), { yIndex: Y, xIndex: nt } = J[0], tt = n.y ? n.y.range.startIdx + Y : Y, st = n.x ? n.x.range.startIdx + nt : nt, lt = `${N} ${(tt + 1) % 2 === 0 ? q : L} ${h}-text-row-${tt} ${h}-text-col-${st}`;
      V.attr("class", lt);
      const at = JK(
        $,
        { width: O, height: P },
        J,
        {
          textDistance: xa,
          xIndex: nt,
          yIndex: Y
        }
      );
      z(
        V,
        U,
        at,
        W
      ).each(function(Qt) {
        const St = X(this), { text: At, rowId: Vt } = Qt, _t = (Q || w) && Qt.backgroundColor;
        if (St.classed(Qt.className, !0), _t && (St.style("background-color", Qt.backgroundColor), B <= 1 && V.style("background-color", Qt.backgroundColor)), St.classed(wI, !1), St.classed(yI, !1), (m || p) && Qt.color)
          St.style("color", Qt.color);
        else if (_t) {
          const { l: zt } = CA(Qt.backgroundColor);
          zt <= 0.5 ? St.classed(wI, !0) : St.classed(yI, !0);
        }
        if ((y || D || Qt.opacity) && St.style("opacity", Qt.opacity), B > 1) {
          const { height: zt } = Qt.allocatedDimens.cell;
          St.style("padding", `0 ${xa}px`).style("height", `${zt}px`).style("display", "grid");
        } else
          St.style("display", "grid").style("width", "100%").style("height", "100%").style("padding", `0 ${xa}px`).style("text-align", d);
        if (A && Qt.hyperlinkInfo && uc(St, Qt, s), At) {
          const zt = Z(Qt, "text");
          if (o === su) {
            let te, ei;
            B > 1 ? (te = Qt.allocatedDimens.text.width, ei = Qt.allocatedDimens.text.height) : (te = O, ei = P);
            const ki = I.getSmartText(
              zt,
              te,
              ei,
              !0
            );
            this.textContent = `${ki.text}`;
          } else
            this.textContent = `${zt}`;
        } else
          this.textContent = null;
        l[Vt] = St;
      });
    }), this._graphicElems = l;
  }
  getNearestPoint(t, i, { event: n }) {
    if (n || (n = bt()), this.renderer() !== "html") {
      const s = this._rtree.search({
        minX: Math.max(t - 1, 0),
        minY: Math.max(i - 1, 0),
        maxX: t + 1,
        maxY: i + 1
      });
      if (s.length)
        return this.getDataFromEvent(n, s[0].point);
    } else
      return this.getDataFromEvent(n);
    return null;
  }
  getDataFromEvent(t, i) {
    return Bu(this, t, i);
  }
  static autoDetectTransformType() {
    return ns;
  }
  getBoundBox(t) {
    if (this.renderer() !== "html") {
      const { x: c, y: g } = t.update, h = this._rtree.search({
        minX: Math.max(c - 1, 0),
        minY: Math.max(g - 1, 0),
        maxX: c + 1,
        maxY: g + 1
      });
      return {
        x: h[0].x,
        y: h[0].y,
        width: h[0].width,
        height: h[0].height
      };
    }
    const { update: i } = t, { x: n, y: s } = this.axes(), A = n.getScaleStep(), o = s.getScaleStep(), a = i.x - A / 2, r = i.y - o / 2, l = this._graphicElems[t.rowId];
    if (l && l.node()) {
      const c = l.node(), g = c.getBoundingClientRect();
      return {
        x: a + c.offsetLeft,
        y: r + c.offsetTop,
        width: g.width,
        height: g.height
      };
    } else
      return {
        x: a,
        y: r,
        width: A,
        height: o
      };
  }
  /**
   * @override
   */
  requiresExtendDomainDiffs() {
    return !0;
  }
  /**
   * @override
   */
  calculateExtendDomainDiffs() {
    const t = this.dependencies().smartLabel.getOriSize("X").height, i = yo(this.axes().x, this.domain().x, [
      t,
      t
    ]), n = yo(this.axes().y, this.domain().y, [
      t,
      t
    ]);
    return { x: i, y: n };
  }
  getElementByRowId(t) {
    return this.renderer() === "html" ? this._graphicElems[t] : this._graphicElems[t] ? this._graphicElems[t].select("text") : null;
  }
};
class Kb extends ci(Ws).with(Jb) {
  static formalName() {
    return "text";
  }
}
const VK = {
  defClassName: "layer-point",
  className: "",
  classPrefix: On,
  defColorStyle: "stroke",
  interaction: {
    highlight: {
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "1px"
              }
            },
            {
              target: (e, t) => {
                const {
                  entryExitSet: { entrySet: i }
                } = e, n = t.getEntryExitSet("select");
                return n ? i.intersect(n.entrySet) : null;
              },
              key: "commonSet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "2px"
              }
            }
          ]
        }
      }
    },
    select: {
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  {
                    target: "exitSet",
                    style: {
                      fill: { a: -0.7 }
                      // strokePosition: "center",
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "1px"
              }
            }
          ]
        }
      }
    },
    brush: {
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  // {
                  //   target: "entrySet",
                  //   style: {
                  //     fill: { a: +0.3 },
                  //     strokePosition: "center",
                  //   },
                  // },
                  {
                    target: "exitSet",
                    style: {
                      fill: { a: -0.5 }
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              // target: (interactionInf, firebolt) => {
              //   if (interactionInf.payload.sourceInfo.layerId !== firebolt.id()) {
              //     return null;
              //   } else {
              //     return interactionInf.entryExitSet.entrySet;
              //   }
              // },
              target: "entrySet",
              style: {
                stroke: "black",
                "stroke-width": "1px",
                strokePosition: "outside"
              }
            }
          ]
        }
      }
    }
  },
  innerPadding: 0.1,
  outerPadding: 0,
  nearestPointThreshold: 5,
  transform: {},
  transition: {
    effect: "cubic",
    duration: 1e3,
    disabled: !0
  },
  encoding: {
    size: {
      value: 30
    },
    color: {},
    opacity: { value: 0.5 },
    // stroke: {
    //   value: "#000",
    // },
    // "stroke-width": {
    //   value: 0,
    // },
    fill: {},
    shape: {
      value: "circle"
    },
    x: {},
    y: {},
    text: {
      ...Oo,
      labelPlacement: void 0
    },
    // "stroke-opacity": {
    //   value: 1,
    // },
    // "fill-opacity": {
    //   value: 0.5,
    // },
    strokePosition: {
      value: "center"
    }
  },
  interactive: !0
}, Vb = ({
  data: e,
  datum: t,
  i,
  layerInst: n,
  xPx: s,
  yPx: A,
  groupIdx: o,
  layerData: a
}) => {
  const r = n.axes(), l = n.config().encoding, { shape: c } = r, g = Ho(n, t), h = ts(n, t), d = ws(n, t), u = n.config().outline;
  let f = c.getShape(t.shape), C = g.getSize(t.size), I = h.getColor(t.color), E = d.getOpacity(t.opacity);
  const B = n.config().encoding, { textField: m } = n.encodingFieldsInf();
  typeof l.opacity.value != "function" && !l.opacity.field && (E = l.opacity.value);
  const p = Qs(n, {
    translatedValues: {
      x: s,
      y: A,
      color: I,
      opacity: E,
      size: C,
      shape: f,
      data: t,
      text: t.text
    },
    datum: t,
    datumIdx: i,
    groupData: e,
    groupIdx: o,
    layerData: a
  }), { rowId: w, source: Q } = t;
  ({ shape: f, size: C, color: I, opacity: E } = p);
  const y = {
    fill: I,
    ...yc(l, [n._mainColorProp]),
    ...mu(u, I),
    opacity: E
  }, { x: D, y: _ } = p;
  let x;
  if (m) {
    const b = Qo(
      { x: 0, y: 0, text: p.text },
      i,
      e,
      n
    ), { smartLabel: R } = n._dependencies, G = new CB(R), T = {
      positionAt: vI(n.config().encoding.text),
      rotation: b
    }, v = t.formattedText, { xPos: H, yPos: N } = IB(
      v,
      { x: 0, y: 0, size: p.size },
      T,
      G
    );
    x = Po(
      n,
      {
        x: H,
        y: N,
        text: p.text,
        formattedText: v,
        color: pu.textColor
      },
      t,
      i,
      e
    );
  }
  const S = { x: D, y: _ };
  return {
    enter: S,
    update: S,
    shape: f,
    source: Q,
    rowId: w,
    style: y,
    data: t.dataObj,
    meta: Object.assign(
      {
        layerId: n.id()
      },
      ys(y, {
        strokePosition: B.strokePosition.value
      })
    ),
    size: C,
    text: x
  };
}, Wb = (e, t, i, n, s) => {
  let A = [];
  const o = i.config().encoding, a = i.axes(), r = i.measurement(), { x: l, y: c } = t.offset;
  for (let g = 0, h = e.length; g < h; g++) {
    const d = e[g];
    let [u, f] = [Gt.X, Gt.Y].map((C) => {
      const I = d[C] === null ? void 0 : d[C], E = C === Gt.X ? r.width : r.height;
      return o[C].field ? a[C].getScaleValue(I) : E / 2;
    });
    if (u += l, f = a.y.constructor.type() === be ? f - c : f + c, !isNaN(u) && !isNaN(f)) {
      const C = Vb({
        data: e,
        datum: d,
        i: g,
        layerInst: i,
        xPx: u,
        yPx: f,
        groupIdx: n,
        layerData: s
      });
      C.className = Vs(d, g, e, i), A.push(C), i.cachePoint(d.rowId, C);
    }
  }
  return A = Uo(i, A), A;
}, qb = "center", jb = "inside", WK = "outside", qK = (e, t) => e === qb ? -t : e === jb ? -(t * Math.PI) : +(t * Math.PI), jK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CENTER: qb,
  INSIDE: jb,
  OUTSIDE: WK,
  getStrokeWidthByPosition: qK,
  pointTranslators: Wb,
  prepareDrawingInf: Vb
}, Symbol.toStringTag, { value: "Module" })), bB = (e) => class extends e {
  /**
   * Creates an instance of PointLayer.
   * @param {*} args
   * @memberof PointLayer
   */
  constructor(...t) {
    super(...t), this._voronoi = new gE(), this._bandScale = dE.band(), this.formattedUids = [], this._rtree = null, this._mainColorProp = "fill";
  }
  elemType() {
    return "g";
  }
  /**
   * Returns the default configuration of the point layer
   * @return {Object} Default configuration of the point layer
   */
  static defaultConfig() {
    return VK;
  }
  // static defaultPolicy(conf, userConf) {
  //   const config = super.defaultPolicy(conf, userConf);
  //   const encoding = config.encoding;
  //   const transform = config.transform;
  //   const colorField = encoding.color && encoding.color.field;
  //   if (colorField) {
  //     transform.groupBy = colorField;
  //   }
  //   return config;
  // }
  static drawFn() {
    return Rb;
  }
  /**
   * Generates an array of objects containing x, y, width and height of the points from the data
   * @param  {Array.<Array>} data Data Array
   * @param  {Object} encoding  Config
   * @param  {Object} axes     Axes object
   * @return {Array.<Object>}  Array of points
   */
  translatePoints(t, i = {}, n, s) {
    return Wb(t, i, this, n, s);
  }
  /**
   * Renders the plot in the given container.
   *
   * @param  {SVGElement} container SVGElement which will hold the plot
   * @return {BarLayer} Instance of bar layer
   */
  render(t, i) {
    this.preRender(i, !0);
    const n = Js();
    let s = 0, A;
    const o = this.config(), a = this._transformedData.getUniqueValues(), { transition: r, className: l, defClassName: c, classPrefix: g } = o, h = this.getRenderableNormalizedData(), d = X(t), u = ms(
      c,
      this.id(),
      g
    );
    this._points = [], this._pointMap = {}, d.classed(u.join(" "), !0).classed(l, !0), this._points = this.generateDataPoints(h, a), this._graphicElems = {}, this._linkedElems = {};
    const f = this.data().getSchema();
    return z(
      t,
      "g",
      this._points,
      null,
      {
        update: (C, I) => {
          s = is([s, ...I.map((E) => E.size || 0)]), A = `${u[0]}`, this.constructor.drawFn()({
            layer: this,
            container: C.node(),
            points: I,
            interpolate: o.interpolate,
            className: A,
            transition: r,
            animationAggregator: n,
            keyFn: (E) => Z_(E.source, f)
          });
        }
      },
      (C) => C[0].rowId
    ), this._maxSize = s * 2, this.postRender(i), n.onAllCallbacksCalled().then(() => {
      this.emitAnimationEndHook(i);
    }), this;
  }
  postRender(t) {
    if (super.postRender(t), this.config().interactive) {
      this.attachDataToVoronoi(this._points);
      const i = this.getBoundBoxes().flat().filter((n) => n !== null);
      this._rtree = new Io(), this._rtree.load(i);
    }
  }
  attachDataToVoronoi(t) {
    pc(this._voronoi, t);
  }
  generateDataPoints(t, i) {
    const [n, s] = RI(this, i), A = n.offsetValues || [], o = s.offsetValues || [];
    return t.map((a, r) => {
      const l = this.getMeasurementConfig(
        A[r],
        o[r],
        n.span,
        s.span
      );
      return this.translatePoints(
        a,
        l,
        r,
        t
      );
    }).filter((a) => a.length);
  }
  getMeasurementConfig(t, i, n, s) {
    return {
      offset: {
        x: (t || 0) + n / 2,
        y: (i || 0) + s / 2
      },
      span: {
        x: n,
        y: s
      }
    };
  }
  getShapeRadius(t) {
    return t ? t.data.data.size : 0;
  }
  /**
   * Gets the nearest point from a position.
   * @param {number} x x position
   * @param {number} y y position
   * @return {Object} Point details
   */
  getNearestPoint(t, i) {
    const n = this.config().nearestPointThreshold, s = Math.max(this._maxSize, n);
    if (!this.data())
      return null;
    const A = this._voronoi.find(t, i, s), o = A && A.data.data.update, a = this.getShapeRadius(A);
    if (A && bx(
      {
        x: o.x,
        y: o.y,
        r: a + n
      },
      { x: t, y: i }
    )) {
      const { source: l, rowId: c } = A.data.data;
      return {
        id: this.getIdentifiersFromData(l, c),
        dimensions: [
          {
            x: o.x,
            y: o.y,
            width: a,
            height: a
          }
        ],
        point: A.data.data,
        layerId: this.id()
      };
    }
    return null;
  }
  getBoundBoxes() {
    return dB(this._points.flat());
  }
  applyElementStyles(t, i) {
    super.applyElementStyles(t, i);
    const n = t.select("path");
    super.applyElementStyles(n, i);
  }
  getOverlayPathMount() {
    return null;
  }
  static autoDetectTransformType() {
    return ns;
  }
  /**
   * @override
   */
  requiresExtendDomainDiffs() {
    return !0;
  }
  /**
   * @override
   */
  calculateExtendDomainDiffs() {
    const { x: t, y: i } = this.axes(), n = this.config().encoding;
    if ((t instanceof xe || t instanceof Be) && (i instanceof xe || i instanceof Be))
      return {
        x: [0, 0],
        y: [0, 0]
      };
    const s = this.dependencies().smartLabel.getOriSize("X").height, A = yo(this.axes().x, this.domain().x, [
      s,
      s
    ]), o = yo(this.axes().y, this.domain().y, [
      s,
      s
    ]), a = {
      left: A[0],
      right: A[1],
      top: o[0],
      bottom: o[1]
    }, r = Math.abs(t.range()[1] - t.range()[0]), l = Math.abs(i.range()[1] - i.range()[0]), c = this._transformedData.getUniqueValues(), [g, h] = RI(this, c), d = g.offsetValues || [], u = h.offsetValues || [], f = this._normalizedData;
    return f.forEach((C, I) => {
      const E = this.getMeasurementConfig(
        d[I],
        u[I],
        g.span,
        h.span
      ), { x: B, y: m } = E.offset;
      for (let p = 0, w = C.length; p < w; p++) {
        const Q = C[p];
        let [y, D] = [Gt.X, Gt.Y].map((_) => {
          const x = Q[_] === null ? void 0 : Q[_], S = _ === Gt.X ? r : l;
          return n[_].field ? this.axes()[_].getScaleValue(x) : S / 2;
        });
        if (y += B, D = i.constructor.type() === be ? D - m : D + m, !isNaN(y) && !isNaN(D)) {
          const _ = Ho(this, Q), x = ws(this, Q), S = Qs(this, {
            translatedValues: {
              x: y,
              y: D,
              opacity: x.getOpacity(Q.opacity),
              size: _.getSize(Q.size)
            },
            datum: Q,
            datumIdx: p,
            groupData: C,
            groupIdx: I,
            layerData: f
          }), { x: b, y: R, size: G } = S, T = b - G;
          T < 0 && (a.left = Math.max(
            Math.abs(T),
            a.left
          ));
          const v = r - (b + G);
          v < 0 && (a.right = Math.max(
            Math.abs(v),
            a.right
          ));
          const H = R - G;
          H < 0 && (a.top = Math.max(Math.abs(H), a.top));
          const N = l - (R + G);
          N < 0 && (a.bottom = Math.max(
            Math.abs(N),
            a.bottom
          ));
        }
      }
    }), {
      x: [a.left, a.right],
      y: [a.top, a.bottom]
    };
  }
};
class zb extends ci(Ws).with(bB) {
  static formalName() {
    return yS;
  }
}
const zK = (e, t, i, n, s) => {
  const { transition: A } = s, { duration: o, disabled: a, effect: r } = A, l = t, c = a ? l : l.transition().duration(o).ease(lc[r]).on("end", s.animationAggregator.newCallback()), g = i.update || i, h = i.style || {};
  i.className && l.classed(i.className, !0), Object.entries(g).forEach(
    (d) => !isNaN(d[1]) && c.attr(d[0], d[1])
  ), Object.entries(h).forEach(
    (d) => l.style(d[0], d[1])
  );
}, $K = (e, t) => {
  const i = e, n = t.enter || {};
  Object.entries(n).forEach(
    (s) => !isNaN(s[1]) && i.attr(s[0], s[1])
  );
}, XK = (e) => {
  const { layer: t, points: i, container: n, keyFn: s, className: A } = e, o = t._graphicElems, a = {
    enter(r, l) {
      $K(r, l);
    },
    update(r, l, c) {
      o[l.rowId] = r, zK(t, r, l, c, e);
    }
  };
  return z(
    n,
    "g",
    i,
    null,
    {
      update: (r, l) => {
        z(
          r.node(),
          "rect",
          (c) => [c],
          null,
          a,
          s
        ), r.attr("class", `${A}-${l.rowId}`), r.classed(l.className, !0);
      }
    },
    s
  );
}, ZK = {
  classPrefix: On,
  defClassName: "layer-bar",
  className: "",
  interaction: {
    highlight: {
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "1px"
              }
            },
            {
              target: (e, t) => {
                const {
                  entryExitSet: { entrySet: i }
                } = e, n = t.getEntryExitSet("select");
                return n ? i.intersect(n.entrySet) : null;
              },
              key: "commonSet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "2px"
              }
            }
          ]
        }
      }
    },
    select: {
      // propagationFields:
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  {
                    target: "exitSet",
                    style: {
                      fill: {
                        a: -0.5
                      }
                      // strokePosition: "center",
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                strokePosition: "outside",
                stroke: "black",
                "stroke-width": "1px"
              }
            }
          ]
        }
      }
    },
    brush: {
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  {
                    target: "entrySet",
                    style: {
                      fill: { a: 0.3 }
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                stroke: "black",
                "stroke-width": "1px",
                strokePosition: "center"
              }
            },
            {
              target: "exitSet",
              style: {
                "fill-opacity": 0.3
              }
            }
          ]
        }
      }
    }
  },
  transform: {},
  transition: {
    effect: "cubic",
    duration: 1e3
  },
  innerPadding: 0.1,
  outerPadding: 1,
  // This is in pixels
  encoding: {
    opacity: {
      value: 1
    },
    color: {},
    detail: {},
    x: {},
    y: {},
    x0: {},
    y0: {},
    size: {
      value: 10
    },
    // stroke: {},
    // 'stroke-width': {},
    // strokePosition: {},
    text: {
      ...Oo,
      showStackSum: !1,
      displayAs: "value"
    }
  },
  highlightExactPoint: !1
}, xf = ["stroke-width", "stroke", "stroke-opacity"], { CONTINUOUS: zs } = ft, $b = (e) => class extends e {
  /**
   * Creates an instance of bar layer
   */
  constructor(...t) {
    super(...t), this._plotPadding = {
      x: 0,
      y: 0
    }, this._plotSpan = {
      x: 0,
      y: 0
    }, this._pointMap = {}, this._overlayPath = {}, this._rtree = null, this._mainColorProp = "fill", this._reducedDataMap = void 0, this._maxPositive = {
      key: void 0,
      value: 0,
      text: void 0
    }, this._maxNegative = {
      key: void 0,
      value: 0,
      text: void 0
    }, this._autoRotationAngle = 0, this._stackedSum = /* @__PURE__ */ new Map();
  }
  elemType() {
    return "rect";
  }
  /**
   * Returns the default configuration of the bar layer
   * @return {Object} Default configuration of the bar layer
   */
  static defaultConfig() {
    return ZK;
  }
  static shouldShowAxisTicksInPercentage(t, i, n) {
    const s = n.def.encoding, A = n.def.transform;
    let o;
    if (s) {
      const a = dA({
        yField: s.y.field,
        yFieldAs: s.y.as,
        xField: s.x.field,
        xFieldAs: s.x.as,
        dm: t,
        transformConf: A
      });
      return ["x", "y"].forEach((r) => {
        !(a && r === "x" || !a && r === "y") && A.type === Xt && (o = s[r].field);
      }), i === o;
    }
    return !1;
  }
  // static defaultPolicy(conf, userConf) {
  //   const config = BaseLayer.defaultPolicy(conf, userConf);
  //   const encoding = config.encoding;
  ////   const colorField = encoding.color.field;
  //   const transform = config.transform;
  //   if (colorField) {
  //     transform.groupBy = colorField;
  //   }
  //   return config;
  // }
  afterDataDidSet() {
    this.reduceNormalizedDataMap();
  }
  calculateDomainFromData(t, i) {
    const n = super.calculateDomainFromData(t, i), { TEMPORAL: s } = K.FieldSubtype;
    return ["x", "y"].forEach((A) => {
      const o = this.isVerticalBar() && A === "x" || !this.isVerticalBar() && A === "y";
      i[`${A}FieldAs`] === zs && i[`${A}FieldSubType`] !== s && Z(n[A], "length") && (i[`${A}0Field`] ? n[A] = n[A].sort((a, r) => a - r) : o ? n[A] = Vh(n[A]) : n[A] = Hl(n[A]));
    }), n;
  }
  /**
   * @override
   */
  requiresExtendDomainDiffs() {
    const { textField: t } = this.encodingFieldsInf(), i = this.config().encoding.text, n = vI(i);
    return t && n === Si;
  }
  calculateExtendDomainDiffs() {
    if (!this.requiresExtendDomainDiffs())
      return { x: [0, 0], y: [0, 0] };
    const { smartLabel: t } = this._dependencies, i = [0, 0], n = [0, 0], s = this.isVerticalBar(), A = 5, [o] = kI(
      this,
      this._transformedData.getUniqueValues()
    );
    this.calculateAutoRotationAngle(o);
    const a = this.axes(), r = a.y && a.y.scale().range()[0], l = a.x && a.x.scale().range()[1], c = r != null ? r / 2 : 0, g = l != null ? l / 2 : 0;
    if (this._reducedDataMap.size === 0) {
      const h = this.config().encoding.text;
      if (vI(h) === Si) {
        const u = Qo(
          { x: 0, y: 0, text: this.largestTextLabel() },
          0,
          [],
          this
        ), { width: f, height: C } = gl(
          this.largestTextLabel(),
          u,
          t
        );
        s && this._domain.y != null ? (n[0] = this._domain.y[1] >= 0 ? C + A : 0, n[1] = this._domain.y[0] < 0 ? C + A : 0) : this._domain.x != null && (i[0] = this._domain.x[0] < 0 ? f + A : 0, i[1] = this._domain.x[1] >= 0 ? f + A : 0);
      }
    } else {
      const h = (d, u, f) => {
        const C = { x: 0, y: 0 }, I = Qo(
          s ? { x: d, y: f, text: u } : { x: f, y: d, text: u },
          0,
          [],
          this
        ), { width: E, height: B } = gl(
          u,
          I,
          t
        );
        let m;
        return this._stackedSum.size ? s ? m = Si : m = Wi : m = this.resolveBestLabelAnchor(
          d,
          {
            width: Number.MAX_SAFE_INTEGER,
            height: Number.MAX_SAFE_INTEGER,
            text: u
          },
          I
        ), s && m === Si ? C.y = B + A : !s && m === Wi && (C.x = E + A), C;
      };
      if (this._maxPositive.key !== void 0) {
        const d = h(
          this._maxPositive.key,
          this._maxPositive.text,
          this._maxPositive.value
        );
        n[0] = d.y, i[1] = d.x;
      }
      if (this._maxNegative.key !== void 0) {
        const d = h(
          this._maxNegative.key,
          this._maxNegative.text,
          this._maxNegative.value
        );
        n[1] = d.y, i[0] = d.x;
      }
    }
    return {
      x: [
        Math.min(i[0], g),
        Math.min(i[1], g)
      ],
      // [extra left pixel, extra right pixel],
      y: [
        Math.min(n[0], c),
        Math.min(n[1], c)
      ]
      // [extra top pixel, extra bottom pixel]
    };
  }
  /**
   * Generates an array of objects containing x, y, width and height of the bars from the data
   * @param  {Array.<Array>} data Data Array
   * @param  {Object} encoding  Config
   * @param  {Object} axes     Axes object
   * @param {Object} conf config object for point generation
   * @return {Array.<Object>}  Array of points
   */
  translatePoints(t, i, n, s) {
    return z6(this, t, i, n, s);
  }
  /**
   * Renders the plot in the given container
   * @param  {SVGGroup} container SVGGroup where plot will be rendered.
   * @return {BarLayer} Instance of bar layer.
   */
  render(t, i = {}) {
    this.preRender(i, !0);
    const n = Js(), { transition: s } = i, A = this.config(), o = wt(s, A.transition), r = this._transformedData.getUniqueValues(), l = this.axes(), c = l.y && l.y.scale().range()[0] || 0, g = l.x && l.x.scale().range()[1] || 0, h = A.defClassName, d = ms(
      h,
      this.id(),
      A.classPrefix
    ), u = A.className, f = X(t);
    f.classed(d.join(" "), !0), f.classed(u, !0), cS(
      t,
      {
        x: 0,
        width: g,
        height: c
      },
      `id-${this.id()}`
    ), this._points = this.generateDataPoints(
      this.getRenderableNormalizedData(),
      r
    ), this._graphicElems = {}, this._linkedElems = {}, Object.keys(this._overlayPath).forEach((B) => this._overlayPath[B].remove()), this._overlayPath = {};
    const I = z(
      f,
      "g",
      [1],
      `${A.classPrefix}-layer-bars`,
      {},
      null
    );
    if (this._overlayMount = z(
      f,
      "g",
      [1],
      `${A.classPrefix}-layer-overlay-path-group`,
      {},
      null
    ).node(), this.hasTextEncodingField()) {
      let B = null;
      this._stackedSum.size ? B = this.getTextPointsForStackSum() : B = this._points.flat(), this.textPointsInfo({
        points: B,
        location: "text"
      });
    } else
      this.textPointsInfo(null);
    _E({
      data: this._points,
      container: I.node(),
      selector: "g",
      append: "g",
      each: (B, m, p) => {
        const w = `${d[0]}-${p}`.toLowerCase();
        m.style("display", "block"), m.attr("class", w), XK({
          layer: this,
          container: m.node(),
          points: B,
          className: w,
          transition: o,
          keyFn: (Q) => Q.rowId,
          animationAggregator: n
        });
      }
    });
    const E = this.getBoundBoxes().flat().filter((B) => B !== null);
    return this._rtree = new Io(), this._rtree.load(E), this.postRender(i), n.onAllCallbacksCalled().then(() => {
      this.emitAnimationEndHook(i);
    }), this;
  }
  generateDataPoints(t, i) {
    const [n, s] = kI(
      this,
      i
    ), A = n.offsetValues || [], o = s.offsetValues || [];
    return this._plotSpan = {
      x: n.groupSpan || 0,
      y: s.groupSpan || 0
    }, this._plotPadding = {
      x: n.padding || 0,
      y: s.padding || 0
    }, this._pointMap = {}, t.map((r, l) => this.translatePoints(
      r,
      {
        barWidth: n.span,
        barWidthOffset: (this._transformType === jn ? A : A[l]) || 0,
        barHeight: s.span,
        barHeightOffset: (this._transformType === jn ? o : o[l]) || 0
      },
      l,
      t
    ));
  }
  getPlotPadding() {
    return this._plotPadding;
  }
  calculateAutoRotationAngle(t) {
    if (this.isVerticalBar()) {
      const { smartLabel: i } = this._dependencies, { width: n } = i.getOriSize(
        this.largestTextLabel()
      ), s = Math.max(
        ...Object.values(t.offsetValues).map(
          (A) => Object.keys(A).length
        )
      );
      this._autoRotationAngle = n > t.padding / (s + 1) + t.span ? -90 : 0;
    }
  }
  getTextAutoRotationAngle() {
    return this._autoRotationAngle;
  }
  resolveTransformType() {
    return this._transformType = gB(this), this._transformType;
  }
  /**
   * Gets the nearest point of the position passed.
   * @param {number} x x position
   * @param {number} y y position
   * @return {Object} Nearest point.
   */
  getNearestPoint(t, i) {
    if (!this.data())
      return null;
    const n = this._rtree.search({
      minX: Math.max(t - 1, 0),
      minY: Math.max(i - 1, 0),
      maxX: t + 1,
      maxY: i + 1
    });
    return n.length ? this.getDataFromEvent(null, n[0].point) : null;
  }
  getNearestPointInRange({ minX: t, minY: i, maxX: n, maxY: s }) {
    if (!this.data())
      return null;
    const A = this._rtree.search({
      minX: t - 1,
      minY: i - 1,
      maxX: n + 1,
      maxY: s + 1
    });
    return A.length ? this.getDataFromEvent(null, A[0].point) : null;
  }
  includeDataFromAllLayersInTooltip() {
    return !0;
  }
  static getDomain(t, {
    field: i,
    encoding: n,
    layerEncodings: s,
    transform: A,
    userDomain: o,
    hasRangedEncodingInValueAxis: a = !1
  }) {
    if (!i || !t.getField(i))
      return [];
    const r = s[n].as || t.getField(i).subtype(), l = dA({
      yField: s.y.field,
      yFieldAs: s.y.as,
      xField: s.x.field,
      xFieldAs: s.x.as,
      dm: t,
      transformConf: A
    });
    if (!Number.isFinite(t.getFieldIndex(i)))
      return [];
    const c = t.getField(i).subtype(), g = l && n === "x" || !l && n === "y";
    let h;
    const { value: d, uniqueField: u } = A.type === Wt || A.type === Xt ? this.getStackConfig(t, {
      encoding: s
    }) : {}, f = this.getOverrideTransformType(A.type, {
      isRanged: a
    });
    if (f === Wt && r === zs && d && (a || d.field === i))
      h = wc({
        dm: t,
        valueField: d.field,
        uniqueField: u.field,
        fieldAs: r
      });
    else if (f === Xt && r === zs && (a || d.field === i)) {
      if (rb(o))
        return ab(
          t,
          o,
          { field: i, uniqueField: u, fieldAs: r, isIndependentEncoding: g }
        );
      h = EB({ dm: t });
    } else if (r === ft.DISCRETE)
      h = c !== zi ? t.getField(i).uniques() : t.getField(i).getAllBins();
    else {
      const C = s[`${n}0`];
      if (t.isEmpty())
        h = null;
      else if (Z(C, "field")) {
        const I = C.as, E = C.field, B = t.getDomain(i, r), m = t.getDomain(
          E,
          I
        );
        h = [
          Math.min(...B, ...m),
          Math.max(...B, ...m)
        ];
      } else
        h = t.getDomain(i, r);
    }
    return r === zs && c !== Au && c !== zi && Z(h, "length") && (Z(s[`${n}0`], "field") ? h.sort((C, I) => C - I) : g ? h = Vh(h) : h = Hl(h)), h;
  }
  resolveOverrideTransformConfig(t) {
    const i = this.hasRangedValueAxis();
    return i ? {
      ...t,
      originalType: t.type,
      type: this.constructor.getOverrideTransformType(
        t.type,
        { isRanged: i }
      )
    } : t;
  }
  hasRangedValueAxis() {
    const { x: t, y: i } = this.axes(), n = this.encodingFieldsInf(), { x0Field: s, x0FieldAs: A, xFieldAs: o, y0Field: a, y0FieldAs: r, yFieldAs: l } = n, c = a && (r === zs || l === zs) ? !0 : s && (A === zs || o === zs) ? !1 : null;
    if (c === null)
      return !1;
    const g = c ? i : t, { fieldInstance: h } = g.config();
    let d = !1;
    return cr(h) && (d = h.vars().map((f) => f.toString()).some(
      (f) => f === (c ? a : s)
    )), d;
  }
  static getOverrideTransformType(t, { isRanged: i }) {
    return t === Wt && i ? ns : t;
  }
  getTextPointsForStackSum() {
    const t = this.axes();
    let i = this._points.flat();
    const n = this.isVertical(), { type: s, originalType: A } = this._transformConfig, o = n ? t.x.config().field : t.y.config().field, a = /* @__PURE__ */ new Map(), r = {};
    i.forEach((c) => {
      const g = K.isInvalid(c) ? c.value() : c.data[o], h = this._stackedSum.get(g);
      if (a.has(g) || a.set(g, { ...c, ...h }), h && s === ns && A === Wt) {
        let { pos: d, neg: u } = r[g] || {
          pos: null,
          neg: null
        };
        if (h.textFieldPosStackSum !== 0) {
          const f = n ? c.update.y : c.update.x + c.update.width;
          d = d ? (n ? Math.min : Math.max)(d, f) : f;
        }
        if (h.textFieldNegStackSum !== 0) {
          const f = n ? c.update.y + c.update.height : c.update.x;
          u = u ? (n ? Math.max : Math.min)(u, f) : f;
        }
        r[g] = { pos: d, neg: u };
      }
    });
    let l = [];
    return a.forEach((c, g) => {
      const h = {
        ...c,
        stackSumLabelCoords: r[n ? c.x : c.y]
      };
      if (c && c.textFieldPosStackSum !== 0) {
        const d = Wh(
          this,
          h,
          g,
          n,
          "posStackSum"
        );
        l.push(d);
      }
      if (c && c.textFieldNegStackSum !== 0) {
        const d = Wh(
          this,
          h,
          g,
          n,
          "negStackSum"
        );
        l.push(d);
      }
    }), l;
  }
  getTransformedData(t, i, n, s) {
    return mc(
      t,
      i,
      n
    );
  }
  getDataFromEvent(t, i) {
    return Bu(this, t, i);
  }
  getPlotSpan() {
    return this._plotSpan;
  }
  hasPlotSpan() {
    return !0;
  }
  applyStyles({ styleObj: t, elem: i, datum: n }, s) {
    const { styles: A, className: o } = t, a = Object.keys(A);
    let r = A;
    const c = xf.some((g) => g in A) ? A.strokePosition || "center" : null;
    c && (this.addOverlayPathAndStyles(
      i,
      n,
      xf.reduce((g, h) => (g[h] = A[h], g), {}),
      c,
      s
    ), r = a.filter((g) => !xf.includes(g)).reduce((g, h) => (g[h] = A[h], g), {})), o && i.classed(o, s.apply), this.applyElementStyles(i, r);
  }
  addOverlayPathAndStyles(t, i, n, s, A) {
    const o = this.getOverlayPathMount(), a = this.config().classPrefix;
    let r;
    if (this._overlayPath[i.rowId])
      r = this._overlayPath[i.rowId];
    else if (A.apply)
      r = z(
        o,
        "path",
        [i],
        `.${a}-layer-overlay-path-${i.rowId}`,
        {},
        (c) => c.rowId
      ), this._overlayPath[i.rowId] = r;
    else
      return;
    const l = parseInt(n["stroke-width"], 10);
    if (l && s) {
      const { L1: c, L2: g, L3: h, M: d } = j6({
        width: l,
        position: s
      });
      r.attr(
        "d",
        (u) => `M ${u.update.x + d.x} ${u.update.y + d.y}
            L ${u.update.x + u.update.width + c.x} ${u.update.y + c.y}
            L ${u.update.x + u.update.width + g.x} ${u.update.y + u.update.height + g.y}
            L${u.update.x + h.x} ${u.update.y + u.update.height + h.y} Z`
      );
    } else
      r.attr("d", "");
    for (let c in n)
      c !== "strokePosition" && r.style(c, n[c]);
  }
  getBoundBoxes() {
    return this._points.flat().map((i) => {
      const { x: n, y: s, width: A, height: o } = i.update, a = i.data;
      return {
        minX: n,
        maxX: n + A,
        minY: s,
        maxY: s + o,
        data: a,
        point: i
      };
    });
  }
  getBoundBox(t) {
    const i = this.measurement(), n = t.update;
    return n.x = Math.max(n.x, 0), n.y = Math.max(n.y, 0), n.x + n.width > i.width && (n.width = i.width - n.x), n.y + n.height > i.height && (n.height = i.height - n.y), n;
  }
  isVerticalBar() {
    const { yFieldAs: t, yField: i, xField: n, xFieldAs: s } = this.encodingFieldsInf();
    return dA({
      yField: i,
      yFieldAs: t,
      xField: n,
      xFieldAs: s,
      dm: this.data(),
      transformConf: this._transformConfig
    });
  }
  isVertical() {
    return this.isVerticalBar();
  }
  resolveBestLabelAnchor(t, i, n) {
    const s = this.config().encoding.text, A = nb(s), { textField: o } = this.encodingFieldsInf();
    if (!o)
      return;
    const a = this.isVerticalBar();
    let r = A.find((l) => this.isAnchorViable(
      t,
      l,
      i,
      a,
      n
    ));
    return r !== void 0 && r !== As && !a && (r = W6(r)), r;
  }
  isAnchorViable(t, i, n, s, A) {
    const { xFieldAs: o, yFieldAs: a, xFieldSubType: r, yFieldSubType: l } = this.encodingFieldsInf();
    if ((o === ft.DISCRETE || r === ot.BINNED) && (a === ft.DISCRETE || l === ot.BINNED))
      return TI(i);
    if (TI(i)) {
      if (s && Math.abs(A) === 90 || !s && (A === 0 || Math.abs(A) === 180))
        return !0;
      const { smartLabel: c } = this._dependencies, { width: g, height: h, text: d } = n, { width: u, height: f } = gl(
        d,
        A,
        c
      );
      return s ? f <= h : u <= g;
    }
    return this._transformType === Xt && fB(i) ? !1 : i !== Si && i !== Ps || this._transformType === jn ? !0 : (this._reducedDataMap === void 0 && this.reduceNormalizedDataMap(), !((this._reducedDataMap.get(t) instanceof Array ? this._reducedDataMap.get(t)[0] : this._reducedDataMap.get(t)) > 1));
  }
  reduceNormalizedDataMap() {
    this._reducedDataMap = /* @__PURE__ */ new Map();
    const { xField: t, x0Field: i, yField: n, y0Field: s } = this.encodingFieldsInf(), A = this.isVerticalBar();
    if (!(A ? s !== void 0 && n !== void 0 : i !== void 0 && t !== void 0) && ![Wt, Xt, jn].includes(this._transformType))
      return;
    const a = (g, h, d, u) => {
      const f = g ? Math.max(h.y || 0, h.y0 || 0) : Math.max(h.x || 0, h.x0 || 0);
      (f > 0 && f > this._maxPositive.value || f === this._maxPositive.value && this._reducedDataMap.get(d) < this._reducedDataMap.get(this._maxPositive.key)) && (this._maxPositive.key = d, this._maxPositive.value = f, this._maxPositive.text = u);
    }, r = (g, h, d, u) => {
      const f = g ? Math.min(h.y || 0, h.y0 || 0) : Math.min(h.x || 0, h.x0 || 0);
      (f < 0 && f < this._maxNegative.value || f === this._maxNegative.value && this._reducedDataMap.get(d) < this._reducedDataMap.get(this._maxNegative.key)) && (this._maxNegative.key = d, this._maxNegative.value = f, this._maxNegative.text = u);
    }, l = (g, h, d) => {
      const u = g.textFieldPosStackSum || g.textFieldNegStackSum;
      u > 0 && u > this._maxPositive.value && (this._maxPositive.key = h, this._maxPositive.value = u, this._maxPositive.text = d);
    }, c = (g, h, d) => {
      const u = g.textFieldPosStackSum || g.textFieldNegStackSum;
      u < 0 && u < this._maxNegative.value && (this._maxNegative.key = h, this._maxNegative.value = u, this._maxNegative.text = d);
    };
    if (this._stackedSum.size)
      this._stackedSum.forEach((g) => {
        const h = this.createKey(g, A);
        g.textFieldPosStackSum && g.textFieldNegStackSum ? this._reducedDataMap.set(h, 2) : this._reducedDataMap.set(h, 1);
        const d = g.formattedTextPosSum !== "0" ? g.formattedTextPosSum : g.formattedTextNegSum;
        l(g, h, d), c(g, h, d);
      });
    else {
      let g;
      const h = this._normalizedData, u = this._transformedData.getData();
      h.forEach((f, C) => {
        f.filter((I) => A ? !isNaN(I.y) || !isNaN(I.y0) : this.encodingFieldsInf().xFieldType === "measure" && this.encodingFieldsInf().xFieldAs === "continuous" ? !isNaN(I.x) || !isNaN(I.x0) : !0).forEach((I) => {
          const E = this.createKey(I, A), B = /* @__PURE__ */ new Set();
          g = u[C].keys.join(","), this._reducedDataMap.has(E) ? this._reducedDataMap.set(E, [
            this._reducedDataMap.get(E)[0] + 1,
            this._reducedDataMap.get(E)[1].add(g)
          ]) : this._reducedDataMap.set(E, [1, B.add(g)]), a(A, I, E, I.formattedText), r(A, I, E, I.formattedText);
        });
      });
    }
  }
  createKey(t, i) {
    let n;
    if (this.encodingFieldsInf().xFieldAs === "discrete" && this.encodingFieldsInf().yFieldAs === "discrete" || this.encodingFieldsInf().xFieldSubType === "binned" && this.encodingFieldsInf().yFieldSubType === "binned")
      return `${K.getActualValue(t.x)}-${K.getActualValue(t.y)}`;
    const s = i ? t.x : t.y, A = i ? t.x0 : t.y0;
    return s !== void 0 ? n = s : n = "", A !== void 0 && A !== s && (typeof n == typeof A ? n += A : n = A), K.getActualValue(n);
  }
};
class tV extends ci(Ws).with($b) {
  static formalName() {
    return GE;
  }
}
const eV = {
  defClassName: "layer-tick",
  className: "",
  classPrefix: On,
  nearestPointThreshold: 10,
  interaction: {
    highlight: {
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "1px"
              }
            },
            {
              target: (e, t) => {
                const {
                  entryExitSet: { entrySet: i }
                } = e, n = t.getEntryExitSet("select");
                return n ? i.intersect(n.entrySet) : null;
              },
              key: "commonSet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "2px"
              }
            }
          ]
        }
      }
    },
    select: {
      // propagationFields:
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  {
                    target: "exitSet",
                    style: {
                      fill: { a: -0.7 }
                      // strokePosition: "center",
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "entrySet",
              style: {
                strokePosition: "center",
                stroke: "black",
                "stroke-width": "1px"
              }
            }
          ]
        }
      }
    },
    brush: {
      target: {
        layer: {
          highlight: {
            sideEffects: {
              "plot-highlighter": {
                rules: [
                  {
                    target: "entrySet",
                    style: {
                      fill: { a: 0.3 },
                      strokePosition: "center"
                    }
                  }
                ]
              }
            }
          }
        }
      },
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: (e, t) => e.payload.sourceInfo.layerId !== t.id() ? null : e.entryExitSet.entrySet,
              key: "commonSet",
              style: {
                stroke: "black",
                "stroke-width": "1px",
                strokePosition: "outside"
              }
            },
            {
              target: "exitSet",
              style: {
                fill: { a: -0.5 }
              }
            }
          ]
        }
      }
    }
  },
  innerPadding: 0.1,
  transform: {},
  transition: {
    effect: "cubic",
    duration: 1e3
  },
  interpolate: "linear",
  encoding: {
    color: {},
    opacity: {
      value: 0.7
    },
    x: {},
    y: {},
    x0: {},
    y0: {},
    radius: {},
    radius0: {},
    angle: {},
    angle0: {},
    text: { ...Oo }
  },
  interactive: !0
}, iV = fn.line, nV = (
  /* istanbul ignore next */
  (e) => {
    const {
      points: t,
      container: i,
      keyFn: n,
      className: s,
      interpolate: A,
      layer: o,
      transition: a,
      animationAggregator: r
    } = e, { disabled: l } = a, c = X(i), g = o._graphicElems;
    return c.attr("class", s), z(
      c,
      "g",
      t,
      null,
      {
        enter: (h, d) => {
          const u = d.enter || {};
          Object.entries(u).forEach(
            (f) => !isNaN(f[1]) && h.attr(f[0], f[1])
          );
        },
        update: (h, d) => {
          const u = z(h, "path", [1]);
          g[d.rowId] = h;
          const { update: f, style: C } = d;
          h.attr("class", s), h.classed(d.className, !0);
          const I = f.x0 !== void 0 ? f.x0 : f.x, E = f.y0 !== void 0 ? f.y0 : f.y, B = gc[A], m = iV().curve(B).x((p) => p[0]).y((p) => p[1]);
          d.className && h.classed(d.className, !0), u.attr(
            "d",
            m([
              [f.x, f.y],
              [I, E]
            ])
          ), d.size && u.attr("stroke-width", d.size), l || (h = h.transition().duration(a.duration).on("end", r.newCallback())), Object.entries(C).forEach(
            (p) => h.style(p[0], p[1])
          );
        },
        exit: (h) => {
          h.remove();
        }
      },
      n
    );
  }
), sV = {
  center: () => ({
    M: { x: 0, y: 0 },
    L: { x: 0, y: 0 }
  }),
  inside: (e) => ({
    M: { x: +e, y: +e },
    L: { x: -e, y: +e }
  }),
  outside: (e) => ({
    M: { x: -e, y: -e },
    L: { x: +e, y: -e }
  })
}, AV = ({ width: e, position: t = "center" }) => {
  const i = e ? e / 2 : 1;
  return sV[t](i);
}, oV = (e, t = {}, i, n, s) => {
  const A = i.axes(), o = i.config().encoding;
  let a = [];
  const { x: r, y: l } = A, { xField: c, yField: g, x0Field: h, y0Field: d } = i.encodingFieldsInf(), u = i.measurement(), { x: f, y: C } = t.offset, { x: I, y: E } = t.span;
  for (let B = 0, m = e.length; B < m; B++) {
    let p, w, Q, y;
    const D = e[B], _ = D.source;
    c && (p = r.getScaleValue(D.x) + f, w = p + I), g && (y = l.getScaleValue(D.y) + C, Q = y !== null ? y + E : null), c || (p = 0, w = u.width, isNaN(y) || (y += E / 2, Q = y)), g || (y = 0, Q = u.height, w = p += I / 2), h && (w = r.getScaleValue(D.x0) + I, y += E / 2, Q -= E / 2), d && (Q = l.getScaleValue(D.y0) + E, p += I / 2, w -= I / 2);
    const S = ts(i, D).getColor(D.color);
    let R = Ho(i, D).getSize(D.size);
    const G = ws(i, D);
    let T;
    G && (T = G.getOpacity(D.opacity)), typeof o.opacity.value != "function" && !o.opacity.field && (T = o.opacity.value);
    const v = Qs(i, {
      translatedValues: {
        x: p,
        y,
        x0: w,
        y0: Q,
        color: S,
        size: R,
        opacity: T
      },
      datum: D,
      datumIdx: B,
      groupData: e,
      groupIdx: n,
      layerData: s
    }), H = {
      stroke: v.color,
      opacity: v.opacity
    };
    if (!isNaN(p) && !isNaN(y)) {
      const N = {
        enter: {},
        update: {
          x: v.x,
          y: v.y,
          x0: v.x0,
          y0: v.y0
        },
        style: H,
        source: _,
        rowId: D.rowId,
        data: D.dataObj,
        size: v.size,
        meta: { layerId: i.id(), ...ys(H) }
      };
      N.className = Vs(D, B, e, i), a.push(N), i.cachePoint(D.rowId, N);
    }
  }
  return a = Uo(i, a), a;
}, Xb = (e) => class extends e {
  constructor(...t) {
    super(...t);
  }
  static defaultConfig() {
    return eV;
  }
  static formalName() {
    return "tick";
  }
  static drawFn() {
    return nV;
  }
  elemType() {
    return "path";
  }
  /**
   * Generates an array of objects containing x, y, width and height of the points from the data
   * @param  {Array.<Array>} data Data Array
   * @param  {Object} encoding  Config
   * @param  {Object} axes     Axes object
   * @return {Array.<Object>}  Array of points
   */
  translatePoints(t, i, n, s) {
    return oV(t, i, this, n, s);
  }
  attachDataToVoronoi(t) {
    pc(this._voronoi, t, (i) => {
      const { x: n, x0: s, y: A, y0: o } = i.update;
      return {
        x: n + (s - n) / 2,
        y: A + (o - A) / 2
      };
    });
  }
  getMeasurementConfig(t, i, n, s) {
    return {
      offset: {
        x: t || 0,
        y: i || 0
      },
      span: {
        x: n,
        y: s
      }
    };
  }
  addOverlayPathAndStyles(t, i, n, s) {
    let A;
    this._overlayPath[i.rowId] ? A = this._overlayPath[i.rowId] : (A = z(
      t,
      "path",
      [i.update],
      null,
      {},
      (l) => `${l.x} ${i.rowId}`
    ), A.style("fill", "none"), A.style("fill-opacity", 0), A.attr("id", i.rowId), this._overlayPath[i.rowId] = A);
    let o = { x: 0, y: 0 }, a = { x: 0, y: 0 };
    if (n.type === "stroke-width") {
      const { L: l, M: c } = AV({
        width: parseInt(n.value, 10),
        position: s
      });
      o = c, a = l;
    }
    A.attr("d", (l) => l.update ? `M ${l.update.x + o.x} ${l.update.y + o.y}
                    L ${l.update.x0 + a.x} ${l.update.y0 + a.y}` : `M ${l.x + o.x} ${l.y + o.y}
                L ${l.x0 + a.x} ${l.y0 + a.y}`);
    let r = n.value;
    if (typeof r == "function") {
      const l = A.style(n.type);
      r = r(l);
    }
    A.style(n.type, r), i.isPathPresent || (rS(t, A.node()), i.isPathPresent = !0);
  }
  getShapeRadius(t) {
    if (t) {
      const { update: i } = t.data.data, n = Math.abs(i.x - i.x0), s = Math.abs(i.y - i.y0);
      return Math.max(n, s) / 2;
    }
    return 0;
  }
  static autoDetectTransformType() {
    return ns;
  }
  getNearestPoint(t, i, { event: n }) {
    if (!this.data())
      return null;
    const s = this._rtree.search({
      minX: Math.max(t - 1, 0),
      minY: Math.max(i - 1, 0),
      maxX: t + 1,
      maxY: i + 1
    });
    return s.length ? Bu(this, n, s[0].point) : null;
  }
  getBoundBoxes() {
    return this._points.flat().map((i) => {
      const n = this.getBoundBox(i), { x: s, y: A, width: o, height: a } = n, r = i.data;
      return {
        minX: s,
        maxX: s + o + 2,
        minY: A - 2,
        maxY: A + a + 2,
        data: r,
        point: i
      };
    });
  }
  getBoundBox(t) {
    const { x: i, y: n, x0: s, y0: A } = t.update;
    return {
      x: i,
      y: n,
      width: s - i,
      height: A - n
    };
  }
};
class Zb extends ci(Ws).with(
  bB,
  Xb
) {
  static formalName() {
    return "tick";
  }
}
const tM = "area", eM = "arc", iM = "line", nM = "text", sM = "point", AM = "bar", oM = "tick", aV = "simple", aM = "base", rM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ARC_LAYER: eM,
  AREA_LAYER: tM,
  BAR_LAYER: AM,
  BASE_LAYER: aM,
  LINE_LAYER: iM,
  POINT_LAYER: sM,
  SIMPLE_LAYER: aV,
  TEXT_LAYER: nM,
  TICK_LAYER: oM
}, Symbol.toStringTag, { value: "Module" })), rV = {
  [tM]: Ub,
  [eM]: Ob,
  [iM]: Pb,
  [nM]: Kb,
  [sM]: zb,
  [oM]: Zb,
  [AM]: tV,
  [aM]: Ws
}, lM = (e = rV) => {
  const t = Object.assign({}, e), i = {
    register: (n) => {
      const s = n.formalName();
      return t[s] = n, i;
    },
    get: () => t
  };
  return i;
}, lV = "data", cV = "config", gV = "measurement", hV = "domain", dV = "mount", uV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CONFIG: cV,
  DATA: lV,
  DOMAIN: hV,
  MEASUREMENT: gV,
  MOUNT: dV
}, Symbol.toStringTag, { value: "Module" })), fV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CONSTANTS: pY,
  LAYER_TYPES: rM,
  PROPS: uV
}, Symbol.toStringTag, { value: "Module" }));
class f0 extends xc {
  constructor(...t) {
    super(...t), this.setApplyChecker({
      source: (i, n, s) => {
        if (i.unitId === n.unitId) {
          const A = this._payload ? this._payload.criteria : null;
          return !_l(A, s.criteria) || s.dragDiff !== 0;
        }
        return !0;
      }
    });
  }
  static formalName() {
    return Pl;
  }
  dispatch(...t) {
    return this.active = t[0].dragging, this.start = t[0].dragStart, super.dispatch(...t);
  }
  setSelectionSet(t, i) {
    if (t === null)
      i.reset();
    else if (t.length) {
      i.reset(), i.add(t);
      const n = Cs(
        [i.getCompleteSet()],
        [i.getEntrySet()]
      );
      i.remove(n);
    } else {
      const n = Cs(
        [i.getCompleteSet()],
        [i.getExitSet()]
      );
      i.remove(n);
    }
  }
}
const IV = Object.assign({}, O6, {
  pointLayerHelpers: jK
}), CV = {
  BarLayerMixin: $b,
  BaseLayerMixin: Fb,
  LineLayerMixin: _B,
  AreaLayerMixin: Lb,
  PointLayerMixin: bB,
  TextLayerMixin: Jb,
  TickLayerMixin: Xb,
  ArcLayerMixin: Hb
}, cM = (e, t) => {
  const i = {};
  e.forEach((n) => {
    const { colorField: s, sizeField: A, shapeField: o, xField: a, yField: r } = n.encodingFieldsInf(), { encoding: l } = n.config(), c = ["x", "y"], g = [a, r].filter(
      (h, d) => l[c[d]] && l[c[d]].as === "continuous"
    );
    [s, A, o].forEach((h) => {
      t.isDimension(h) && g.length && (!i[h] && (i[h] = []), i[h].push(...g));
    });
  });
  for (const n in i)
    ({}).hasOwnProperty.call(i, n) && (i[n] = [
      ...new Set(i[n])
    ]);
  return i;
}, EV = (e, t) => {
  const i = {};
  for (const n in e)
    if ({}.hasOwnProperty.call(e, n)) {
      const s = e[n];
      i[n] = s(t);
    }
  return i;
}, gM = (e, t, i, n, s = {}) => {
  let A = i;
  const o = e._dependencies, a = e.metaInf(), r = e.facetFieldsMap();
  if (!i) {
    A = en.getLayerInstance(
      t,
      () => e.createChildEventManager()
    );
    const g = e.store();
    Bn(A).forEach((h) => {
      h.dependencies(o).store(g);
    });
  }
  const l = {}, c = Bn(A);
  return t = Bn(t), t.reduce((g, h, d) => {
    const u = c[d];
    return Z(h.encoding.color, "field") in r && (h.transform.type = wt(h.transform.type, "identity")), u.id(h.id), h.theme = e.config().theme, u.config(h), u.renderer(n), u.valueParser(e.valueParser()), u.interactionRegistry(e.registry().interactions), u.dataProps({
      timeDiffs: e._timeDiffs
    }), hM(e, u, a), h.name && u.alias(h.name), !s.skipLayerFireboltCreation && u.createFirebolt(), l[u.alias()] = u, g;
  }, {}), l;
}, hM = (e, t, i) => {
  t.metaInf({
    unitRowIndex: i.rowIndex,
    unitColIndex: i.colIndex,
    rowFacets: i.rowFacets,
    colFacets: i.colFacets,
    canvasAlias: e.parentAlias(),
    unitId: e.id(),
    facets: e.facetFieldsMap(),
    totals: i.totals || null,
    rowTotalString: i.rowTotalString,
    colTotalString: i.colTotalString,
    columnTotalString: i.columnTotalString
  });
}, dM = (e, t) => {
  const i = e.config().encodingTransform || {}, n = i.resolvable;
  let s = [];
  if (n) {
    const A = n(t);
    s = A.depArr, e.encodingTransform(A.fn);
  } else i instanceof Function && e.encodingTransform(i);
  return s;
}, PI = (e) => {
  const t = [];
  return e.forEach((i, n) => {
    const s = i.def, A = i.mark;
    if (s)
      s.name || (s.name = `${A}-${n}`), t.push(i);
    else {
      const o = en.getSerializedConf(i.mark, i);
      o.name || (o.name = `${A}-${n}`), t.push({
        mark: i.mark,
        def: o
      });
    }
  }), t;
}, MB = (e, t, i, n) => {
  let s = typeof i == "function" ? i(e) : e;
  const A = Object.keys(t.encoding).map((l) => t.encoding[l].field).filter((l) => !!l).flat(), o = e.getDimensions();
  let a = !1;
  const r = [];
  return o.forEach((l) => {
    A.includes(l) ? r.push(l) : a = !0;
  }), a && !n.disabled && (s = s.groupBy(r)), s;
}, uM = (e, t, i) => {
  const n = e._cache, { autoGroupBy: s } = e.config(), A = e._customLayerDataModels, o = e._layerDataModels;
  t.forEach((a) => {
    let { encoding: r, source: l } = a.config(), c;
    if (Z(r, "detail", "field") || (r.detail = et({}, r.detail, {
      field: e.detailFields()
    })), A)
      c = A[a.id()];
    else {
      const h = o[a.id()];
      if (h)
        c = h || i;
      else {
        const d = Z(e.transform(), l) || l;
        c = MB(
          i,
          a.config(),
          d,
          s
        );
      }
    }
    n ? a.enableCaching() : a.disableCaching(), e.layerDomains()[a.id()] && a.domain(e.layerDomains()[a.id()]), a.data(c);
  });
}, fM = (e, t, i) => {
  t.forEach((n) => {
    const s = {}, A = n.config();
    cE(e, (o) => {
      let a;
      const r = e[o] || [], l = Z(A.encoding, o, "field"), c = Z(A.encoding, o, "splitBy"), g = r.find(
        (h) => h.config().metaInfo?.isTotalsAxis
      );
      if (l) {
        const h = Z(A.encoding, o, "as") || bi(i.data().getField(l)), d = Z(A.encoding, o, "var");
        a = r.filter((I) => {
          const E = I.config(), B = E.fieldInstance;
          return B && d ? B === d : B ? B.getMembers().includes(l) && E.fieldAs === h : E.field === l && E.fieldAs === h;
        }), c ? a = a.reduce((I, E) => (I[E.config().splitFieldValue] = E, I), {}) : a = a[0];
        const u = i.metaInf(), f = i.fields(), C = {
          field: l,
          type: h,
          subtype: i.data().getField(l).subtype()
        };
        g && kx(C, u, f) && (a = g);
      } else {
        let h;
        const d = r.findIndex(
          (u) => u.isGlobal && u.isGlobal()
        );
        d !== -1 ? h = d : h = 0, a = e[o][h];
      }
      e[o] && (s[o] = wt(a));
    }), Object.keys(s).length && n.axes(s), n.metaInf({
      totalsAxis: {
        color: A.encoding.color.field && e.color?.find((o) => o.config().metaInfo?.isTotalsAxis),
        backgroundColor: A.encoding.backgroundColor.field && e.backgroundColor?.find((o) => o.config().metaInfo?.isTotalsAxis),
        size: A.encoding.size.field && e.size?.find((o) => o.config().metaInfo?.isTotalsAxis)
      }
    });
  });
}, { X: BV, Y: mV, RADIUS: I0, ANGLE: IM, ANGLE0: CM, RADIUS0: pV } = Gt, QV = (e, t) => {
  const i = {};
  return e.forEach((n) => {
    const { axis: s, encoding: A } = n.config(), o = n.id();
    [BV, mV, IM, CM, I0].forEach((a) => {
      let r;
      const l = Z(A, a, "field"), c = a === I0 ? wt(l, Z(A, pV, "field")) : Z(A, a, "field"), g = wt(Z(s, a), c);
      t[a] && t[a].length ? r = t[a].findIndex(
        (h) => h.getMembers().indexOf(g) !== -1
      ) : r = 0, !i[o] && (i[o] = {}), i[o][a] = r;
    });
  }), i;
}, yV = (e, t, i, n) => i === IM || i === CM ? e.concat(t.filter((s) => e.indexOf(s) === -1)) : we([e, t], n), ua = (e, t, i) => {
  let n = [];
  return e.forEach((s) => {
    [s.def].flat().forEach((A) => {
      const o = i.encoding, a = t[A.id], r = i.field.has(
        A.encoding[o].field
      ) ? a[i.encoding] : null;
      if (r !== null && A.calculateDomain !== !1) {
        const l = A.encoding, c = Z(l, o, "field"), g = Z(l, o, "as");
        c && (n = yV(n, r, o, g));
      }
    });
  }), n;
}, EM = (e, t, i, n, s) => {
  const A = e.renderer(), o = e.config().classPrefix, a = i.sort(
    (d, u) => d.config().order - u.config().order
  ), r = A === "html" ? "div" : "g", l = z(
    t,
    r,
    [1],
    `${o}-layer-group`
  );
  l.style("width", "inherit").style("height", "inherit");
  const c = ux(e._layerDepOrder), g = {};
  z(l, r, a, null, {
    update: (d, u) => {
      g[u.alias()] = {
        group: d,
        layer: u
      };
    }
  }), c.map((d) => g[d]).filter((d) => d !== void 0).forEach((d) => {
    const u = d.layer, f = d.group;
    u.measurement(n), u.dataProps({
      timeDiffs: e._timeDiffs
    }), u.config().render !== !1 && u.mount(f.node(), s);
  });
}, YI = (e, t) => {
  const { CONTINUOUS: i, TEMPORAL: n, BINNED: s } = K.FieldSubtype, A = e.fields();
  if (!A.x.length || !A.y.length)
    return null;
  const o = e.data(), a = e.axes(), r = Z(A, "x", 0), l = Z(A, "y", 0), c = { value: null }, g = [
    ["x", r],
    ["y", l]
  ].find(
    ([, f]) => f.as() === "discrete" || f.subtype() === "temporal" || f.subtype() === "binned"
  );
  if (!g || r.subtype() !== i && l.subtype() !== i)
    return c;
  const h = g[1], d = cr(h);
  let u = a[g[0]][0].getNearestInvertedValue(t[g[0]]);
  if (d) {
    if ((g[1].subtype() === n || g[1].subtype() === s) && g[1].as() === i) {
      let f = h.vars().map((C) => [...new Set(o.getFieldData(C.toString()))]);
      f = f.sort((C, I) => C - I), u = f.map((C) => hI(C, u));
    }
    return u !== void 0 && (c.value = [h.vars().map((f) => f.toString()), u]), { ...c, multipleDimFields: !0 };
  }
  if ((g[1].subtype() === n || g[1].subtype() === s) && g[1].as() === i) {
    let f = [...new Set(o.getFieldData(h.toString()))];
    f = f.sort((C, I) => C - I), u = hI(f, u);
  }
  return u !== void 0 && (Array.isArray(u) ? c.value = [[h.toString()], u] : c.value = [[h.toString()], [u]]), c;
}, JI = (e, t, i) => e.filter((n) => (t === "type" ? n.constructor.formalName() : n.alias()) === i), KI = (e, t, i) => {
  e.filter((n) => (t === "type" ? n.config().mark : n.alias()) === i ? (n.remove(), !1) : !0);
}, BM = (e, t) => z(e, "g", [1], t).node(), mM = (e, t, i = {}) => {
  const { innerRadius: n, outerRadius: s } = i;
  return [n || 0, s || Math.min(t, e) / 2];
}, pM = (e) => {
  const t = e.axes(), { radius: i } = t;
  i && i.forEach((n) => {
    n.range(mM(e.width(), e.height()));
  });
}, wV = (e) => {
  (e.node().__on || []).forEach(({ type: i }) => {
    e.on(i, null);
  });
}, QM = (e) => {
  const t = e._graphics.rootSvg, i = e.config().classPrefix, n = e._graphics;
  if (!e.layers().find((s) => s.config().mark === pS) && e.renderer() !== "html") {
    const s = `${i}-tracker`;
    n.trackerGroup = z(
      n.rootSvg,
      "g",
      [1],
      `${s}-group`
    ), n.tracker = z(
      n.trackerGroup,
      "rect",
      [1],
      s
    ), hA(n.tracker, {
      x: 0,
      y: 0,
      width: e.width(),
      height: e.height(),
      class: s
    }), wV(t);
  } else
    n.tracker && n.tracker.remove(), n.tracker = null;
}, DV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attachAxisToLayers: fM,
  attachDataToLayers: uM,
  createSideEffectGroup: BM,
  createTrackerElement: QM,
  getDimensionMeasureMap: cM,
  getLayerAxisIndex: QV,
  getLayerFromDef: gM,
  getLayersBy: JI,
  getNearestDimensionalValue: YI,
  getRadiusRange: mM,
  getTransformedLayerDataModel: MB,
  removeLayersBy: KI,
  renderLayers: EM,
  resolveEncodingTransform: dM,
  sanitizeLayerDef: PI,
  setAxisRange: pM,
  transformDataModels: EV,
  unionDomainFromLayers: ua,
  updateLayerMetaInf: hM
}, Symbol.toStringTag, { value: "Module" })), xV = "config", yM = "data", SV = "axes", wM = "layerDef", _V = "width", bV = "height", MV = "mount", NV = "transform", FV = "transformedData", RV = "dataDomain", kV = "fields", vV = "layers", DM = "domain", TV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AXES: SV,
  CONFIG: xV,
  DATA: yM,
  DATADOMAIN: RV,
  DOMAIN: DM,
  FIELDS: kV,
  HEIGHT: bV,
  LAYERDEFS: wM,
  LAYERS: vV,
  MOUNT: MV,
  TRANSFORM: NV,
  TRANSFORMEDDATA: FV,
  WIDTH: _V
}, Symbol.toStringTag, { value: "Module" })), xM = "muze", GV = "__id__", SM = "grid-lines", _M = "grid-bands", bM = "grid-parent-group", LV = "band", UV = "tick", iA = "gridBands", MM = "gridLines", NM = "consolidated", HV = "fragmented", FM = "facetByFields", RM = "retinalFields", kM = "parentAlias", OV = "layers", vM = "cachedData", PV = "store", YV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAND: LV,
  CACHED_DATA: vM,
  CLASSPREFIX: xM,
  CONSOLIDATED: NM,
  FACET_BY_FIELDS: FM,
  FRAGMENTED: HV,
  GRID_BAND: iA,
  GRID_BAND_PARENT_GROUP_CLASS: _M,
  GRID_LINE: MM,
  GRID_LINE_PARENT_GROUP_CLASS: SM,
  GRID_PARENT_GROUP: bM,
  IDFIELD: GV,
  LAYERS: OV,
  PARENT_ALIAS: kM,
  RETINAL_FIELDS: RM,
  STORE: PV,
  TICK: UV
}, Symbol.toStringTag, { value: "Module" })), JV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CONSTANTS: YV,
  REACTIVE_PROPS: TV
}, Symbol.toStringTag, { value: "Module" })), KV = (e, t, i) => {
  const n = e.context.getNearestPoint(t.x, t.y, {
    data: i.data,
    event: i.event
  });
  return {
    criteria: n.id ? {
      dimensions: n.id
    } : null,
    target: (n || {}).target,
    position: t,
    layerId: (n || {}).layerId,
    targetData: Z(n, "targetData"),
    metaInfo: e.context.metaInf()
  };
}, VV = {
  [va.CARTESIAN]: (e, { startPos: t, endPos: i }) => {
    if (t.x === i.x && t.y === i.y)
      return {
        criteria: null
      };
    const n = e.context.getRangeFromPositions(
      {
        startPos: t,
        endPos: i
      },
      {
        brush: Z(e.config().brush, "mode")
      }
    ), s = {};
    return s.x = [t.x, i.x], s.y = [t.y, i.y], {
      criteria: n,
      dimensions: s
    };
  },
  [va.POLAR]: () => ({
    criteria: null
  })
}, C0 = (e, t) => {
  const n = e.context.coord();
  return VV[n](e, t);
};
class TM extends Yo {
  constructor(...t) {
    super(...t), this._propagationDms = {}, this._entryExitSet = {}, this._payloads = {}, this._interactionStates = /* @__PURE__ */ new Map(), this._actionPayloadMap = {
      hover: (i, n, s) => {
        const A = i.context.layers(), a = A.find((I) => I.config().highlightExactPoint !== !1) ? {} : {
          getAllPoints: !0,
          detectEmptyArea: !!A.find(
            (I) => I.config().detectHoverOnEmptyArea
          ) && A.length === 1
        }, { tooltip: r } = i.config();
        let l = null, c = [], g = null;
        const h = r.includeDataFromAllLayers && A.length > 1 && A.every((I) => I.includeDataFromAllLayersInTooltip());
        if (h) {
          const I = i.context.getNearestPointsFromAllLayers(
            n.x,
            n.y,
            Object.assign(a, {
              data: s.data,
              event: s.event
            })
          );
          l = I[0], l.id && (g = {
            dimensions: l.id
          }), c = I.slice(1).filter((E) => {
            const { point: B, isVertical: m } = E, p = l.point.update, w = B.update, Q = m ? w.y : w.x, y = m ? w.y + w.height : w.x + w.width, D = m ? p.y : p.x, _ = m ? p.y + p.height : p.x + p.width;
            return D >= Q && _ <= y || D <= Q && _ >= y;
          });
        } else
          l = i.context.getNearestPoint(
            n.x,
            n.y,
            Object.assign(a, {
              data: s.data,
              event: s.event
            })
          ), l.id && (g = {
            dimensions: l.id
          });
        const d = i.context.layers().map((I) => I.getDataBoundary(n.x, n.y)).filter((I) => !!I), u = d[d.length - 1], f = i.context.metaInf();
        return {
          criteria: g,
          target: (l || {}).target,
          position: n,
          layerId: (l || {}).layerId,
          targetData: Z(l, "targetData"),
          metaData: {
            layersInfo: A,
            isTotals: f.totals,
            isCollapsed: f.isCollapsed,
            includeTotalDomain: f.includeTotalDomain,
            rowFacets: i.context.metaInf().rowFacets,
            colFacets: i.context.metaInf().colFacets,
            ...h ? { includeDataFromAllLayers: h } : {},
            ...h ? { hasPointsInBackground: !!c.length } : {},
            ...u ? {
              borderPoints: u.points,
              borderId: u.id,
              layerId: u.layerId
            } : {}
          }
        };
      },
      drag: (i, n, s) => {
        const { startPos: A, endPos: o } = n, a = i.context.getNearestPoint(
          A.x,
          A.y,
          {
            data: s.data,
            event: s.event
          }
        ), r = C0(i, n);
        return r.dragging = s.isDragging, r.dragDiff = Math.abs(A.x - o.x) + Math.abs(A.y - o.y), r.dragEnd = s.dragEnd, r.dragEnd && (r.hideSelBox = !0), r.dragStart = s.dragStart, r.target = a.id, r;
      },
      selectiondrag: (i, n, s) => {
        const { startPos: A, endPos: o } = n, a = C0(i, n);
        return a.dragging = s.isDragging, a.dragDiff = Math.abs(A.x - o.x) + Math.abs(A.y - o.y), a.dragEnd = s.dragEnd, a.dragEnd && (a.hideSelBox = !0), a;
      }
    };
  }
  data(...t) {
    if (t.length) {
      const i = t[0] === null ? this.context.cachedData()[0] : t[0], n = t[1], s = this.context;
      return s.setCustomLayerData(n), s.enableCaching().data(i), s.clearCustomLayerData(), this;
    }
    return this.context.data();
  }
  disposeBehaviours({ exclude: t }) {
    const i = this._actions.behavioural;
    for (const n in i)
      n !== t && i[n].dispose();
  }
  resetData() {
    const { context: t } = this, i = t.layers().reduce((n, s) => (n[s.id()] = s.cachedData()[0], n), {});
    return t.setCustomLayerData(i), t.clearCaching().resetData(), this;
  }
  target() {
    return "visual-unit";
  }
  remove() {
    return this.context.cachedData()[0].unsubscribe("propagation"), this;
  }
  id() {
    return this.context.id();
  }
  getPropagationSource() {
    return this.context.cachedData()[0];
  }
  sourceCanvas() {
    return this.context.parentAlias();
  }
  groupFirebolt(...t) {
    return t.length ? (this._groupFirebolt = t[0], this) : this._groupFirebolt;
  }
  onPhysicalActionTrigger(t) {
    this.groupFirebolt().onPhysicalActionTrigger({
      ...t,
      sourceUnit: this.id(),
      unitMetaInf: this.context.metaInf()
    });
  }
  dispatchBehaviour(t, i, n = {}) {
    const s = this._childFirebolts;
    let A = !0;
    const o = s.find(
      (c) => c.id() === i.sourceInfo.layerId
    );
    (o ? [
      o,
      ...s.filter(
        (c) => c !== o
      )
    ] : s).forEach((c) => {
      let g = i.criteria;
      const h = c.getSideEffectsForSourceAction({
        action: t
      }), d = wt(
        i.sideEffects ? i.sideEffects : h,
        []
      ), u = i.sourceInfo.layerId, { includeDataFromAllLayers: f, hasPointsInBackground: C } = i.metaData || {}, I = this.layers().some(
        (B) => B._transformedData._config && B._transformedData._config.groupBy && B._transformedData._config.groupBy.length
      );
      if (!(f && (C || I)) && i.isExplicitAction && i.criteria !== null && (u && u !== c.id() || i.sourceInfo.unitId !== this.id()) && (g = {
        uids: []
      }), c.dispatchBehaviour(
        t,
        {
          ...i,
          sideEffects: d,
          criteria: g
        },
        n
      )) {
        const B = c.actions().behavioural[t].getSelectionSet().resetted();
        B ? c.removeInteractionState({
          action: t
        }) : c.saveInteractionState({
          action: t,
          payload: {
            ...i,
            sideEffects: d,
            criteria: g
          },
          propagationInf: n
        }), A = A && B;
      }
    }), this.createEntryExitSet(i);
    const r = this.getSideEffectsForSourceAction({
      action: i.action
    }), { tooltip: l } = this.config();
    this.metaData(
      l && l.includeDataFromAllLayers ? {
        entryExitSetsByLayerId: s.reduce((c, g) => {
          const h = g.context.id(), d = g.getEntryExitSet(i.action);
          return { ...c, [h]: d };
        }, {})
      } : {}
    ), this.dispatchSideEffects(
      t,
      { ...i, sideEffects: r },
      n
    ), A ? this.removeInteractionState({
      action: t
    }) : this.saveInteractionState({
      action: t,
      payload: { ...i, sideEffects: r },
      propagationInf: n
    }), this._lastInteraction.set(t, {
      behaviour: t,
      sideEffects: r
    });
  }
  applyExistingInteractions() {
    this._childFirebolts.forEach((i) => {
      i.applyExistingInteractions();
    }), this._interactionStates.forEach(({ action: i, payload: n, propagationInf: s }) => {
      const A = n.sideEffects.filter((o) => this.sideEffects()[o.name] && this.sideEffects()[o.name].shouldApplyOnRenderAfterScrolling());
      this.dispatchSideEffects(
        i,
        { ...n, sideEffects: A },
        s
      );
    });
  }
  shouldResetAllInteractions(t) {
    return this._childFirebolts[0].getBehaviouralAction(t).shouldResetOtherActionsOnTrigger();
  }
  addChildFirebolts(t) {
    this._childFirebolts = t, this._propagationCount = /* @__PURE__ */ new Map(), t.forEach((i) => {
      i.onPropagationDone((n, s, A) => {
        let o = this._propagationCount.get(n.action) || 0;
        o++, this._propagationCount.set(n.action, o), o === t.length && (this.onLayerPropagationComplete({
          payload: n,
          propagationData: s,
          propagationInf: A
        }), this._propagationCount.set(n.action, 0));
      });
    });
  }
  createEntryExitSet(t) {
    const i = this._childFirebolts, n = t.action, s = i.map((A) => A.getEntryExitSet(n)).filter((A) => A);
    return this._entryExitSet[n] && this._entryExitSet[n].dispose(!1), this._entryExitSet[n] = new gb(s, {
      extraData: {
        data: this.context.facetFieldsMap(),
        schema: this.context.facetSchema()
      },
      name: `visual-unit-${t.action}`
    }), this._entryExitSet[n];
  }
  getSideEffectsForSourceAction({ action: t }) {
    const i = this.config()[t] || {};
    return Object.keys(i.sideEffects || {}).map((s) => ({
      name: s,
      ...i.sideEffects[s]
    })).filter((s) => s.enabled !== !1);
  }
  onLayerPropagationComplete({ payload: t, propagationData: i, propagationInf: n }) {
    const s = t.action;
    let A;
    t.resetAllInteractions ? (A = Z(this._lastInteraction.get(s), "sideEffects") || [], this._lastInteraction.delete(s)) : (A = mB(
      {
        action: t.action.split(":")[1],
        targetActions: t.targetActions,
        sourceCanvas: t.sourceInfo.canvasId
      },
      this
    ), this._lastInteraction.set(s, {
      behaviour: s,
      sideEffects: A
    })), (t.applyOnVisibleUnits ? this.isVisible() : !0) && (this.createEntryExitSet(t), this._payloads[s] = t, this.dispatchSideEffects(
      s,
      { ...t, sideEffects: A },
      n
    )), this.saveInteractionState({
      action: s,
      payload: { ...t, sideEffects: A },
      propagationInf: n
    }), this._onPropagationDone(t, i, n);
  }
  getEntryExitSet(t) {
    return this._entryExitSet[t];
  }
  getSourceInfo() {
    const { layers: t } = this.context.getSourceInfo();
    return Object.assign({}, this.context.getSourceInfo(), {
      targetLayer: t.find((i) => i.id() === this._targetLayer)
    });
  }
  layers() {
    return this.context.layers();
  }
  getPlotPointsFromIdentifiers(...t) {
    return this.context.getPlotPointsFromIdentifiers(...t);
  }
  getDrawingContext() {
    return this.context.getDrawingContext();
  }
  getPayloadFromEvent(t, i, n) {
    const s = this._actionPayloadMap[t];
    return s ? s(this, i, n) : KV(this, i, n);
  }
  getPropagationIdentifiers(t) {
    const n = this.context.layers().filter((r) => r.config().interactive !== !1).map((r) => r.firebolt()), s = {
      conditions: [],
      operator: "or"
    };
    let A = !0, o = !1, a = /* @__PURE__ */ new Set();
    return n.forEach((r) => {
      const l = r.getBehaviouralAction(t).propagationIdentifiers(), c = Z(
        r.context.config().interaction,
        t,
        "propagationFields"
      );
      if (l) {
        o = l.interpolated || o;
        let g = {};
        const h = r.context.data(), d = c || l.fields.filter((u) => h.isFieldPresent(u)).filter(
          (u) => c ? c.includes(u) : u !== pt.ROW_ID
        );
        if (l.interpolated)
          g = h.getFilterRangeQuery(
            l.identifiers
          ), a.add(...l.fields);
        else if (l.identifiers.length) {
          const u = this.context.facetFieldsMap();
          a.add(...l.fields), g = h.getQueryFromIds(
            l.identifiers,
            d,
            !0
          );
          const f = [];
          for (let C in u)
            f.push({
              value: u[C],
              operator: "eq",
              field: C
            });
          g = {
            conditions: [g, ...f],
            operator: "and"
          };
        }
        g.conditions && g.conditions.length && (s.conditions = [...s.conditions, g]);
      }
      A = A && l === null;
    }), A ? null : {
      query: s,
      interpolated: o,
      fields: [...a]
    };
  }
  isVisible() {
    const t = this.context.store(), i = this.context.metaInf(), { rowIndex: n, colIndex: s } = i, { rowStart: A, rowEnd: o, colStart: a, colEnd: r } = t.get(
      "virtualScrolling.viewport"
    );
    return Va(n, [A, o]) && Va(s, [a, r]);
  }
}
const WV = {
  [BB]: {
    behaviours: [Pl],
    touch: !1
  },
  [ba]: {
    behaviours: [QB]
  },
  [dl]: {
    behaviours: [GI],
    touch: !0
  },
  [lb]: {
    behaviours: [Pl],
    touch: !0
  },
  [Ol]: {
    behaviours: [GI],
    touch: !1
  },
  [qh]: {
    behaviours: [hb],
    touch: !1
  }
}, { BAR_LAYER: qV, TICK_LAYER: jV } = rM, { DISCRETE: zV } = ft, GM = be, $V = (e, t, i, n) => {
  let s;
  const A = e.config(), { classPrefix: o, gridLines: a, gridBands: r } = A, l = a.color, c = a.zeroLineColor, g = i === iA ? r.defClassName : a.defClassName, h = r[n].color, d = t[n][0], u = new Y_({ range: [1, 1], type: "ordinal" }), f = d.constructor.type() === GM;
  i === iA && f ? s = {
    [n]: `${n}value`,
    [`${n}0`]: `${n}value0`
  } : s = {
    [n]: f ? `${n}value` : `${n}dim`
  }, s.color = {
    value: (E) => {
      const { datum: B, datumIdx: m } = E, p = f && d.domain()[0] < 0;
      return i === iA ? h[m % 2] : p && B[n] === 0 ? c : l;
    }
  };
  const { color: C, shape: I } = e.axes();
  return {
    definition: {
      defClassName: `${g}-${n}`,
      className: A.className,
      name: n,
      calculateDomain: !1,
      individualClassName: (E, B) => {
        let m;
        return f && d.domain()[0] < 0 && E.y === 0 && i !== iA ? m = `${o}-axis-zero-line` : m = `${o}-grid-${i}-${n}-${B % 2}`, m;
      },
      [`pad${n.toUpperCase()}`]: i === iA ? 0 : void 0,
      encoding: s,
      interactive: !1,
      transform: {
        type: "identity"
      }
    },
    axes: {
      [n]: d,
      color: C[0],
      shape: I[0],
      size: u
    }
  };
}, XV = (e, t) => t.constructor.type() === GM && t.config().fieldSubtype != "binned" ? e : !1, ZV = (e, t, i) => ["x", "y"].map((n) => {
  const s = e.axes();
  return !s[n] || !s[n].length ? null : wt(
    t[n] && t[n].show,
    XV(t.show, s[n][0])
  ) ? $V(e, s, i, n) : null;
}).filter((n) => n !== null), E0 = (e, t, i) => i[e] ? e : t.CATEGORICAL, tW = (e, t) => {
  const i = t.fields(), { DataStore: n } = t._dependencies, { MEASURE: s, DIMENSION: A } = n.FieldType, o = n.FieldSubtype, { ...a } = o, r = {};
  return ["x", "y"].forEach((l) => {
    let c = e[l][0].getTickValues();
    const g = i[l][0].subtype(), h = i[l][0].as(), d = i[l][0].data()?._model._config, u = [
      {
        name: "yvalue",
        type: s
      },
      {
        name: "xvalue",
        type: s
      },
      {
        name: "yvalue0",
        type: s
      },
      {
        name: "xvalue0",
        type: s
      },
      {
        name: "xdim",
        type: A,
        subtype: E0(g, o, a)
      },
      {
        name: "ydim",
        type: A,
        subtype: E0(g, o, a)
      }
    ], f = Math.max(c.length);
    c = g === o.TEMPORAL && h !== zV ? c.map((B) => B.getTime()) : c;
    const C = {
      [`${l}value`]: [],
      [`${l}value0`]: [],
      [`${l}dim`]: []
    };
    for (let B = 0; B < f; B += 1)
      C[`${l}value`].push(c[B]), C[`${l}value0`].push(c[B + 1]), C[`${l}dim`].push(c[B]);
    const I = Object.keys(C), E = u.filter((B) => I.includes(B.name));
    r[l] = new n(
      {
        data: Object.values(C),
        schema: E
      },
      d
    );
  }), r;
}, eW = (e, t) => {
  const i = e.config(), n = e.metaInf(), s = e.store(), A = e._timeDiffs;
  [iA, MM].forEach((o) => {
    let a, r;
    o === iA ? (a = qV, r = i.gridBands) : (a = jV, r = i.gridLines);
    const l = ZV(e, r, o), c = `_${o}Selection`;
    t[c] || (e[c] = Cx(
      e[c],
      (g) => {
        const h = en.getLayerInstance({ mark: a }, null);
        h.dependencies(e._dependencies);
        const d = g.definition.name;
        return h.metaInf({
          unitRowIndex: n.rowIndex,
          unitColIndex: n.colIndex,
          namespace: `${n.namespace}${o}${d}`,
          parentNamespace: n.namespace
        }).store(s), h;
      },
      l,
      (g) => g.definition.name
    ), e[c].each((g, h) => {
      const d = h.definition, u = en.getSerializedConf(a, d), f = h.axes;
      g.config(u).dataProps({
        timeDiffs: A
      }).axes(f);
    }), e[`_${o}`] = e[c].getObjects());
  });
}, iW = (e, t) => {
  const i = e.axes(), n = e._gridLines, s = e._gridBands;
  if (n.length || s.length) {
    let A = t;
    t || (A = tW(i, e), t = A), [].concat(...s, ...n).forEach((o) => {
      o.data(o.axes().x ? A.x : A.y);
    });
  }
  return t;
}, nW = (e, t) => {
  const n = e.config().classPrefix, s = e._gridLines, A = e._gridBands, o = {
    width: e.width(),
    height: e.height()
  };
  if (e.renderer() !== "svg")
    return;
  const a = z(
    t,
    "g",
    [1],
    `${n}-${bM}`
  );
  s.length === 0 && A.length === 0 || [
    [s, `${n}-${SM}`],
    [A, `${n}-${_M}`]
  ].forEach((r) => {
    const [l, c] = r, g = z(
      a,
      "g",
      [1],
      `.${c}`
    ), h = `${c}-group`;
    z(g, "g", l, `.${h}`, {
      update: (d, u) => {
        u.dataProps({ timeDiffs: e._timeDiffs }).measurement(o).mount(d.node());
      }
    });
  });
}, { DISCRETE: sW } = ft, AW = (e, t) => {
  const i = t._layersMap, n = {};
  e.forEach((s, A) => {
    const o = wt(s.name, `${s.mark}-${A}`);
    n[o] = !0;
  });
  for (const s in i)
    s in n || (i[s].forEach((A) => A.remove()), delete i[s]);
}, oW = (e) => [
  {
    props: wM,
    listener: (t, i, n = {}) => {
      const s = e.fields();
      if (i && s) {
        AW(i, e);
        const A = e._queuedLayerDefs;
        let o = i;
        A.forEach((r) => {
          o = [...o, ...r(i)];
        }), e.addLayer(o, n), e.registerHookAggEvents();
        const a = e.layers().some((r) => r.hasPlotSpan());
        ["x", "y"].forEach((r) => {
          wt(Z(e.axes(), r), []).forEach((c) => {
            c.config({
              adjustRange: a
            });
          });
        });
      }
    }
  },
  {
    props: yM,
    listener: (t, i, n = {}) => {
      if (i) {
        e.transform();
        const s = e.axes(), A = {}, { timeDiffObj: o } = e.metaInf();
        Object.entries(e.fields()).forEach(([l, [c]]) => {
          if (c) {
            const h = cr(c) ? Math.min(...c.vars().map((d) => o[`${d}`])) : o[`${c}`];
            h != null && !Number.isNaN(h) && c.as() !== sW && (A[l] = h, s[l].forEach((d) => {
              d.minDiff && d.minDiff(h);
            }));
          }
        }), e._timeDiffsByField = o, e._timeDiffs = A, e.layers().forEach((l) => {
          l.dataProps({
            timeDiffs: e._timeDiffs
          });
        });
        const a = e.axes(), r = e.layers();
        r && a && (fM(a, r, e), n.skipAttachLayerData || uM(e, r, i), e._createGridLinesAndBands = e.createGridLinesAndBands(), e._dimensionMeasureMap = cM(
          e.layers(),
          e.data(),
          e.retinalFields()
        ));
      }
    }
  }
], aW = {
  [FM]: {
    onset: (e, t) => {
      const i = t[0].reduce((n, s, A) => (n[`${s}`] = t[1][A], n), {});
      e.facetFieldsMap(i);
    }
  },
  facetSchema: {},
  facetFieldsMap: {},
  [RM]: {},
  [kM]: {},
  [vM]: {},
  detailFields: {},
  axes: {
    defaultValue: {
      x: [],
      y: []
    }
  },
  fields: {
    defaultValue: {
      x: [],
      y: []
    },
    sanitization: (e, t) => et(
      {
        x: [],
        y: []
      },
      t
    )
  },
  metaInf: {},
  registry: {},
  parentContainerInf: {},
  valueParser: {
    defaultValue: (e) => e
  },
  coord: {},
  renderer: {
    defaultValue: "svg"
  }
}, rW = {
  classPrefix: xM,
  defClassName: "visual-unit",
  className: "",
  trackerClassName: "visual-unit-tracker",
  minOuterRadius: 10,
  gridLines: {
    defClassName: "axis-grid-lines",
    className: "",
    show: !0,
    color: "#efefef",
    zeroLineColor: "#b6b6b6"
  },
  gridBands: {
    defClassName: "axis-grid-bands",
    className: "",
    show: !1,
    y: {
      color: ["#fff", "#fbfbfb"]
    },
    x: {
      color: ["#fff", "#f9f9f9"]
    }
  },
  arcLayerClassName: "layer-arc",
  interaction: {
    tooltip: {
      mode: NM
    }
  },
  sideEffectClassName: "side-effect-container"
}, lW = (e) => (t) => {
  const i = ".muze-layer-text-grid-container .muze-layer-text-outer-cell";
  t.selectAll(i).on("pointerover", cW.bind(void 0, e)), t.selectAll(i).on("pointermove", gW.bind(void 0, e)), t.selectAll(i).on("pointerout", hW.bind(void 0, e));
}, cW = (e) => {
  NB(e, !0);
}, gW = (e) => {
  NB(e, !0);
}, hW = (e) => {
  NB(e, !1);
}, NB = (e, t) => {
  const i = bt(), n = X(i.currentTarget);
  e.triggerPhysicalAction(bh, {
    target: n,
    isActive: t
  });
}, dW = "VisualUnit";
class zh extends ci().with(Lo) {
  /**
   * Creates instance of visualization unit.
   *
   * @param {Object} registry  Component registry
   * @param {Object} dependencies  Dependencies required by visual unit.
   */
  constructor(t, i, n) {
    super(), this.eventManager(n), this._id = Zt(), this._listeners = {}, oW(this).forEach((s) => {
      this._listeners[s.props] = s.listener;
    }), this._dependencies = i, this._canvasHelpers = i.canvasActions, en.setLayerRegistry(t.layerRegistry), this._layersMap = {}, this._gridLinesSelection = null, this._gridBandsSelection = null, this._gridLines = [], this._gridBands = [], this._queuedLayerDefs = [], this._graphics = {}, ve(this, this.constructor.getterSetters()), this.registry(t), this.cachedData([]), this.emitSelfHooks(mt.INITIALIZED);
  }
  static formalName() {
    return dW;
  }
  static getState() {
    return [
      {
        domain: null
      }
    ];
  }
  static getterSetters() {
    return aW;
  }
  associatedHookComponentPaths() {
    return [[Ht.UNIT]];
  }
  store(...t) {
    return t.length ? (this._store = t[0], this) : this._store;
  }
  initializeInteractionModel() {
    const t = this.firebolt();
    t.addChildFirebolts(this.layers().map((i) => i.firebolt())), t.config(this.config().interaction);
  }
  createFireboltInstance() {
    const { interactions: t } = this.registry(), i = this.getFireboltCls();
    return this.firebolt(
      new i(
        this,
        {
          physical: Object.assign({}, t.physicalActions, {
            [bh]: lW
          }),
          behavioural: Object.assign({}, t.behaviours, {
            [Bo]: SB
          }),
          physicalBehaviouralMap: Object.assign(
            {},
            t.physicalBehaviouralMap,
            {
              [bh]: {
                behaviours: [Bo],
                touch: !1
              }
            }
          )
        },
        Object.assign({}, t.sideEffects),
        Object.assign({}, t.behaviourEffectMap)
      )
    ), this;
  }
  getFireboltCls() {
    return TM;
  }
  /**
   * Static helper for creates a unit instance
   *
   * @param {Object} [id] optional unique identifier for a unit; , id is calculated internally
   * @param {DataModel} data instance of datamodel
   * @param {Array.<Layer>} layers layer configuration
   * @param {Object} config configurtion for the visual unit
   * @return {VisualUnit} Instance of a unit
   */
  static create(...t) {
    return new this(...t);
  }
  /**
   * Returns the instance of firebolt associated with this visual unit. Firebolt dispatches the behavioural actions
   * when any physical action happens on the elements of visual unit.
   *
   * @public
   *
   * @return {Firebolt} Instance of firebolt.
   */
  firebolt(...t) {
    return t.length ? (this._firebolt = t[0], this) : this._firebolt;
  }
  /**
   * Returns the unique id of this visual unit.
   *
   * @public
   * @return {string} Unique identifier.
   */
  id() {
    return this._id;
  }
  lockModel() {
    return this.store().lockModel(), this;
  }
  unlockModel() {
    return this.store().unlockModel(), this;
  }
  lockLocalModel() {
    return this._locked = !0, this;
  }
  unlockLocalModel(t = {}) {
    return this._locked = !1, this.triggerAllListeners(t), this.initializeInteractionModel(), this;
  }
  timeDiffsByField(...t) {
    return t.length ? this : this._timeDiffsByField;
  }
  /**
   * Renders the visual unit. It creates the layout and renders the axes and layers.
   *
   * @return {VisualUnit} Instance of visual unit.
   */
  render(t, i = {}) {
    this.emitSelfHooks(mt.BEFORE_RENDERED, {
      virtualScrolling: {
        viewportRange: Z(i, "viewportRange") || null
      }
    }), t || (t = this.mount()), this.createRootContainers(t), pM(this), this.renderLayers(i), this.thinAndRenderTextPoints();
    const n = this._graphics.rootSvg.node(), { sideEffectClassName: s, classPrefix: A } = this.config();
    return QM(this), this._sideEffectGroup = BM(
      n,
      `${A}-${s}`
    ), this.firebolt().mapActionsAndBehaviour(), this;
  }
  thinAndRenderTextPoints() {
    const t = this.layers(), i = t.map((h) => {
      const d = h.textPointsInfo();
      return d ? { layer: h, pointsInfo: d } : null;
    }).filter((h) => !!h);
    let n = [];
    i.forEach(({ layer: h, pointsInfo: d }) => {
      const { location: u, points: f } = d, { filter: C } = h.config().encoding.text, I = h.data(), E = (B) => {
        if (B.isLabelThinned || !B.text)
          return !1;
        const m = { rowData: B.data, rowId: B.rowId };
        return C(m, { context: h, dm: I });
      };
      f.forEach((B) => {
        const m = B.text;
        if (!m)
          return;
        if (E(B)) {
          const [w, Q] = dn.getLabelPosition(B, u);
          m.originalPosition = {
            x: m.update.x,
            y: m.update.y
          }, m.update.x = w, m.update.y = Q, n.push(B);
        } else
          B.isLabelThinned = !0;
      });
    });
    const s = this.width(), A = this.height(), { smartLabel: o } = this._dependencies;
    n = dn.getUniquePositionedPoints(
      n,
      "text"
    ), t.map((h) => {
      const { encoding: d } = h.config();
      return d.text.removeCollision;
    }).every((h) => h) && (dn.thinVoronoi(
      s,
      A,
      o,
      n,
      "text"
    ), dn.thinFinally(
      s,
      A,
      o,
      n,
      "text",
      { thinOverflowingLabels: !0 }
    )), i.forEach(({ pointsInfo: h }) => {
      const { points: d } = h;
      d.forEach((u) => {
        const f = u.text;
        f && (f.originalPosition && (f.update.x = f.originalPosition.x, f.update.y = f.originalPosition.y, f.originalPosition = null), f.isVisible && (f.isVisible = !u.isLabelThinned));
      });
    });
    const { classPrefix: r } = this.config(), l = this._graphics.rootSvg, c = z(
      l,
      "g",
      [1],
      `${r}-layer-labels-group`
    );
    z(
      c,
      "g",
      i,
      `${r}-layer-labels`,
      {},
      (h) => h.layer.id()
    ).each(function(h) {
      const d = X(this), { layer: u, pointsInfo: f } = h;
      d.classed(
        `${r}-layer-${u.constructor.formalName()}-labels`,
        !0
      ), u.onAnimationEnd().then(() => {
        u.renderTextPoints(d, f);
      });
    });
  }
  emitAllRenderHooksWhenRenderSkipped(t) {
    this.emitSelfHooks(mt.BEFORE_RENDERED, {
      virtualScrolling: {
        viewportRange: Z(t, "viewportRange") || null
      }
    }), this.layers().forEach(
      (i) => i.emitAllRenderHooksWhenRenderSkipped(t)
    );
  }
  registerHookAggEvents() {
    const t = this.layers().reduce((n, s) => {
      const { mark: A } = s.config();
      return n.has(A) ? n.get(A).push(s) : n.set(A, [s]), n;
    }, /* @__PURE__ */ new Map());
    [
      {
        componentPath: [Ht.LAYER],
        target: this.layers()
      },
      ...[...t.keys()].map((n) => ({
        componentPath: [Ht.LAYER, n],
        target: t.get(n)
      }))
    ].forEach((n) => {
      [
        mt.BEFORE_RENDERED,
        mt.AFTER_RENDERED,
        mt.ANIMATION_END
      ].forEach((s) => {
        const A = new $e({
          componentPath: n.componentPath,
          modifier: ze.EACH,
          hookName: s
        });
        n.target.forEach((o) => {
          if (o) {
            const a = o.eventManager().listeners(A).find(
              (r) => Z(r, "meta", "tag") === tg
            );
            a && o.eventManager().off(A, a.listener);
          }
        }), xY(
          new $e({
            componentPath: n.componentPath,
            modifier: ze.EACH,
            hookName: s
          }),
          n.target,
          (o) => {
            const { rowStart: a, rowEnd: r, colStart: l, colEnd: c } = this.store().get(
              `${re}.viewport`
            );
            this.emitEvent({
              name: new $e({
                componentPath: [
                  Ht.UNIT,
                  ...n.componentPath
                ],
                modifier: ze.ALL,
                hookName: s
              }),
              target: n.target,
              data: { aggEventObjects: o },
              virtualScrolling: {
                viewportRange: {
                  rowRange: [a, r],
                  colRange: [l, c]
                }
              }
            });
          },
          { tag: tg }
        );
      });
    }), [
      mt.AFTER_RENDERED,
      mt.ANIMATION_END
    ].forEach((n) => {
      const s = new $e({
        componentPath: [
          Ht.UNIT,
          Ht.LAYER
        ],
        modifier: ze.ALL,
        hookName: n
      }), A = this.eventManager().listeners(s).find(
        (o) => Z(o, "meta", "tag") === tg
      );
      A && this.eventManager().off(s, A.listener), this.eventManager().on(
        s,
        () => {
          const { rowStart: o, rowEnd: a, colStart: r, colEnd: l } = this.store().get(
            `${re}.viewport`
          );
          this.emitSelfHooks(n, {
            virtualScrolling: {
              viewportRange: {
                rowRange: [o, a],
                colRange: [r, l]
              }
            }
          });
        },
        { tag: tg },
        {
          executePostPropagation: !0
        }
      );
    });
  }
  createRootContainers(t) {
    const i = this.config(), { defClassName: n } = i, s = ms(
      n,
      this.id(),
      i.classPrefix
    ), A = this.renderer(), o = this.width(), a = this.height();
    this._container = X(t);
    const r = X(t).style(
      "position",
      "relative"
    ), l = A === "html" ? "div" : "svg", c = this._graphics.rootSvg && this._graphics.rootSvg.node();
    (l === "svg" && c instanceof HTMLElement || l === "div" && c instanceof SVGElement) && this._graphics.rootSvg.remove(), this._graphics.rootSvg = z(
      r,
      l,
      [1],
      s[1]
    ).style("left", "0px").style("top", "0px").style("position", "absolute").style("width", "inherit").style("height", "inherit");
    const g = this._graphics.rootSvg.node();
    return hA(g, {
      width: o,
      height: a,
      class: s.join(" ")
    }), this;
  }
  renderLayers(t) {
    const i = this.width(), n = this.height(), s = this._graphics.rootSvg.node();
    return this._createGridLinesAndBands(), nW(this, s), EM(
      this,
      s,
      this.layers(),
      {
        width: i,
        height: n
      },
      t
    ), this;
  }
  /**
   * Caches all the datamodels in an array from the next `data()` call on visual unit until `clearCaching()` or
   * `resetData()` is called on it.
   *
   * @public
   * @return {VisualUnit} Instance of visual unit.
   */
  enableCaching() {
    return this._cache = !0, this;
  }
  /**
   * Clears all the previous cached data.
   *
   * @public
   * @segment VisualUnit
   * @return {VisualUnit} Instance of visual unit.
   */
  clearCaching() {
    return this._cache = !1, this.cachedData([this.cachedData()[0]]), this;
  }
  clearCachedLayerData() {
    return (this.layers() || []).forEach((i) => {
      i._cachedData.forEach((n) => {
        n.dispose();
      }), i._cachedData.length = 0;
    }), this;
  }
  /**
   * Returns the drawing information from visual unit.Drawing context contains the dimensions of unit and the svg
   * container of the visual unit.
   *
   * @public
   *
   * @return {Object} Drawing information.
   *      ```
   *          {
   *              htmlContainer: // Html container of svg container of the visual unit
   *              svgContainer: // Root svg container
   *              width: // Width of the visual unit
   *              height: // Height of the visual unit
   *              sideEffectGroup: // Svg group for drawing side effect elements.
   *              parentContainer: // Parent html container of the visual unit.
   *              xOffset: // x offset space from the starting x position of the container,
   *              yOffset: // y offset space from the starting y position of the container
   *          }
   *      ```
   */
  getDrawingContext() {
    const t = this._graphics.rootSvg && this._graphics.rootSvg.node(), i = this.width(), n = this.height(), { el: s, dimensions: A } = this.parentContainerInf();
    return {
      htmlContainer: this.mount(),
      svgContainer: t,
      width: i,
      height: n,
      sideEffectGroup: this._sideEffectGroup,
      parentContainer: s,
      parentContainerDimensions: A,
      xOffset: 0,
      yOffset: 0
    };
  }
  /**
   * Returns the serialized configuration of visual unit.
   *
   * @return {Object} serialized configuration
   */
  serialize() {
    return {
      layers: this.layers().map((t) => t.serialize()),
      config: this.config(),
      axes: this.axes().map((t) => t.serialize())
    };
  }
  mount(...t) {
    return t.length ? (this._mount = t[0], this) : this._mount;
  }
  /**
   * Adds a new layer to the visual unit. It takes a layer definition and creates layer instances from them. It does
   * not render the layers. It returns the layer instances in an array. If the layer definition is a composite layer,
   * then multiple layer instances will be returned in the array.
   *
   * To add a layer in the unit,
   * ```
   *      unit.addLayer({
   *          name: 'bullet',
   *          mark: 'bar',
   *          encoding: {
   *              x: 'Year',
   *              y: 'Acceleration',
   *              color: 'Origin'
   *          }
   *      });
   * ```
   * @public
   * @param {Object} layerDef Definition of new layer.
   *
   * @return {Array} Array of layer instances.
   */
  addLayer(t, i = {}) {
    if (t instanceof Function)
      return this._queuedLayerDefs.push(t), this;
    const n = this.renderer(), s = PI(Bn(t)), A = this._layersMap, o = {
      layers: {},
      components: {
        unit: this
      }
    };
    let a = 0;
    const r = s.sort((g, h) => g.order - h.order).reduce((g, h) => {
      const d = h.def, u = d.name, f = Bn(d);
      f.forEach((E) => {
        E.order = h.order + a;
      }), a += f.length;
      const C = gM(
        this,
        d,
        A[u],
        // namespaces,
        n,
        i
      );
      o.layers = Object.assign(o.layers, C);
      const I = Object.values(C);
      return g = g.concat(...I), A[u] = I, g;
    }, []);
    o.unit = this;
    const l = {}, c = [].concat(...Object.values(this._layersMap));
    return c.forEach((g) => {
      const h = g.alias();
      o.layers[h] = g, l[h] = [];
    }), r.forEach((g) => {
      const h = dM(g, o);
      l[g.alias()] = h;
    }), this._layerDepOrder = l, this.layers(c), r;
  }
  remove() {
    const t = this.layers();
    return X(this.mount()).remove(), this.firebolt().remove(), this.firebolt().dispose(), this._firebolt = null, this.data().dispose(), this._data = null, [...t, ...this._gridLines, ...this._gridBands].forEach(
      (i) => i.remove()
    ), this._layers.length = 0, this._gridLines.length = 0, this._gridBands.length = 0, this._fields = null, this;
  }
  /**
   * Resets the data of visual unit to original data model. It also clears the cached data.
   *
   * @public
   * @segment VisualUnit
   * @return {VisualUnit} Instance of visual unit.
   */
  resetData() {
    return this.data(this.cachedData()[0]), this;
  }
  getSourceInfo() {
    return {
      dimensionMeasureMap: this._dimensionMeasureMap,
      fields: this.fields(),
      data: this.data(),
      axes: this.axes(),
      retinalFields: this.retinalFields(),
      layers: this.layers(),
      timeDiffs: this.timeDiffsByField(),
      useUTC: this.config().useUTC
    };
  }
  dataDomain(...t) {
    const { namespace: i } = this.metaInf(), n = this.store(), s = `${Ld}.${DM}`;
    if (t.length) {
      const o = t[0];
      n.commit(s, (a) => Object.assign(a || {}, {
        [i]: o
      }));
    }
    const A = n.get(s);
    return Z(A, i);
  }
  getDefaultTargetContainer() {
    const { classPrefix: t, defClassName: i, sideEffectClassName: n } = this.config();
    return this._graphics.tracker ? [
      `.${t}-tracker-group`,
      `.${t}-${n}`
    ] : [`.${t}-${i}`];
  }
  /**
   * Returns an array of layer instances which matches the supplied mark type.
   *
   * @public
   *
   * @param {string} type Mark type of layer.
   *
   * @return {Array} Array of layer instances.
   */
  getLayersByType(t) {
    return JI(this.layers(), "type", t);
  }
  /**
   * Returns the layer instance which matches the supplied layer name. If no layer is found, then it returns
   * undefined.
   *
   * @public
   * @param {string} name Name of layer.
   *
   * @return {VisualUnit} Layer instance.
   */
  getLayerByName(t) {
    return JI(this.layers(), "name", t)[0];
  }
  getLayerById(t) {
    return this.layers().find((i) => i.id() === t);
  }
  /**
   * Returns the point located nearest to the supplied x and y position. It returns the unique identifiers of the
   * point. This function also accepts an additional configuration `getAllPoints` inside `config` object in the third
   * argument which if set to true, then it returns the identifiers of all the points which falls on the nearest
   * x value or y value if any one of the field is a dimension. Additionally, a target property is also returned
   * which contains the identifier of the nearest point. If no nearest point is found, then it returns identifier
   * as null.
   *
   * @public
   *
   * @param {number} x X Position of the point from where nearest point is to be found.
   * @param {number} y Y Position of the point from where nearest point is to be found.
   * @param {Object} config Additional configuration options.
   * @param {boolean} config.getAllPoints If true, then returns all the points nearest to the x value or y value if
   * it is dimension.
   * @param {Object} config.data Data associated with the nearest point.
   * @return {Object} Nearest point information
   * ```
   *      {
   *          id: [['Origin'], ['USA'], ['Japan']], // Identifiers of all the points closest to the x value.
   *          target: [['Origin'], ['Japan']] // Identifier of the nearest point.
   *      }
   * ```
   */
  getNearestPoint(t, i, n = { includeFromAllLayers: !1 }) {
    const s = wt(n.getAllPoints, !1), A = wt(n.detectEmptyArea, !1);
    let { value: o, multipleDimFields: a } = YI(this, {
      x: t,
      y: i
    }), r = this.getMarkInfFromLayers(t, i, {
      ...n,
      dimValue: o
    });
    if (o)
      if (r) {
        const l = o[0][0], c = r?.id[1][r.id[0].indexOf(l)], g = o[1].length;
        let h = 0;
        for (h; h < g; h++)
          if (o[1][h] === c) {
            o[1] = [c];
            break;
          }
        h === g && c !== null && c !== void 0 && (o[1] = [c]);
      } else
        o[1] = [o[1][0]];
    return this.getPointsDataFromMarkInf(r, {
      getAllPoints: s,
      detectEmptyArea: A,
      multipleDimFields: a,
      dimValue: o
    });
  }
  getNearestPointsFromAllLayers(t, i, n) {
    const s = wt(n.getAllPoints, !1), A = wt(n.detectEmptyArea, !1), { value: o, multipleDimFields: a } = YI(this, {
      x: t,
      y: i
    }), r = this.getMarkInfFromAllLayers(t, i, {
      ...n,
      dimValue: o
    });
    return r.length || r.push(null), r.map((l) => this.getPointsDataFromMarkInf(l, {
      getAllPoints: s,
      detectEmptyArea: A,
      multipleDimFields: a,
      dimValue: o
    }));
  }
  getPointsDataFromMarkInf(t, i) {
    const { getAllPoints: n, dimValue: s, multipleDimFields: A, detectEmptyArea: o } = i;
    t || (t = {
      id: null,
      target: null,
      layerId: null
    });
    const a = t.layerId;
    if (A) {
      const g = Array.isArray(t.id) && Array.isArray(t.id[0]) ? t.id[0][0] : this.layers().length ? this.layers()[0].encodingFieldsInf().xField : void 0;
      if (g) {
        const h = s[0].findIndex((d) => d === g);
        s[0] = [s[0][h]], s[1] = [s[1][h]];
      }
    }
    const r = t.point && t.point.data ? Object.keys(t.point.data).reduce(
      (g, h) => [
        [...g[0], h],
        [...g[1], t.point.data[h]]
      ],
      [[], []]
    ) : t.id, l = t.id;
    if (!n)
      return { id: t.id, target: l, targetData: r, layerId: a };
    const c = Object.assign({}, t);
    if (o && s)
      c.id = s, t.id && t.id[0].length === 1 && (t.id[1][0] = s[1][0]), c.target = l;
    else if (t.id) {
      if (s) {
        const g = s[0][0], h = t.id[1][t.id[0].indexOf(g)];
        c.id = h === s[1][0] ? s : t.id;
      } else
        c.id = t.id;
      c.target = l;
    } else
      c.id = c.target = null;
    return c.layerId = a, c.targetData = r, c;
  }
  getMarkInfFromLayers(t, i, n = {}) {
    const s = this.layers();
    let A = null;
    for (let o = s.length - 1; o >= 0; o--) {
      const a = s[o];
      if (a.config().interactive !== !1 && (A = a.getNearestPoint(t, i, n)), A)
        return A;
    }
    return A;
  }
  getMarkInfFromAllLayers(t, i, n = {}) {
    const s = this.layers(), A = [];
    let o = !1, a = {
      minX: null,
      minY: null,
      maxX: null,
      maxY: null
    };
    for (let r = s.length - 1; r >= 0; r--) {
      const l = s[r];
      if (l.config().interactive !== !1)
        if (l.includeDataFromAllLayersInTooltip()) {
          const g = o ? l.getNearestPointInRange(a) : l.getNearestPoint(t, i, n);
          if (g) {
            const h = l.isVertical();
            A.push({ ...g, isVertical: h });
            const { point: d } = g;
            let { X: u, Y: f, X0: C, Y0: I } = {
              X: d.update.x + d.update.width,
              Y: d.update.y + d.update.height,
              X0: d.update.x,
              Y0: d.update.y
            };
            a = {
              minX: Number.isFinite(a.minX) ? Math.min(a.minX, C) : C,
              minY: Number.isFinite(a.minY) ? Math.min(a.minY, I) : I,
              maxX: Number.isFinite(a.maxX) ? Math.min(a.maxX, u) : u,
              maxY: Number.isFinite(a.maxY) ? Math.min(a.maxY, f) : f
            }, o = !0;
          }
        } else {
          const g = l.getNearestPoint(t, i, n);
          if (g)
            return [g];
        }
    }
    return A;
  }
  /**
   * Get the information of all the marks such as x, y position and size from supplied identifiers. It
   * returns an array of points whose data matches the given identifiers.
   *
   * @public
   *
   * @param {Array|Object} identifiers Field names and their corresponding values.
   * ```
   * identifiers can be given in an array of array,
   *      ['Origin', 'Name'], // Names of the fields supplied in first array
   *      ['USA', 'ford'], // Data values of each field supplied in rest of the arrays.
   *      ['Japan', 'ford']
   * or in an object,
   *      {
   *          Origin: ['USA']
   *      }
   * ```
   * @param {Object} config Optional configurations which decides which information of the mark will
   * be retrieved.
   * @param {boolean} [config.getAllAttrs = false] If true, then returns all the information of each mark.
   * @param {boolean} [config.getBBox = false] If true, then returns the bounding box of each mark.
   *
   * @return {Array} Array of objects containing the information of each point.
   * ```
   * By default, the method returns the array of points in this structure,
   *      [
   *          {
   *              x: 20,
   *              y: 100,
   *              width: 200,
   *              height: 100
   *          }
   *      ]
   * If 'config.getAllAttrs' is true, then it returns all the information of each mark,
   *      [
   *      // Positions of mark on initial state of transition.
   *          enter: {
   *              x: 0,
   *              y: 0
   *          },
   *          // Final positions of the mark
   *          update: {
   *              x: 20,
   *              y: 10
   *          },
   *          style: // css styles of each mark
   *          source: [200, 'USA'] // Row information of each mark
   *          id: 20 // Row id of each mark
   *      ]
   * ```
   */
  getPlotPointsFromIdentifiers(t, i = {}, n) {
    let s = [];
    if (t === null)
      return [];
    const A = this.layers(), o = A.find((r) => r.id() === n), a = o ? [o] : A;
    for (let r = 0, l = a.length; r < l; r++) {
      const c = a[r];
      c.config().interactive !== !1 && (s = [
        ...s,
        ...c.getPointsFromIdentifiers(t, i)
      ]);
    }
    return s;
  }
  /**
   * Removes the layer instance which matches the supplied layer name.
   *
   * @public
   * @param {string} name Name of layer
   *
   * @return {VisualUnit} Instance of visual unit.
   */
  removeLayerByName(t) {
    return KI("name", t), this;
  }
  /**
   * Removes all the layer instances which matches the supplied mark type.
   *
   * @public
   * @param {string} type Mark type of layer.
   *
   * @return {VisualUnit} Instance of visual unit.
   */
  removeLayersByType(t) {
    return KI("type", t), this;
  }
  calculateDomainFromData() {
    return ua(this.layers(), this.fields());
  }
  getRangeFromIdentifiers({ criteria: t, fields: i }) {
    return i.reduce((n, s) => (n[s] = t[s], n), {});
  }
  getRangeFromPositions({ startPos: t, endPos: i }, n = {}) {
    const { x: s, y: A } = this.fields(), o = this.axes(), a = s[0], r = A[0], l = this.data().getDimensions(), { brush: c } = n;
    if (c === "x") {
      let g = o.x[0].invertExtent(t.x, i.x).sort((u, f) => u - f);
      g = a.subtype() === "temporal" && a.as() !== De ? g.map((u) => u.getTime()) : g;
      const h = a.getMembers(), d = {};
      return h.forEach((u) => {
        d[u] = g;
      }), { range: d };
    } else if (c === "y") {
      let g = o.y[0].invertExtent(t.y, i.y).sort((u, f) => u - f);
      g = r.subtype() === "temporal" && r.as() !== De ? g.map((u) => u.getTime()) : g;
      const h = r.getMembers(), d = {};
      return h.forEach((u) => {
        d[u] = g;
      }), { range: d };
    } else if (a.isContinuous() && r.isContinuous()) {
      const g = {
        x: o.x[0].invertExtent(t.x, i.x).sort((d, u) => d - u),
        y: o.y[0].invertExtent(t.y, i.y).sort((d, u) => d - u)
      }, h = {};
      if (`${a}` == `${r}`) {
        const d = g.x, u = g.y, f = d[0] > u[0] ? u : d, C = f === u ? d : u;
        f[1] < C[0] ? h[a] = [] : h[a] = [C[0], f[1] < C[1] ? f[1] : C[1]];
      } else
        a.getMembers().forEach((f) => {
          h[f] = g.x;
        }), r.getMembers().forEach((f) => {
          h[f] = g.y;
        });
      return { range: h };
    } else if (a.isDiscrete() || r.isDiscrete()) {
      const g = this.getPointsWithinRange({
        minX: t.x,
        minY: t.y,
        maxX: i.x,
        maxY: i.y
      }), h = [[]];
      return l.forEach((d) => {
        h[0].push(`${d}`);
      }), g.forEach((d) => {
        const u = d.data, f = [];
        l.forEach((C) => {
          f.push(u[C]);
        }), h.push(f);
      }), {
        dimensions: h
      };
    }
    return null;
  }
  getPointsWithinRange(t) {
    return this.layers().filter(
      (n) => n.config().interactive !== !1
    ).map((n) => n.getPointsWithinRange(t)).flat();
  }
  isSortedDomain() {
    return this.layers().some((t) => t.isSortedDomain());
  }
  getRetinalFieldsDomain() {
    const t = this.layers().map(
      (n) => n.getRetinalFieldsDomain()
    );
    return Eh(t);
  }
  calculateExtendDomainDiffs() {
    const t = {
      topAxis: [],
      bottomAxis: [],
      leftAxis: [],
      rightAxis: []
    };
    let i, n;
    if (this.layers().forEach((s) => {
      const A = s.axes();
      if (A.x && A.y) {
        const o = A.x.config().alignZeroLine, a = A.y.config().alignZeroLine, r = A.x.config().orientation, l = A.y.config().orientation, { x: c, y: g } = s.calculateExtendDomainDiffs();
        i = i == null ? o || !1 : i && o, n = n == null ? a || !1 : n && a, r === "top" ? t.topAxis.push(c) : t.bottomAxis.push(c), l === "left" ? t.leftAxis.push(g) : t.rightAxis.push(g);
      }
    }), i || n) {
      const s = {};
      return i ? (s.topAxis = rn(
        t.topAxis.concat(t.bottomAxis)
      ), s.bottomAxis = s.topAxis.slice()) : (s.topAxis = rn(t.topAxis), s.bottomAxis = rn(t.bottomAxis)), n ? (s.leftAxis = rn(
        t.leftAxis.concat(t.rightAxis)
      ), s.rightAxis = s.leftAxis.slice()) : (s.leftAxis = rn(t.leftAxis), s.rightAxis = rn(t.rightAxis)), s;
    } else
      return {
        topAxis: rn(t.topAxis),
        bottomAxis: rn(t.bottomAxis),
        leftAxis: rn(t.leftAxis),
        rightAxis: rn(t.rightAxis)
      };
  }
  setCustomLayerData(t) {
    this._customLayerDataModels = t;
  }
  clearCustomLayerData() {
    return this._customLayerDataModels = null, this;
  }
  layers(...t) {
    return t.length ? (this._layers = t[0], this) : this._layers;
  }
  transform(...t) {
    return t.length ? (this._transform = t[0], this) : this._transform;
  }
  layerDef(...t) {
    return t.length ? (this._layerDef = PI(t[0]), this.triggerListener("layerDef", this._prevLayerDef, this._layerDef), this) : this._layerDef;
  }
  width(...t) {
    return t.length ? (this._width = t[0], this) : this._width;
  }
  height(...t) {
    return t.length ? (this._height = t[0], this) : this._height;
  }
  setSize(t, i) {
    this.width(t), this.height(i), this._createGridLinesAndBands = this.createGridLinesAndBands();
  }
  transformedData(...t) {
    return t.length ? (this._transformedData = t[0], this) : this._transformedData;
  }
  config(...t) {
    if (t.length) {
      const i = this._config, n = t[0], s = et(
        i || et({}, rW),
        n
      );
      return this.renderer() === "html" && (s.gridLines.show = !1, s.gridBands.show = !1), this._prevconfig = i, this._config = s, this.triggerListener("config", i, this._config), this;
    }
    return this._config;
  }
  data(...t) {
    if (t.length) {
      let i = this._data;
      this._data = t[0];
      const n = this._data;
      if (this._prevdata = i, this._cache) {
        const s = this.cachedData();
        this.cachedData([...s, n]);
      } else {
        const s = this.cachedData()[0];
        s && s.unsubscribe("propagation"), this.cachedData([n]);
      }
      return this.triggerListener("data", this._prevdata, this._data), this;
    }
    return this._data;
  }
  triggerListener(t, i, n) {
    this._locked || this._listeners[t](i, n);
  }
  triggerAllListeners(t) {
    const i = this._listeners;
    for (let n in i)
      i[n](this[`_prev${n}`], this[`_${n}`], t);
  }
  createGridLinesAndBands() {
    let t = null, i = null, n = null;
    return () => {
      eW(this, {
        gridLinesSelection: t,
        gridBandsSelection: i
      }), n = iW(this, n), t = this._gridLinesSelection, i = this._gridBandsSelection;
    };
  }
  layerDataModels(...t) {
    return t.length ? (this._layerDataModels = t[0], this) : this._layerDataModels;
  }
  layerDomains(...t) {
    return t.length ? (this._layerDomains = t[0], this) : this._layerDomains;
  }
  isCanvasDisposed() {
    return this._canvasHelpers.isDisposed();
  }
}
class FB {
  /**
   *
   *
   * @memberof Variable
   */
  type() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   *
   *
   * @memberof Variable
   */
  toString() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  varType() {
    return null;
  }
}
class $h extends FB {
  /**
   * Creates an instance of ComposeVars.
   *
   * @param {Array} vars Array of SimpleVars.
   */
  constructor(...t) {
    super(), this.vars(t);
  }
  varType() {
    return RC;
  }
  vars(...t) {
    return t.length ? (this._vars = t[0], this) : this._vars;
  }
  as(t) {
    return t ? (this.vars().forEach((i) => i.as(t)), this) : this.vars()[0].as();
  }
  data(...t) {
    return t.length ? (this.vars().forEach((i) => i.data(t[0])), this._data = t[0], this) : this._data;
  }
  /**
   * Get all the field names from composed variable instance.
   *
   * @public
   * @return {Array} Array of field names.
   */
  getMembers() {
    return this.vars().map((i) => i.getMembers()[0]);
  }
  /**
   * Type of field associated with this composed variable.
   *
   * @return {string} Type of variable (Measure/Dimension).
   */
  type() {
    return this.vars()[0].type();
  }
  toString() {
    return this.vars().map((t) => t.toString()).join(",");
  }
  /**
   * Returns the number formatter function of the variable.
   *
   * @return {Function} Number formatter function of the variable.
   */
  numberFormat() {
    return this.vars()[0].numberFormat();
  }
  format(t) {
    return this.vars()[0].format(t);
  }
  getSchemaDef() {
    return this.vars()[0].getSchemaDef();
  }
  /**
   * Returns the subtype of the fields associated with this variable instance.
   *
   * @public
   * @return {string} Subtype of the variable.
   */
  subtype() {
    return this.vars()[0].subtype();
  }
  /**
   * Returns the consecutive minimum difference of the field values.
   *
   * @public
   * @return {number} Minimum consecutive difference.
   */
  getMinDiff() {
    return this.vars()[0].getMinDiff();
  }
  /**
   * Returns the display name of the fields.
   *
   * @return {string} returns the display name.
   */
  displayName() {
    return this.vars().map((t) => t.displayName()).join(",");
  }
  isContinuous() {
    return this.as() === "continuous";
  }
  isDiscrete() {
    return this.as() === "discrete";
  }
  has(t) {
    return this.getMembers().find((i) => `${i}` === t);
  }
}
class RB extends FB {
  /**
   * Creates an instance of simple variable instance.
   *
   * @param {string} name Field name.
   * @param {as} name Field will used as discrete or continuous.
   */
  constructor(t, i) {
    super(), this.oneVar(t), this.as(i);
  }
  varType() {
    return Ww;
  }
  /**
   * Gets the field name associated with this variable instance.
   *
   * @public
   * @return {string} Name of the field.
   */
  oneVar(...t) {
    return t.length ? (this._oneVar = t[0], this) : this._oneVar;
  }
  as(t) {
    return t ? (this._as = t, this) : this._as;
  }
  data(...t) {
    return t.length ? (this._data = t[0], this) : this._data;
  }
  toString() {
    return this._oneVarString || (this._oneVarString = this.oneVar()), this._oneVarString;
  }
  /**
   * Gets the number formatter function of this variable.
   *
   * @public
   * @return {Function} Number formatter function.
   */
  numberFormat() {
    return this.type() === "measure" ? this.data().getField(this.oneVar()).schema().format : (t) => t;
  }
  format(t) {
    const { FieldSubtype: i, DateTimeFormatter: n } = K;
    if (t && this.subtype() === i.TEMPORAL) {
      const s = this.data().getField(this.oneVar()).schema().format;
      if (typeof s == "function")
        t = t.map((A) => s(A));
      else {
        const A = new n(s);
        t = t.map((o) => A.getNativeDate(o));
      }
    }
    return t;
  }
  /**
   * Returns a formatter function which transforms the input value to its original form.
   *
   * @public
   * @return {Function} Returns raw formatter function.
   */
  rawFormat() {
    const { FieldSubtype: t } = K;
    if (this.subtype() === t.TEMPORAL) {
      const i = this.data().getField(this.oneVar()).schema().format;
      return (n) => To(n, i);
    }
    return (i) => i;
  }
  /**
   * Return the field names associated with this variable instance.
   *
   * @public
   * @return {Array} Array of fields.
   */
  getMembers() {
    return [this.oneVar()];
  }
  /**
   * Returns the type of the variable. Whether it is measure or dimension.
   *
   * @public
   * @return {string} Type of variable.
   */
  type() {
    const t = this.data().getField(this.oneVar());
    if (!t)
      throw new Gn(`Field '${this.oneVar()}' not found in DataModel`, {
        cause: "Trying to read the type of a field that does not exist in DataModel schema"
      });
    return t.type();
  }
  /**
   * Returns the subtype of the variable. Subtype can be categorical or temporal. If no subtype is found, then it
   * returns the type of the variable.
   *
   * @public
   * @return {string} Subtype of variable.
   */
  subtype() {
    const t = this.data().getField(this.oneVar());
    return t.subtype() || t.type();
  }
  /**
   * Returns the minimum consecutive difference between the data values of this variable.
   *
   * @return {number} Minimum consecutive difference.
   */
  getMinDiff() {
    return this.data().getFieldspace().fieldsObj()[this.oneVar()].minimumConsecutiveDifference();
  }
  /**
   * Returns true if two variable instances are same.If both variable has the same field names, they are equal.
   *
   * @return {Boolean} Whether two variable instances are same.
   */
  equals(t) {
    return this.oneVar() === t.oneVar();
  }
  /**
   * Returns the display name of the field.
   *
   * @return {string} returns the display name.
   */
  displayName() {
    return dc(this.data(), this.oneVar());
  }
  /**
   * Returns the schema defination of the field.
   *
   * @return {Object} schema def
   */
  getSchemaDef() {
    return this.data().getField(this.oneVar()).schema();
  }
  isContinuous() {
    return this.as() === "continuous";
  }
  isDiscrete() {
    return this.as() === "discrete";
  }
  has(t) {
    return this.getMembers().find((i) => `${i}` === t);
  }
  getBinSize() {
    return this.subtype() === ot.BINNED ? this.data().getField(this.oneVar()).getBinSize() : null;
  }
}
class LM extends RB {
  type() {
    return "measure";
  }
  subtype() {
    return "continuous";
  }
  varType() {
    return qw;
  }
}
const zn = (e) => e instanceof LM, { SCALES: kB } = Zw, Xh = (e) => e.filter((t) => t.as() === kB.DISCRETE), Zh = (e) => e.filter((t) => t.as() === kB.CONTINUOUS), UM = (e, t) => {
  const i = [], n = [], s = Math.max(e.length, t.length);
  for (let A = 0; A < s; A++) {
    let o = e[A], a = t[A];
    zn(o) && zn(a) || (o && i.push(o), a && n.push(a));
  }
  return [i, n];
}, uW = (e) => {
  const t = e[0], i = e[1];
  let n = Zh(t), s = Zh(i);
  const A = Xh(t), o = Xh(i);
  [n, s] = UM(
    n,
    s
  );
  const a = [];
  return n.length + s.length ? (a[0] = [...A, ...o, ...n], a[1] = [...s]) : (a[0] = A, a[1] = o), a;
}, fW = (e) => {
  const t = e[0], i = e[1];
  let n = Zh(t), s = Zh(i);
  const A = Xh(t), o = Xh(i), a = [];
  return [n, s] = UM(
    n,
    s
  ), n.length + s.length ? (a[0] = [...A, ...o, ...n], a[1] = [...s]) : (a[0] = [
    ...A,
    ...o.slice(0, o.length - 1)
  ], a[1] = [
    ...o.slice(
      o.length - 1,
      o.length
    )
  ]), a;
}, IW = (e, t) => {
  const i = [];
  return Array.isArray(e[0]) ? (i[0] = e[0] || [], i[1] = e[1] || []) : (i[0] = t === "column" ? [] : e, i[1] = t === "column" ? e : []), i;
}, B0 = (e, t) => {
  const i = [];
  let n;
  return e.forEach((s) => {
    if (n = s && (s.field || s), n === null)
      i.push(new LM(null, kB.CONTINUOUS));
    else if (n instanceof $h) {
      const A = bi(
        t.model.getField(n.vars()[0].oneVar())
      );
      n.as(A), n.data(t), i.push(n);
    } else {
      let A;
      typeof s == "string" ? (n = s, A = bi(t.model.getField(s))) : (n = s.field, A = typeof s.as == "string" ? s.as : bi(t.model.getField(s.field))), i.push(new RB(n, A).data(t));
    }
  }), i;
}, m0 = (e, t, i) => {
  const n = IW(t, e), s = [
    B0(n[0], i),
    B0(n[1], i)
  ];
  return e === "row" ? uW(s) : fW(s);
}, HM = (e, { rows: t, columns: i }) => ({
  rows: m0("row", t, e),
  columns: m0("column", i, e)
}), CW = (e, t) => {
  for (let i = 0; i < e.length; i++)
    i !== 0 ? e[i].config({
      externalClassname: [`${Vi}`]
    }) : e[i].config({
      externalClassname: [`${eA}-${Je}`, `${Vi}`]
    });
}, { POLAR: EW } = va, { DISCRETE: p0, CONTINUOUS: VI } = ft, WI = (e) => [...e[0], ...e[1]].reduce((t, i) => (i.as() === VI && (t = !0), t), !1), OM = (e) => {
  const t = {};
  return [
    k_,
    v_,
    T_,
    "autoGroupBy",
    "useUTC"
  ].forEach((n) => {
    e[n] !== void 0 && (t[n] = e[n]);
  }), t;
}, PM = (e) => {
  let t = !1;
  return t = Object.keys(e).some((n) => e[n].length > 0), t;
}, YM = (e, t, i) => {
  let n = "";
  if (t === i - 1 && e.length > i) {
    for (let s = t; s < e.length - 1; s++)
      n += `${e[s].toString()} / `;
    return n += e[e.length - 1].toString(), n;
  } else if (e[t])
    return e[t].toString();
  return "";
}, qI = (e, t, i, { classPrefix: n, labelManager: s, sanitizeCheck: A }) => {
  const o = e.length > 0 ? e[0].map(
    (a, r) => new i(
      {
        type: G_,
        className: `${n}-grid-headers`
      },
      {
        labelManager: s
      }
    ).source(YM(t, r, e[0].length)).config({ show: a.config().show })
  ) : [];
  return A && CW(o), o;
}, jI = (e = {}) => {
  const { isBorderPresent: t } = e;
  return !t || [
    "color",
    "showRowBorders",
    "showColBorders",
    "showValueBorders"
  ].every((n) => !t[n]);
}, JM = (e = {}, t) => {
  const [i, n] = ["row", "column"].map((s) => {
    const A = {};
    return Object.keys(e[s].fields || {}).map((o) => {
      e[s].fields[o] && e[s].fields[o].formatter && (A[o] = {
        format: Ma(
          e[s].fields[o].formatter,
          t
        )
      });
    }), {
      format: Ma(
        e[s].formatter,
        t
      ),
      fields: A
    };
  });
  return {
    row: i,
    column: n,
    format: Ma(e.formatter, t)
  };
}, Q0 = (e, t) => {
  const { generateHref: i } = e;
  return i ? (n, s, A) => {
    let o = i(
      {
        formattedValue: s,
        rawValue: n
      },
      {
        fieldName: A,
        dateTimeFormatter: K.DateTimeFormatter.formatAs,
        dataModel: t
      }
    );
    const [a, r, l] = e.sanitizeHyperlink ? t.sanitiseStrings([
      o.target,
      o.rel,
      o.url
    ]) : [o.target, o.rel, o.url], c = l || s;
    return {
      target: a || bo,
      rel: r || Mo,
      url: e.encode ? encodeURI(c) : c,
      classNames: o.classNames ? o.classNames : Fo,
      styles: o.styles ? o.styles : No
    };
  } : null;
}, y0 = (e, t) => {
  const { generateHref: i } = e;
  if (!i) return {
    target: bo,
    rel: Mo,
    url: Xw,
    classNames: Fo,
    styles: No
  };
}, KM = (e = {}, t) => {
  const [i, n] = ["row", "column"].map((s) => {
    const A = {};
    return Object.keys(e[s].fields || {}).map((o) => {
      e[s].fields[o] && e[s].fields[o].hyperlink && e[s].fields[o].hyperlink.enabled && (A[o] = {
        format: Q0(
          e[s].fields[o].hyperlink,
          t
        ),
        hyperlink: y0(
          e[s].fields[o].hyperlink
        )
      });
    }), {
      format: e[s]?.hyperlink?.enabled && e[s]?.hyperlink?.generateHref ? Q0(
        e[s]?.hyperlink,
        t
      ) : null,
      hyperlink: e[s]?.hyperlink?.enabled && e[s]?.hyperlink?.generateHref ? y0(
        e[s]?.hyperlink
      ) : null,
      fields: A
    };
  });
  return {
    row: i,
    column: n
  };
}, td = (e, t, i) => {
  const n = i.getField(t).schema();
  let s;
  if (n.subtype === K.FieldSubtype.TEMPORAL)
    s = K.isInvalid(e) ? e : To(e, n.format);
  else if (n.subtype === K.FieldSubtype.BINNED) {
    if (e = us(e), typeof e == "string")
      return e;
    s = K.isInvalid(e) ? e : Co([
      e,
      e + i.getField(t).getBinSize()
    ]);
  } else
    s = e;
  return Zi(s);
}, Ma = (e, t) => e ? (i, n, s, { rawValue: A } = { rawValue: void 0 }) => e(
  {
    formattedValue: td(
      i,
      n,
      t
    ),
    rawValue: A ?? i
  },
  {
    fieldName: n,
    dateTimeFormatter: K.DateTimeFormatter.formatAs,
    dataPath: s,
    dataModel: t
  }
) : (i, n) => td(i, n, t), VM = (e, t) => {
  let i = null;
  return [yA, wA, po].forEach((n) => {
    (void 0).store.get(n) && e === (void 0).store.get(n)[0] && (i = n);
  }), i ? { channel: i } : ([Oi, zA].forEach((n) => {
    t[`${n}Facets`].forEach((s) => {
      s.toString() === e && (i = { channel: nB, type: n === zA ? Ec : Oi });
    });
  }), i || ([Oi, zA].forEach((n) => {
    t[`${n}Projections`].forEach((s) => {
      s.forEach((A) => {
        A.toString() === e && (i = n === zA ? Cc : gu);
      });
    });
  }), i ? { channel: i } : null));
}, WM = (e, t, i) => {
  let n = Gh;
  const s = e.getField(t);
  return s && ((i || bi(s)) === ft.CONTINUOUS ? n = iB : n = Gh), n;
}, qM = () => new j1(), zI = (e, t, i) => {
  let n = i[e], s = "";
  const A = e === Oi ? [Je, oi] : [Ee, Pe], [o, a] = t, r = (c) => o.length ? o[c].toString() === ht ? "dimension" : o[c].type() : null, l = (c) => a.length ? a[c].toString() === ht ? "dimension" : a[c].type() : null;
  return r(o.length - 1) === mi && l(0) === mi ? (s = n ? A[1 - A.indexOf(n)] : A[1], e === Ec && o[o.length - 1].toString() === a[0].toString() ? n = Pe : n = n || A[0]) : l(a.length - 1) === mi ? (s = e === Oi ? oi : Ee, n = e === Oi ? oi : Ee) : (s = e === Oi ? Je : Pe, n = e === Oi ? Je : Pe), r(o.length - 1) === ha && l(0) === ha ? n = e === Oi ? Je : Pe : l(0) === ha ? n = e === Oi ? oi : Ee : r(o.length - 1) === ha && (n = e === Oi ? Je : Pe), [s, n];
}, BW = (e, t, { cellRenderer: i, topColumns: n, bottomColumns: s }) => {
  const A = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  return e.length > 1 || t.length > 1 ? (A.top = !0, A.bottom = !0, A.left = !0, A.right = !0) : i === "html" && (A.top = !!n.length, A.bottom = !!s.length, A.left = !0, A.right = !0), A;
}, mW = (e, t, { cellRenderer: i, leftRows: n }) => {
  const s = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  if (e.length || t.length) {
    if (e[0] && e[0].length > 1 || t[0] && t[0].length > 1)
      s.top = !0, s.bottom = !0, s.left = !0, s.right = !0;
    else if (i === "html") {
      s.top = !0, s.bottom = !0, s.left = !!n.length, s.right = !0;
    }
  }
  return s;
}, pW = (e, t, i) => {
  const n = { top: !0, left: !0, bottom: !0, right: !0 }, s = [Je, oi], A = [Pe, Ee];
  return e.forEach((o, a) => {
    o[0] && o[0].length ? n[s[a]] = !(!i.showYAxesLine && o.length === 1) : n[s[a]] = !1;
  }), t.forEach((o, a) => {
    o.length ? n[A[a]] = !(!i.showXAxesLine && o.length === 1) : n[A[a]] = !1;
  }), n;
}, $I = (e, t, i) => {
  let n = { top: !1, bottom: !1, left: !1, right: !1 }, s = { top: !1, bottom: !1, left: !1, right: !1 }, A = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  const { rows: o, columns: a, values: r, cellRenderer: l } = e, [c, g] = o, [h, d] = a, { rows: u, columns: f } = t.fieldInfo(), C = [
    ...u.flat().filter((B) => B.as() === p0),
    ...f.flat().filter((B) => B.as() === p0)
  ].length, I = [
    ...u.flat().filter((B) => B.as() === VI),
    ...f.flat().filter((B) => B.as() === VI)
  ].length, E = [
    ...u.flat().filter((B) => B.subtype() === er),
    ...f.flat().filter((B) => B.subtype() === er)
  ].length;
  if (t.constructor.type() === EW) {
    if (!C)
      return { showRowBorders: n, showColBorders: s, showValueBorders: A };
  } else if (!I && !E && l !== "html" && C <= 2)
    return { showRowBorders: n, showColBorders: s, showValueBorders: A };
  return n = BW(c, g, {
    cellRenderer: l,
    topColumns: h,
    bottomColumns: d
  }), s = mW(h, d, {
    cellRenderer: l,
    leftRows: c
  }), A = pW(
    [c, g],
    [h, d],
    i
  ), r.length > 1 && (A.top = !0, A.bottom = !0), r.length && (r[0].length > 1 || l === "html") && (A.left = !0, A.right = !0), { showRowBorders: n, showColBorders: s, showValueBorders: A };
}, vB = (e) => {
  const t = e.map((n) => n.encoding || {}), i = [].concat(
    ...t.map((n) => Object.values(n).flatMap((s) => {
      const A = typeof s == "object" ? s.field : s;
      return Array.isArray(A) ? A : [A];
    }))
  );
  return [...new Set(i.filter((n) => n))];
}, jM = (e, t) => {
  const i = Object.values(e).map((n) => {
    const s = [].concat(...n);
    return [].concat(...s);
  });
  return [].concat(...i, ...t);
}, zM = (e, t) => {
  for (let i = 0; i < e.length; i++) {
    const n = e[i];
    Array.isArray(n) ? t.push(n) : zM(n.values, t);
  }
}, XI = (e) => {
  const t = xx({
    data: e,
    keys: e[0].map((n, s) => s)
  }), i = [];
  return zM(t, i), i;
}, QW = (e) => {
  e.autoSort.disabled && Object.keys(e).forEach((t) => {
    t !== "autoSort" && delete e[t];
  });
}, $M = (e, t, i) => {
  let n;
  const s = i.data(), { suppliedLayers: A, facetsAndProjections: o, globalConfig: a } = t, r = a.autoGroupBy;
  s instanceof K && s.dispose();
  const l = e.getDimensions(), c = vB(A).filter(
    (C) => l.includes(C)
  ), g = Array.from(jM(o, c)), h = [
    ...new Set(
      g.flatMap(
        (C) => C instanceof FB ? C.getMembers() : C
      )
    )
  ], d = e.project(
    e.getFieldNames().filter((C) => C !== pt.ROW_ID)
  );
  if (i.data(d), r.disabled)
    n = d;
  else {
    const C = h.filter(
      (w) => e.isDimension(w)
    ), I = r.measures, E = e.getMeasures(), B = hc(
      e,
      E
    ), m = et(B, I), p = Object.keys(m).map((w) => ({
      aggn: m[w],
      field: w
    }));
    n = d.groupBy(C, p);
  }
  const u = a.sort;
  QW(u);
  const f = Object.entries(u).filter(
    (C) => C[0] !== "autoSort"
  );
  return n = n.sort(f), i.transformedData(n), n;
}, el = (e, t) => e.filter((i) => i.as() === t).map((i) => i.getMembers()).flat(), XM = (e) => {
  const t = el(
    e.colProjections,
    "discrete"
  ), i = el(
    e.rowProjections,
    "discrete"
  ), n = e.optionalProjections.filter((a) => a.as === "discrete").map((a) => a.field), s = el(
    e.colProjections,
    "continuous"
  ), A = el(
    e.rowProjections,
    "continuous"
  ), o = e.optionalProjections.filter((a) => a.as === "continuous").map((a) => a.field);
  return {
    discreteColumnProjections: t,
    discreteRowProjections: i,
    discreteOptionalProjections: n,
    continuousColumnProjections: s,
    continuousRowProjections: A,
    continuousOptionalProjections: o
  };
}, Yg = {
  getRowHeaderSortingHook(e) {
    return (i, n) => {
      const s = e._matrix.row(), A = s._axisFields.flat(), o = s._facetFields.flat();
      let a = {};
      A.find((r) => `${r}` == `${i.field}`) ? a = {
        axes: {
          y: {
            fields: {
              [i.field]: {
                ordering: n === "clearSort" ? null : {
                  type: "alphabetical",
                  direction: n === "sortAscending" ? "asc" : "desc"
                }
              }
            }
          }
        }
      } : o.find((r) => `${r}` == `${i.field}`) && (a = {
        rows: {
          facets: {
            fields: {
              [i.field]: {
                ordering: n === "clearSort" ? null : {
                  type: "alphabetical",
                  direction: n === "sortAscending" ? "asc" : "desc"
                }
              }
            }
          }
        }
      }), e.context()._canvasHelpers.setCanvasConfig(a);
    };
  },
  getYAxisSortingHook(e) {
    return (t, i) => {
      const n = e._matrix.row()._axisFields.flat(), s = e._matrix.column()._axisFields.flat()[0];
      let A = null;
      n.find((o) => `${o}` == `${t.field}`) && (A = {
        axes: {
          x: {
            fields: {
              [s]: {
                ordering: i === "clearSort" ? null : {
                  type: "nested",
                  direction: i === "sortAscending" ? "asc" : "desc",
                  nested: {
                    field: {
                      name: e.units()[0][0].layers()[0].config().encoding.text.field
                    },
                    filters: [
                      ...t.facetPath,
                      {
                        field: t.field,
                        value: t.value
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }), A && e.context()._canvasHelpers.setCanvasConfig(A);
    };
  },
  getXAxisSortingHook(e) {
    return (t, i) => {
      const n = e._matrix.row()._axisFields.flat()[0], s = e._matrix.column()._axisFields.flat();
      let A = null;
      s.find((o) => `${o}` == `${t.field}`) && (A = {
        axes: {
          y: {
            fields: {
              [n]: {
                ordering: i === "clearSort" ? null : {
                  type: "nested",
                  direction: i === "sortAscending" ? "asc" : "desc",
                  nested: {
                    field: {
                      name: e.units()[0][0].layers()[0].config().encoding.text.field
                    },
                    filters: [
                      ...t.facetPath,
                      {
                        field: t.field,
                        value: t.value
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }), A && e.context()._canvasHelpers.setCanvasConfig(A);
    };
  }
}, ZM = (e, {
  rowGrandTotalDataMatrix: t,
  greatGrandTotalDataMatrix: i,
  columnGrandTotalDataMatrix: n
}, s = "start", A = "end") => (i && t ? s === "start" ? e = [
  ...n.map((o, a) => A === "start" ? [...i[a], ...o] : [...o, ...i[a]]),
  ...e
] : e = [
  ...e,
  ...n.map((o, a) => A === "start" ? [...i[a], ...o] : [...o, ...i[a]])
] : s === "start" ? e = [
  ...n,
  ...e
] : e = [
  ...e,
  ...n
], e), t1 = (e, t, i = "start") => (i === "start" ? e = [
  ...e.map((n, s) => [
    ...t[s],
    ...n
  ])
] : e = [
  ...e.map((n, s) => [
    ...n,
    ...t[s]
  ])
], e), e1 = (e, t) => {
  const i = e.columns.totals.grandTotals;
  return i.enabled && i.position === "start" ? t : 0;
}, i1 = (e, t) => {
  const i = e.rows.totals.grandTotals;
  return i.enabled && i.position === "start" ? t : 0;
}, n1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extractFields: jM,
  extractUnitConfig: OM,
  filterProjectionFields: el,
  findInGroup: VM,
  getAxisType: WM,
  getBorders: $I,
  getColOffset: i1,
  getDefaultFormattedFacetLabel: td,
  getDetailedProjectionInfo: XM,
  getEncoder: qM,
  getFieldsFromSuppliedLayers: vB,
  getHeaderAxisFrom: zI,
  getHeaderText: YM,
  getRowOffset: e1,
  groupFacetKeys: XI,
  hasContinuousAxis: WI,
  hasOneField: PM,
  headerCreator: qI,
  mergeColumnGrandTotalMatrices: ZM,
  mergeRowGrandTotalMatrices: t1,
  resolveFacetFormatters: JM,
  resolveFacetHyperlinkFormatters: KM,
  resolveSingleFacetFormatter: Ma,
  sanitizeCheck: jI,
  sortingHooks: Yg,
  transformDataModel: $M
}, Symbol.toStringTag, { value: "Module" })), yW = {
  layers: {},
  data: {},
  globalConfig: {}
};
class TB {
  constructor() {
    ve(this, yW);
  }
  createAxis() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  setCommonDomain() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  getLayerConfig() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  fieldInfo(...t) {
    return t.length ? (this._fieldInfo = et(this._fieldInfo || {}, t[0]), this) : this._fieldInfo;
  }
  sanitizeFields(t, i) {
    return this.fieldInfo(HM(t, i)), this.fieldInfo();
  }
  axisFrom(...t) {
    return t.length ? (this._axisFrom = t[0], this) : this._axisFrom;
  }
  headerFrom(...t) {
    return t.length ? (this._headerFrom = t[0], this) : this.__headerFrom;
  }
  setAxisAndHeaders(t = {}, i) {
    const [n, s] = zI(Oi, i.rows, t), [A, o] = zI(Ec, i.columns, t);
    return this.axisFrom({
      row: s,
      column: o
    }), this.headerFrom({
      row: n,
      column: A
    }), this;
  }
  getProjectionFields(t) {
    return vB(t);
  }
  hasMandatoryFields(t) {
    return PM(t);
  }
}
const s1 = {
  linear: Ln,
  band: xe,
  temporal: fr,
  size: Y_,
  color: ir,
  opacity: r6,
  backgroundColor: ir,
  shape: m6
}, Mn = "All", w0 = (e, t, i, n, s, A, o, a) => {
  let r = [], l = [], c = !1;
  const g = t.length, h = t.findIndex((u) => u === a);
  for (let u = 0; u < g; u++) {
    const f = t[u], C = e.getValueAtIndex(f, 0);
    if (l.push(C), !c) {
      r.push(C);
      const I = o(r);
      u < g - 1 && I && (c = I, u < h ? r = [
        ...r,
        ...new Array(h - u - 1).fill(Mn),
        e.getValueAtIndex(a, 0),
        ...new Array(g - (h + 1)).fill(Mn)
      ] : r = r.concat(new Array(g - (u + 1)).fill(Mn))), u === g - 1 && (c = !!I);
    }
  }
  const d = r.join(",");
  return i[d] === void 0 && (i[d] = A++, n.push(r)), s.push(l), {
    rowKey: r,
    allKeys: l,
    isCollapsed: c
  };
}, Xo = (e, t) => e.map((i) => t.getValueAtIndex(i, 0)), D0 = (e) => e.map((t) => ({
  keyArr: t,
  joinedKey: t.join(",")
})), Lr = (e) => e.getMembers(), wW = ({ name: e }) => e, DW = (e) => Ye(e).flat(), x0 = (e, t, i) => e.map(
  () => Array.from(Ka(t, i))
), S0 = (e, t) => K.isInvalid(e.data[0]) ? t : e.data[0], _0 = (e, t, i) => {
  const n = t(
    [...e.data[1].keys()],
    e.ancestors().map(({ data: [o] }) => o).reverse().filter((o) => o != null).map((o, a) => ({ field: i[a], value: o }))
  ), s = Symbol(), A = n.reduce((o, a, r) => (K.isInvalid(a) ? o.set(s, r) : o.set(a, r), o), /* @__PURE__ */ new Map());
  e.sort((o, a) => {
    const r = S0(o, s), l = S0(a, s);
    return A.get(r) - A.get(l);
  });
}, b0 = (e, t, i, n, s = {}) => {
  const { row: A = {}, column: o = {} } = s;
  t = XI(t), e = XI(e);
  const a = K.Invalid(), r = K.Invalid(), l = pa(
    e,
    ...i.map((d, u) => (f) => K.isInvalid(f[u]) ? a : f[u])
  ), c = pa(
    t,
    ...n.map((d, u) => (f) => K.isInvalid(f[u]) ? r : f[u])
  ), g = un(
    l,
    (d) => Array.isArray(d) && !Array.isArray(d[1]) ? d[1] : null
  ), h = un(
    c,
    (d) => Array.isArray(d) && !Array.isArray(d[1]) ? d[1] : null
  );
  return g.each((d) => {
    const { depth: u } = d;
    if (u < i.length) {
      const f = A[i[u]];
      f && _0(d, f, i);
    }
  }), h.each((d) => {
    const { depth: u } = d;
    if (u < n.length) {
      const f = o[n[u]];
      f && _0(d, f, n);
    }
  }), {
    treeRowKeys: g,
    treeColumnKeys: h
  };
}, xW = (e, t, i, { allRowHeaderKeys: n, allColumnHeaderKeys: s }) => {
  const A = e.map((o) => o.value).join("-");
  if (i === "row") {
    const o = t.findIndex(
      (a, r) => n[r].config?.sourceType !== "total" && a[0].rowFacetValues.join("-") === A
    );
    return t[o].map((a, r) => [o, r]);
  } else {
    const o = t[0].findIndex(
      (a, r) => s[r].config?.sourceType !== "total" && a.columnFacetValues.join("-") === A
    );
    return t.map((a, r) => [r, o]);
  }
}, SW = (e, { allRowHeaderKeys: t, allColumnHeaderKeys: i }, n) => {
  const s = e.map((a) => a.value).join("-");
  let A = -1, o = -1;
  return n === "row" ? t.forEach((a, r) => {
    const l = a.keys.slice(0, e.length).map((g) => `${g}`).join("-"), c = a.config?.sourceType === "total";
    l === s && !c && (A = A === -1 ? r : A, o = A !== -1 ? r : o);
  }) : i.forEach((a, r) => {
    const l = a.keys.slice(0, e.length).map((g) => `${g}`).join("-"), c = a.config?.sourceType === "total";
    l === s && !c && (A = A === -1 ? r : A, o = A !== -1 ? r : o);
  }), {
    startIndex: A,
    endIndex: o
  };
}, _W = (e, t, i) => {
  const n = {};
  return e.forEach((s) => {
    const A = s.mark === H_;
    return [s.def || s].flat().forEach((o) => {
      const a = {};
      ["x", "y"].forEach((r) => {
        const l = t[o.id], c = en.getLayerClass(o.mark), g = o.encoding[r], h = o.encoding[`${r}0`], { field: d, as: u, var: f } = g, C = h ? h.field : null, I = i.axes[r].fields || {}, { domain: E } = I[d] || {}, B = f && cr(f) ? f.vars().some(
          (p) => p && C && p.toString() === C
        ) : !1, m = {
          layerEncodings: o.encoding,
          transform: o.transform,
          userDomain: E,
          encoding: r,
          fieldAs: u
        };
        if (A && C) {
          const p = [d, C].map((w) => c.getDomain(l, {
            ...m,
            field: w.toString(),
            hasRangedEncodingInValueAxis: !0
          }));
          a[r] = we(p, u);
        } else if (B) {
          const { domain: p } = I[f.vars().toString()] || {}, w = f.vars().map((Q) => c.getDomain(l, {
            ...m,
            userDomain: p,
            field: Q.toString(),
            hasRangedEncodingInValueAxis: B
          }));
          a[r] = we(w, u);
        } else
          a[r] = c.getDomain(l, {
            ...m,
            field: d
          });
      }), n[o.id] = a;
    }), s;
  }), n;
}, nA = (e, t) => e.map((i) => i.map((n) => {
  const { layerDataModels: s, layerConfig: A } = n, o = _W(
    A,
    s,
    t
  );
  return {
    ...n,
    layerDomainsById: o
  };
})), KA = (e, t, i, n) => {
  const s = e.config();
  return i.map((A) => A.map((o) => {
    const {
      rowProjections: a,
      columnProjections: r,
      suppliedLayers: l,
      dataStore: c
    } = o, g = t.getResolvedEncodings(
      {
        rowFields: a,
        columnFields: r,
        dataStore: c
      },
      l || n,
      e.config(),
      e
    ), h = e.getAllRetinalEncodings(
      g.flatMap(
        ({ def: C }) => Array.isArray(C) ? C.map(({ encoding: I }) => I) : C.encoding
      )
    ), d = t.setRetinalFieldsInLayers(
      h,
      g
    ), u = {}, f = d.map((C) => ([C.def].flat().map((I) => {
      const E = e.transform(), B = I.mark, m = I.encoding, p = en.getLayerClass(B);
      Z(m, "detail", "field") || (m.detail = et({}, m.detail, {
        field: e.detail()
      }));
      const Q = p.getDefaultTransformConfig(
        I,
        c
      );
      I.transform = {
        ...Q,
        ...I.transform
      };
      const y = I.source, D = Z(E, y) || y, _ = s.autoGroupBy, x = MB(
        c,
        I,
        D,
        _
      );
      I.id = `${C.mark}-${Zt()}`, u[I.id] = ed(
        x,
        c
      );
    }), C));
    return {
      ...o,
      layerConfig: f,
      layerDataModels: u
    };
  }));
}, ed = (e, t) => e.project(
  t.getSchema().filter((i) => i.name !== pt.ROW_ID).map((i) => i.name)
), M0 = (e, t) => K.isInvalid(e) && K.isInvalid(t) || e === t, N0 = (e, t) => {
  let i;
  return t.forEach((n) => {
    i = i ? i.find((s) => M0(s.data?.[0], n.value)) : e.find((s) => M0(s.data?.[0], n.value));
  }), i.leaves().map((n) => n.data[1] == null ? [] : n.data[1][0]) ?? [];
}, tA = (e) => {
  const {
    rows: {
      facets: t,
      totals: {
        grandTotals: {
          splitTotal: { field: i } = {},
          position: n
        } = {},
        subTotals: {
          text: s,
          splitTotal: { field: A } = {},
          position: o
        } = {},
        data: { totalString: a } = {}
      } = {}
    } = {},
    columns: {
      facets: r,
      totals: {
        grandTotals: {
          splitTotal: { field: l } = {},
          position: c
        } = {},
        subTotals: {
          text: g,
          splitTotal: { field: h } = {},
          position: d
        } = {},
        data: { totalString: u } = {}
      } = {}
    } = {}
  } = e;
  return {
    rowFacetsConfig: t,
    rowTotalsSplitField: i,
    rowSubTotalsText: s,
    colFacetsConfig: r,
    columnTotalsSplitField: l,
    columnSubTotalsText: g,
    columnTotalString: u,
    rowTotalString: a,
    rowGrandTotalsPosition: n,
    columnGrandTotalsPosition: c,
    colSubTotalsSplitField: h,
    rowSubTotalsSplitField: A,
    rowSubTotalsPosition: o,
    columnSubTotalsPosition: d
  };
}, F0 = {
  default: 2,
  facet: 1,
  table: 1
}, bW = {
  className: `${uu}-facet-header`
}, MW = et(
  {},
  vo
), NW = {
  [Pe]: {
    [SI]: {
      [Je]: 5,
      [oi]: 5,
      [Pe]: 3,
      [Ee]: 2
    },
    [_I]: [bI]
  },
  [Ee]: {
    [SI]: {
      [Je]: 5,
      [oi]: 5,
      [Pe]: 5,
      [Ee]: 2
    },
    [_I]: [bI]
  }
}, FW = {
  dependencies: {},
  layerConfig: {},
  encoder: {},
  valueParser: {},
  data: {},
  transformedData: {},
  store: {}
}, { DISCRETE: R0 } = ft, RW = (e, t, i, n) => (e.forEach(({ type: s, domains: A }) => {
  const o = {
    primary: we(
      [
        ...A.filter(({ primary: a }) => a.domain.length).map(({ primary: a }) => a.domain)
      ],
      s
    ),
    secondary: we(
      [
        ...A.filter(({ secondary: a }) => a.domain.length).map(({ secondary: a }) => a.domain)
      ],
      s
    )
  };
  A.forEach(({ primary: a, secondary: r }) => {
    const { field: l, domain: c } = a, { field: g, domain: h } = r, d = Z(i, "fields", l) || {};
    if ((d.uniformAxisDomains !== void 0 ? d.uniformAxisDomains : n) && (t[l] = we(
      [c, t[l] || []],
      s
    ), g && (t[g] = we(
      [h, t[g] || []],
      s
    ), i.alignZeroLine))) {
      let f = t[l][1], C = t[l][0], I = t[g][1], E = t[g][0];
      f = Number.isFinite(f) ? f : I, C = Number.isFinite(C) ? C : E, I = Number.isFinite(I) ? I : f, E = Number.isFinite(E) ? E : I, [f, C, I, E].some((m) => m !== 0 && !m) && (f = o.primary[1], C = o.primary[0], I = o.secondary[1], E = o.secondary[1]);
      const B = Y1([f, I], [C, E]);
      t[l] = B[0], t[g] = B[1];
    }
  });
}), t), kW = (e, t, i) => {
  const { x: n, y: s } = e;
  let A = [], o = [];
  return n[0].type !== R0 ? A = k0(
    n,
    t.x,
    i
  ) : A = bl(n, i), s[0].type !== R0 ? o = k0(
    s,
    t.y,
    i
  ) : o = bl(s, i), {
    x: A,
    y: o
  };
}, k0 = (e, t, i) => {
  const n = {};
  RW(
    e,
    n,
    t,
    i
  );
  let s = [];
  return e.forEach(({ type: A, domains: o }) => {
    const a = o[0].primary.field, r = o[0].secondary.field, l = Z(t, "fields", a) || {};
    if (l.uniformAxisDomains !== void 0 ? l.uniformAxisDomains : i)
      s.push([
        n[a],
        r ? n[r] : []
      ]);
    else {
      const g = o.map((f) => f.primary.domain), h = o.map((f) => f.secondary.domain), d = we(g, A), u = we(h, A);
      s.push([d, u]);
    }
  }), s;
}, v0 = (e, t) => e.length ? e.map((i, n) => {
  const s = t.length ? t[n] : [];
  return [...i, ...s];
}) : t, ZI = (e, t, i, n, { rawValue: s = "" } = { rawValue: "" }) => {
  const { format: A, subtype: o } = t.getSchemaDef(), a = t.getMembers()[0];
  let r;
  return typeof i == "function" ? r = i(e, a, n, { rawValue: s }) : i.fields[a] && typeof i.fields[a].format == "function" ? r = i.fields[a].format(e, a, n, {
    rawValue: s
  }) : i.format ? r = i.format(e, a, n, { rawValue: s }) : o === "temporal" && A ? r = To(e, A) : r = e, { formattedValue: r, rawValue: s ?? e };
}, A1 = (e, t, i) => {
  const n = t.getMembers()[0];
  let s;
  return i.fields[n] && typeof i.fields[n].format == "function" ? s = i.fields[n].format(
    e.rawValue,
    e.formattedValue,
    n
  ) : i.format && typeof i.format == "function" && (s = i.format(
    e.rawValue,
    e.formattedValue,
    n
  )), i.fields[n] && i.fields[n].hyperlink && (s = i.fields[n].hyperlink), s;
};
function T0(e, t, i) {
  const n = { fields: {}, ...e };
  return [t, i].forEach((s) => {
    Object.keys(s.fields || {}).forEach((A) => {
      const o = s.fields[A];
      n.fields[A] = {
        ...e.fields ? e.fields[A] : {},
        // IF headers.fields[k].show is false, then don't show header | ELSE IF
        // facets/axis.fields.show is not true, then show; and if false, don't
        show: e.fields[A] && e.fields[A].show === !1 ? !!e.fields[A] && e.fields[A].show : o && o.show !== void 0 ? o.show : s.show
      };
    });
  }), n;
}
class qs {
  constructor(t) {
    this._dependencies = t, this.config({});
  }
  // /**
  //  * Iterates through the two dimensional matrix array and calls the given callback function with the cell instance,
  //  * row index, column index and the matrix array.
  //  *
  //  * @param {Function} fn Callback function which will get called for every cell.
  //  */
  // each (fn) {
  //     const matrix = this.cells();
  //     matrix.forEach((row, rIndex) => {
  //         row.forEach((col, cIndex) => {
  //             fn(col, rIndex, cIndex, matrix);
  //         });
  //     });
  //     return this;
  // }
  config(...t) {
    return t.length ? (this._config = t[0], this) : this._config;
  }
  clear() {
    this._dependencies = {}, this.config({});
  }
}
const o1 = (e, t, i, n) => e.map(
  ({
    formattedValue: s,
    rawValue: A,
    key: o,
    sourceType: a = "normal",
    overrideConfig: r = {},
    metaInf: l,
    fieldName: c,
    hyperlinkInfo: g
  }) => {
    r.style = {
      ...r.labels ? r.labels.style : {},
      ...r.labels && r.labels.align ? {
        "text-align": r.labels.align
      } : {}
    };
    const h = new i.TextCell(
      {
        className: `${t.className} ${r.className}`,
        useExternalCSS: t.useExternalCSS,
        style: t.style,
        ...t.charsAcross ? { numChars: t.charsAcross } : {}
      },
      { labelManager: n }
    );
    return h.key(o || A).source(s).rawSource(A).config({
      ...t,
      ...r,
      metaInf: { ...l, sourceType: a, hyperlinkInfo: g },
      fieldName: c
    }), h;
  }
);
class vW extends qs {
  constructor(t) {
    super(t), this._cells = {
      left: [],
      right: []
    };
  }
  props(t) {
    this._props = t;
  }
  createPlaceHolders(t) {
    this._cells = {
      left: [],
      right: []
    };
    const {
      takeHeaderFrom: i,
      facet: n,
      facetFields: s,
      useExternalCSS: A,
      facetConfig: {
        labels: { style: o },
        hyperlink: a
      },
      facetsConfig: r,
      show: l,
      globalConfig: c
    } = this.config(), g = {
      ...o,
      ...r.labels.style,
      "justify-content": r.labels.align
    }, h = this.createHeaders(t, {
      ...n,
      facetFields: s,
      facetsConfig: r,
      useExternalCSS: A,
      style: g,
      show: l,
      className: `${this.config().className || ""} ${r.className || ""} ${n.className || ""}`,
      globalConfig: c,
      hyperlinkConfig: a
    });
    i === "left" ? this._cells.left = h : this._cells.right = h;
  }
  createHeaders(t, i) {
    const { cellRegistry: n, smartLabel: s } = this._dependencies, A = { ...i, type: Tl }, { facetFields: o, facetsConfig: a } = i;
    return t = t.map(({ keys: r, config: l = {} }) => r.map((c, g) => {
      const h = o[g].toString(), d = Z(a, "fields", h) || {}, u = et(
        { ...l },
        et({}, a),
        d
      );
      return u.className = `${a.className || ""} ${d.className || ""} ${l.className || ""}`, {
        ...c,
        fieldName: h,
        overrideConfig: {
          ...u,
          show: wt(u.show, !0)
        },
        metaInf: {
          type: Tl,
          canvasHelpers: this.config().canvasHelpers,
          getDataPath: () => r.slice(0, g + 1).map((f, C) => {
            const I = o[C];
            let E = f.rawValue;
            return {
              field: I,
              value: E,
              sourceType: f.sourceType
            };
          })
        }
      };
    })), t.map((r) => o1(r, A, n, s));
  }
  clear() {
    super.clear(), this._cells = {
      left: [],
      right: []
    };
  }
}
class TW extends qs {
  constructor(t) {
    super(t), this._cells = {
      top: [],
      bottom: []
    };
  }
  createPlaceHolders(t) {
    this._cells = {
      top: [],
      bottom: []
    };
    const {
      takeHeaderFrom: i,
      facet: n,
      facetFields: s,
      useExternalCSS: A,
      facetConfig: {
        labels: { style: o },
        charsAcross: a
      },
      facetsConfig: r,
      show: l,
      globalConfig: c
    } = this.config(), g = {
      ...o,
      ...r.labels.style,
      "justify-content": r.labels.align
    }, h = this.createHeaders(t, {
      ...n,
      facetFields: s,
      facetsConfig: r,
      useExternalCSS: A,
      style: g,
      show: l,
      charsAcross: a,
      className: `${this.config().className || ""} ${r.className || ""} ${n.className || ""}`,
      globalConfig: c
    });
    i === "top" ? this._cells.top = h : this._cells.bottom = h;
  }
  createHeaders(t, i) {
    const { cellRegistry: n, smartLabel: s } = this._dependencies, A = {
      ...i,
      type: Uh
    }, { facetFields: o, facetsConfig: a } = i;
    return t = t.map(({ keys: r, config: l = {} }) => r.map((c, g) => {
      const h = o[g].toString(), d = Z(a, "fields", h) || {}, u = et(
        { ...l },
        et({}, a),
        d
      );
      return u.className = `${a.className || ""} ${d.className || ""} ${l.className || ""}`, u.labels.style = et(
        et({}, u.labels.style),
        {
          display: "flex",
          "justify-content": u.labels.align === Je ? "flex-start" : u.labels.align === oi ? "flex-end" : u.labels.align
        }
      ), {
        ...c,
        fieldName: h,
        overrideConfig: {
          ...u,
          show: wt(u.show, !0),
          verticalAlign: "middle"
        },
        metaInf: {
          type: Uh,
          canvasHelpers: this.config().canvasHelpers,
          getDataPath: () => r.slice(0, g + 1).map((f, C) => ({
            field: o[C],
            value: f.rawValue,
            sourceType: f.sourceType
          }))
        }
      };
    })), t.map((r) => o1(r, A, n, s));
  }
  clear() {
    super.clear(), this._cells = {
      top: [],
      bottom: []
    };
  }
}
const { DISCRETE: G0 } = ft, id = (e, t) => e.map(
  (i) => (
    // Create axis cell
    // @todo check why do we need to send configuration to axis cell from axisinstance
    GW(
      i,
      i ? i.config() : {},
      t
    )
  )
), GW = (e, t, i) => {
  const { orientation: n, show: s, renderer: A } = t;
  return e ? new i.AxisCell().source(e).config({
    isOffset: n === Ze || n === Se,
    show: s,
    renderer: A
  }) : new i.BlankCell().config({ show: !1 });
}, LW = (e, t, i, n, s, A) => {
  const o = {
    fieldInstance: t,
    id: t.toString(),
    name: t.displayName(),
    field: t.toString(),
    fieldAs: t.as(),
    fieldType: t.type(),
    fieldSubtype: t.subtype(),
    numberFormat: t.numberFormat(),
    // tickFormat: field.getSchemaDef().format,
    orientation: i,
    useExternalCSS: n.useExternalCSS,
    useUTC: n.useUTC,
    renderer: n.renderer,
    isBold: n.isBold,
    isCompact: n.isCompact,
    isFacet: n.isFacet,
    isGrandTotalsEnabled: n[e === "x" ? "rows" : "columns"].totals.grandTotals.enabled,
    grandTotalFormatter: n[e === "x" ? "rows" : "columns"].totals.grandTotals.formatter
  };
  let a;
  n.renderer === "html" ? (o.labels = {
    rotation: 0,
    align: e === "x" && n.firstSuppliedTextLayerInfo != null ? n.firstSuppliedTextLayerInfo.as === kh ? "right" : "left" : i === "left" ? "left" : "right"
  }, o.paddingInner = 0, o.paddingOuter = 0, a = `${n.classPrefix}-axis ${n.classPrefix}-pivot-table-axis`) : a = `${n.classPrefix}-axis ${n.classPrefix}-discrete-axis`;
  const r = Z(n, "axes", e) || {}, l = Z(r, "fields", t) || {};
  !r.tickFormat && !n.tickFormat && !l.tickFormat && o.field === `${A}` && (o.tickFormat = (h) => `${Math.trunc(h.formattedValue * 100)}%`), n.tickFormat && n.tickFormat[o.fieldAs] && (o.tickFormat = n.tickFormat[o.fieldAs]), typeof n == "function" && (n = n(t));
  let c = et(
    o.tickFormat ? o : et(o, r),
    l
  );
  n.renderer === "html" && (c.labels.rotation = 0), c.show = c.show !== !1;
  const g = c.className || s.className || "";
  return {
    ...c,
    ...s,
    className: a ? `${a} ${g}` : g
  };
}, a1 = (e) => {
  const t = e.as(), i = e.subtype();
  return i === vh ? t === G0 ? Be : qi : t === G0 ? xe : i === er ? fr : Ln;
}, UW = (e, t, i, n, s = {}, A) => {
  let o = LW(
    e,
    t,
    i,
    n,
    s,
    A
  );
  const a = a1(t);
  return e === Cc && (a === xe || a === fr) && n.columnTitle && n.columnTitle.show && ("showAxisName" in o || (o = Object.assign(o, { showAxisName: !1 }))), o;
}, r1 = (e, t, i, n, s, A = {}, o, a) => {
  const { smartLabel: r } = s, l = a1(t);
  let c = UW(
    e,
    t,
    i,
    n,
    A,
    a
  );
  return c = et({}, c, {
    ticks: {
      labels: {
        style: et(
          {},
          oA(Z(n.theme, "font")),
          oA(
            Z(n.theme, "font", "components", "axis", "ticks")
          )
        )
      }
    },
    title: {
      style: et(
        {},
        oA(Z(n.theme, "font")),
        oA(
          Z(n.theme, "font", "components", "axis", "name")
        )
      )
    }
  }), new l(
    c,
    { labelManager: r },
    o
  );
};
class HW extends qs {
  constructor(t) {
    super(t), this._cells = {
      top: [],
      bottom: []
    };
  }
  createAxisInstances(t, i, n, s, A) {
    return t.map(
      ({ field: a, config: r = {}, metaInf: l = {} }) => a && !zn(a) ? r1(
        Cc,
        a,
        i,
        { ...n, ...r },
        this._dependencies,
        { ...r, metaInf: l },
        s(),
        A
      ) : null
    );
  }
  createPlaceHolders(t, i, n) {
    this._cells = {
      top: [],
      bottom: []
    };
    const {
      axisFrom: s,
      globalConfig: A,
      renderer: o,
      isBold: a,
      isCompact: r,
      tickFormat: l,
      show: c,
      firstSuppliedTextLayerInfo: g,
      interaction: h
    } = this.config(), {
      columnAxisInfo: { topAxisInfo: d, bottomAxisInfo: u }
    } = t;
    A.columnTitle = t.columnTitle;
    const f = et(
      {},
      {
        axes: {
          x: {
            interaction: h
          }
        }
      },
      Object.assign(
        {},
        A,
        {
          isBold: a,
          isCompact: r,
          renderer: o,
          tickFormat: l,
          firstSuppliedTextLayerInfo: g,
          columnTitle: t.columnTitle
        },
        c != null ? { show: c } : {}
      )
    ), C = this.createAxisInstances(
      d,
      s === "bottom" ? "bottom" : "top",
      f,
      i,
      n
    ), I = this.createTopAxisCells(C), E = this.createAxisInstances(
      u,
      "bottom",
      A,
      i,
      n
    ), B = E.every((p) => !p), m = this.createBottomAxisCells(
      B ? [] : E
    );
    this._cells = {
      top: s === "bottom" ? m : I,
      bottom: s === "bottom" ? I : m
    };
  }
  createTopAxisCells(t) {
    return id(t, this._dependencies.cellRegistry);
  }
  createBottomAxisCells(t) {
    return id(t, this._dependencies.cellRegistry);
  }
  setDomains(t, i, n) {
    const { AxisCell: s } = this._dependencies.cellRegistry, { axisFrom: A } = this.config(), { top: o, bottom: a } = this._cells;
    let r = [];
    A === "top" ? r = [o, a] : r = [a, o];
    const l = {};
    r.forEach((c, g) => {
      c.forEach((h, d) => {
        if (!(h instanceof s))
          return;
        const u = h.source();
        let f = t[d][g];
        u.domain(f, n), l[`${d}-${g}`] = f;
      });
    }), i.commit(
      `${Ya}.domain.x`,
      l
    );
  }
  clear() {
    super.clear(), this._cells = {
      top: [],
      bottom: []
    };
  }
  getCells() {
    return this._cells;
  }
}
class OW extends qs {
  constructor(t) {
    super(t), this._cells = {
      left: [],
      right: []
    };
  }
  dependencies(t) {
    this._dependencies = t;
  }
  createAxisInstances(t, i, n, s, A) {
    return t.map(
      ({ field: a, config: r = {}, metaInf: l = {} }) => a && !zn(a) ? r1(
        gu,
        a,
        i,
        n,
        this._dependencies,
        { ...r, metaInf: l },
        s(),
        A
      ) : null
    );
  }
  createPlaceHolders(t, i, n) {
    this._cells = {
      left: [],
      right: []
    };
    const {
      globalConfig: s,
      renderer: A,
      isBold: o,
      isCompact: a,
      tickFormat: r,
      show: l,
      interaction: c
    } = this.config(), {
      rowAxisInfo: { leftAxisInfo: g, rightAxisInfo: h }
    } = t;
    s.rowTitle = t.rowTitle;
    const d = et(
      {},
      {
        axes: {
          y: {
            interaction: c
          }
        }
      },
      Object.assign(
        {},
        s,
        {
          isBold: o,
          isCompact: a,
          renderer: A,
          tickFormat: r,
          rowTitle: t.rowTitle
        },
        l != null ? { show: l } : {}
      )
    ), u = this.createAxisInstances(
      g,
      "left",
      d,
      i,
      n
    ), f = this.createLeftAxisCells(u), C = this.createAxisInstances(
      h,
      "right",
      d,
      i,
      n
    ), I = C.every((B) => !B), E = this.createRightAxisCells(
      I ? [] : C
    );
    this._cells = {
      left: f,
      right: E
    };
  }
  createLeftAxisCells(t) {
    return id(t, this._dependencies.cellRegistry);
  }
  createRightAxisCells(t) {
    return id(t, this._dependencies.cellRegistry);
  }
  setDomains(t, i, n) {
    const { AxisCell: s } = this._dependencies.cellRegistry, { left: A, right: o } = this._cells, a = {};
    [A, o].forEach((r, l) => {
      r.forEach((c, g) => {
        if (!(c instanceof s))
          return;
        const h = c.source();
        let d = t[g][l];
        h.domain(d, n), a[`${g}-${l}`] = d;
      });
    }), i.commit(
      `${Ya}.domain.y`,
      a
    );
  }
  clear() {
    super.clear(), this._cells = {
      left: [],
      right: []
    };
  }
  getCells() {
    return this._cells;
  }
}
const Sf = `${uu}-column-guideline`, L0 = `${uu}-column-drag-pointer`, GB = "column-dimension-changer", LB = "column-header-tooltip", Ao = "toggle-sort-menu-btn", oo = "toggle-sort-dropdown", ao = "toggle-sort-tooltip", Jg = "row-cell-highlighter", Kg = "col-cell-highlighter", ro = "expand-collapse-effect", lo = "context-menu-effect", co = "ctrl-click-effect";
class l1 extends pe {
  static formalName() {
    return GB;
  }
  apply(t, i, n) {
    const { dimensions: s, el: A } = this.firebolt.context.parentContainerInf(), o = i.showMarker;
    let a, r;
    if (i.targetData && i.targetElem) {
      const l = i.dimensions.x, c = z(
        A,
        "div",
        [1],
        `.${Sf}`
      );
      c.attr(
        "class",
        `${Sf} ${i.className || ""}`
      );
      const g = Rn(A);
      let {
        x: h,
        width: d,
        y: u
      } = Rn(i.targetElem);
      const f = i.resizeDelta == null ? n.draggableOutsideChart ? X("html").node().offsetWidth : g.x + g.width : h + d - g.x + Math.floor(i.resizeDelta);
      r = i.targetData.path.map((_) => ({
        field: _.field === null ? _.field : `${_.field}`,
        value: _.value,
        sourceType: _.sourceType
      }));
      const { minWidth: I } = this.firebolt.context._canvasHelpers.getMinTargetDimensions(
        r,
        i.isHeaderCell
      );
      h -= g.x;
      const E = Math.min(h + I || 0, h + d), B = i.markerPositionAtTarget ? h + d : Math.min(Math.max(l, E), f), m = u - g.y, p = s.height - (m - s.top), w = i.targetElem.closest(".muze-grid-bottom"), Q = this.firebolt.context._canvasHelpers.getMatrixDimensions().heights[0], y = w ? s.top + Q : m, D = this.firebolt.context._canvasHelpers.getMatrixDimensions().heights[2];
      if (vt(c, {
        position: "absolute",
        transform: `translate(${B}px, ${y}px)`,
        width: "0px",
        height: `${w ? s.height - Q : p - D}px`
      }), a = B - h, i.updateColumnWidth) {
        this.firebolt.context._canvasHelpers.getColumnWidthState(
          n.widths,
          i.isHeaderCell
        );
        const _ = r.map(({ value: S }) => S).filter((S) => S != null), x = this.firebolt.context._canvasHelpers.getColumnsCollapseState(_);
        this.firebolt.context.updateColumnWidths([
          {
            target: r,
            [x ? "collapsedWidth" : "width"]: a
          }
        ]);
      }
    }
    o || X(A).selectAll(`.${Sf}`).remove();
  }
}
const c1 = (e) => e === "" || e === " ";
class g1 extends pe {
  constructor(...t) {
    super(...t), this._tooltipRenderer = null;
  }
  static formalName() {
    return LB;
  }
  apply(t, { tooltext: i, tooltipAnchorBox: n, rotation: s }) {
    i = K.isInvalid(i) ? i.value() : i, this._tooltipRenderer == null && (this._tooltipRenderer = new nr(document.body, {
      creatorName: "header-tooltip"
    }), this._tooltipRenderer.extent({
      x: 0,
      y: 0,
      width: this.firebolt.context.parentContainerInf().dimensions.width,
      height: this.firebolt.context.parentContainerInf().dimensions.height
    }), this._tooltipRenderer.config({
      content: {
        rowMargin: "0 10px 5px 10px",
        className: this.firebolt.context._className
      }
    })), c1(i) ? this._tooltipRenderer.hide() : (this._tooltipRenderer.content("tooltip", [{ data: [i] }]), s ? (this._tooltipRenderer.offset({
      x: -20,
      y: -20
    }), this._tooltipRenderer.position(
      n.x,
      n.y + n.height
    )) : (this._tooltipRenderer.offset({
      x: 0,
      y: 0
    }), this._tooltipRenderer.positionRelativeTo(n)));
  }
  dispose() {
    this._tooltipRenderer && this._tooltipRenderer.dispose();
  }
}
class h1 extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return Ao;
  }
  apply(t, { target: i, showMenuButton: n, isActive: s }) {
    tC(i, n, s);
  }
}
const tC = (e, t, i) => {
  const n = zE(e);
  if (!(n && n.node()))
    return;
  const s = n.datum();
  if (!s.directSortEnabled)
    return;
  const A = s.sortStatus;
  if (t ? n.classed("highlight", !0) : n.classed("highlight", !1), t = !!A || t, t && t_(e), !A) {
    PW(e, t);
    const o = i ? r4 : jE;
    n.select("img").attr("src", o);
  }
}, PW = (e, t) => {
  zE(e).style("display", t ? "flex" : "none");
}, U0 = "sortAscending", H0 = "sortDescending", O0 = "clearSort", YW = "asc", P0 = "sort-active";
class d1 extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return oo;
  }
  apply(t, { data: i, anchorBox: n, target: s }) {
    let A = this.firebolt.context._sortDropdown;
    if (A == null) {
      const a = {
        menuItems: [
          {
            key: U0,
            label: "Sort ascending",
            onClick: this.onClickMenuItem.bind(this)
          },
          {
            key: H0,
            label: "Sort descending",
            onClick: this.onClickMenuItem.bind(this)
          },
          {
            key: O0,
            label: "Clear sort",
            onClick: this.onClickMenuItem.bind(this)
          }
        ],
        activeMenuItem: null
      };
      A = new aJ(
        document.body,
        { contextName: "direct-sort" },
        a
      ), A.extent({
        x: 0,
        y: 0,
        width: this.firebolt.context.parentContainerInf().dimensions.width,
        height: this.firebolt.context.parentContainerInf().dimensions.height
      }), this.firebolt.context._sortDropdown = A;
    }
    if (!i) {
      this.onResetEffect();
      return;
    }
    this.firebolt.context.resetDirectSort(), A.metaInfo({ data: i }), A.offset({
      x: -5,
      y: 43
    }), A.positionRelativeTo(n);
    const { sortStatus: o } = i;
    if (o) {
      const a = o.sortInfo.direction === YW ? U0 : H0;
      A.content({
        activeMenuItem: a,
        disabledMenuItems: []
      });
    } else
      A.content({
        activeMenuItem: null,
        disabledMenuItems: [O0]
      });
    this.firebolt.context._activeSortTarget = s, s.classed(P0, !0), tC(s, !0, !0);
  }
  onClickMenuItem(t, i) {
    const n = this.firebolt.context, {
      type: s,
      data: A,
      meta: o
    } = i.data.contextData, a = t.key;
    let r, l;
    if (s === VE) {
      const c = Z(n.config().headers, "interaction");
      l = Z(
        c,
        "directSortSelect",
        "sideEffects",
        "toggle-sort-dropdown",
        "hook"
      );
      const g = A.getDataPath(), h = g[g.length - 1];
      r = {
        field: h.field,
        value: h.field
      };
    } else if (s === WE || s === qE || s === VS || s === WS) {
      const { axisFieldName: c } = o, h = (n.getAxes() || []).find(
        (E) => E.config().field === c
      ).config().interaction;
      l = Z(
        h,
        "directSortSelect",
        "sideEffects",
        "toggle-sort-dropdown",
        "hook"
      );
      const d = A.getDataPath(), u = d[d.length - 1], f = u.field.getMembers()[0], C = u.value, I = d.slice(0, d.length - 1).map((E) => ({
        field: E.field.getMembers()[0],
        value: Xe(E.value) ? null : E.value
      }));
      r = {
        field: f,
        value: Xe(C) ? null : C,
        facetPath: I
      };
    } else
      throw new Error(`Direct sort is not yet implemented for: ${s}`);
    l && l(r, a);
  }
  onResetEffect() {
    const { context: t } = this.firebolt;
    t._sortDropdown && t._sortDropdown.hide();
    const i = t._activeSortTarget;
    i && (i.classed(P0, !1), tC(i, !1, !1), t._activeSortTarget = null);
  }
  dispose() {
    this.firebolt.context._sortDropdown && this.firebolt.context._sortDropdown.dispose();
  }
}
class u1 extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return ao;
  }
  apply(t, { showTooltip: i, currentSortStatus: n, tooltipAnchorBox: s }) {
    if (this._tooltipRenderer == null && (this._tooltipRenderer = new nr(document.body, {
      creatorName: ["direct-sort-tooltip", "header-tooltip"]
    }), this._tooltipRenderer.extent({
      x: 0,
      y: 0,
      width: this.firebolt.context.parentContainerInf().dimensions.width,
      height: this.firebolt.context.parentContainerInf().dimensions.height
    }), this._tooltipRenderer.config({
      content: {
        rowMargin: "0 10px 5px 10px",
        className: this.firebolt.context._className
      }
    })), !(i && n && n.sortInfo)) {
      this._tooltipRenderer.hide();
      return;
    }
    const A = this.genTooltipTextFromSortInfo(n);
    this._tooltipRenderer.content("tooltip", [{ data: [A] }]), this._tooltipRenderer.offset({
      x: 0,
      y: 0
    }), this._tooltipRenderer.positionRelativeTo(s);
  }
  genTooltipTextFromSortInfo(t) {
    const { sortInfo: i, targetField: n, metaInfo: s, formatterByFields: A } = t, { type: o, direction: a } = i, r = a === "asc" ? "ascending" : "descending";
    let l = "";
    if (o === "natural")
      l = `Sorted ${r} by data value`;
    else if (o === "alphabetical")
      l = `Sorted ${r} alphabetically`;
    else if (o === "nested") {
      const c = i.nested || {}, g = this.resolveFieldDisplayName(
        Z(c, "field", "name")
      ), h = Z(c, "field", "aggregation") || "SUM", d = Z(c, "filters") || [], u = h.toUpperCase(), { field: f, value: C } = d[d.length - 1], I = this.resolveFieldDisplayName(n.name);
      l = `Sorted ${r} by ${u}(${g}) within ${I}`;
      const E = A[f] || ((B) => B);
      s.sourceType !== "total" && (l += `, based on ${E(C)}`);
    } else
      throw new Error(`Unsupported sort type: ${o}`);
    return l;
  }
  resolveFieldDisplayName(t) {
    const { context: i } = this.firebolt;
    t = t || "";
    const n = i._canvasHelpers.getFieldInfo(t);
    return n ? n.displayName() : t;
  }
  dispose() {
    this._tooltipRenderer && this._tooltipRenderer.dispose();
  }
}
const JW = (e, t, i = 4) => {
  const n = X(e.currentTarget).datum();
  let s, A, o, a, r = !1, l;
  if (Z(n.placeholder, "type") === "text" || Z(n.placeholder, "type") === "blank")
    A = e.currentTarget, o = n.placeholder.config().metaInf.getDataPath(), a = "facet", l = _h(A, e).x, r = !0;
  else if (Z(n.placeholder, "type") === "axis")
    if (e.target.classList.value.includes("muze-ticks") && e.target.closest(".muze-pivot-table-axis")) {
      A = e.target;
      const c = X(A).datum();
      o = c.getDataPath(), a = "ticklabel", l = e.offsetX, r = c.isLastValueInDomain;
    } else
      A = e.currentTarget, o = n.placeholder.getDataPath(), a = "axis", r = !0, l = _h(A, e).x;
  if (A) {
    const c = A.getBoundingClientRect();
    let g = o;
    if (c.width - l <= i)
      s = {
        element: A,
        path: g,
        isLastCell: r
      };
    else if (l < i) {
      const h = X(e.currentTarget).datum().placeholder;
      let d;
      if (h.type === "text" || h.type === "blank" ? d = h.mount().previousElementSibling : d = t.context.getPreviousAxisElem({
        cell: h,
        axisElem: A
      }), d) {
        if (a === "ticklabel") {
          const u = X(d).datum();
          g = u.getDataPath(), r = u.isLastValueInDomain;
        } else a === "axis" ? (g = X(d).datum().placeholder.getDataPath(), r = !0) : g = X(d).datum().placeholder.getDataPath();
        s = {
          element: d,
          path: g,
          isLastCell: r
        };
      }
    }
  }
  return s;
}, f1 = (e) => (t) => {
  let i = !1, n, s, A = !1, o = !1;
  const a = "html", r = () => {
    X(a).classed(L0, !0);
  }, l = () => {
    X(a).classed(L0, !1);
  }, c = function() {
    if (i)
      return;
    const E = bt();
    if (X(E.currentTarget).datum()) {
      const { path: m, element: p, isLastCell: w } = JW(E, e) || {};
      if (m) {
        n = {
          path: m
        }, s = p, r();
        const Q = e.context.parentContainerInf().el, y = io(Q, bt()).x;
        w || (e.triggerPhysicalAction("columnDrag", {
          dimensions: {
            x: y
          },
          className: "muze-column-guideline-hover",
          targetData: n,
          showMarker: !0,
          markerPositionAtTarget: !0,
          targetElem: s
        }), o = !0), A = !0;
      } else
        l(), e.triggerPhysicalAction("columnDrag", {
          showMarker: !1,
          targetData: null
        }), A = !1;
    }
    E.preventDefault();
  }, g = () => {
    i || (l(), e.triggerPhysicalAction("columnDrag", {
      showMarker: !1,
      targetData: null
    }), o = !1, A = !1);
  };
  let h = null;
  const d = () => {
    if (i) {
      const E = e.context.parentContainerInf().el, B = io(E, bt()).x, m = X(s).datum().placeholder == null || X(s).datum().placeholder._resizeDelta == null ? 1 / 0 : X(s).datum().placeholder._resizeDelta, p = X(s).datum().placeholder != null && X(s).datum().placeholder.config().type === "headerTitle";
      return e.triggerPhysicalAction("columnDrag", {
        dimensions: {
          x: B
        },
        resizeDelta: m,
        targetData: n,
        showMarker: !0,
        targetElem: s,
        isHeaderCell: p,
        className: "muze-column-guideline-drag"
      }), bt().preventDefault(), B;
    }
  }, u = () => {
    A && (e.context._canvasHelpers.disableBehaviour(["highlight", "hover"]), e.context._canvasHelpers.disableLegendBehaviour([
      "highlight",
      "hover"
    ]), i = !0, h = d());
  }, f = () => {
    if (i) {
      const E = e.context.parentContainerInf().el, B = io(E, bt()).x, m = X(s).datum().placeholder == null || X(s).datum().placeholder._resizeDelta == null ? 1 / 0 : X(s).datum().placeholder._resizeDelta, p = X(s).datum().placeholder != null && X(s).datum().placeholder.config().type === "headerTitle";
      e.triggerPhysicalAction("columnDrag", {
        showMarker: !1,
        updateColumnWidth: Math.abs(h - B) > 1,
        dimensions: {
          x: B
        },
        resizeDelta: m,
        isHeaderCell: p,
        targetData: n,
        targetElem: s,
        className: "muze-column-guideline-drag"
      }), i = !1, A = !1, l(), e.context._canvasHelpers.enableBehaviour("highlight"), e.context._canvasHelpers.enableLegendBehaviour("highlight");
    }
  }, C = t.selectAll(function() {
    const E = X(this);
    return E.classed("muze-grid-top-1") || E.classed("muze-grid-top-2") || E.classed("muze-grid-bottom-1") || E.classed("muze-grid-bottom-2") ? E.selectAll(".muze-grid-td").nodes() : [null];
  });
  C.on("mouseover", c), C.on("mousemove", c), C.on("mouseout", g);
  const I = e.context.sourceCanvas();
  X(a).on(
    `mousedown.${I}-${e.context.id()}`,
    u
  ), X(a).on(
    `mousemove.${I}-${e.context.id()}`,
    d
  ), X(a).on(
    `mouseup.${I}-${e.context.id()}`,
    f
  ), e.context._canvasHelpers.afterDisposed(() => {
    X(a).on(
      `mousedown.${I}-${e.context.id()}`,
      null
    ), X(a).on(
      `mousemove.${I}-${e.context.id()}`,
      null
    ), X(a).on(
      `mouseup.${I}-${e.context.id()}`,
      null
    );
  }), e.context._canvasHelpers.onHScroll(() => {
    o && e.triggerPhysicalAction("columnDrag", {
      showMarker: !1,
      targetData: null
    }), o = !1;
  });
}, KW = (e) => Rs(e, "source") && typeof e.source == "function" && Rs(e, "type") && Rs(e, "config") && typeof e.config == "function" && Rs(e, "mount") && typeof e.mount == "function", I1 = (e) => (t) => {
  let i = 0, n = 0, s = 0, A = 0, o = !1;
  const a = () => {
    const { currentTarget: c, target: g } = bt();
    let h = "", d = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }, u = 0;
    if (c instanceof HTMLTableCellElement) {
      const f = X(c).datum();
      if (Rs(f, "placeholder") && KW(f.placeholder)) {
        const C = f.placeholder, I = C.source(), E = C.type, B = C.config();
        if (E === "text") {
          const m = K.getActualValue(I);
          if (typeof m == "string" && !c1(m)) {
            const p = X(C.mount()).select(
              ".muze-text-cell"
            );
            p.select("span").node() ? g === p.select("span").node() && (h = m, d = Rn(g)) : g === p.select(".muze-facet-inner-text").node() && (h = m, d = Rn(g));
          }
        } else if (E === "axis") {
          const m = I.constructor.type() === "band";
          if (B.renderer === "html" && m) {
            if (g instanceof HTMLSpanElement) {
              const w = X(g).datum();
              Rs(w, "originalText") && typeof w.originalText == "string" && (h = w.originalText, d = Rn(g));
            }
          } else if (B.renderer === "svg" && (g instanceof SVGTextElement || g instanceof SVGTSpanElement)) {
            const [p, w] = wE(c), Q = I.config().orientation;
            let y = !1;
            if (o && (Q === "bottom" ? y = w > i : Q === "top" ? y = w < n : Q === "left" ? y = p < A : Q === "right" && (y = p > s)), y)
              h = I.renderConfig().smartAxisName.oriText, d = Rn(g);
            else if (m) {
              let D = X(g);
              g instanceof SVGTSpanElement && g.parentElement instanceof SVGTextElement && (D = X(g.parentElement));
              const _ = D.datum();
              h = I.axis().tickFormat()(_), u = I.config().labels.rotation == null ? 0 : I.config().labels.rotation, d = Rn(g);
            }
          }
        }
      }
    }
    e.triggerPhysicalAction("columnHeaderHover", {
      tooltext: h,
      tooltipAnchorBox: d,
      rotation: u
    });
  }, r = () => {
    const { currentTarget: c, target: g } = bt();
    if (c instanceof HTMLTableCellElement) {
      const d = X(c).datum();
      if (Rs(d, "placeholder")) {
        const u = d.placeholder;
        if (Rs(u, "source") && typeof u.source == "function") {
          const f = u.source();
          if (f && !(typeof f == "string" || K.isInvalid(f)) && !(g instanceof HTMLDivElement)) {
            o = f.config().showAxisName;
            const C = f.mount();
            if (C instanceof SVGSVGElement) {
              const B = X(C).select(".muze-axis-name").node();
              if (B instanceof SVGElement) {
                const { height: m } = B.getBBox(), {
                  e: p,
                  f: w
                } = B.getCTM();
                i = w - m / 2, n = w + m / 2, s = p - m / 2, A = p + m / 2;
              }
            }
          }
        }
      }
    }
  }, l = () => {
    e.triggerPhysicalAction("columnHeaderHover", {
      tooltext: "",
      tooltipAnchorBox: { x: 0, y: 0, width: 0, height: 0 },
      rotation: 0
    });
  };
  t.selectAll(".muze-grid-td").on("pointerover", r), t.selectAll(".muze-grid-td").on("pointermove", a), t.selectAll(".muze-grid-td").on("pointerout", l);
}, C1 = (e) => (t) => {
  const { directSortEnabledInfo: i } = e.context.config();
  $E({
    baseTargets: {
      rowsHeaders: "div.muze-text-cell.muze-grid-headers",
      axis: [
        "div.muze-ticks",
        "g.tick.muze-ticks",
        "div.muze-direct-sort-container",
        "text.muze-axis-name"
      ]
    },
    directSortEnabledInfo: i
  }).forEach((s) => {
    t.selectAll(s).on("pointerover", VW.bind(void 0, e)), t.selectAll(s).on("pointermove", WW.bind(void 0, e)), t.selectAll(s).on("pointerout", qW.bind(void 0, e));
  });
}, VW = (e) => {
  const t = HB(e);
  UB(e, !0, t);
}, WW = (e) => {
  const t = HB(e);
  UB(e, !0, t);
}, qW = (e) => {
  const t = bt(), { context: i } = e, n = au(X(t.currentTarget)), s = i._sortDropdown, A = s && s.isVisible(), o = i._activeSortTarget, a = A && n.node() === o.node() || !1, r = HB(e);
  UB(e, a, r);
}, UB = (e, t, i) => {
  const n = bt(), s = au(X(n.currentTarget));
  e.triggerPhysicalAction("directSortHover", {
    target: s,
    showMenuButton: t,
    isActive: i
  });
}, HB = (e) => {
  const t = bt(), i = au(X(t.currentTarget)), n = e.context, s = n._sortDropdown, A = n._activeSortTarget;
  return s && s.isVisible() && i.node() === A.node();
}, E1 = (e) => (t) => {
  const { directSortEnabledInfo: i } = e.context.config();
  $E({
    baseTargets: {
      rowsHeaders: "div.muze-text-cell.muze-grid-headers .sort-menu",
      axis: [
        "div.muze-ticks .sort-menu",
        "div.muze-direct-sort-container .sort-menu"
      ]
    },
    directSortEnabledInfo: i
  }).forEach((A) => {
    t.selectAll(A).on("click", jW.bind(void 0, e));
  });
  const s = _f.bind(void 0, e);
  document.addEventListener("click", s), e.context._canvasHelpers.afterDisposed(() => {
    document.removeEventListener("click", s);
  }), e.context._canvasHelpers.onHScroll(
    _f.bind(void 0, e)
  ), e.context._canvasHelpers.onVScroll(
    _f.bind(void 0, e)
  );
}, jW = (e) => {
  const t = bt();
  t.stopPropagation();
  const i = X(t.currentTarget), n = i.datum(), s = Rn(i.node()), A = au(
    X(i.node().parentElement)
  );
  e.triggerPhysicalAction("directSortClick", {
    data: n,
    anchorBox: s,
    target: A
  });
}, _f = (e) => {
  const t = e.context._sortDropdown;
  t && t.isVisible() && B1(e);
}, B1 = (e) => {
  e.triggerPhysicalAction("directSortClick", {
    data: null,
    anchorBox: null,
    target: null
  });
}, m1 = (e) => (t) => {
  const { directSortEnabledInfo: i } = e.context.config();
  $E({
    baseTargets: {
      rowsHeaders: "div.muze-text-cell.muze-grid-headers .sort-menu",
      axis: [
        "div.muze-ticks .sort-menu",
        "div.muze-direct-sort-container .sort-menu"
      ]
    },
    directSortEnabledInfo: i
  }).forEach((s) => {
    t.selectAll(s).on("pointerover", zW.bind(void 0, e)), t.selectAll(s).on("pointermove", $W.bind(void 0, e)), t.selectAll(s).on("pointerout", XW.bind(void 0, e));
  });
}, zW = (e) => {
  OB(e, !0);
}, $W = (e) => {
  OB(e, !0);
}, XW = (e) => {
  OB(e, !1);
}, OB = (e, t) => {
  const i = bt(), n = X(i.currentTarget), s = n.datum().sortStatus;
  t = !!(t && s);
  const A = Rn(n.node());
  e.triggerPhysicalAction("directSortBtnHover", {
    showTooltip: t,
    currentSortStatus: s,
    tooltipAnchorBox: A
  });
};
class p1 extends sn {
  static formalName() {
    return "resize";
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
class Q1 extends sn {
  static formalName() {
    return "headerTooltip";
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
const ul = (e, t = !0, i) => {
  e.forEach((n) => {
    const s = n.source(), { renderer: A } = n.config();
    A === "html" ? s.getTicksBasedOnData(i)[i !== void 0 ? "selectionSet" : "rejectionSet"].each(
      function() {
        X(this).classed("muze-axis-cell-highlight", t);
      }
    ) : A === "svg" && i === void 0 && X(n.mount()).selectAll(".muze-axis-cell").classed("muze-axis-cell-highlight", t);
  });
}, Y0 = (e, t) => {
  e.forEach((i) => {
    X(i.mount()).classed("muze-facet-cell-highlight", t);
  });
}, J0 = (e, t) => {
  e.forEach((i) => {
    X(i.mount()).classed("muze-row-header-cell-highlight", t);
  });
};
class ZW extends pe {
  constructor(...t) {
    super(...t), this._interactedCells = {
      rowHeader: null,
      axis: null,
      facet: null
    };
  }
  static formalName() {
    return Jg;
  }
  apply(t, i) {
    const n = i.data && i.data.contextData.data ? i.data.contextData.data.getDataPath() : null;
    if (this._interactedCells && (ul(this._interactedCells.axis || [], !1), Y0(this._interactedCells.facet || [], !1), J0(this._interactedCells.rowHeader || [], !1), this._interactedCells = {}), !n)
      return this;
    const s = n[n.length - 1];
    if ("value" in s) {
      const o = this.firebolt.context._matrices.axes._cells.left.find((a) => {
        const r = a.source().config().metaInf.facets;
        return `${n.slice(0, n.length - 1).map(({ value: l }) => l)}` == `${r.map(({ value: l }) => l)}` && (a.source().config().sourceType || "normal") === s.sourceType;
      });
      o && (ul([o], !0, s.value), this._interactedCells = [o], this._interactedCellType = "axis", this._interactedCells.axis = [o]);
    } else {
      const A = [
        ...this.firebolt.context._headerTitleMatrices._matrices.topLeft,
        ...this.firebolt.context._headerTitleMatrices._matrices.bottomLeft
      ].flat(), o = s.field, a = this.firebolt.context._matrices.axes._cells.left, r = this.firebolt.context._matrices.headers._cells.left, l = a[0].source().config().field === o ? 0 : -1, c = (r[0] || []).findIndex(
        (h) => h && h.config().fieldName === o
      ), g = A.find((h) => h.config().fieldName === o);
      if (J0([g], !0), this._interactedCells.rowHeader = [g], l !== -1)
        ul(a, !0), this._interactedCells.axis = a;
      else if (c !== -1) {
        const h = r.map((d) => d[c]).flat();
        Y0(h, !0), this._interactedCellType = "facet", this._interactedCells.facet = h;
      }
    }
  }
}
class t7 extends pe {
  static formalName() {
    return Kg;
  }
  apply(t, i) {
    const n = i.data && i.data.contextData.data ? i.data.contextData.data.getDataPath() : null;
    if (this._interactedCells && this._interactedCellType === "axis" && ul(this._interactedCells || [], !1), !n)
      return this;
    const s = n[n.length - 1];
    if ("value" in s) {
      const A = this.firebolt.context._matrices.axes._cells, a = [...A.bottom, ...A.top].find((r) => {
        const l = r.source().config().metaInf.facets;
        return `${n.slice(0, n.length - 1).map(({ value: g }) => g)}` == `${l.map(({ value: g }) => g)}` && (r.source().config().sourceType || "normal") === s.sourceType;
      });
      a && (ul([a], !0, s.value), this._interactedCells = [a], this._interactedCellType = "axis");
    }
  }
}
class y1 extends Yo {
  dispatchBehaviour(t, i, ...n) {
    super.dispatchBehaviour(t, i, ...n), Z(
      this.context.config().interaction,
      t,
      "propagate"
    ) && this.context._canvasHelpers.propagateIdentifiers({
      payload: {
        ...i,
        targetActions: this.context.config().interaction[t].target
      },
      action: t
    });
  }
}
class w1 extends sn {
  static formalName() {
    return "directSortHighlight";
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
class D1 extends sn {
  static formalName() {
    return "directSortSelect";
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
class x1 extends sn {
  static formalName() {
    return "directSortBtnHighlight";
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
const S1 = (e) => (t) => {
  t.selectAll(
    "div.muze-text-cell .muze-facet-expand-icon,div.muze-text-cell .muze-facet-collapse-icon"
  ).on("click", function() {
    e7.call(this, e);
  });
}, K0 = (e, t) => e.map((i, n) => ({
  field: `${i.field}`,
  value: i.value,
  collapsed: n === e.length - 1 ? !t : null
})), e7 = function(e) {
  const t = X(this).datum();
  if (t) {
    const i = t.getDataPath(), n = t.type, s = t.canvasHelpers.getCanvasConfig(), A = i.map((o) => o.value);
    if (n === Tl) {
      const o = s.rows.facets.interaction.collapse.handleClick, a = t.canvasHelpers.getRowCollapseState(A), r = K0(i, a);
      e.context._canvasHelpers.setRowCollapseState(r), o && o({
        targetPath: r,
        state: e.context._canvasHelpers.getRowCollapseState()
      });
    } else {
      const o = s.columns.facets.interaction.collapse.handleClick, a = t.canvasHelpers.getColumnsCollapseState(A), r = K0(i, a);
      e.context._canvasHelpers.setColumnsCollapseState(r), o && o({
        targetPath: r,
        state: e.context._canvasHelpers.getColumnsCollapseState()
      });
    }
  }
};
class _1 extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return ro;
  }
  apply() {
  }
}
class b1 extends sn {
  static formalName() {
    return "expandCollapse";
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
const M1 = (e, t, i) => {
  let n = "";
  i?.splitTotal.field && (n = i.splitTotal.field);
  const s = t.interaction.collapse, A = e._facetFields;
  s.fields = {};
  for (let o = 0; o < A.length; o++)
    o === A.length - 1 ? s.fields[A[o]] = {
      enabled: e._axisFields.flat().find((a) => a.as() === De && `${a}` !== n) ? s.enabled : !1
    } : s.fields[A[o]] = {
      enabled: n !== `${A[o + 1]}` ? s.enabled : !1
    };
  return s;
};
class N1 extends sn {
  static formalName() {
    return "contextMenu";
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
const i7 = [
  "td.muze-grid-td-facet",
  // For rows/columns facets
  "div.tick.muze-ticks",
  // For axis ticks for pivot table
  "g.tick.muze-ticks",
  //For axis ticks for non-pivot
  "div.muze-columnHeader-cell",
  "div.muze-grid-headers"
], F1 = (e) => (t) => {
  t.selectAll(i7.join(",")).on("contextmenu", function() {
    s7.call(this, e);
  });
}, R1 = (e, t) => {
  switch (e) {
    case Tl:
      return t?.rows?.facets?.interaction?.contextMenu;
    case Uh:
      return t?.columns?.facets?.interaction?.contextMenu;
    case hu:
      return t?.axes?.x?.interaction?.contextMenu;
    case du:
      return t?.axes?.y?.interaction?.contextMenu;
    case "columnHeaderTitle":
      return t?.columns?.headers?.interaction?.contextMenu;
    case "rowHeaderTitle":
      return t?.rows?.headers?.interaction?.contextMenu;
    default:
      return null;
  }
};
function k1(e) {
  return e?.enabled && e?.hook ? e : null;
}
function V0(e, t, i) {
  const n = e.datum();
  if (!n) return;
  const s = i.context._canvasHelpers.getCanvasConfig(), A = k1(R1(t, s));
  if (!A) return;
  const o = bt();
  o.preventDefault(), A.hook({
    type: t,
    event: o,
    dataPath: n.placeholder?.getDataPath() ?? [],
    ...n
  });
}
function n7(e, t) {
  const i = e.selectAll(
    "div.muze-text-cell .muze-facet-cell-container"
  ), s = (i.size() ? i : e).datum();
  if (!s?.type) return;
  const A = t.context._canvasHelpers.getCanvasConfig(), o = k1(R1(s.type, A));
  if (!o) return;
  const a = bt();
  a.preventDefault();
  const r = typeof s.getDataPath == "function" ? s.getDataPath().map((l) => ({
    field: l.field.oneVar(),
    value: l.value
  })) : [];
  o.hook({ type: s.type, event: a, dataPath: r });
}
function s7(e) {
  const t = X(this);
  t.classed("muze-columnHeader-cell") && !t.classed("muze-column-header-separator") ? V0(t, "columnHeaderTitle", e) : t.classed("muze-grid-headers") ? V0(t, "rowHeaderTitle", e) : n7(t, e);
}
class v1 extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return lo;
  }
  apply() {
  }
}
const T1 = (e) => (t) => {
  t.selectAll("a.muze-hyperlink-text").on("click", function() {
    A7.call(this, e);
  });
}, A7 = function() {
  const e = bt();
  e.metaKey || e.preventDefault();
};
class G1 extends sn {
  static formalName() {
    return "ctrlClickOpen";
  }
  dispatch() {
    return this;
  }
}
class L1 extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return co;
  }
  apply() {
  }
}
const W0 = (e, t, i, { renderer: n } = {}) => {
  const s = t === `${oi}` ? `${Vi}` : `${Hh}`, A = e.length;
  let o = e[0][0].source();
  const a = e[e.length - 1][0].source(), r = {};
  for (let l = 0; l < e.length; l++) {
    const c = l === e.length - 1;
    for (let g = 0; g < e[0].length; g++)
      n === "html" && c ? e[l][g].config({
        externalClassname: [`${Hh}`]
      }) : e[l][g].config({
        externalClassname: [s]
      });
    e[l][0].source() !== o && (r[l] = l, o = e[l][0].source());
  }
  for (let l = 0; l < e.length; l++)
    for (let c = 0; c < e[0].length; c++)
      c === 0 ? (e[l][0].config().externalClassname.push(`${eA}-${t}`), e[l][c].source() === a && l !== 0 ? n === "svg" && e[l][c].config().externalClassname.push(`${_a}-${Ee}`) : e[l][0].config().externalClassname.push(`${Vi}-${Ee}`), e[l][c] instanceof i && (e[l][c].config().externalClassname.push(`${eA}-${Pe}`), e[l][c].config().externalClassname.push(`${eA}-${Ee}`))) : c !== e[l].length - 1 && e[l][c].config().externalClassname.push(`${Vi}-${t}`), l === 0 ? e[0][c].config().externalClassname.push(`${_a}-${Pe}`) : l === A - 1 && n === "svg" && e[l][c].config().externalClassname.push(`${_a}-${Ee}`), l === 0 && e.length === 1 && e[l][c].config().externalClassname.push(`${Vi}-${Ee}`), r[l] && e[l - 1][c].config().externalClassname.push(`${Vi}-${Ee}`), e[l][c] instanceof i && (e[l][c].config().externalClassname.push(`${eA}-${Je}`), e[l][c].config().externalClassname.push(`${eA}-${oi}`));
  return r;
};
class o7 extends qs {
  constructor(...t) {
    super(...t), this._borderConfig = {}, this._mergedMatrices = { leftMatrix: [], rightMatrix: [] }, this._matrices = {
      headers: new vW(this._dependencies),
      axes: new OW(this._dependencies)
    }, this._facetFields = null, this._axisFields = null, this._className = "row-header", this._firebolt = new y1(
      this,
      {
        behavioural: {
          resize: p1,
          headerTooltip: Q1,
          directSortHighlight: w1,
          directSortSelect: D1,
          directSortBtnHighlight: x1,
          expandCollapse: b1,
          contextMenu: N1,
          ctrlClickOpen: G1
        },
        physical: {
          columnDrag: f1,
          columnHeaderHover: I1,
          directSortHover: C1,
          directSortClick: E1,
          directSortBtnHover: m1,
          expandCollapseClick: S1,
          contextMenuClick: F1,
          ctrlClick: T1
        },
        physicalBehaviouralMap: {
          columnDrag: {
            behaviours: ["resize"]
          },
          columnHeaderHover: {
            behaviours: ["headerTooltip"]
          },
          directSortHover: {
            behaviours: ["directSortHighlight"]
          },
          directSortClick: {
            behaviours: ["directSortSelect"]
          },
          directSortBtnHover: {
            behaviours: ["directSortBtnHighlight"]
          },
          expandCollapseClick: {
            behaviours: ["expandCollapse"]
          },
          contextMenuClick: {
            behaviours: ["contextMenu"]
          },
          ctrlClick: {
            behaviours: ["ctrlClickOpen"]
          }
        }
      },
      {
        [GB]: l1,
        [LB]: g1,
        [Ao]: h1,
        [oo]: d1,
        [ao]: u1,
        [Jg]: ZW,
        [ro]: _1,
        [lo]: v1,
        [co]: L1
      },
      {}
    );
  }
  config(...t) {
    if (t.length) {
      const i = t[0], n = et({}, this._config, i);
      return this._config = n, this;
    }
    return this._config;
  }
  generateHeaders(t, i, n) {
    const s = this._matrices.headers;
    s.config({
      ...this.config().headers,
      facetsConfig: n,
      facetFields: i.rowFacets,
      canvasHelpers: this._canvasHelpers,
      globalConfig: this.config().axes.globalConfig
    }), s.createPlaceHolders(t);
  }
  generateAxes(t, i) {
    const {
      axes: n,
      renderer: s,
      isBold: A,
      tickFormat: o,
      show: a,
      isRowsCompact: r,
      fieldToShowInPercentage: l
    } = this.config(), c = this._matrices.axes;
    c.config({
      show: a,
      isBold: A,
      isCompact: r,
      tickFormat: o,
      renderer: s,
      fieldToShowInPercentage: l,
      ...n
    }), c.createPlaceHolders(
      t,
      i,
      l
    );
  }
  updateMatrices({
    axesInfo: t,
    headers: i,
    facets: n,
    rowFacetsConfig: s,
    facetFormatters: A,
    facetHyperLinkFormatters: o
  }) {
    this._facetFields = n.rowFacets, this._axisFields = t.axisFields;
    const { leftAxisInfo: a, rightAxisInfo: r } = t.rowAxisInfo, l = this.getAxesInfos([a, r], i);
    t.rowAxisInfo.leftAxisInfo = l[0], t.rowAxisInfo.rightAxisInfo = l[1], this._matrices.axes._cells.left.forEach((f) => {
      f.remove();
    }), this._matrices.axes._cells.right.forEach((f) => {
      f.remove();
    }), this._matrices.axes._cells.left.length = 0, this._matrices.axes._cells.right.length = 0, this.generateAxes(t, this._eventManager), this._matrices.headers._cells.left.forEach((f) => {
      f.forEach((C) => {
        C.remove();
      });
    }), this._matrices.headers._cells.right.forEach((f) => {
      f.forEach((C) => {
        C.remove();
      });
    }), this._matrices.headers._cells.left.length = 0, this._matrices.headers._cells.right.length = 0;
    const c = this.getHeaderKeys(
      i,
      n,
      A,
      o
    );
    this.generateHeaders(c, n, s), this._mergedMatrices = this.merge();
    const { sanitizeCheckBorder: g } = this.config();
    this._borderConfig = g ? this._sanitiseBorderMatrix() : {};
    const h = Object.assign(
      {},
      this.config().interaction,
      {
        directSortHighlight: {
          enabled: !0,
          sideEffects: { [Ao]: {} }
        },
        directSortSelect: {
          enabled: !0,
          propagate: !0,
          sideEffects: {
            [oo]: {},
            [Jg]: {}
          },
          target: {
            layer: {
              highlight: {
                sideEffects: {
                  "pivot-cell-highlighter": {}
                }
              }
            }
          }
        },
        directSortBtnHighlight: {
          enabled: !0,
          sideEffects: { [ao]: {} }
        },
        expandCollapse: {
          enabled: !0,
          sideEffects: {
            [ro]: {}
          }
        },
        ctrlClickOpen: {
          enabled: !0,
          sideEffects: {
            [co]: {}
          }
        },
        contextMenu: {
          enabled: !0,
          sideEffects: {
            [lo]: {}
          }
        }
      }
    );
    this.config({ interaction: h });
    const d = Object.keys(h).reduce(
      (f, C) => {
        const I = h[C].sideEffects;
        return f[C] = Object.keys(I).map((E) => ({
          name: E,
          ...I[E]
        })), f;
      },
      {}
    );
    this._firebolt.mapSideEffects(d, !1);
    const u = this._firebolt.actions().behavioural;
    Object.keys(u).forEach((f) => {
      h[f] && h[f].enabled ? u[f].enable() : u[f].disable();
    });
  }
  generateMatrices({
    axesInfo: t,
    headers: i,
    facets: n,
    rowFacetsConfig: s,
    columnSubTotalsConfig: A,
    facetFormatters: o,
    facetHyperLinkFormatters: a,
    childEventManagerCreator: r,
    canvasActions: l
  }) {
    this._canvasHelpers = l, this._facetFields = n.rowFacets, this._axisFields = t.axisFields, this._eventManager = r;
    const { leftAxisInfo: c, rightAxisInfo: g } = t.rowAxisInfo, h = this.getAxesInfos([c, g], i);
    t.rowAxisInfo.leftAxisInfo = h[0], t.rowAxisInfo.rightAxisInfo = h[1], this.generateAxes(t, r);
    const { sanitizeCheckBorder: d } = this.config(), u = this.getHeaderKeys(
      i,
      n,
      o,
      a
    );
    M1(
      this,
      s,
      A
    ), this.generateHeaders(u, n, s), this._mergedMatrices = this.merge(), this._borderConfig = d ? this._sanitiseBorderMatrix() : {};
    const f = Object.assign(
      {},
      this.config().interaction,
      {
        directSortHighlight: {
          enabled: !0,
          sideEffects: { [Ao]: {} }
        },
        directSortSelect: {
          enabled: !0,
          propagate: !0,
          sideEffects: {
            [oo]: {},
            [Jg]: {}
          },
          target: {
            layer: {
              highlight: {
                sideEffects: {
                  "pivot-cell-highlighter": {}
                }
              }
            }
          }
        },
        directSortBtnHighlight: {
          enabled: !0,
          sideEffects: { [ao]: {} }
        },
        expandCollapse: {
          enabled: !0,
          sideEffects: {
            [ro]: {}
          }
        },
        ctrlClickOpen: {
          enabled: !0,
          sideEffects: {
            [co]: {}
          }
        },
        contextMenu: {
          enabled: !0,
          sideEffects: {
            [lo]: {}
          }
        }
      }
    );
    this.config({ interaction: f });
    const C = Object.keys(f).reduce(
      (E, B) => {
        const m = f[B].sideEffects;
        return E[B] = Object.keys(m).map((p) => ({
          name: p,
          ...m[p]
        })), E;
      },
      {}
    );
    this._firebolt.mapSideEffects(C, !1);
    const I = this._firebolt.actions().behavioural;
    Object.keys(I).forEach((E) => {
      f[E] && f[E].enabled ? I[E].enable() : I[E].disable();
    });
  }
  getAxesInfos(t, i) {
    return t.map((n) => n.map((s, A) => ({
      ...s,
      metaInf: {
        sourceType: wt(
          Z(s, "config", "sourceType"),
          gn
        ),
        facets: wt(Z(i[A], "keys"), []).map(
          (o, a) => ({
            field: this._facetFields[a],
            value: ke(o) ? o.rawValue : o,
            sourceType: ke(o) ? o.sourceType : gn
          })
        )
      }
    })));
  }
  getHeaderKeys(t, i, n, s) {
    return t.map(({ keys: A, config: o, ...a }) => ({
      keys: A.map((r, l, c) => {
        let g, h, d, u = gn, f;
        ke(r) ? (g = r.value, h = r.format, d = r.key, u = r.sourceType, f = r.rawValue) : (g = r, h = n.row, d = `${i.rowFacets[l]}-${r}`, f = r);
        const C = ZI(
          g,
          i.rowFacets[l],
          h,
          c.slice(0, l + 1).map((E, B) => {
            const m = i.rowFacets[B];
            let p = ke(E) ? E.value : E;
            return {
              field: m,
              value: p,
              sourceType: u
            };
          }),
          { rawValue: f }
        ), I = A1(
          C,
          i.rowFacets[l],
          s.row
        );
        return {
          ...C,
          key: d,
          sourceType: u,
          hyperlinkInfo: I
        };
      }),
      config: o,
      ...a
    }));
  }
  _sanitiseBorderMatrix() {
    const { leftMatrix: t, rightMatrix: i } = this.getMergedMatrices(), {
      cellRegistry: { BlankCell: n }
    } = this._dependencies, { renderer: s } = this.config();
    let A = {};
    return i.length && (A = W0(
      i,
      `${oi}`,
      n,
      { renderer: s }
    )), t.length && (A = W0(t, `${Je}`, n, {
      renderer: s
    })), A;
  }
  getPriority() {
    const t = this._matrices.axes, { left: i, right: n } = t._cells;
    let s = n.length ? 1 : -1;
    return i.length && s++, s;
  }
  merge() {
    const { headers: t, axes: i } = this._matrices, { left: n, right: s } = t._cells, { left: A, right: o } = i._cells, a = v0(
      n,
      A.map((l) => [l])
    ), r = v0(
      o.map((l) => [l]),
      s
    );
    return {
      leftMatrix: a,
      rightMatrix: r
    };
  }
  getMergedMatrices() {
    return this._mergedMatrices;
  }
  getBorderConfig() {
    return this._borderConfig;
  }
  getAxes() {
    const { left: t, right: i } = this._matrices.axes._cells;
    return [
      ...t.map((n) => n.source()).filter((n) => n),
      ...i.map((n) => n.source()).filter((n) => n)
    ];
  }
  getLeftAxes() {
    const { left: t } = this._matrices.axes._cells;
    return t;
  }
  getRightAxes() {
    return this._matrices.axes._cells.right;
  }
  clear() {
    super.clear();
    const { axes: t, headers: i } = this._matrices;
    t.clear(), i.clear(), this._borderConfig = {}, this._mergedMatrices = { leftMatrix: [], rightMatrix: [] };
  }
  matrices() {
    return this._matrices;
  }
  getFacetFields() {
    return this._facetFields;
  }
  getAxisFields() {
    return this._axisFields;
  }
  getDefaultTargetContainer() {
    return ".muze-grid-center-1, .muze-grid-top-1, .muze-grid-top-3, .muze-grid-center-3, .muze-grid-bottom-1";
  }
  mount() {
    return this.parentContainerInf().el;
  }
  sourceCanvas() {
    return this.config().sourceCanvasAlias;
  }
  data() {
    return null;
  }
  id() {
    return "row-matrix";
  }
  parentContainerInf(...t) {
    return t.length ? (this._parentContainerInf = t[0], this) : this._parentContainerInf;
  }
  updateColumnWidths(t) {
    this._canvasHelpers.updateColumnWidths(t, "rows");
  }
  mapActionsAndBehaviour() {
    const t = this._firebolt._actionBehaviourMap, i = {};
    for (let n in t) {
      const s = t[n].behaviours, A = this._firebolt._actions.behavioural;
      s.some(
        (a) => A[a]._enabled
      ) && (i[n] = {
        ...t[n],
        behaviours: []
      });
    }
    Object.keys(i).length && this._firebolt.mapActionsAndBehaviour(null, i);
  }
  directSortResetter(...t) {
    return t.length ? (this._directSortResetter = t[0], this) : this._directSortResetter;
  }
  resetDirectSort() {
    const t = this.directSortResetter();
    t && t();
  }
}
function eC(e, t) {
  if (t)
    for (let i = 0; i < e.length; i++)
      i !== 0 ? e[i].config({
        externalClassname: [`${Vi}`]
      }) : e[i].config({
        externalClassname: [`${eA}-${Je}`, `${Vi}`]
      });
  else
    for (let i = 0; i < e.length; i++)
      for (let n = 0; n < e[0].length; n++)
        e[i][n].config({
          externalClassname: [`${Vi}`]
        });
}
class a7 extends qs {
  constructor(...t) {
    super(...t), this._mergedMatrices = { topMatrix: [], bottomMatrix: [] }, this._matrices = {
      headers: new TW(this._dependencies),
      axes: new HW(this._dependencies)
    }, this._titles = null, this._titleFields = null, this._facetFields = null, this._axisFields = null, this._className = "column-header", this._firebolt = new y1(
      this,
      {
        behavioural: {
          resize: p1,
          headerTooltip: Q1,
          directSortHighlight: w1,
          directSortSelect: D1,
          directSortBtnHighlight: x1,
          expandCollapse: b1,
          contextMenu: N1,
          ctrlClickOpen: G1
        },
        physical: {
          columnDrag: f1,
          columnHeaderHover: I1,
          directSortHover: C1,
          directSortClick: E1,
          directSortBtnHover: m1,
          expandCollapseClick: S1,
          contextMenuClick: F1,
          ctrlClick: T1
        },
        physicalBehaviouralMap: {
          columnDrag: {
            behaviours: ["resize"]
          },
          columnHeaderHover: {
            behaviours: ["headerTooltip"]
          },
          directSortHover: {
            behaviours: ["directSortHighlight"]
          },
          directSortClick: {
            behaviours: ["directSortSelect"]
          },
          directSortBtnHover: {
            behaviours: ["directSortBtnHighlight"]
          },
          expandCollapseClick: {
            behaviours: ["expandCollapse"]
          },
          contextMenuClick: {
            behaviours: ["contextMenu"]
          },
          ctrlClick: {
            behaviours: ["ctrlClickOpen"]
          }
        }
      },
      {
        [GB]: l1,
        [LB]: g1,
        [Ao]: h1,
        [oo]: d1,
        [ao]: u1,
        [Kg]: t7,
        [ro]: _1,
        [lo]: v1,
        [co]: L1
      },
      {}
    );
  }
  generateColumnMatrixTitle() {
    const {
      columnVariables: t = [],
      axes: { globalConfig: i }
    } = this.config(), n = i.columns.headers.formatter, s = i.columns.headers, A = i.columns.facets, o = i.axes.x, a = this.getFacetFields().map((g) => g.toString()), r = this.getAxisFields().map((g) => g.toString()), l = t.reduce(
      (g, h = []) => [
        ...g,
        ...h.filter(
          // @todo: Filter only discrete and temporal fields to show header.
          (d) => {
            const u = wt(
              Z(s, "fields", d.toString()),
              ...(a || []).indexOf(d.toString()) >= 0 ? [Z(A, "fields", d.toString())] : [],
              ...(r || []).indexOf(d.toString()) >= 0 ? [Z(o, "fields", d.toString())] : []
            );
            return u && u.show === !1 ? !1 : (d.as() === "discrete" && d.toString() !== ht || d.subtype() === "temporal") && s.show;
          }
        )
      ],
      []
    );
    this._titleFields = l;
    const c = n(
      { fieldNames: l.map((g) => g.displayName()) },
      { context: this }
    );
    this._titles = Array.isArray(c) ? c : [c];
  }
  getColumnTitleFields() {
    return this._titleFields;
  }
  getColumnTexts() {
    return this._titles;
  }
  generateHeaders(t, i, n) {
    const s = this._matrices.headers, A = this.config();
    s.config({
      ...A.headers,
      facetsConfig: n,
      facetFields: i.colFacets,
      canvasHelpers: this._canvasHelpers,
      globalConfig: this.config().axes.globalConfig
    }), s.createPlaceHolders(t);
  }
  config(...t) {
    if (t.length) {
      const i = t[0], n = et({}, this._config, i);
      return this._config = n, this;
    }
    return this._config;
  }
  generateAxes(t, i) {
    const {
      axes: n,
      renderer: s,
      isBold: A,
      isColumnsCompact: o,
      tickFormat: a,
      show: r,
      firstSuppliedTextLayerInfo: l,
      fieldToShowInPercentage: c
    } = this.config(), g = this._matrices.axes;
    g.config({
      show: r,
      isBold: A,
      isCompact: o,
      tickFormat: a,
      renderer: s,
      firstSuppliedTextLayerInfo: l,
      fieldToShowInPercentage: c,
      ...n
    }), g.createPlaceHolders(
      t,
      i,
      c
    );
  }
  getAxesInfo(t, i) {
    return t.map((n) => n.map((s, A) => ({
      ...s,
      metaInf: {
        sourceType: wt(
          Z(s, "config", "sourceType"),
          gn
        ),
        facets: wt(Z(i[A], "keys"), []).map(
          (o, a) => ({
            field: this._facetFields[a],
            value: ke(o) ? o.rawValue : o,
            sourceType: ke(o) ? o.sourceType : gn
          })
        )
      }
    })));
  }
  getHeaderKeys(t, i, n, s) {
    return t.map(({ keys: A, config: o, ...a }) => ({
      keys: A.map((r, l, c) => {
        let g, h, d, u = gn, f;
        const C = c.slice(0, l + 1).map((I, E) => {
          const B = i.colFacets[E];
          let m = ke(I) ? I.value : I;
          return {
            field: B,
            value: m,
            sourceType: u
          };
        });
        if (ke(r))
          return g = r.value, h = r.format, d = r.key, u = r.sourceType, f = r.rawValue, {
            ...ZI(g, i.colFacets[l], h, C, {
              rawValue: f
            }),
            key: d,
            sourceType: u
          };
        {
          g = r, h = n.column, d = `${i.colFacets[l]}-${r}`, f = r;
          const I = ZI(
            g,
            i.colFacets[l],
            h,
            C,
            { rawValue: f }
          ), E = A1(
            I,
            i.colFacets[l],
            s.column
          );
          return {
            ...I,
            key: d,
            hyperlinkInfo: E,
            sourceType: u
          };
        }
      }),
      config: o,
      ...a
    }));
  }
  updateMatrices({
    axesInfo: t,
    headers: i,
    facets: n,
    colFacetsConfig: s,
    facetFormatters: A,
    facetHyperLinkFormatters: o
  }) {
    this._facetFields = n.colFacets, this._axisFields = t.axisFields;
    const { topAxisInfo: a, bottomAxisInfo: r } = t.columnAxisInfo, l = this.getAxesInfo([a, r], i);
    t.columnAxisInfo.topAxisInfo = l[0], t.columnAxisInfo.bottomAxisInfo = l[1], this._matrices.axes._cells.top.forEach((f) => {
      f.remove();
    }), this._matrices.axes._cells.bottom.forEach((f) => {
      f.remove();
    }), this._matrices.axes._cells.top.length = 0, this._matrices.axes._cells.bottom.length = 0, this.generateAxes(t, this._eventManager);
    const { sanitizeCheckBorder: c } = this.config();
    this._matrices.headers._cells.top.forEach((f) => {
      f.forEach((C) => {
        C.remove();
      });
    }), this._matrices.headers._cells.bottom.forEach((f) => {
      f.forEach((C) => {
        C.remove();
      });
    }), this._matrices.headers._cells.top.length = 0, this._matrices.headers._cells.bottom.length = 0;
    const g = this.getHeaderKeys(
      i,
      n,
      A,
      o
    );
    this.generateHeaders(g, n, s), this.generateColumnMatrixTitle(), this._mergedMatrices = this.merge(), c && this._sanitiseBorderMatrix();
    const h = Object.assign(
      {},
      this.config().interaction,
      {
        directSortHighlight: {
          enabled: !0,
          sideEffects: { [Ao]: {} }
        },
        directSortSelect: {
          enabled: !0,
          propagate: !0,
          sideEffects: {
            [oo]: {},
            [Kg]: {}
          },
          target: {
            layer: {
              highlight: {
                sideEffects: {
                  "pivot-cell-highlighter": {}
                }
              }
            }
          }
        },
        directSortBtnHighlight: {
          enabled: !0,
          sideEffects: { [ao]: {} }
        },
        expandCollapse: {
          enabled: !0,
          sideEffects: {
            [ro]: {}
          }
        },
        ctrlClickOpen: {
          enabled: !0,
          sideEffects: {
            [co]: {}
          }
        },
        contextMenu: {
          enabled: !0,
          sideEffects: {
            [lo]: {}
          }
        }
      }
    );
    this.config({ interaction: h });
    const d = Object.keys(h).reduce(
      (f, C) => {
        const I = h[C].sideEffects;
        return f[C] = Object.keys(I).map((E) => ({
          name: E,
          ...I[E]
        })), f;
      },
      {}
    );
    this._firebolt.mapSideEffects(d, !1);
    const u = this._firebolt.actions().behavioural;
    Object.keys(u).forEach((f) => {
      h[f] && h[f].enabled ? u[f].enable() : u[f].disable();
    });
  }
  generateMatrices({
    axesInfo: t,
    headers: i,
    facets: n,
    colFacetsConfig: s,
    rowSubTotalsConfig: A,
    facetFormatters: o,
    facetHyperLinkFormatters: a,
    childEventManagerCreator: r,
    canvasActions: l
  }) {
    this._eventManager = r, this._canvasHelpers = l, this._facetFields = n.colFacets, this._axisFields = t.axisFields;
    const { topAxisInfo: c, bottomAxisInfo: g } = t.columnAxisInfo, h = this.getAxesInfo([c, g], i);
    t.columnAxisInfo.topAxisInfo = h[0], t.columnAxisInfo.bottomAxisInfo = h[1], this.generateAxes(t, r);
    const { sanitizeCheckBorder: d } = this.config(), u = this.getHeaderKeys(
      i,
      n,
      o,
      a
    );
    M1(
      this,
      s,
      A
    ), this.generateHeaders(u, n, s), this.generateColumnMatrixTitle(), this._mergedMatrices = this.merge(), d && this._sanitiseBorderMatrix();
    const f = Object.assign(
      {},
      this.config().interaction,
      {
        directSortHighlight: {
          enabled: !0,
          sideEffects: { [Ao]: {} }
        },
        directSortSelect: {
          enabled: !0,
          propagate: !0,
          sideEffects: {
            [oo]: {},
            [Kg]: {}
          },
          target: {
            layer: {
              highlight: {
                sideEffects: {
                  "pivot-cell-highlighter": {}
                }
              }
            }
          }
        },
        directSortBtnHighlight: {
          enabled: !0,
          sideEffects: { [ao]: {} }
        },
        expandCollapse: {
          enabled: !0,
          sideEffects: {
            [ro]: {}
          }
        },
        ctrlClickOpen: {
          enabled: !0,
          sideEffects: {
            [co]: {}
          }
        },
        contextMenu: {
          enabled: !0,
          sideEffects: {
            [lo]: {}
          }
        }
      }
    );
    this.config({ interaction: f });
    const C = Object.keys(f).reduce(
      (E, B) => {
        const m = f[B].sideEffects;
        return E[B] = Object.keys(m).map((p) => ({
          name: p,
          ...m[p]
        })), E;
      },
      {}
    );
    this._firebolt.mapSideEffects(C, !1);
    const I = this._firebolt.actions().behavioural;
    Object.keys(I).forEach((E) => {
      f[E] && f[E].enabled ? I[E].enable() : I[E].disable();
    });
  }
  _sanitiseBorderMatrix() {
    const { topMatrix: t, bottomMatrix: i } = this.getMergedMatrices();
    t.length && eC(t), i.length && eC(i);
  }
  getPriority() {
    const t = this._matrices.axes, { top: i, bottom: n } = t._cells;
    let s = n.length ? 1 : -1;
    return i.length && s++, s;
  }
  merge() {
    const { cellRegistry: t } = this._dependencies, { headers: i, axes: n } = this._matrices, { top: s, bottom: A } = i._cells, o = [], a = (I) => {
      const E = new t.TextCell(
        {},
        { labelManager: this._dependencies.smartLabel }
      ).rawSource(al).source(al);
      return E.config({
        externalClassname: ["empty-column-cell-container"],
        className: "muze-empty-column-cell",
        fieldName: null,
        metaInf: {
          sourceType: I === "total" ? ye : gn,
          getDataPath: () => [
            {
              field: null,
              sourceType: I === "total" ? ye : gn,
              value: al
            }
          ]
        }
      }), E;
    };
    s && s.forEach((I) => {
      I.forEach((E, B) => {
        o[B] = o[B] || [], o[B].push(E);
      });
    });
    const { top: r, bottom: l } = n._cells;
    r.length && o.push(r);
    let c = [];
    l.length && c.push(l);
    const g = c.length;
    A && A.forEach((I) => {
      I.forEach((E, B) => {
        c[B + g] = c[B + g] || [], c[B + g].push(E);
      });
    });
    const { axes: h, rowHeadersConfig: d, renderer: u } = this.config(), f = !!(Object.keys(d.fields || {}).some(
      (I) => d.fields[I].show
    ) || d.show), C = h.globalConfig.columns.headers.position;
    if (!o.length && (f || u === "html") && C !== "bottom" && (o.push(
      c[0].map(
        (I) => a(I.source().config().metaInf.sourceType)
      )
    ), (!c.length || !c[0].length) && c.push([[new t.BlankCell()]])), (!c.length || !c[0].length) && (f || u === "html") && C === "bottom") {
      const I = f && C === "bottom" ? a() : new t.BlankCell();
      c.push([I]);
    }
    return {
      topMatrix: o,
      bottomMatrix: c
    };
  }
  getAxes() {
    const { top: t, bottom: i } = this._matrices.axes._cells;
    return [
      ...t.map((n) => n.source()).filter((n) => n),
      ...i.map((n) => n.source()).filter((n) => n)
    ];
  }
  getTopAxes() {
    const { top: t } = this._matrices.axes._cells;
    return t;
  }
  getBottomAxes() {
    return this._matrices.axes._cells.bottom;
  }
  getMergedMatrices() {
    return this._mergedMatrices;
  }
  matrices() {
    return this._matrices;
  }
  clear() {
    super.clear();
    const { axes: t, headers: i } = this._matrices;
    t.clear(), i.clear(), this._titles = null, this._titleFields = null, this._mergedMatrices = { topMatrix: [], bottomMatrix: [] };
  }
  getFacetFields() {
    return this._facetFields;
  }
  getAxisFields() {
    return this._axisFields;
  }
  getDefaultTargetContainer() {
    return ".muze-grid-top-2, .muze-grid-bottom-2, .muze-composite-columnHeader-cell";
  }
  mount() {
    return this.parentContainerInf().el;
  }
  sourceCanvas() {
    return this.config().sourceCanvasAlias;
  }
  data() {
    return null;
  }
  id() {
    return "column-matrix";
  }
  parentContainerInf(...t) {
    return t.length ? (this._parentContainerInf = t[0], this) : this._parentContainerInf;
  }
  updateColumnWidths(t) {
    this._canvasHelpers.updateColumnWidths(t, "columns");
  }
  mapActionsAndBehaviour() {
    const t = this._firebolt._actionBehaviourMap, i = {};
    for (let n in t) {
      const s = t[n].behaviours, A = this._firebolt._actions.behavioural;
      s.some(
        (a) => A[a]._enabled
      ) && (i[n] = {
        ...t[n],
        behaviours: []
      });
    }
    Object.keys(i).length && this._firebolt.mapActionsAndBehaviour(null, i);
  }
  getPreviousAxisElem({ cell: t, axisElem: i }) {
    let n;
    if (i.previousElementSibling === null) {
      const { top: s, bottom: A } = this._matrices.axes._cells;
      [s, A].forEach((o) => {
        const a = o.findIndex((r) => r === t);
        if (a > 0) {
          const r = o[a - 1];
          n = r ? r.source().getLastTickElement() : null;
        }
      });
    } else
      n = i.previousElementSibling;
    return n;
  }
  directSortResetter(...t) {
    return t.length ? (this._directSortResetter = t[0], this) : this._directSortResetter;
  }
  resetDirectSort() {
    const t = this.directSortResetter();
    t && t();
  }
}
const q0 = (e, t, i, n, s, { type: A, subtype: o }) => {
  const a = o[0] ? zn(o[0]) ? null : o[0] : null, r = o[1] ? zn(o[1]) ? null : o[1] : null;
  !e[t] && (e[t] = {
    type: i,
    fieldType: A,
    fieldSubType: {
      primary: a,
      secondary: r
    },
    domains: []
  });
  const l = s[0] ? zn(s[0]) ? null : s[0] : null, c = s[1] ? zn(s[1]) ? null : s[1] : null;
  e[t].domains.push({
    primary: {
      field: l,
      domain: n[`${s[0]}`] || []
    },
    secondary: {
      field: c,
      domain: n[`${s[1]}`] || []
    }
  });
}, j0 = (e) => {
  const t = {};
  return e.forEach((i) => {
    i.forEach(({ dataStore: n }) => {
      n.getTemporalFields().forEach((s) => {
        const A = n.getFieldData(s);
        if (A.length) {
          let o = n.getField(s).minimumConsecutiveDifference();
          (o === 0 || Number.isNaN(o)) && (o = A[0]), t[s] = Math.min(
            t[s] || 1 / 0,
            o
          );
        }
      });
    });
  }), t;
}, r7 = (e, t, i) => {
  let n = [];
  return e.length > t && (n = n.concat(e.splice(t))), e[0].length > i && e.forEach((s, A) => {
    n = n.concat(e[A].splice(i));
  }), n;
}, z0 = [`${Vi}-${oi}`], nd = [`${Hh}`], $0 = nd.concat(`${_a}-${Pe}`), X0 = nd.concat(`${_a}-${Ee}`);
class l7 extends qs {
  constructor(...t) {
    super(...t), this._matrix = [], this._cellMap = [], this._rootMatrixInfo = null, this._totalsData = null, this._layerDomains = null;
  }
  _createVisualUnit({
    rowIndex: t,
    columnIndex: i,
    timeDiffObj: n,
    renderer: s,
    dataStore: A,
    axisFields: o,
    xAxes: a,
    yAxes: r,
    unitConfig: l,
    theme: c,
    layerConfig: g,
    facets: h,
    metaInfo: d,
    colFacets: u,
    rowFacets: f,
    layerDataModels: C,
    layerDomainsById: I,
    columnTotalString: E,
    rowTotalString: B
  }, m, p, w) {
    const {
      store: Q,
      throwback: y,
      smartLabel: D,
      layerRegistry: _,
      VisualUnit: x,
      DataStore: S
    } = this._dependencies, { interactions: b } = this.config(), { alias: R, coord: G, valueParser: T, retinalConfig: v, fireboltDeps: H } = this.config(), N = `unit${t}-${i}-${Zt()}`;
    m || (m = x.create(
      { layerRegistry: _, interactions: b },
      {
        DataStore: S,
        throwback: y,
        smartLabel: D,
        fireboltDeps: H,
        canvasActions: w
      },
      p
    ), m.metaInf({
      colIndex: i,
      rowIndex: t,
      namespace: N
    }), m.createFireboltInstance());
    const M = Object.values(f).filter(
      ($) => $ !== Mn
    ), F = Object.values(u).filter(
      ($) => $ !== Mn
    ), k = M.length ? this._canvasActions.getRowCollapseState(M) : !1, O = F.length ? this._canvasActions.getColumnsCollapseState(F) : !1;
    m.store(Q).coord(G).parentAlias(R).valueParser(T).coord(G).renderer(s).metaInf({
      ...m.metaInf(),
      totals: d.totals,
      timeDiffObj: n,
      ...d,
      includeTotalDomain: this.config().visualGroupConfig.legend.includeTotalDomain,
      colFacets: u,
      rowFacets: f,
      isRowCollapsed: k,
      isColCollapsed: O,
      isCollapsed: k || O,
      columnTotalString: E,
      rowTotalString: B
    }).retinalFields(v);
    const { retinalAxes: P, detailFields: L, dataModelTransform: q } = this.config();
    return l.theme = c, m.clearCaching().clearCustomLayerData().clearCachedLayerData().lockLocalModel().data(A).config(l).layerDef(g).layerDataModels(C).layerDomains(I).fields({ x: o.x, y: o.y }).transform(q).detailFields(L).facetByFields(h.data).facetSchema(h.schema).axes(Object.assign({ x: a, y: r }, P)).unlockLocalModel();
  }
  _createGeomCell({ visualUnit: t }, i) {
    const { GeomCell: n } = this._dependencies.cellRegistry;
    return i || (i = new n()), i.source(t);
  }
  _updateMatrixUsingUpdateInfo(t) {
    const [i, n] = t.exitSet;
    let s = [];
    i[0] !== -1 && i[1] !== -1 && (this._matrix.splice(i[0], i[1] - i[0] + 1), s = this._cellMap.splice(
      i[0],
      i[1] - i[0] + 1
    )), n[0] !== -1 && n[1] !== -1 && this._matrix.forEach((A, o) => {
      this._matrix[o].splice(
        n[0],
        n[1] - n[0] + 1
      ), s = s.concat(
        this._cellMap[o].splice(
          n[0],
          n[1] - n[0] + 1
        )
      );
    }), this.removeExitCells(s);
  }
  updateMatrix({
    axes: t,
    borderConfig: i,
    dataModelMatrix: n,
    facets: { rowFacets: s, colFacets: A },
    rootMatrixInfo: o,
    paginatedMatrixInfo: a,
    rootGroupedData: r,
    canvasActions: l,
    updateInfo: c,
    facetType: g,
    paginated: h,
    targetPath: d,
    subTotalsInfo: { rowSplitSubtotalsField: u, colSplitSubtotalsField: f }
  } = {
    isColSubTotalsEnabled: !1,
    isRowSubTotalsEnabled: !1,
    rowSplitSubtotalsField: void 0,
    colSplitSubtotalsField: void 0,
    rowSubTotalsDS: null,
    colSubTotalsDS: this._columnSubTotalsDataModel
  }) {
    const { store: C } = this._dependencies;
    this._rootMatrixInfo = o, this._paginatedMatrixInfo = a, this._rootGroupedData = r;
    const I = A.concat(s);
    C.lockModel();
    const E = j0(n);
    this._updateMatrixUsingUpdateInfo(c);
    const B = this.getUpdatedMatrixFromCoordinates(
      c.updateSet,
      n,
      I,
      t,
      i,
      l,
      E,
      s,
      A,
      h
    );
    let m = [];
    if (g === "row") {
      const Q = d.find(
        ({ field: D }) => D === u
      ) ? -1 : s.map((D) => `${D}`).indexOf(u), y = Q >= 0 ? c.splitFieldUniques : [];
      if (this._matrix.splice(
        c.updateSet[0][0],
        Q >= 0 && d.length != s.length ? y.length : 1,
        ...B.map((D) => D.map((_) => _))
      ), m = this._cellMap.splice(
        c.updateSet[0][0],
        Q >= 0 && d.length != s.length ? y.length : 1,
        ...B.map((D) => D.map((_) => _))
      ), c.entrySet.length && h) {
        const D = this.getUpdatedMatrixFromCoordinates(
          c.entrySet,
          n,
          I,
          t,
          i,
          l,
          E,
          s,
          A,
          h
        );
        this._matrix.splice(c.entrySet[0][0], 0, ...D), this._cellMap.splice(
          c.entrySet[0][0],
          0,
          ...D.map((_) => _.map((x) => x))
        );
      }
    } else if (g === "column") {
      const Q = d.find(
        ({ field: D }) => D === f
      ) ? -1 : A.map((D) => `${D}`).indexOf(f), y = Q >= 0 ? c.splitFieldUniques : [];
      this._matrix.forEach((D, _, x) => {
        x[_].splice(
          c.updateSet[0][1],
          Q >= 0 && d.length != A.length ? y.length : 1,
          ...B[_]
        ), m = m.concat(
          this._cellMap[_].splice(
            c.updateSet[0][1],
            Q >= 0 && d.length != A.length ? y.length : 1,
            ...B[_]
          )
        );
      });
    }
    const { retinalAxes: p } = this.config(), w = c.updateSet.reduce((Q, y) => (Q.set(`${y[0]}-${y[1]}`, !0), Q), /* @__PURE__ */ new Map());
    this._matrix.forEach((Q, y) => {
      Q.forEach((D, _) => {
        if (!w.has(`${y}-${_}`)) {
          if (D.source().lockLocalModel(), D.source().metaInf({
            ...D.source().metaInf(),
            colIndex: _,
            rowIndex: y,
            namespace: `unit${y}-${_}-${Zt()}`
          }), D.source().axes(
            Object.assign(
              {
                x: [t.x.top[_], t.x.bottom[_]].filter(
                  (x) => x
                ),
                y: [t.y.left[y], t.y.right[y]].filter(
                  (x) => x
                )
              },
              p
            )
          ), i[y]) {
            const x = this._matrix[y - 1][_], S = x.config(), R = {
              externalClassname: (x.config().externalClassname ?? []).concat(
                `${Vi}-${Ee}`
              )
            };
            x.config(Object.assign({}, S, R));
          }
          D.source().unlockLocalModel({
            skipAttachLayerData: !0,
            skipLayerFireboltCreation: !0
          });
        }
      });
    }), C.unlockModel(), m.length && this.removeExitCells(m);
  }
  getUpdatedMatrixFromCoordinates(t, i, n, s, A, o, a, r, l, c) {
    const {
      renderer: g,
      unitConfig: h,
      sanitizeCheckBorder: d,
      theme: u,
      columnTotalString: f,
      rowTotalString: C
    } = this.config(), I = [];
    let E = -1, B = -1;
    return t.forEach(([m, p]) => {
      const {
        rowFacetValues: w,
        columnFacetValues: Q,
        rowProjections: y,
        columnProjections: D,
        metaInfo: _ = {},
        layerConfig: x,
        layerDomainsById: S
      } = i[m][p];
      let { dataStore: b, layerDataModels: R } = i[m][p];
      c || (b = ed(b, b)), R = Object.keys(R).reduce((P, L) => (P[L] = ed(R[L], b), P), {}), E !== m && (E = m, B += 1);
      const G = Q.concat(w), T = m === 0, { length: v } = i, H = m === v - 1, N = i[m].length, M = p === N - 1, F = this._createVisualUnit(
        {
          renderer: g,
          rowIndex: m,
          columnIndex: p,
          layerConfig: x,
          layerDataModels: R,
          layerDomainsById: S,
          timeDiffObj: a,
          metaInfo: _,
          dataStore: b,
          facets: {
            data: [n, G],
            schema: n.map((P) => b.getField(`${P}`).schema())
          },
          colFacets: l.reduce((P, L, q) => (P[L] = Q[q], P), {}),
          rowFacets: r.reduce((P, L, q) => (P[L] = w[q], P), {}),
          // rowFacets,
          axisFields: {
            x: D,
            y
          },
          unitConfig: h,
          theme: u,
          // Note: The order of the axes being passed matter. For x-axes,
          // first top, then bottom. For y-axes, first left and then right.
          xAxes: [s.x.top[p], s.x.bottom[p]].filter(
            (P) => P
          ),
          yAxes: [s.y.left[m], s.y.right[m]].filter(
            (P) => P
          ),
          columnTotalString: f,
          rowTotalString: C
        },
        null,
        this._childEventManagerCreator(),
        o
      ), k = this._createGeomCell(
        {
          visualUnit: F
        },
        null
      ), O = () => {
        let P = [];
        return d && (P = nd, T ? P = $0 : H && g === "svg" && (P = X0), M && (P = P.concat(z0))), P;
      };
      I[B] || (I[B] = []), I[B].push(
        k.config(
          Object.assign({}, h, {
            externalClassname: O()
          })
        )
      );
    }), I;
  }
  generateMatrix({
    axes: t,
    borderConfig: i,
    dataModelMatrix: n,
    facets: { rowFacets: s, colFacets: A },
    childEventManagerCreator: o,
    totalsData: a,
    rootMatrixInfo: r,
    paginatedMatrixInfo: l,
    rootGroupedData: c,
    canvasActions: g
  }) {
    const { store: h } = this._dependencies;
    this._totalsData = a, this._rootMatrixInfo = r, this._paginatedMatrixInfo = l, this._rootGroupedData = c, this._canvasActions = g, this._childEventManagerCreator = o;
    const {
      renderer: d,
      unitConfig: u,
      sanitizeCheckBorder: f,
      theme: C,
      columnTotalString: I,
      rowTotalString: E
    } = this.config(), B = A.concat(s);
    h.lockModel();
    const m = j0(n), p = n.map((Q, y) => (this._cellMap[y] || (this._cellMap[y] = []), Q.map(
      ({
        rowFacetValues: D,
        columnFacetValues: _,
        rowProjections: x,
        columnProjections: S,
        metaInfo: b = {},
        dataStore: R,
        layerDataModels: G,
        layerConfig: T,
        layerDomainsById: v
      }, H) => {
        const N = _.concat(D);
        let M = this._cellMap?.[y]?.[H];
        const F = this._createVisualUnit(
          {
            renderer: d,
            rowIndex: y,
            columnIndex: H,
            layerConfig: T,
            layerDataModels: G,
            layerDomainsById: v,
            timeDiffObj: m,
            metaInfo: b,
            dataStore: R,
            facets: {
              data: [B, N],
              schema: B.map((k) => R.getField(`${k}`).schema())
            },
            colFacets: A.reduce((k, O, P) => (k[O] = _[P], k), {}),
            rowFacets: s.reduce((k, O, P) => (k[O] = D[P], k), {}),
            // rowFacets,
            axisFields: {
              x: S,
              y: x
            },
            unitConfig: u,
            theme: C,
            // Note: The order of the axes being passed matter. For x-axes,
            // first top, then bottom. For y-axes, first left and then right.
            xAxes: [
              t.x.top[H],
              t.x.bottom[H]
            ].filter((k) => k),
            yAxes: [t.y.left[y], t.y.right[y]].filter(
              (k) => k
            ),
            columnTotalString: I,
            rowTotalString: E
          },
          M ? M.source() : null,
          o(),
          g
        );
        return M = this._createGeomCell(
          {
            visualUnit: F
          },
          M
        ), this._cellMap[y][H] = M, M;
      }
    )));
    this._matrix = p.map((Q, y, D) => {
      const _ = y === 0, { length: x } = D, S = y === x - 1;
      return Q.map((b, R, { length: G }) => {
        const T = R === G - 1, v = () => {
          let H = [];
          if (f && (H = nd, _ ? H = $0 : S && d === "svg" && (H = X0), T && (H = H.concat(z0)), i[y])) {
            const N = D[y - 1][R], M = N.config(), k = {
              externalClassname: N.config().externalClassname.concat(
                `${Vi}-${Ee}`
              )
            };
            N.config(Object.assign({}, M, k));
          }
          return H;
        };
        return b.config(
          Object.assign({}, u, {
            externalClassname: v()
          })
        );
      });
    });
    const w = r7(
      this._cellMap,
      this._matrix.length,
      this._matrix?.[0]?.length
    );
    h.unlockModel(), w.length && this.removeExitCells(w);
  }
  removeExitCells(t) {
    t.forEach((i) => {
      Array.isArray(i) ? i.forEach((n) => {
        n.source().eventManager().remove(), n.source()._eventManager = null, n.remove();
      }) : (i?.source()?.eventManager()?.remove(), i && (i.source()._eventManager = null), i?.remove());
    });
  }
  forEach(t) {
    const i = this._matrix;
    i && i.forEach((n, s) => {
      n.forEach((A, o) => {
        t(A, s, o);
      });
    });
  }
  /**
   * Returns an array of x and y axis domains
   *
   * {
   *    x: [
   *      // Domains of the first column index
   *      {
   *          type: 'linear',
   *          domains: [
   *              {
   *                  primary: {
   *                      field: fieldInst,
   *                      domain: [0, 100]
   *                  },
   *                  secondary: {
   *                      field: fieldInst,
   *                      domain: [0, 200]
   *                  }
   *              },
   *          ]
   *      }
   *    ],
   *    y: []
   * }
   */
  getXYDomains(t = {}) {
    const i = [], n = [], s = this._paginatedMatrixInfo, { completeDataModelMatrix: A } = s, o = this._rootMatrixInfo, { leftAxisInfo: a } = t.unionAxisDomainPerPage ? s.allRowAxisInfo : o.allRowAxisInfo, { topAxisInfo: r, bottomAxisInfo: l } = o.allColumnAxisInfo;
    for (let d = 0; d < r.length; d++) {
      const { field: u } = r[d], { field: f } = l[d];
      a.forEach((C, I) => {
        const { layerConfig: E, dataStore: B, layerDomainsById: m } = t.unionAxisDomainPerPage ? s.dataModelMatrix[I][d] : A[I][d], p = u && u.getMembers().every((Q) => B.getField(Q)) ? ua(E, m, {
          field: u,
          encoding: "x"
        }) : [], w = f && f.getMembers().every((Q) => B.getField(Q)) ? ua(E, m, {
          field: f,
          encoding: "x"
        }) : [];
        q0(
          n,
          d,
          u.as(),
          {
            [u]: p,
            [f]: w
          },
          [u, f],
          {
            type: u.type(),
            subtype: [u.subtype(), f?.subtype()]
          }
        );
      });
    }
    const c = t.calculateUniformAxisDomains && !t.unionAxisDomainPerPage, g = c ? o.allRowAxisInfo.leftAxisInfo : s.allRowAxisInfo.leftAxisInfo, h = c ? o.allRowAxisInfo.rightAxisInfo : s.allRowAxisInfo.rightAxisInfo;
    for (let d = 0; d < g.length; d++) {
      const { field: u } = g[d], { field: f } = h[d];
      l.forEach((C, I) => {
        const { layerConfig: E, dataStore: B, layerDomainsById: m } = c ? s.completeDataModelMatrix[d][I] : s.dataModelMatrix[d][I], p = u && u.getMembers().every((Q) => B.getField(Q)) ? ua(E, m, {
          field: u,
          encoding: "y"
        }) : [], w = f && f.getMembers().every((Q) => B.getField(Q)) ? ua(E, m, {
          field: f,
          encoding: "y"
        }) : [];
        q0(
          i,
          d,
          u.as(),
          {
            [u]: p,
            [f]: w
          },
          [u, f],
          {
            type: u.type(),
            subtype: [u.subtype(), f?.subtype()]
          }
        );
      });
    }
    return {
      x: n,
      y: i
    };
  }
  count() {
    let t = 0;
    return this.forEach(() => {
      t++;
    }), t;
  }
  getMatrix() {
    return this._matrix;
  }
  findPlaceHolderById(t) {
    let i = null;
    return this.forEach((n) => {
      n.source().id() === t && (i = n.source());
    }), i;
  }
  getAllDataModelIds() {
    const t = [];
    return this.forEach((i) => {
      t.push(i.source().data().id());
    }), t;
  }
  getUnits() {
    const t = [];
    return this.forEach((i) => {
      t.push(i.source());
    }), t;
  }
  findUnitByPayload(t) {
    let i;
    if (t.sourceInfo && t.sourceInfo.unitId) {
      if (t.sourceInfo.unitRowIndex !== void 0 && t.sourceInfo.unitColIndex !== void 0)
        return this._cellMap[t.sourceInfo.unitRowIndex][t.sourceInfo.unitColIndex].source();
      const n = this.findPlaceHolderById(t.sourceInfo.unitId);
      if (n)
        return n;
    } else {
      const n = t.facets || {}, s = Object.keys(n);
      this.forEach((A) => {
        const o = A.source(), a = o.facetFieldsMap();
        s.every((r) => n[r] === a[r]) && (i = o);
      });
    }
    return i = i || this.getUnits()[0], i;
  }
  findCellsByFacets(t) {
    const i = [];
    return this.forEach((n) => {
      const A = n.source().facetFieldsMap();
      Object.keys(t).every(
        (a) => A[a] === t[a]
      ) && i.push(n);
    }), i;
  }
  findCellsByFacetsAndAxis({ facets: t = {}, axis: i = {} }) {
    return this.findCellsByFacets(t).filter((s) => {
      const A = s.source();
      return Object.keys(i).every((o) => {
        const a = A.axes()[o];
        return i[o] === a[0].config().field || i[o] === (a[1] && a[1].config().field);
      });
    });
  }
  getRetinalFieldsDomain(t = {}) {
    let i = {};
    const n = this._paginatedMatrixInfo, { completeDataModelMatrix: s, dataModelMatrix: A } = n, { unionAxisDomainPerPage: o } = this.config().visualGroupConfig.pagination, a = [];
    return (o ? A : s).forEach((l) => {
      l.forEach((c) => {
        const { layerConfig: g, layerDataModels: h } = c, d = g.map((u) => [u.def].flat().map((f) => {
          const C = h[f.id], { encoding: I } = f;
          return en.getLayerClass(f.mark).getRetinalFieldsDomain(
            C,
            I,
            {
              config: t
            },
            this._rootGroupedData
          );
        })).flat().filter((u) => u !== null);
        a.push(Eh(d));
      });
    }), i = Eh(a), i;
  }
  clear() {
    super.clear(), this._matrix = [], this._cellMap = [];
  }
  parentContainerInf(...t) {
    if (t.length) {
      this._parentContainerInf = t[0];
      const { el: i, dimensions: n } = t[0];
      return this.forEach((s) => {
        s.valueOf().parentContainerInf({
          el: i,
          dimensions: n
        });
      }), this;
    }
    return this._parentContainerInf;
  }
}
function c7(e, t, i) {
  let n = "";
  if (e = e.filter((s) => !zn(s)), t === i - 1 && e.length > i) {
    for (let s = t; s < e.length - 1; s++)
      n += `${e[s].displayName()} / `;
    return n += e[e.length - 1].displayName(), n;
  } else if (e[t])
    return e[t].displayName();
  return "";
}
function Z0(e = [], t = [], {
  classPrefix: i,
  sanitizeCheckBorder: n,
  textAlign: s = "center",
  dependencies: A,
  renderer: o,
  isDummyFieldFoundInAxis: a
}, r = {}) {
  const { charsAcross: l, charsAlong: c } = r, g = e.length > 0 ? e.map((h, d, u) => {
    const f = g7(h, t[d]), I = u.slice(0, d + 1).map((Q) => ({
      field: Q.type === "axis" ? Q.source().config().field : Q.config().fieldName,
      sourceType: gn
    })), {
      smartLabel: E,
      cellRegistry: { TextCell: B, BlankCell: m }
    } = A;
    if (a)
      return new m();
    r.show = r.show === null ? o === "html" : !!r.show;
    let p = {};
    if (r.fields) {
      if (p = r.fields[t[d] ? t[d].toString() : {}] || {}, p.show = p.show === !0 ? !0 : p.show === !1 ? !1 : r.show, p.show === !1)
        return new m().config({
          type: Lh,
          fieldName: h.type === "axis" ? h.source().config().field : h.config().fieldName,
          metaInf: {
            getDataPath: () => I,
            sourceType: gn
          }
        });
    } else if (!r.show)
      return new m();
    const w = c7(t, d, e.length);
    return new B(
      {
        ...NW[r.position === Pe ? Pe : Ee],
        verticalAlign: r.position === Ee ? Pe : "middle",
        textAlign: s,
        type: Lh,
        className: `${i}-grid-headers ${r.className || ""} ${p.className || ""}`,
        metaInf: {
          getDataPath: () => I,
          sourceType: gn,
          sortStatus: f,
          directSortEnabled: h.type === "axis" ? h.source().config().fieldInstance.as() === ft.DISCRETE : !0
        },
        fieldName: h.type === "axis" ? h.source().config().field : h.config().fieldName
      },
      {
        labelManager: E
      }
    ).key(w).source(w).rawSource(w).config({
      show: h.config().show,
      numLines: { max: c.max, min: c.min },
      numChars: { max: l.max, min: l.min }
    });
  }) : [];
  return n && eC(g, !0), g;
}
function g7(e, t) {
  const i = e.type;
  if (i === "axis") {
    const { ordering: n } = e.source().config();
    return n && n.type === Ki.ALPHABETICAL_ORDER ? {
      sortInfo: n,
      targetField: {
        name: t.getMembers()[0]
      },
      metaInfo: {}
    } : null;
  } else if (i === "text") {
    const { ordering: n } = e.config();
    return n && n.type === Ki.ALPHABETICAL_ORDER ? {
      sortInfo: n,
      targetField: {
        name: t.getMembers()[0]
      },
      metaInfo: {}
    } : null;
  } else
    return null;
}
class h7 extends qs {
  constructor(...t) {
    super(...t), this._matrices = {
      topLeft: [],
      topRight: [],
      bottomLeft: [],
      bottomRight: []
    };
  }
  getMatrices() {
    return this._matrices;
  }
  generateMatrices({ leftMatrix: t, rightMatrix: i, topMatrix: n, bottomMatrix: s }) {
    const A = {}, {
      cellRegistry: { BlankCell: o }
    } = this._dependencies, {
      renderer: a,
      classPrefix: r,
      rowHeaders: l,
      sanitizeCheckBorder: c,
      rowHeadersConfig: g
      // rowFacetsConfig,
      // yAxisConfig,
      // rowFacetFields,
    } = this.config(), h = (Q, y, D) => {
      const x = D.slice(0, y + 1).map((S) => ({
        field: S.type === "axis" ? S.source().config().field : S.config().fieldName,
        sourceType: gn
      }));
      return new o().config({
        show: Q.config().show,
        type: Lh,
        metaInf: {
          getDataPath: () => x
        }
      });
    }, d = Z(l, 0, 0);
    let u = !1;
    d && (u = d.getMembers().includes(ht));
    const f = l, C = {
      left: Z0(
        t[0],
        f[0],
        {
          classPrefix: r,
          sanitizeCheckBorder: c,
          textAlign: g.align ? g.align : "start",
          dependencies: this._dependencies,
          renderer: a,
          isDummyFieldFoundInAxis: u
        },
        g
      ),
      right: Z0(
        i[0],
        f[1],
        {
          classPrefix: r,
          sanitizeCheckBorder: c,
          textAlign: g.align ? g.align : "start",
          dependencies: this._dependencies,
          renderer: a,
          isDummyFieldFoundInAxis: u
        },
        g
      )
    }, I = {
      left: t[0] != null ? t[0].map(h) : [],
      right: i[0] != null ? i[0].map(h) : []
    };
    let E, B, m, p, w;
    (w = n.length - s.length) > 0 ? Array(w).fill([]).map((Q) => {
      s.push(Q);
    }) : Array(-1 * w).fill([]).map((Q) => {
      n.push(Q);
    }), g.position === "bottom" ? (E = n.map(
      () => t[0] != null ? t[0].map(h) : []
    ), B = n.map(
      () => i[0] != null ? i[0].map(h) : []
    ), [m, p] = [Je, oi].map(
      (Q) => s.map((y, D) => D === 0 ? C[Q] : I[Q])
    )) : ([E, B] = [Je, oi].map(
      (Q) => n.map((y, D) => D === n.length - 1 ? C[Q] : I[Q])
    ), m = s.map(
      () => t[0] != null ? t[0].map(h) : []
    ), p = s.map(
      () => i[0] != null ? i[0].map(h) : []
    )), A.topLeft = E, A.topRight = B, A.bottomLeft = m, A.bottomRight = p, this._matrices = A;
  }
  clear() {
    super.clear(), this._matrices = {
      topLeft: [],
      topRight: [],
      bottomLeft: [],
      bottomRight: []
    };
  }
}
const d7 = (e, t) => {
  if (e.length !== t.length)
    return !1;
  const i = e.length;
  for (let n = 0; n < i; n++) {
    const s = e[n], A = t[n];
    if (s.field !== A.field || !Ml(s.value, A.value))
      return !1;
  }
  return !0;
};
class u7 extends qs {
  constructor(t) {
    super(t), this._matrices = {
      row: new o7(t),
      column: new a7(t),
      geom: new l7(t),
      headerTitle: new h7(t)
    }, this.registerDirectSortResets();
  }
  context(...t) {
    return t.length ? (this._context = t[0], this) : this._context;
  }
  updateMatrices({
    axesInfo: t,
    headers: i,
    dataModelMatrix: n,
    layerDomains: s,
    facets: A,
    rowFacetsConfig: o,
    colFacetsConfig: a,
    facetFormatters: r,
    facetHyperLinkFormatters: l,
    canvasActions: c,
    rootGroupedData: g,
    totalsData: h,
    rootMatrixInfo: d,
    paginatedMatrixInfo: u,
    updateInfo: f,
    facetType: C,
    paginated: I,
    targetPath: E,
    subTotalsInfo: B = {
      isColSubTotalsEnabled: !1,
      isRowSubTotalsEnabled: !1,
      rowSplitSubtotalsField: void 0,
      colSplitSubtotalsField: void 0,
      rowSubTotalsDS: null,
      colSubTotalsDS: this._columnSubTotalsDataModel
    }
  }) {
    this._paginatedMatrixInfo = u;
    const { x: m, y: p } = t, { rowKeys: w, columnKeys: Q } = i, y = this.config(), D = y.rows.axes.globalConfig, _ = T0(
      D.rows.headers,
      D.rows.facets,
      D.axes.y
    ), x = this._matrices.row, S = this._matrices.column;
    C === "row" ? x.updateMatrices({
      axesInfo: p,
      headers: w,
      facets: A,
      rowFacetsConfig: o,
      facetFormatters: r,
      facetHyperLinkFormatters: l
    }) : S.updateMatrices({
      axesInfo: m,
      headers: Q,
      facets: A,
      colFacetsConfig: a,
      facetFormatters: r,
      facetHyperLinkFormatters: l
    });
    const { bottom: b, top: R } = S._matrices.axes._cells, { left: G, right: T } = x._matrices.axes._cells, v = x.getBorderConfig();
    this._matrices.geom.updateMatrix({
      axes: {
        x: {
          bottom: b.map((O) => O.source()),
          top: R.map((O) => O.source())
        },
        y: {
          left: G.map((O) => O.source()),
          right: T.map((O) => O.source())
        }
      },
      facets: A,
      borderConfig: v,
      dataModelMatrix: n,
      layerDomains: s,
      rootGroupedData: g,
      totalsData: h,
      rootMatrixInfo: d,
      paginatedMatrixInfo: u,
      canvasActions: c,
      updateInfo: f,
      facetType: C,
      paginated: I,
      targetPath: E,
      subTotalsInfo: B
    });
    const { topMatrix: N, bottomMatrix: M } = S.getMergedMatrices(), { leftMatrix: F, rightMatrix: k } = x.getMergedMatrices();
    this.generateHeaderTitleMatrices({
      topMatrix: N,
      leftMatrix: F,
      rightMatrix: k,
      bottomMatrix: M,
      config: {
        ...y.headerTitle,
        rowHeadersConfig: _,
        rowFacetsConfig: o,
        yAxisConfig: D.axes.y,
        rowFacetFields: this._matrices.row.getFacetFields().map((O) => O.toString())
      }
    }), x._headerTitleMatrices = this._matrices.headerTitle, this.extractNestedSortStatusForAxis(), this.disableDirectSortForAxisIfNeeded();
  }
  generateMatrices({
    axesInfo: t,
    headers: i,
    dataModelMatrix: n,
    layerDomains: s,
    facets: A,
    rowFacetsConfig: o,
    colFacetsConfig: a,
    facetFormatters: r,
    facetHyperLinkFormatters: l,
    childEventManagerCreator: c,
    canvasActions: g,
    rootGroupedData: h,
    totalsData: d,
    rootMatrixInfo: u,
    paginatedMatrixInfo: f
  }) {
    this._paginatedMatrixInfo = f;
    const { x: C, y: I } = t, { rowKeys: E, columnKeys: B } = i, m = this.config(), p = m.rows.axes.globalConfig;
    this._globalConfig = p;
    const w = T0(
      p.rows.headers,
      p.rows.facets,
      p.axes.y
    );
    let Q = !1, y;
    n.forEach((M) => {
      M.forEach((F) => {
        const { layerConfig: k } = F;
        k.forEach((O) => {
          [O.def || O].flat().forEach((P) => {
            ["x", "y"].forEach((L) => {
              Q = en.getLayerClass(P.mark).shouldShowAxisTicksInPercentage(
                F.dataStore,
                P.encoding[L].field,
                O
              ), Q && (y = P.encoding[L].var);
            });
          });
        });
      });
    }), this.generateRowMatrix({
      axesInfo: I,
      config: {
        ...m.rows,
        rowHeadersConfig: w,
        fieldToShowInPercentage: y
      },
      headers: E,
      facets: A,
      rowFacetsConfig: o,
      columnSubTotalsConfig: p.columns.totals.subTotals,
      facetFormatters: r,
      facetHyperLinkFormatters: l,
      childEventManagerCreator: c,
      canvasActions: g
    }), this.generateColumnMatrix({
      axesInfo: C,
      config: {
        ...m.columns,
        columnVariables: m.headerTitle.columnHeaders || [],
        rowHeadersConfig: w,
        fieldToShowInPercentage: y
      },
      headers: B,
      facets: A,
      colFacetsConfig: a,
      rowSubTotalsConfig: p.rows.totals.subTotals,
      facetFormatters: r,
      facetHyperLinkFormatters: l,
      childEventManagerCreator: c,
      canvasActions: g
    });
    const D = this.row(), _ = this.column(), { bottom: x, top: S } = _._matrices.axes._cells, { left: b, right: R } = D._matrices.axes._cells, G = D.getBorderConfig();
    this.generateGeomMatrix({
      facets: A,
      borderConfig: G,
      dataModelMatrix: n,
      layerDomains: s,
      config: {
        ...m.geoms,
        theme: p.theme
      },
      axes: {
        x: {
          bottom: x.map((M) => M.source()),
          top: S.map((M) => M.source())
        },
        y: {
          left: b.map((M) => M.source()),
          right: R.map((M) => M.source())
        }
      },
      childEventManagerCreator: c,
      rootGroupedData: h,
      totalsData: d,
      rootMatrixInfo: u,
      paginatedMatrixInfo: f,
      canvasActions: g
    });
    const { topMatrix: T, bottomMatrix: v } = _.getMergedMatrices(), { leftMatrix: H, rightMatrix: N } = D.getMergedMatrices();
    this.generateHeaderTitleMatrices({
      topMatrix: T,
      leftMatrix: H,
      rightMatrix: N,
      bottomMatrix: v,
      config: {
        ...m.headerTitle,
        rowHeadersConfig: w,
        rowFacetsConfig: o,
        yAxisConfig: p.axes.y,
        rowFacetFields: this._matrices.row.getFacetFields().map((M) => M.toString())
        // yAxisFields: this._matrices.row
        //   .getAxisFields()
        //   .map((f) => f.toString()),
      }
    }), D._headerTitleMatrices = this._matrices.headerTitle, this.extractNestedSortStatusForAxis(), this.disableDirectSortForAxisIfNeeded();
  }
  extractNestedSortStatusForAxis() {
    const t = this._matrices.row, i = this._matrices.column, { facetConfig: n } = t.config().headers, { facetConfig: s } = i.config().headers, A = [], o = [], a = this._matrices.geom._rootGroupedData;
    [
      [t, o],
      [i, A]
    ].forEach(([c, g]) => {
      const h = new Set(
        c.getAxisFields().flat(1 / 0).map((I) => I.getMembers()).flat(2)
      ), d = c.getAxes(), u = [];
      for (let I = 0; I < d.length; I++) {
        const E = d[I], B = E.config().field;
        if (h.has(B) && (u.push({
          fieldName: B,
          ordering: E.config().ordering
        }), h.delete(B), h.size === 0))
          break;
      }
      const f = c._matrices.headers._cells, C = [
        f.left,
        f.right,
        f.top,
        f.bottom
      ].filter((I) => I && I.length > 0);
      if (C.length > 0) {
        const I = C[0];
        if (I.length > 0) {
          const E = I[0];
          if (E.length > 0) {
            const B = E[E.length - 1], { fieldName: m, ordering: p } = B.config();
            u.push({
              fieldName: m,
              ordering: p
            });
          }
        }
      }
      u.filter((I) => I.ordering && I.fieldName).forEach(({ fieldName: I, ordering: E }) => {
        if (E.type === Ki.NESTED_ORDER) {
          const B = Z(E, "nested", "filters") || [];
          g.push({
            sortInfo: E,
            targetField: {
              name: I
            },
            path: B
          });
        }
      });
    });
    const r = i.getAxes(), l = t.getAxes();
    [
      [r, o, s],
      [l, A, n]
    ].forEach(([c, g, h]) => {
      for (let d = 0; d < c.length; d++) {
        const u = c[d], { fields: f } = h;
        if (!(u instanceof xe || u instanceof Be || u instanceof Ln))
          continue;
        const C = u.config().metaInf.facets.map((E) => {
          const B = E.field.getMembers()[0], m = E.value, p = B && f && f[B] && f[B].formatter ? f[B].formatter : h.formatter || (({ rawValue: w }) => w);
          return {
            field: B,
            value: m,
            formatter: (w) => p(
              {
                formattedValue: td(
                  w,
                  B,
                  a
                ),
                rawValue: w
              },
              {
                fieldName: B,
                dateTimeFormatter: K.DateTimeFormatter.formatAs,
                dataModel: a
              }
            )
          };
        });
        let I = null;
        for (let E = 0; E < g.length; E++) {
          const B = g[E], { sortInfo: m, targetField: p, path: w } = B;
          if (!w.length)
            continue;
          let Q, y;
          if (u instanceof xe || u instanceof Be ? (Q = w.slice(0, w.length - 1), y = w[w.length - 1].value) : (Q = w.slice(), y = Z(m, "nested", "field", "name")), d7(C, Q)) {
            I = {
              sortInfo: m,
              targetField: p,
              facetsPath: C,
              axisTarget: {
                value: y
              }
            };
            break;
          }
        }
        u.currentNestedSortInfo(I);
      }
    });
  }
  disableDirectSortForAxisIfNeeded() {
    const t = this._matrices.row, i = this._matrices.column, [n, s] = [t, i].map(
      (A) => [
        ...new Set(
          [...A.getAxisFields(), ...A.getFacetFields()].flat(4)
        )
      ].filter((r) => r.getMembers()[0] !== ht).some(
        (r) => r.as() === ft.DISCRETE
      )
    );
    [
      [t, s],
      [i, n]
    ].forEach(([A, o]) => {
      A.getAxes().forEach((a) => {
        a.directSortEnabled(o);
      });
    });
  }
  generateRowMatrix({
    axesInfo: t,
    config: i,
    headers: n,
    facets: s,
    rowFacetsConfig: A,
    columnSubTotalsConfig: o,
    facetFormatters: a,
    facetHyperLinkFormatters: r,
    childEventManagerCreator: l,
    canvasActions: c
  }) {
    const g = this._matrices.row;
    g.config(i), g.generateMatrices({
      axesInfo: t,
      headers: n,
      facets: s,
      rowFacetsConfig: A,
      columnSubTotalsConfig: o,
      facetFormatters: a,
      facetHyperLinkFormatters: r,
      childEventManagerCreator: l,
      canvasActions: c
    });
  }
  generateColumnMatrix({
    axesInfo: t,
    config: i,
    headers: n,
    facets: s,
    colFacetsConfig: A,
    rowSubTotalsConfig: o,
    facetFormatters: a,
    facetHyperLinkFormatters: r,
    childEventManagerCreator: l,
    canvasActions: c
  }) {
    const g = this._matrices.column;
    g.config(i), g.generateMatrices({
      axesInfo: t,
      headers: n,
      facets: s,
      colFacetsConfig: A,
      rowSubTotalsConfig: o,
      facetFormatters: a,
      facetHyperLinkFormatters: r,
      childEventManagerCreator: l,
      canvasActions: c
    });
  }
  generateHeaderTitleMatrices({
    leftMatrix: t,
    rightMatrix: i,
    topMatrix: n,
    bottomMatrix: s,
    config: A = {}
  }) {
    const o = this.headerTitle();
    o.config(A), o.generateMatrices({
      leftMatrix: t,
      rightMatrix: i,
      topMatrix: n,
      bottomMatrix: s
    });
  }
  generateGeomMatrix({
    axes: t,
    facets: i,
    borderConfig: n,
    dataModelMatrix: s,
    layerDomains: A,
    config: o = {},
    childEventManagerCreator: a,
    rootGroupedData: r,
    totalsData: l,
    rootMatrixInfo: c,
    paginatedMatrixInfo: g,
    paginatedLayerDomains: h,
    canvasActions: d
  }) {
    const u = this._matrices.geom;
    u.config(o), u.generateMatrix({
      axes: t,
      facets: i,
      borderConfig: n,
      dataModelMatrix: s,
      layerDomains: A,
      childEventManagerCreator: a,
      rootGroupedData: r,
      totalsData: l,
      rootMatrixInfo: c,
      paginatedMatrixInfo: g,
      paginatedLayerDomains: h,
      canvasActions: d
    });
  }
  setPaginatedMatrixInfo(t) {
    this._paginatedMatrixInfo = t, this.geom()._paginatedMatrixInfo = t;
  }
  getMatrices() {
    const { row: t, column: i, geom: n, headerTitle: s } = this._matrices, { leftMatrix: A, rightMatrix: o } = t.merge(), { topMatrix: a, bottomMatrix: r } = i.merge();
    return {
      rows: [A, o],
      columns: [a, r],
      values: n.getMatrix(),
      headerTitles: s.getMatrices(),
      priority: {
        row: t.getPriority(),
        col: i.getPriority()
      }
    };
  }
  row() {
    return this._matrices.row;
  }
  column() {
    return this._matrices.column;
  }
  geom() {
    return this._matrices.geom;
  }
  headerTitle() {
    return this._matrices.headerTitle;
  }
  // sortAxisDomainsBasedOnRootData(groupedModel, union) {
  //   const { row, column } = this._matrices;
  //   ["x", "y"].forEach((axisType) => {
  //     let axes;
  //     if (axisType === "x") {
  //       axes = [
  //         column._matrices.axes._cells.bottom,
  //         column._matrices.axes._cells.top,
  //       ];
  //     } else {
  //       axes = [
  //         row._matrices.axes._cells.left,
  //         row._matrices.axes._cells.right,
  //       ];
  //     }
  //     union[axisType] = union[axisType].map((domains, axisIdx) => {
  //       return domains.map((domain, domainTypeIdx) => {
  //         const axisCell = axes[domainTypeIdx][axisIdx];
  //         if (axisCell && axisCell.source() instanceof BandAxis) {
  //           const field = axisCell.source().config().field;
  //           const rootUniques = groupedModel.getField(field).uniques();
  //           const invalidValIndx = domain.findIndex((d) =>
  //             DataStore.isInvalid(d)
  //           );
  //           const domainSet = new Set(domain);
  //           const sortedDomain = [];
  //           for (let i = 0; i < rootUniques.length; i++) {
  //             const val = rootUniques[i];
  //             if (
  //               (!DataStore.isInvalid(val) && domainSet.has(val)) ||
  //               (DataStore.isInvalid(val) && invalidValIndx !== -1)
  //             ) {
  //               sortedDomain.push(val);
  //             }
  //             if (sortedDomain.length === domain.length) {
  //               break;
  //             }
  //           }
  //           return sortedDomain;
  //         } else {
  //           return domain;
  //         }
  //       });
  //     });
  //   });
  // }
  /**
   * Unions the x and y axis domains and sets it on the axis
   *
   * @param {boolean} calculateUniformAxisDomains
   */
  setAxisDomains(t = !0, i, n = {}) {
    const s = this._dependencies.store, { row: A, column: o, geom: a } = this._matrices, r = this.column().config().axes, l = this.row().config().axes, c = {
      x: r.globalConfig.axes.x,
      y: l.globalConfig.axes.y
    }, g = a.getXYDomains({
      ...n,
      calculateUniformAxisDomains: t
    }), h = kW(
      g,
      c,
      t
    ), { pageStartIndex: d, pageEndIndex: u } = this._paginatedMatrixInfo;
    h.y.length >= u && (h.y = h.y.slice(d, u)), this.sortAxisDomains(i, h), s.lockModel();
    const f = [h.x, h.y];
    [o, A].forEach((C, I) => {
      const E = C._matrices.axes;
      E.setDomains(f[I], s, {
        overrideUserDomain: !!E.config().fieldToShowInPercentage
      });
    }), s.unlockModel();
  }
  registerHooksEvents(t) {
    const i = this._matrices, n = this._dependencies.store, s = [
      i.column.getBottomAxes().map((o) => o.source()),
      i.column.getTopAxes().map((o) => o.source())
    ].reduce((o, a) => (a.length && o.push(a), o), []), A = [
      i.row.getLeftAxes().map((o) => o.source()),
      i.row.getRightAxes().map((o) => o.source())
    ].reduce((o, a) => (a.length && a.forEach((r, l) => {
      const c = o[l] || [];
      c.push(r), o[l] = c;
    }), o), []);
    [
      ["x", s],
      ["y", A]
    ].forEach(([o, a]) => {
      [[Ht.AXIS, o]].forEach((r) => {
        [
          mt.BEFORE_RENDERED,
          mt.AFTER_RENDERED,
          mt.ANIMATION_END
        ].forEach((l) => {
          this.registerAggHooksEvents(
            t,
            a,
            { componentPath: r, hookName: l },
            () => {
              const { rowStart: c, rowEnd: g, colStart: h, colEnd: d } = n.get(
                `${re}.viewport`
              );
              return {
                rowRange: o === "x" ? [0, a.length - 1] : [c, g],
                colRange: o === "x" ? [h, d] : [0, a[0].length - 1]
              };
            }
          );
        });
      });
    }), this.registerAggHooksEventsForLayers(t), [
      mt.BEFORE_RENDERED,
      mt.AFTER_RENDERED,
      mt.ANIMATION_END
    ].forEach((o) => {
      this.registerAggHooksEvents(
        t,
        i.geom._matrix.map((a) => a.map((r) => r.source())),
        { componentPath: [Ht.UNIT], hookName: o },
        () => {
          const { rowStart: a, rowEnd: r, colStart: l, colEnd: c } = n.get(
            `${re}.viewport`
          );
          return {
            rowRange: [a, r],
            colRange: [l, c]
          };
        }
      );
    });
  }
  setCanvasDimensionsToAxes(t, i) {
    const n = this._matrices;
    let s = [];
    switch (i) {
      case "row":
        s = [
          ...n.row.getLeftAxes().map((o) => o.source()),
          ...n.row.getRightAxes().map((o) => o.source())
        ];
        break;
      case "column":
        s = [
          ...n.column.getBottomAxes().map((o) => o.source()),
          ...n.column.getTopAxes().map((o) => o.source())
        ];
        break;
      default:
        s = [
          ...n.row.getLeftAxes().map((o) => o.source()),
          ...n.row.getRightAxes().map((o) => o.source()),
          ...n.column.getBottomAxes().map((o) => o.source()),
          ...n.column.getTopAxes().map((o) => o.source())
        ];
        break;
    }
    const A = t._canvasHelpers.getCanvasDimensions();
    s.forEach((o) => {
      o && o.config({
        metaInf: {
          canvasDimensions: A
        }
      });
    });
  }
  registerAggHooksEvents(t, i, n, s) {
    const A = new $e({
      componentPath: n.componentPath,
      modifier: ze.EACH,
      hookName: n.hookName
    });
    i.forEach((o) => {
      o.forEach((a) => {
        if (a) {
          const r = a.eventManager().listeners(A).find(
            (l) => Z(l, "meta", "tag") === Zc
          );
          r && a.eventManager().off(A, r.listener);
        }
      });
    }), EQ(
      A,
      i,
      ({ eventObjects: o, ranges: { rowRange: a, colRange: r } }) => {
        let l = i.slice(a[0], a[1] + 1).map((c) => c.slice(r[0], r[1] + 1));
        t.emitEvent({
          name: new $e({
            componentPath: A.componentPath,
            modifier: ze.ALL,
            hookName: A.hookName
          }),
          target: l.flat(1).filter((c) => !!c),
          data: { aggEventObjects: o },
          virtualScrolling: { viewportRange: { rowRange: a, colRange: r } }
        });
      },
      s,
      { tag: Zc }
    );
  }
  registerAggHooksEventsForLayers(t) {
    const i = this._matrices, n = this._dependencies.store, s = i.geom._matrix.map(
      (o) => o.map((a) => a.source())
    );
    ["all", ...[
      ...s.flat().map((o) => o.layers()).flat(1).reduce((o, a) => (o.add(a.config().mark), o), /* @__PURE__ */ new Set())
    ]].forEach((o) => {
      [
        mt.BEFORE_RENDERED,
        mt.AFTER_RENDERED,
        mt.ANIMATION_END
      ].forEach((a) => {
        const r = new $e({
          componentPath: o === "all" ? [
            Ht.UNIT,
            Ht.LAYER
          ] : [
            Ht.UNIT,
            Ht.LAYER,
            o
          ],
          modifier: ze.ALL,
          hookName: a
        });
        s.forEach((l) => {
          l.forEach((c) => {
            const g = c.eventManager().listeners(r).find(
              (h) => Z(h, "meta", "tag") === Zc
            );
            g && c.eventManager().off(r, g.listener);
          });
        }), EQ(
          r,
          s,
          ({ eventObjects: l, ranges: { rowRange: c, colRange: g } }) => {
            let h = s.slice(c[0], c[1] + 1).map((d) => d.slice(g[0], g[1] + 1)).flat(1).map(
              (d) => o === "all" ? d.layers() : d.layers().filter((u) => u.config().mark === o)
            ).flat(1);
            t.emitEvent({
              name: new $e({
                componentPath: o === "all" ? [Ht.LAYER] : [Ht.LAYER, o],
                modifier: ze.ALL,
                hookName: a
              }),
              target: h,
              data: {
                aggEventObjects: l.map((d) => d.data.aggEventObjects).flat(1)
              },
              virtualScrolling: { viewportRange: { rowRange: c, colRange: g } }
            });
          },
          () => {
            const { rowStart: l, rowEnd: c, colStart: g, colEnd: h } = n.get(
              `${re}.viewport`
            );
            return {
              rowRange: [l, c],
              colRange: [g, h]
            };
          },
          { tag: Zc },
          !0
        );
      });
    });
  }
  sortAxisDomains({ rootModel: t, columnGTRootModel: i, rowGTRootModel: n }, s) {
    const { row: A, column: o } = this._matrices, a = {
      x: /* @__PURE__ */ new Map(),
      y: /* @__PURE__ */ new Map()
    }, r = this._globalConfig, l = r.rows.totals.data.totalString, c = r.rows.totals.subTotals.position, g = r.columns.totals.data.totalString, h = r.columns.totals.subTotals.position;
    ["x", "y"].forEach((d) => {
      let u, f, C = t, { totalString: I } = d === "y" ? o._matrices.axes.config().globalConfig.columns.totals.data : A._matrices.axes.config().globalConfig.rows.totals.data;
      const E = (B) => B.value === I;
      if (d === "x") {
        const { axisFrom: B } = o._matrices.axes.config(), { takeHeaderFrom: m } = o._matrices.headers.config();
        B === "top" ? u = [
          o._matrices.axes._cells.top,
          o._matrices.axes._cells.bottom
        ] : u = [
          o._matrices.axes._cells.bottom,
          o._matrices.axes._cells.top
        ], m === "top" ? f = [
          o._matrices.headers._cells.top,
          o._matrices.headers._cells.bottom
        ] : f = [
          o._matrices.headers._cells.bottom,
          o._matrices.headers._cells.top
        ];
      } else
        u = [
          A._matrices.axes._cells.left,
          A._matrices.axes._cells.right
        ], f = [
          A._matrices.headers._cells.left,
          A._matrices.headers._cells.right
        ];
      s[d] = s[d].map((B, m) => B.map((p, w) => {
        const Q = u[w][m], y = f[w][m];
        if (Q && (Q.source() instanceof xe || Q.source() instanceof Be)) {
          const _ = Q.source().config(), x = _.field, S = y == null ? [] : y.map((T, v) => ({
            field: T.config().facetFields[v].getMembers()[0],
            value: T.rawSource()
          }));
          let b = _.ordering;
          if (b.type === Ki.NESTED_ORDER && b[Ki.NESTED_ORDER]) {
            const T = b[Ki.NESTED_ORDER];
            (T.filters == null ? [] : T.filters).some(E) && (C = d === "x" ? i : n);
          }
          const R = a[d];
          return R.has(x) || R.set(
            x,
            zd(
              { name: x },
              { ...b },
              C,
              d === "x" ? {
                totalString: l,
                subTotalsPosition: c
              } : {
                totalString: g,
                subTotalsPosition: h
              }
            )
          ), R.get(x)(p, S);
        } else
          return p;
      }));
    });
  }
  checkIfExtendDomainNeeded() {
    return !!this.geom().getUnits().find((i) => !!i.layers().find((s) => s.requiresExtendDomainDiffs()));
  }
  checkIfExtendedAxisDomainCachePresent() {
    return [...this.row().getAxes(), ...this.column().getAxes()].every((i) => i.cachedExtendedDomainDiffs());
  }
  clearExtendedAxisDomainCache() {
    [...this.row().getAxes(), ...this.column().getAxes()].forEach((i) => {
      i.cachedExtendedDomainDiffs(null);
    });
  }
  extendAxisDomainsIfNeeded() {
    if (!this.checkIfExtendDomainNeeded())
      return;
    const { AxisCell: t } = this._dependencies.cellRegistry, { row: i, column: n } = this._matrices, s = this.checkIfExtendedAxisDomainCachePresent();
    let A;
    s || (A = this._matrices.geom._matrix.map(
      (o) => o.map((a) => a.source().calculateExtendDomainDiffs())
    )), ["top", "bottom"].forEach((o) => {
      const a = n._matrices.axes, { fieldToShowInPercentage: r } = a.config();
      n._matrices.axes._cells[o].forEach((l, c) => {
        if (!(l instanceof t))
          return;
        const g = l.source();
        let h;
        s ? h = g.cachedExtendedDomainDiffs() : h = rn(
          A.map((d) => d[c][`${o}Axis`])
        ), (h[0] || h[1]) && g.extendDomain(h, { fieldToShowInPercentage: r }), g.cachedExtendedDomainDiffs(h);
      });
    }), ["left", "right"].forEach((o) => {
      const a = n._matrices.axes, { fieldToShowInPercentage: r } = a.config();
      i._matrices.axes._cells[o].forEach((l, c) => {
        if (!(l instanceof t))
          return;
        const g = l.source();
        let h;
        s ? h = g.cachedExtendedDomainDiffs() : h = rn(
          A[c].map(
            (d) => d[`${o}Axis`]
          )
        ), (h[0] || h[1]) && g.extendDomain(h, { fieldToShowInPercentage: r }), g.cachedExtendedDomainDiffs(h);
      });
    });
  }
  clear() {
    super.clear(), Object.values(this._matrices).forEach((t) => {
      t.clear();
    });
  }
  parentContainerInf(...t) {
    return t.length ? (this._parentContainerInf = t[0], this.row().parentContainerInf(t[0]), this.column().parentContainerInf(t[0]), this.geom().parentContainerInf(t[0]), this) : this._parentContainerInf;
  }
  registerDirectSortResets() {
    this.row().directSortResetter(this.resetDirectSort.bind(this)), this.column().directSortResetter(this.resetDirectSort.bind(this));
  }
  resetDirectSort() {
    [this.row(), this.column()].forEach((t) => {
      const i = t._firebolt, n = t._sortDropdown;
      i && n && n.isVisible() && B1(i);
    });
  }
  dispose() {
    [this.row(), this.column()].forEach((t) => {
      const n = t._firebolt.sideEffects();
      for (let s in n)
        n[s].dispose();
    });
  }
}
const f7 = (e, t, i, n, s, A, o, a, r) => {
  const l = [], c = [], g = e.length || 1, h = A.findIndex(
    (d) => `${d}` === o
  );
  for (let d = 0; d < g; d++)
    for (let u = 0; u < t.length; u++) {
      const [f, C] = t[u], I = i(e[d]), E = o != null && h > 0 && e[d][h - 1] === s;
      l.push(
        I && f?.isDiscrete() && `${f}` !== o ? {
          field: f,
          config: {
            ...r != null && { show: r },
            internalFormat: () => n,
            showAxisName: !1,
            sourceType: gs
          }
        } : {
          field: f,
          config: {
            ...r != null && { show: r },
            internalFormat: ({ rawValue: B }) => E ? a : B === s ? n : B
          }
        }
      ), c.push(
        I && C?.isDiscrete() && `${C}` !== o ? {
          field: C,
          config: {
            ...r != null && { show: r },
            internalFormat: () => n,
            showAxisName: !1,
            sourceType: gs
          }
        } : {
          field: C,
          config: {
            ...r != null && { show: r },
            internalFormat: ({ rawValue: B }) => E ? a : B === s ? n : B
          }
        }
      );
    }
  return {
    leftAxisInfo: l,
    rightAxisInfo: c
  };
}, I7 = (e, t, i, n, s, A, o, a, r) => {
  const l = [], c = [], g = e.length ? e[e.length - 1].length : 1, h = A.findIndex(
    (d) => `${d}` === o
  );
  for (let d = 0; d < g; d++)
    for (let u = 0; u < t.length; u++) {
      const [f, C] = t[u], I = e.map((m) => m[d]), E = i(I), B = o != null && h > 0 && I[h - 1] === s;
      l.push(
        E && f?.isDiscrete() && `${f}` !== o ? {
          field: f,
          config: {
            ...r != null && { show: r },
            internalFormat: () => n,
            showAxisName: !1,
            sourceType: gs
          }
        } : {
          field: f,
          config: {
            ...r != null && { show: r },
            internalFormat: ({ rawValue: m }) => B ? a : m === s ? n : m
          }
        }
      ), c.push(
        E && C?.isDiscrete() && `${C}` !== o ? {
          field: C,
          config: {
            ...r != null && { show: r },
            internalFormat: () => n,
            showAxisName: !1,
            sourceType: gs
          }
        } : {
          field: C,
          config: {
            ...r != null && { show: r },
            internalFormat: ({ rawValue: m }) => B ? a : m === s ? n : m
          }
        }
      );
    }
  return {
    topAxisInfo: l,
    bottomAxisInfo: c
  };
}, U1 = (e, { bottomAxisInfo: t, topAxisInfo: i }, n, s, A, o, a, r, l) => {
  const c = i.length ? i : t, g = e.length ? e[0].map((u, f) => e.map((C) => C[f])) : [], h = c.length / g.length;
  return g.length ? c.map(
    (u, f) => O1(
      g[Math.floor(f / h)],
      n,
      s,
      A,
      o,
      a,
      r,
      l
    )
  ) : [];
}, H1 = (e, { leftAxisInfo: t }, i, n, s, A, o, a, r) => {
  const l = t.length / e.length;
  return e.length ? t.map(
    (c, g) => O1(
      e[Math.floor(g / l)],
      i,
      n,
      s,
      A,
      o,
      a,
      r
    )
  ) : [];
}, O1 = (e, t, i, n, s, A = [], o, a) => {
  let r = [];
  const l = A.findIndex(
    (c) => `${c}` === s
  );
  for (let c = 0; c < e?.length; c++) {
    const g = s != null && l > 0 && e[l - 1] === a, h = A[c]?.toString();
    let d;
    if (o == null)
      d = () => i;
    else {
      const u = o?.fields[h]?.format;
      u == null ? d = o.format.length === 2 ? () => i : o.format : d = u.length === 2 ? () => i : u;
    }
    if (r.push(
      e[c] === a ? g ? n : {
        value: i,
        rawValue: a,
        sourceType: gs,
        format: d
      } : e[c]
    ), t && t(r)) {
      const u = e.slice(c + 1);
      if (!u.every((C) => C === a)) {
        const C = u.findIndex(
          (I, E, B) => E === 0 && I !== a || E > 0 && I !== a && B[E - 1] === a
        );
        r = [
          ...r,
          ...u.slice(0, C).map(() => ({
            value: i,
            format: d,
            sourceType: gs,
            rawValue: a
          })),
          {
            value: u[C],
            format: () => u[C],
            sourceType: gs,
            rawValue: u[C]
          },
          ...u.slice(C + 1).map(() => ({
            value: i,
            format: d,
            sourceType: gs,
            rawValue: a
          }))
        ];
      } else
        r = r.concat(
          new Array(e.length - (c + 1)).fill({
            value: i,
            format: d,
            sourceType: gs,
            rawValue: a
          })
        );
      break;
    }
  }
  return r;
};
function C7({
  hasDummyColumnAxis: e,
  hasDummyRowAxis: t,
  showUnivariateXAxis: i,
  showUnivariateYAxis: n,
  showUnivariateAxis: s
}) {
  const A = (l) => typeof l == "boolean", o = () => A(s) && s;
  function a() {
    if (e)
      return A(i) ? i : o() ? n !== !0 : !1;
  }
  function r() {
    if (t)
      return A(n) ? n : A(s) && !s ? !1 : s === !0 ? a() !== !0 : !1;
  }
  return {
    shouldShowColumnAxis: a(),
    shouldShowRowAxis: r()
  };
}
const ty = ({
  rowKeys: e,
  columnKeys: t,
  rowFacets: i,
  colFacets: n,
  rowProjections: s,
  colProjections: A,
  facetFormatters: o = {},
  rowCollapseStatus: a,
  columnCollapseStatus: r,
  globalConfig: l
}) => {
  const {
    rowSubTotalsText: c,
    columnSubTotalsText: g,
    columnTotalString: h,
    rowTotalString: d
  } = tA(l), {
    axes: {
      showUnivariateAxis: u,
      x: { showUnivariateAxis: f },
      y: { showUnivariateAxis: C }
    },
    columns: {
      totals: {
        subTotals: {
          splitTotal: {
            field: I,
            text: E
          }
        }
      }
    },
    rows: {
      totals: {
        subTotals: {
          splitTotal: {
            field: B,
            text: m
          }
        }
      }
    }
  } = l, p = !!A.find(
    (b) => `${b}` === ht
  ), w = !!s.find(
    (b) => `${b}` === ht
  ), { shouldShowColumnAxis: Q, shouldShowRowAxis: y } = C7({
    hasDummyColumnAxis: p,
    hasDummyRowAxis: w,
    showUnivariateXAxis: f,
    showUnivariateYAxis: C,
    showUnivariateAxis: u
  }), D = I7(
    t,
    A,
    r,
    c,
    d,
    n,
    B,
    m,
    Q
  ), _ = f7(
    e,
    s,
    a,
    g,
    h,
    i,
    I,
    E,
    y
  );
  let x = H1(
    e,
    _,
    a,
    g,
    E,
    I,
    i,
    o.row,
    h
  ), S = U1(
    t,
    D,
    r,
    c,
    m,
    B,
    n,
    o.column,
    d
  );
  return {
    rowHeaderKeys: x,
    columnHeaderKeys: S,
    columnAxisInfo: D,
    rowAxisInfo: _
  };
}, P1 = (e, t, i, n, s, { totalString: A = "All", aggregations: o = {}, isRow: a }, r, l, c) => {
  const g = K.DataModel(), h = e._model._config, { data: d, schema: u } = e.getData({
    shouldSanitize: !0,
    excludeFields: [pt.ROW_ID]
  }), f = u.map(
    (Q) => o[Q.name] ? { ...Q, defAggFn: o[Q.name] } : { ...Q }
  ), C = f.map(
    (Q, y) => (
      // rootDmData.map((r) => (DataStore.isInvalid(r[idx]) ? null : r[idx]))
      d.map((D) => D[y])
    )
  ), I = new g(
    {
      data: C,
      schema: f
    },
    h
  ), E = t.concat(c).concat(r ? [r] : []), B = I.project([
    .../* @__PURE__ */ new Set([
      ...E,
      ...s,
      ...n
    ])
  ]).splitByRow(E.filter((Q) => Q != ht));
  let m = B.reduce((Q, y) => {
    const D = {};
    (a === !0 ? E : E.filter(
      (T) => !i.includes(T) || T === r
    )).forEach((T) => {
      const v = y.getField(T).data(void 0, !0)[0];
      D[T] = v;
    }), (a === !0 ? i.filter((T) => !E.includes(T)) : i.filter((T) => T !== r)).forEach((T) => {
      D[T] = A;
    });
    const S = y.groupBy([...n]), { data: b, schema: R } = S.getData(
      void 0,
      { shouldSanitize: !0 }
    ), G = b.map((T, v) => R.filter(
      ({ name: H, type: N }) => N === "measure" || n.includes(H)
    ).reduce(
      (H, { name: N }) => {
        const M = S.getField(N).data(void 0, !0)[v];
        return {
          ...H,
          // [name]: typeof value === "object" ? null : value,
          [N]: M
        };
      },
      { ...D }
    ));
    return [...Q, ...G];
  }, []).flat();
  const p = [
    ...new Set(
      [
        ...t,
        ...i,
        ...s,
        ...n
      ].filter(
        (Q) => Q != null && c.indexOf(Q) === -1
      )
    )
  ].map((Q) => {
    let y = f.find((D) => D.name === Q);
    return o[y.name] && (y = { ...y, defAggFn: o[y.name] }), y.subtype === "temporal" ? { ...y, subtype: "categorical" } : { ...y };
  });
  if (c?.forEach((Q) => {
    let y = f.find((D) => D.name === Q);
    o[y.name] ? p.push({ ...y, defAggFn: o[y.name] }) : p.push({ ...y });
  }), t.filter((Q) => Q != ht).length > 0) {
    const Q = {}, y = I.groupBy([
      .../* @__PURE__ */ new Set([
        ...n,
        ...c,
        r,
        l
      ])
    ]);
    [...t, ...i].filter((_) => _ !== r || _ !== l).forEach((_) => {
      Q[_] = A;
    });
    const D = y.getData(void 0, { shouldSanitize: !0 }).data.map((_, x) => p.filter(
      ({ name: S, type: b }) => b === "measure" || n.includes(S) || c.includes(S) || r === S || l === S
    ).reduce(
      (S, { name: b }) => {
        const R = y.getField(b).data(void 0, !0);
        return {
          ...S,
          [b]: K.isInvalid(R[x]) ? null : R[x]
        };
      },
      { ...Q }
    ));
    m.push(...D);
  }
  m = p.map(({ name: Q }) => m.map((y) => y[Q]));
  const w = new g({ data: m, schema: p }, h);
  return B.length = 0, I.dispose(), w;
}, PB = (e, t, i, n, s, A = !0) => {
  const o = [
    ...[
      ...t.discreteRowProjections,
      ...t.rowFacets
    ].filter((r) => `${r}` !== n),
    ...[
      ...t.discreteColumnProjections,
      ...t.colFacets
    ].filter((r) => `${r}` !== i)
  ];
  let a = [
    ...new Set(
      o.flatMap(
        (r) => typeof r == "string" ? r : r.getMembers()
      )
    )
  ];
  return A && (a = a.filter(
    (r) => r !== ht
  )), a.length ? lr(
    [a, a.map(() => s)],
    e,
    "neq",
    "or"
  ) : null;
}, sa = "columnGrandTotals", Aa = "rowGrandTotals", Ur = "greatGrandTotals", E7 = (e, t, i) => e ? e.select({
  conditions: i.map((A) => ({
    field: A.field,
    value: A.value,
    operator: "eq"
  })),
  operator: "or"
}).getField(t)?.uniques() ?? [] : [];
class Su {
  constructor() {
    this._rowCollapseStatus = () => !1, this._columnCollapseStatus = () => !1, this._rowFacets = null, this._columnFacets = null, this._mainFacetedDataStoreMatrixMap = /* @__PURE__ */ new Map();
  }
  /**
   * Gets Matrixes for corresponding datamodel, facets and projections.
   *
   * @param {Object} mainDataStore input datamodel
   * @param {Object} fieldInformation Information about the fields
   * @param {Object} sortConfig Information about how to sort the facet fields
   *
   * @return {Array<Array<Object>>} A 2D array of value matrices
   */
  getMatrixModel(t, i, {
    facetSortConfig: n,
    globalConfig: s,
    rowTotalsDM: A,
    columnTotalsDM: o,
    greatTotalsDM: a,
    canvasHelpers: r,
    detailedFacetProjectionInfo: l,
    isGrandTotals: c,
    totalsType: g
  } = {
    globalConfig: {}
  }) {
    const {
      rows: {
        totals: {
          subTotals: {
            enabled: h,
            splitTotal: { field: d }
          } = { enabled: !1, splitTotal: {} }
        } = {}
      } = {},
      columns: {
        totals: {
          subTotals: {
            enabled: u,
            splitTotal: { field: f }
          } = { enabled: !1, splitTotal: {} }
        } = {}
      } = {}
    } = s, {
      colFacets: C = [],
      rowFacets: I = [],
      optionalProjections: E = [],
      colProjections: B = [],
      rowProjections: m = []
    } = i, p = {}, w = {};
    let Q = [], y = [];
    const _ = t.getSchema({
      excludeFields: [pt.ROW_ID]
    }).map(wW);
    this._rowFacets = I.flatMap(Lr), this._columnFacets = C.flatMap(Lr);
    const x = this._rowFacets.concat(this._columnFacets), S = m.map(
      (W) => B.map((U) => ({
        rowProjections: W,
        colProjections: U,
        combinedProjections: [...W, ...U].flatMap(
          Lr
        )
      }))
    );
    if (this._colProjectionMatrix = B?.flat()?.flatMap(Lr), this._rowProjectionMatrix = m?.flat()?.flatMap(Lr), x.length === 0)
      return m.length && B.length ? {
        dataModelMatrix: S.map((W) => {
          const U = x0(
            W,
            _,
            E
          );
          return t.splitByColumn(U, E).map((J, V) => ({
            dataStore: J,
            rowFacetValues: [],
            columnFacetValues: [],
            rowProjections: W[V].rowProjections,
            columnProjections: W[V].colProjections
          }));
        }),
        rowKeys: [],
        columnKeys: []
      } : {
        getDataModelMatrix: () => [
          [
            {
              dataStore: t,
              rowProjections: [...m.flat()],
              columnProjections: [...B.flat()],
              columnFacetValues: [],
              rowFacetValues: []
            }
          ]
        ],
        rowKeys: [],
        columnKeys: []
      };
    t = this.generateTotalsMatrixMaps(
      A,
      o,
      a,
      r,
      s,
      l,
      c,
      t,
      g
    ) ?? t;
    let R;
    const G = (W, U) => {
      const J = W.getSchema(), V = U.getSchema(), Y = /* @__PURE__ */ new Map();
      return J.forEach(({ name: tt, ...st }) => {
        Y.set(tt, {
          name: tt,
          subtype: st.subtype,
          ...st
        });
      }), V.forEach(({ name: tt, ...st }) => {
        const lt = Y.get(tt)?.subtype;
        lt === ot.TEMPORAL || st.subtype === ot.TEMPORAL && lt !== st.subtype || st.subtype === ot.CONTINUOUS && lt !== st.subtype || st.subtype === ot.BINNED && lt !== st.subtype ? Y.set(tt, {
          name: tt,
          type: Ct.DIMENSION,
          subtype: ot.CATEGORICAL
        }) : Y.set(tt, {
          name: tt,
          subtype: st.subtype,
          ...st
        });
      }), [...Y.values()];
    };
    if (u && h && !c) {
      const W = Nn(
        [t, A, o, a],
        void 0,
        {
          preserveNullColumns: !0,
          dmSchema: A && o ? G(A, o) : null
        }
      );
      W.openBroadcastChannel(), R = W.splitByRow(x);
    } else if (u && !c) {
      const W = Nn([t, o], void 0, {
        preserveNullColumns: !0,
        dmSchema: o ? o.getSchema() : null
      });
      W.openBroadcastChannel(), R = W.splitByRow(x);
    } else if (h && !c) {
      const W = Nn([t, A], void 0, {
        preserveNullColumns: !0,
        dmSchema: A ? A.getSchema() : null
      });
      W.openBroadcastChannel(), R = W.splitByRow(x);
    } else
      R = t.splitByRow(x);
    this._emptyDm = t.createEmptyDm();
    let T = 0;
    const v = [], H = [], N = ({
      rowCollapsed: W,
      colCollapsed: U,
      facetedDataStore: J,
      rowKey: V,
      colKey: Y,
      isRowSubTotalsEnabled: nt,
      isColSubTotalsEnabled: tt,
      context: st
    }) => {
      const lt = st._rowTotalsMatrixMap, at = st._colTotalsMatrixMap, Dt = st._greatTotalsMatrixMap, Qt = W && U, At = [
        {
          collapsed: W && !Qt,
          dm: at?.get(`${Y}-${V}`)
        },
        {
          collapsed: U && !Qt,
          dm: lt?.get(`${V}-${Y}`)
        },
        {
          collapsed: Qt || W && nt || U && tt,
          dm: Dt?.get(`${Y}-${V}`)
        }
      ].map(({ collapsed: Vt, dm: _t }) => Vt ? _t : null).filter((Vt) => Vt != null);
      return At.length ? At.length > 1 ? Nn(At, void 0, {
        preserveNullColumns: !0
      }) : At[0] : J;
    }, M = [...R].reduce(
      (W, U) => {
        const {
          rowKey: J,
          allKeys: V,
          isCollapsed: Y
        } = w0(
          U,
          this._rowFacets,
          p,
          Q,
          v,
          0,
          this._rowCollapseStatus,
          f
        ), {
          rowKey: nt,
          allKeys: tt,
          isCollapsed: st
        } = w0(
          U,
          this._columnFacets,
          w,
          y,
          H,
          1,
          this._columnCollapseStatus,
          d
        );
        return T += Y + st, this._mainFacetedDataStoreMatrixMap.set(
          `${V}-${tt}`,
          U
        ), W.set(
          `${J}-${nt}`,
          N({
            rowCollapsed: Y,
            colCollapsed: st,
            context: this,
            rowKey: J,
            colKey: nt,
            isRowSubTotalsEnabled: h,
            isColSubTotalsEnabled: u,
            facetedDataStore: U
          })
        );
      },
      /* @__PURE__ */ new Map()
    ), { treeRowKeys: F, treeColumnKeys: k } = b0(
      Q,
      y,
      this._rowFacets,
      this._columnFacets,
      n
    );
    if (T > 0) {
      const { treeRowKeys: W, treeColumnKeys: U } = b0(
        v,
        H,
        this._rowFacets,
        this._columnFacets,
        n
      );
      this._allTreeRowKeys = W, this._allTreeColKeys = U;
    } else
      this._allTreeRowKeys = F, this._allTreeColKeys = k;
    Q = F.leaves().map((W) => W.data[1] == null ? [] : W.data[1][0]), y = k.leaves().map((W) => W.data[1] == null ? [] : W.data[1][0]);
    const O = D0(Q), P = D0(y);
    let L = [];
    const q = O.map(
      ({ keyArr: W, joinedKey: U }) => P.map(
        ({ keyArr: J, joinedKey: V }) => {
          const Y = `${U}-${V}`, nt = M.has(Y) ? M.get(Y) : this._emptyDm;
          return {
            rowFacetValues: W,
            facetedDataStore: nt,
            columnFacetValues: J
          };
        }
      )
    );
    return L = DW(
      S.map((W) => {
        const U = x0(
          W,
          _,
          E
        );
        return q.map(
          (J) => J.flatMap(
            ({ rowFacetValues: V, columnFacetValues: Y, facetedDataStore: nt }) => U.map((tt, st) => ({
              dataStore: nt,
              rowFacetValues: V,
              columnFacetValues: Y,
              rowProjections: W[st].rowProjections,
              columnProjections: W[st].colProjections
            }))
          )
        );
      })
    ), {
      dataModelMatrix: L,
      rowKeys: Q,
      columnKeys: Ye(y)
    };
  }
  getUpdatedDataModel(t, i, n, s, A, o, a) {
    let r;
    switch (`${t}-${i}`) {
      case "true-true":
        r = this._greatTotalsMatrixMap.get(
          `${o}-${A}`
        );
        break;
      case "true-false":
        (s || t) && n ? a ? r = this._colTotalsMatrixMap.get(
          `${o}-${A}`
        ) : r = Nn(
          [
            this._colTotalsMatrixMap.get(`${o}-${A}`),
            this._greatTotalsMatrixMap.get(`${o}-${A}`)
          ],
          void 0,
          { preserveNullColumns: !0 }
        ) : r = this._colTotalsMatrixMap.get(
          `${o}-${A}`
        );
        break;
      case "false-true":
        s && (n || i) ? a ? r = this._rowTotalsMatrixMap.get(
          `${A}-${o}`
        ) : r = Nn(
          [
            this._rowTotalsMatrixMap.get(`${A}-${o}`),
            this._greatTotalsMatrixMap.get(`${o}-${A}`)
          ],
          void 0,
          { preserveNullColumns: !0 }
        ) : r = this._rowTotalsMatrixMap.get(
          `${A}-${o}`
        );
        break;
      default:
        r = this._mainFacetedDataStoreMatrixMap.get(
          `${A}-${o}`
        );
        break;
    }
    return r ?? this._emptyDm;
  }
  updatedDataModelAtIndex(t, i, n, s, A, o, a) {
    const { rowFacetValues: r, columnFacetValues: l } = t[i][n], c = !!this._rowCollapseStatus(r), g = !!this._columnCollapseStatus(l), {
      rows: {
        totals: {
          subTotals: { enabled: h } = { enabled: !1 }
        } = {}
      } = {},
      columns: {
        totals: {
          subTotals: { enabled: d } = { enabled: !1 }
        } = {}
      } = {}
    } = s.config(), u = this.getUpdatedDataModel(
      c,
      g,
      h,
      d,
      r,
      l,
      a
    );
    return nA(
      KA(
        s,
        A,
        [
          [
            {
              ...t[i][n],
              dataStore: u
            }
          ]
        ],
        o
      ),
      s.config()
    )[0][0];
  }
  updateMatrixModelForTargetPath(t, i, n, s, A, o, a, r) {
    let {
      dataModelMatrix: l,
      rowKeys: c,
      columnKeys: g,
      allRowHeaderKeys: h,
      allColumnHeaderKeys: d
    } = n;
    const u = [], f = {
      entrySet: [],
      exitSet: [
        [-1, -1],
        [-1, -1]
      ],
      // [ row: [startIndex, endIndex], col: [startIndex, endIndex] ]
      updateSet: [],
      splitFieldUniques: [],
      splitFieldIdx: -1
    }, {
      rows: {
        totals: {
          subTotals: {
            enabled: C,
            splitTotal: { field: I }
          } = { enabled: !1 }
        } = {}
      } = {},
      columns: {
        totals: {
          subTotals: {
            enabled: E,
            splitTotal: { field: B }
          } = { enabled: !1 }
        } = {}
      } = {}
    } = s.config(), m = i === "row" ? this._rowFacets : this._columnFacets;
    let p;
    i === "row" ? p = I : p = B;
    const w = i === "row" ? a : r;
    if (t.length === m.length) {
      const Q = xW(
        t,
        l,
        i,
        {
          allRowHeaderKeys: h,
          allColumnHeaderKeys: d
        }
      );
      Q.forEach(([y, D]) => {
        const { metaInfo: _ } = l[y][D];
        [Aa, sa, Ur].includes(
          _?.totals?.type
        ) ? u.push([y, D]) : l[y][D] = this.updatedDataModelAtIndex(
          l,
          y,
          D,
          s,
          A,
          o
        );
      }), f.updateSet = Q;
    } else {
      const Q = s.config(), y = t[t.length - 1].collapsed;
      let { startIndex: D, endIndex: _ } = SW(
        t,
        {
          allRowHeaderKeys: h,
          allColumnHeaderKeys: d
        },
        i
      );
      const x = Q.columns.totals.grandTotals, S = Q.rows.totals.grandTotals, b = x.enabled && x.position === "start" ? h.length - c.length : 0, R = S.enabled && S.position === "start" ? d.length - (g[0]?.length || 0) : 0;
      let G = D - b, T = _ - b, v = D - R, H = _ - R;
      const N = t.find(({ field: k }) => k === p) ? -1 : m.indexOf(p);
      f.splitFieldUniques = E7(
        w,
        p,
        t
      ), f.splitFieldIdx = N;
      const M = N >= 0 ? f.splitFieldUniques : [];
      let F;
      if (M.length > 0 ? (F = _ - M.length + 1, T = i === "row" ? T - M.length + 1 : T, H = i === "row" ? H : H - M.length + 1) : F = _, y)
        if (i === "row") {
          let k;
          if (M.length > 0) {
            const q = l.slice(
              D,
              D + M.length
            ), $ = l.slice(
              D,
              _ + 1
            ), W = [
              ...new Set(
                $.map(
                  ([{ rowFacetValues: U }]) => U[N]
                )
              )
            ];
            k = q.map(
              ([{ rowFacetValues: U }], J) => [
                ...U.map(
                  (V, Y) => (
                    // If the row facet index matches the splitField index, then
                    // replace the split field value with values from the unique
                    // ordered split fields in the collapsed facet
                    Y === N ? W[J] : V
                  )
                )
              ]
            );
          } else
            k = l.slice(D, D + 1).map(([{ rowFacetValues: q }]) => [...q]);
          D !== F && (l.splice(D + 1, F - D), f.exitSet[0] = [D + 1, F], c.splice(
            G + 1,
            T - G
          ));
          const P = k.map(
            (q) => {
              const $ = q.map((W, U) => [W, U]).splice(
                t.length,
                q.length - t.length
              );
              return q.splice(
                t.length,
                q.length - t.length
              ), $;
            }
          ).map(
            (q) => q.map(([$, W]) => N > 0 && W === N ? $ : Mn)
          );
          k = AI(k, P).map(
            ([q, $]) => q.concat($)
          ), c.splice(
            G,
            k.length,
            ...k
          );
          const L = l.slice(
            D,
            D + k.length
          );
          L.forEach((q, $, W) => {
            const U = D + $;
            q.forEach((V, Y) => {
              const { metaInfo: nt } = V;
              f.updateSet.push([U, Y]), [
                Aa,
                sa,
                Ur
              ].includes(nt?.totals?.type) && u.push([U, Y]), V.rowFacetValues = k[$];
              const tt = !!this._columnCollapseStatus(
                V.columnFacetValues
              );
              V.dataStore = this.getUpdatedDataModel(
                !0,
                tt,
                C,
                E,
                V.rowFacetValues,
                V.columnFacetValues
              );
            });
            let J = nA(
              KA(
                s,
                A,
                [q],
                o
              ),
              s.config()
            );
            W[$] = J[0];
          }), l.splice(
            D,
            k.length,
            ...L
          );
        } else {
          let k;
          if (M.length > 0) {
            const L = l[0].slice(
              D,
              D + M.length
            ), q = l[0].slice(
              D,
              _ + 1
            ), $ = [
              ...new Set(
                q.map(
                  ({ columnFacetValues: W }) => W[N]
                )
              )
            ];
            k = L.map(
              ({ columnFacetValues: W }, U) => [
                ...W.map(
                  (J, V) => (
                    // If the column facet index matches the splitField index, then
                    // replace the split field value with values from the unique
                    // ordered split fields in the collapsed facet
                    V === N ? $[U] : J
                  )
                )
              ]
            );
          } else
            k = l[0].slice(D, D + 1).map(({ columnFacetValues: L }) => [...L]);
          const P = k.map((L) => {
            const q = L.map(($, W) => [$, W]).splice(
              t.length,
              L.length - t.length
            );
            return L.splice(
              t.length,
              L.length - t.length
            ), q;
          }).map(
            (L) => L.map(([q, $]) => N > 0 && $ === N ? q : Mn)
          );
          k = AI(
            k,
            P
          ).map(
            ([L, q]) => L.concat(q)
          ), g = Ye(g), D !== F && (f.exitSet[1] = [D + 1, F], g.splice(
            v + 1,
            H - v
          )), l.forEach((L, q) => {
            D !== F && L.splice(D + 1, F - D), k.map(
              ($, W) => {
                const U = D + W, J = v + W;
                L[U].columnFacetValues = $;
                const { metaInfo: V } = L[U];
                f.updateSet.push([q, U]), [
                  Aa,
                  sa,
                  Ur
                ].includes(V?.totals?.type) && u.push([q, U]);
                const Y = !!this._rowCollapseStatus(
                  L[U].rowFacetValues
                );
                L[U].dataStore = this.getUpdatedDataModel(
                  Y,
                  !0,
                  C,
                  E,
                  L[U].rowFacetValues,
                  L[U].columnFacetValues
                );
                let nt = nA(
                  KA(
                    s,
                    A,
                    [[L[U]]],
                    o
                  ),
                  s.config()
                );
                L[U] = nt[0][0], g[J] = $;
              }
            );
          }), g = Ye(g);
        }
      else if (i === "row") {
        const k = l.splice(
          D,
          N >= 0 ? M.length : 1
        );
        c.splice(
          G,
          N >= 0 ? M.length : 1
        );
        const O = N0(
          this._allTreeRowKeys,
          t
        );
        let P = [];
        const L = [];
        let q = null, $ = -1;
        for (let W = 0; W < O.length; W++) {
          const U = O[W];
          let J = U.slice(0, t.length), V = !1;
          for (let tt = t.length; tt < U.length; tt++) {
            if (J.push(U[tt]), V = !!this._rowCollapseStatus(J), V) {
              J = J.concat(
                new Array(U.length - tt - 1).fill(Mn)
              );
              break;
            }
            tt === U.length - 1 && !V && (V = !!this._rowCollapseStatus(J));
          }
          const Y = J.join("-");
          if (q === Y)
            continue;
          q = Y, $ += 1, L.push(J);
          let nt = [];
          k[0]?.forEach((tt, st) => {
            const lt = !!this._columnCollapseStatus(
              tt.columnFacetValues
            ), at = this.getUpdatedDataModel(
              V,
              lt,
              C,
              E,
              J,
              tt.columnFacetValues
            );
            nt.push({
              ...tt,
              rowFacetValues: J,
              dataStore: at
            });
            const { metaInfo: Dt } = tt;
            f.updateSet.push([D + $, st]), [
              Aa,
              sa,
              Ur
            ].includes(Dt?.totals?.type) && u.push([D + $, st]);
          }), P.push(nt);
        }
        P = nA(
          KA(
            s,
            A,
            P,
            o
          ),
          s.config()
        ), P.length > 1 && (f.entrySet[0] = [
          D + 1,
          D + P.length - 1
        ]), l.splice(D, 0, ...P), c.splice(G, 0, ...L);
      } else {
        let k = [];
        const O = N0(
          this._allTreeColKeys,
          t
        );
        l.forEach((P, L) => {
          let q = [];
          k = [];
          const $ = P.splice(
            D,
            N >= 0 ? M.length : 1
          );
          let W = null, U = -1;
          for (let J = 0; J < O.length; J++) {
            const V = O[J];
            let Y = V.slice(0, t.length), nt = !1;
            for (let Dt = t.length; Dt < V.length; Dt++) {
              if (Y.push(V[Dt]), nt = !!this._columnCollapseStatus(Y), nt) {
                Y = Y.concat(
                  new Array(V.length - Dt - 1).fill(Mn)
                );
                break;
              }
              Dt === V.length - 1 && !nt && (nt = !!this._columnCollapseStatus(Y));
            }
            const tt = Y.join("-");
            if (W === tt)
              continue;
            W = tt, U += 1, k.push(Y);
            const st = !!this._rowCollapseStatus(
              $[0].rowFacetValues
            ), lt = this.getUpdatedDataModel(
              st,
              nt,
              C,
              E,
              $[0].rowFacetValues,
              Y
            );
            q.push({
              ...$[0],
              columnFacetValues: Y,
              dataStore: lt
            });
            const { metaInfo: at } = $[0];
            [
              Aa,
              sa,
              Ur
            ].includes(at?.totals?.type) && u.push([L, D + U]), f.updateSet.push([L, D + U]);
          }
          q.length > 1 && (f.entrySet[1] = [
            D + 1,
            D + q.length - 1
          ]), q = nA(
            KA(
              s,
              A,
              [q],
              o
            ),
            s.config()
          ), P.splice(D, 0, ...q[0]);
        }), g = Ye(g), g.splice(
          v,
          N >= 0 ? M.length : 1,
          ...k
        ), g = Ye(g);
      }
    }
    return {
      dataModelMatrix: l,
      rowKeys: c,
      columnKeys: g,
      grandTotalsCoordinates: u,
      updateInfo: f
    };
  }
  updateGrandTotalsMatrix(t, i, n, s, A) {
    return t.forEach(([o, a]) => {
      i[o][a] = this.updatedDataModelAtIndex(
        i,
        o,
        a,
        n,
        s,
        A,
        !0
      );
    }), i;
  }
  getFilterQuery(t, i, n) {
    return {
      operator: i,
      conditions: [
        ...t.filter((s) => s !== ht).map((s) => ({
          field: s,
          value: Mn,
          operator: n
        }))
      ]
    };
  }
  generateTotalsMatrixMaps(t, i, n, s, A = {}, o, a, r, l) {
    const {
      rowFacetsConfig: c,
      rowTotalsSplitField: g,
      colFacetsConfig: h,
      columnTotalsSplitField: d
    } = tA(A), {
      rows: {
        totals: { subTotals: { enabled: u } = {} } = {}
      } = {},
      columns: {
        totals: { subTotals: { enabled: f } = {} } = {}
      } = {}
    } = A, {
      interaction: { collapse: { enabled: C } = {} } = {}
    } = c ?? {}, {
      interaction: { collapse: { enabled: I } = {} } = {}
    } = h ?? {}, E = this._rowFacets.concat(this._columnFacets);
    let B;
    if (a && l === "row") {
      const m = [
        ...this._rowFacets,
        ...o.discreteRowProjections
      ].filter((p) => `${p}` !== g);
      i = r.select(
        this.getFilterQuery(m, "or", "eq")
      ), f || (B = r.select(
        this.getFilterQuery(m, "and", "neq")
      ), t = B);
    }
    if (a && l === "column") {
      const m = [
        ...this._columnFacets,
        ...o.discreteColumnProjections
      ].filter((p) => `${p}` !== d);
      t = r.select(
        this.getFilterQuery(m, "or", "eq")
      ), u || (B = r.select(
        this.getFilterQuery(m, "and", "neq")
      ), i = B);
    }
    if ((C || f) && (this._colTotalsMatrixMap = /* @__PURE__ */ new Map(), i?.splitByRow(E)?.reduce((m, p) => {
      const w = Xo(this._rowFacets, p), Q = Xo(this._columnFacets, p);
      return m.set(`${Q}-${w}`, p);
    }, this._colTotalsMatrixMap), C && (this._rowCollapseStatus = (m) => s.getRowCollapseState(
      m?.filter((p) => p !== Mn)
    ))), (I || u) && (this._rowTotalsMatrixMap = /* @__PURE__ */ new Map(), t?.splitByRow(E)?.reduce((m, p) => {
      const w = Xo(this._rowFacets, p), Q = Xo(this._columnFacets, p);
      return m.set(`${w}-${Q}`, p);
    }, this._rowTotalsMatrixMap), I && (this._columnCollapseStatus = (m) => s.getColumnsCollapseState(
      m?.filter((p) => p !== Mn)
    ))), (C || f) && (I || u) && (this._greatTotalsMatrixMap = /* @__PURE__ */ new Map(), n?.splitByRow(E)?.reduce((m, p) => {
      const w = Xo(this._rowFacets, p), Q = Xo(this._columnFacets, p);
      return m.set(`${Q}-${w}`, p);
    }, this._greatTotalsMatrixMap)), B)
      return B;
  }
}
const B7 = ({
  dataStore: e,
  detailedFacetProjectionInfo: t,
  columnTotalString: i,
  aggregations: n,
  splitField: s,
  rowSplitField: A
}) => {
  const o = [], a = [];
  return [
    ...t.continuousColumnProjections,
    ...t.continuousRowProjections,
    ...t.continuousOptionalProjections
  ].forEach((r) => {
    e.getSchema().find((c) => c.name === `${r}`)?.type === Ct.DIMENSION ? o.push(r) : a.push(r);
  }), P1(
    e,
    t.colFacets.flatMap((r) => r.getMembers()).concat(t.discreteColumnProjections),
    t.rowFacets.flatMap((r) => r.getMembers()).concat(t.discreteRowProjections),
    t.discreteOptionalProjections,
    a,
    { totalString: i, isRow: !1, aggregations: n },
    s,
    A,
    o
  );
}, m7 = ({
  columnTotalsDSWithAll: e,
  columnTotalString: t,
  facetsAndProjections: i,
  matrixModelConfig: n,
  matrixModelInst: s,
  detailedFacetProjectionInfo: A,
  splitField: o,
  rowSplitField: a
}) => {
  const r = PB(
    e,
    A,
    a,
    o,
    t
  );
  let l = r ? e.select(r) : e;
  return l.getData().data.length === 0 && (l = e), {
    matrixModel: s.getMatrixModel(
      l,
      i,
      n
    )
  };
}, p7 = ({
  facetsAndProjections: e,
  suppliedLayers: t,
  globalConfig: i,
  dataStore: n,
  detailedFacetProjectionInfo: s,
  canvasHelpers: A,
  subTotalsInfo: { rowSubTotalsDS: o, columnSubTotalsDS: a, greatSubTotalsDS: r }
}) => {
  let {
    facetSortConfig: l,
    columns: {
      totals: {
        grandTotals: {
          enabled: c,
          text: g,
          layers: h,
          splitTotal: { field: d, text: u }
        },
        data: {
          dataModel: f,
          grandTotalsDM: C,
          totalString: I
        },
        // position: columnTotalPosition,
        aggregations: E
      },
      facets: {
        interaction: { collapse: { enabled: B } = {} } = {}
      } = {}
    },
    rows: {
      totals: {
        grandTotals: { enabled: m },
        subTotals: {
          enabled: p,
          splitTotal: { field: w }
        } = {},
        grandTotals: { splitTotal: { field: Q } } = {}
      } = {}
    } = {}
  } = i;
  const y = {
    facetSortConfig: l,
    globalConfig: i,
    canvasHelpers: A,
    detailedFacetProjectionInfo: s,
    isGrandTotals: !0,
    totalsType: "column",
    rowTotalsDM: o,
    columnTotalsDM: a,
    greatTotalsDM: r
  }, D = (G) => G != ht, _ = [
    ...s.discreteRowProjections.filter(
      D
    ),
    ...s.rowFacets
  ], x = [
    ...s.colFacets,
    ...s.discreteColumnProjections.filter(
      D
    )
  ], S = [..._, ...x], b = _.find((G) => `${G}` === d)?.toString() ?? void 0, R = x.find((G) => `${G}` === w)?.toString() ?? void 0;
  if (c && S.length > 0) {
    let G;
    if (C && C.getData().data.length > 0) {
      const W = n.getSchema().find(({ name: U }) => U === ht);
      if (C.setCreatorIdentifier(n.getCreatorIdentifier()).openBroadcastChannel(), W) {
        const [U] = n.getField(ht).domain();
        if (C.getDataMeta().rows === 0) {
          const J = K.DataModel(), V = C.getSchema().filter(({ name: Y }) => Y !== pt.ROW_ID).concat({
            name: ht,
            type: mi
          });
          C = new J({
            schema: V,
            data: [[]]
          });
        } else
          C = C.calculateVariable(
            {
              name: ht,
              type: mi
            },
            C.getSchema().filter(({ name: J }) => J !== ht).map(({ name: J }) => J),
            () => U
          );
      } else
        C = C.project(
          C.getSchema().filter(({ name: U }) => U !== pt.ROW_ID).map(({ name: U }) => U)
        );
      G = new K(C, {
        creatorIdentifier: n.getCreatorIdentifier(),
        ...n._model._config
      });
    } else if (f) {
      const W = n.getSchema().find(({ name: J }) => J === ht);
      if (f.setCreatorIdentifier(n.getCreatorIdentifier()).openBroadcastChannel(), W) {
        const [J] = n.getField(ht).domain();
        if (f.getDataMeta().rows === 0) {
          const V = K.DataModel(), Y = f.getSchema().filter(({ name: nt }) => nt !== pt.ROW_ID).concat({
            name: ht,
            type: mi
          });
          f = new V({
            schema: Y,
            data: [[]]
          });
        } else
          f = f.calculateVariable(
            {
              name: ht,
              type: mi
            },
            f.getSchema().filter(({ name: V }) => V !== ht).map(({ name: V }) => V),
            () => J
          );
      } else
        f = f.project(
          f.getSchema().filter(({ name: J }) => J !== pt.ROW_ID).map(({ name: J }) => J)
        );
      f = f.select({
        operator: "and",
        conditions: [
          ...s.rowFacets,
          ...s.discreteRowProjections
        ].filter((J) => {
          const V = `${J}`;
          return !(V === ht) && !(V === b) && !(p && V === R);
        }).map((J) => ({
          field: `${J}`,
          value: I,
          operator: "eq"
        }))
      });
      const U = [
        ...s.colFacets,
        ...s.discreteColumnProjections,
        ...s.continuousColumnProjections.filter(
          (J) => n.getSchema().find(({ name: V }) => V === J).type === Ct.DIMENSION
        )
      ].filter((J) => `${J}` !== ht);
      !m && U.length && (f = f.select(
        {
          operator: "and",
          conditions: [
            ...s.rowFacets,
            ...s.discreteRowProjections,
            ...U,
            ...s.continuousRowProjections.filter(
              (J) => n.getSchema().find(({ name: V }) => V === J).type === Ct.DIMENSION
            )
          ].filter((J) => {
            const V = `${J}`;
            return !(V === ht) && !(V === b) && !(p && V === R);
          }).map((J) => ({
            field: `${J}`,
            value: I,
            operator: "eq"
          }))
        },
        {
          mode: "inverse"
        }
      )), G = new K(f, {
        creatorIdentifier: n.getCreatorIdentifier(),
        ...n._model._config
      });
    } else {
      if (G = new K(
        B7({
          detailedFacetProjectionInfo: s,
          dataStore: n,
          columnTotalString: I,
          aggregations: E,
          splitField: b,
          rowSplitField: Q
        }),
        {
          creatorIdentifier: n.getCreatorIdentifier(),
          ...n._model._config
        }
      ), B || p) {
        const { colFacets: W } = e, U = [], J = [], V = G.getSchema();
        U.push(
          ...s.discreteOptionalProjections
        ), [
          ...s.continuousColumnProjections,
          ...s.continuousRowProjections,
          ...s.continuousOptionalProjections
        ].forEach((Y) => {
          V.find(
            (tt) => tt.name === `${Y}`
          )?.type === Ct.DIMENSION && U.push(Y);
        }), b && U.push(`${b}`), R && U.push(`${R}`), W.forEach((Y, nt) => {
          U.push(`${Y}`);
          const tt = [
            ...W.slice(nt + 1).map((_t) => `${_t}`),
            ...s.discreteRowProjections,
            ...s.discreteColumnProjections,
            ...s.rowFacets.map((_t) => `${_t}`)
          ].filter(
            (_t) => `${_t}` !== b && `${_t}` !== R
          );
          let st = G.groupBy([
            .../* @__PURE__ */ new Set([...U])
          ]);
          st = st.select({
            operator: "and",
            conditions: [
              ...U.map((_t) => `${_t}`).map((_t) => ({
                field: _t,
                value: I,
                operator: "neq"
              }))
            ]
          });
          const { data: lt, schema: at } = st.getData({
            excludeFields: [
              pt.ROW_ID,
              ...tt.map((_t) => `${_t}`)
            ],
            shouldSanitize: !0
          }), Dt = Ye(lt), Qt = tt.map(
            () => new Array(lt.length).fill(0).map(() => I)
          ), St = [...Dt, ...Qt], At = [
            ...at,
            ...tt.map((_t) => ({
              name: `${_t}`,
              type: Ct.DIMENSION,
              subtype: V.find((zt) => zt.name === `${_t}`).subtype
            }))
          ], Vt = new K({
            data: St,
            schema: At
          });
          J.push(Vt);
        }), J.unshift(G), G = Nn(J, null, {
          creatorIdentifier: n.getCreatorIdentifier(),
          ...n._model._config
        }), J.forEach((Y) => Y.dispose()), J.length = 0;
      }
      G.openBroadcastChannel();
    }
    const T = new Su(), {
      matrixModel: {
        rowKeys: v,
        columnKeys: H,
        dataModelMatrix: N
      }
    } = m7({
      facetsAndProjections: e,
      detailedFacetProjectionInfo: s,
      columnTotalsDSWithAll: G,
      columnTotalString: I,
      matrixModelConfig: y,
      splitField: b,
      rowSplitField: Q,
      matrixModelInst: T
    }), M = i.rows.facets, F = M?.fields[b], k = F ? F.formatter : M.formatter, O = h == null ? t : Sc(h), P = v.map((W) => W.map((U, J) => {
      const V = e.rowFacets[J];
      return `${V}` === b ? {
        value: U,
        format: k ? Ma(k, n) : (Y) => Y,
        key: `${V}-${U}-Total`,
        sourceType: ye,
        rawValue: U
      } : J === 0 ? {
        value: g,
        format: () => g,
        sourceType: ye,
        rawValue: I
      } : {
        value: "",
        format: (Y) => Y,
        sourceType: ye,
        rawValue: I
      };
    }));
    let L = [];
    for (let W = 0; W < (P.length || 1); W++)
      for (let U = 0; U < e.rowProjections.length; U++) {
        let J = {};
        const V = e.rowProjections[U][0];
        if (V && V.as() === "discrete") {
          const Y = V.toString() === ht, nt = Y ? !1 : void 0;
          P[0] && P[0].length > 0 ? b ? J = {
            show: !Y,
            showAxisName: !1,
            tickFormat: b === `${V}` ? (st) => u ?? st.formattedValue : () => g,
            sourceType: ye
          } : J = {
            show: wt(
              Z(i, "axes", "y", "fields", V, "show"),
              Z(i, "axes", "y", "show")
            ) === !1 ? !1 : !Y,
            tickFormat: () => " ",
            className: "muze-column-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          } : b ? J = {
            show: !Y,
            showAxisName: !1,
            tickFormat: b === `${V}` ? (st) => u ?? st.formattedValue : () => g,
            sourceType: ye
          } : J = {
            ...nt != null && { show: nt },
            tickFormat: () => g,
            className: "muze-column-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          };
        }
        L.push({
          field: V,
          config: J
        });
      }
    let q = [];
    for (let W = 0; W < (P.length || 1); W++)
      for (let U = 0; U < e.rowProjections.length; U++) {
        let J = {};
        const V = e.rowProjections[U][1];
        if (V && V.as() === "discrete") {
          const nt = V.toString() === ht ? !1 : void 0;
          P[0] && P[0].length > 0 ? J = {
            show: !1,
            className: "muze-column-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          } : J = {
            ...nt != null && { show: nt },
            tickFormat: () => g,
            className: "muze-column-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          };
        }
        q.push({
          field: V,
          config: J
        });
      }
    return {
      rowKeys: H1(P, { leftAxisInfo: L }),
      columnKeys: H.map(
        (W) => W.map((U, J) => J === 0 ? g : "")
      ),
      rowAxisInfo: {
        leftAxisInfo: L,
        rightAxisInfo: q
      },
      rowFacetsInfo: {
        leftFacetsInfo: L,
        rightFacetsInfo: q
      },
      dataModelMatrix: N.map((W) => W.map((U) => ({
        ...U,
        suppliedLayers: O.map((J) => ({
          className: "muze-layer-column-grand-totals",
          ...J
        })),
        metaInfo: {
          totals: {
            type: sa
          }
        }
      }))),
      columnTotalsDSWithAll: G,
      matrixModelInst: T
    };
  }
}, Q7 = ({
  dataStore: e,
  facetsAndProjections: t,
  rowTotalString: i,
  detailedFacetProjectionInfo: n,
  aggregations: s,
  splitField: A,
  columnSplitField: o
}) => {
  const { rowFacets: a, colFacets: r } = t, l = [], c = [];
  return [
    ...n.continuousColumnProjections,
    ...n.continuousRowProjections,
    ...n.continuousOptionalProjections
  ].forEach((g) => {
    e.getSchema().find((d) => d.name === g)?.type === Ct.DIMENSION ? l.push(g) : c.push(g);
  }), P1(
    e,
    a.flatMap((g) => g.getMembers()).concat(n.discreteRowProjections),
    r.flatMap((g) => g.getMembers()).concat(n.discreteColumnProjections),
    n.discreteOptionalProjections,
    c,
    { totalString: i, isRow: !0, aggregations: s },
    A,
    o,
    l
  );
}, y7 = ({
  rowTotalsDSWithAll: e,
  rowTotalString: t,
  facetsAndProjections: i,
  matrixModelConfig: n,
  detailedFacetProjectionInfo: s,
  matrixModelInst: A,
  splitField: o
}) => {
  const a = PB(
    e,
    s,
    o,
    null,
    t
  );
  let r = a ? e.select(a) : e;
  return r.getData().data.length === 0 && (r = e), {
    matrixModel: A.getMatrixModel(
      r,
      i,
      n
    ),
    rowTotalsDS: r
  };
}, w7 = ({
  globalConfig: e,
  facetsAndProjections: t,
  suppliedLayers: i,
  dataStore: n,
  detailedFacetProjectionInfo: s,
  canvasHelpers: A,
  subTotalsInfo: { rowSubTotalsDS: o, columnSubTotalsDS: a, greatSubTotalsDS: r }
}) => {
  let {
    facetSortConfig: l,
    rows: {
      totals: {
        grandTotals: {
          enabled: c,
          text: g,
          layers: h,
          splitTotal: { field: d, text: u }
        },
        data: {
          dataModel: f,
          grandTotalsDM: C,
          totalString: I
        },
        aggregations: E
      },
      facets: {
        interaction: { collapse: { enabled: B } = {} } = {}
      } = {}
    },
    columns: {
      totals: {
        subTotals: {
          enabled: m,
          splitTotal: { field: p }
        } = {},
        grandTotals: { splitTotal: { field: w } } = {}
      } = {}
    } = {}
  } = e;
  const Q = {
    facetSortConfig: l,
    globalConfig: e,
    canvasHelpers: A,
    detailedFacetProjectionInfo: s,
    isGrandTotals: !0,
    totalsType: "row",
    rowTotalsDM: o,
    columnTotalsDM: a,
    greatTotalsDM: r
  }, y = (R) => R != ht, D = [
    ...s.discreteRowProjections.filter(
      y
    ),
    ...s.rowFacets
  ], _ = [
    ...s.colFacets,
    ...s.discreteColumnProjections.filter(
      y
    )
  ], x = [...D, ..._], S = _.find((R) => `${R}` === d)?.toString() ?? void 0, b = D.find((R) => `${R}` === p)?.toString() ?? void 0;
  if (c && x.length > 0) {
    let R;
    if (C && C.getData().data.length > 0) {
      const W = n.getSchema().find(({ name: U }) => U === ht);
      if (C.setCreatorIdentifier(n.getCreatorIdentifier()).openBroadcastChannel(), W) {
        const [U] = n.getField(ht).domain();
        if (C.getDataMeta().rows === 0) {
          const J = K.DataModel(), V = C.getSchema().filter(({ name: Y }) => Y !== pt.ROW_ID).concat({
            name: ht,
            type: mi
          });
          C = new J({
            schema: V,
            data: [[]]
          });
        } else
          C = C.calculateVariable(
            {
              name: ht,
              type: mi
            },
            C.getSchema().filter(({ name: J }) => J !== pt.ROW_ID).map(({ name: J }) => J),
            () => U
          );
      } else
        C = C.project(
          C.getSchema().filter(({ name: U }) => U !== pt.ROW_ID).map(({ name: U }) => U)
        );
      R = new K(C, {
        creatorIdentifier: n.getCreatorIdentifier(),
        ...n._model._config
      });
    } else if (f) {
      const W = n.getSchema().find(({ name: U }) => U === ht);
      if (f.setCreatorIdentifier(n.getCreatorIdentifier()).openBroadcastChannel(), W) {
        const [U] = n.getField(ht).domain();
        if (f.getDataMeta().rows === 0) {
          const J = K.DataModel(), V = f.getSchema().filter(({ name: Y }) => Y !== pt.ROW_ID).concat({
            name: ht,
            type: mi
          });
          f = new J({
            schema: V,
            data: [[]]
          });
        } else
          f = f.calculateVariable(
            {
              name: ht,
              type: mi
            },
            f.getSchema().filter(({ name: J }) => J !== pt.ROW_ID).map(({ name: J }) => J),
            () => U
          );
      } else
        f = f.project(
          f.getSchema().filter(({ name: U }) => U !== pt.ROW_ID).map(({ name: U }) => U)
        );
      f = f.select({
        operator: "and",
        conditions: [
          ...s.colFacets,
          ...s.discreteColumnProjections
        ].filter((U) => {
          const J = `${U}`;
          return !(J === ht) && !(J === S) && !(m && J === b);
        }).map((U) => ({
          field: `${U}`,
          value: I,
          operator: "eq"
        }))
      }), R = new K(f, {
        creatorIdentifier: n.getCreatorIdentifier(),
        ...n._model._config
      });
    } else {
      if (R = new K(
        Q7({
          facetsAndProjections: t,
          detailedFacetProjectionInfo: s,
          dataStore: n,
          rowTotalString: I,
          aggregations: E,
          splitField: S
        }),
        {
          creatorIdentifier: n.getCreatorIdentifier(),
          ...n._model._config
        }
      ), B || m) {
        const { rowFacets: W } = t, U = [], J = [], V = R.getSchema();
        U.push(
          ...s.discreteOptionalProjections
        ), [
          ...s.continuousColumnProjections,
          ...s.continuousRowProjections,
          ...s.continuousOptionalProjections
        ].forEach((Y) => {
          V.find((tt) => tt.name === Y)?.type === Ct.DIMENSION && U.push(Y);
        }), S && U.push(`${S}`), b && U.push(`${b}`), W.forEach((Y, nt) => {
          U.push(`${Y}`);
          const tt = [
            ...W.slice(nt + 1).map((_t) => `${_t}`),
            ...s.discreteColumnProjections,
            ...s.discreteRowProjections,
            ...s.colFacets.map((_t) => `${_t}`)
          ].filter(
            (_t) => `${_t}` !== S && `${_t}` !== b
          ), st = R.groupBy([...new Set(U)]), { data: lt, schema: at } = st.getData({
            excludeFields: [
              pt.ROW_ID,
              ...tt.map((_t) => `${_t}`)
            ],
            shouldSanitize: !0
          }), Dt = Ye(lt), Qt = tt.map(
            () => new Array(lt.length).fill(0).map(() => I)
          ), St = [...Dt, ...Qt], At = [
            ...at,
            ...tt.map((_t) => ({
              name: `${_t}`,
              type: Ct.DIMENSION,
              subtype: V.find((zt) => zt.name === `${_t}`).subtype
            }))
          ], Vt = new K({
            data: St,
            schema: At
          });
          J.push(Vt);
        }), J.unshift(R), R = Nn(J, null, {
          creatorIdentifier: n.getCreatorIdentifier(),
          ...n._model._config
        }), J.forEach((Y) => Y.dispose()), J.length = 0;
      }
      R.openBroadcastChannel();
    }
    const G = new Su(), {
      matrixModel: {
        rowKeys: T,
        columnKeys: v,
        dataModelMatrix: H
      }
      // rowTotalsDS
    } = y7({
      rowTotalsDSWithAll: R,
      detailedFacetProjectionInfo: s,
      rowTotalString: I,
      facetsAndProjections: t,
      matrixModelConfig: Q,
      matrixModelInst: G,
      splitField: S
    }), N = h == null ? i : Sc(h), M = Z(v[0], "length") || 1;
    let F = [];
    for (let W = 0; W < M; W++)
      t.colProjections.forEach((U) => {
        let J = {};
        const V = U[0];
        if (V && V.as() === "discrete") {
          const Y = V.toString() === ht, nt = Y ? !1 : void 0;
          v[0] && v[0].length ? S ? J = {
            ...nt != null && { show: nt },
            tickFormat: S === `${V}` ? (st) => u ?? st.formattedValue : () => g,
            className: "muze-row-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          } : J = {
            show: !Y,
            /**
             * Giving one space reduces the row grand total column width. This is because layout takes the axis width
             * and sets it as the column width. Ideally, layout should take the maximum width of facets and the axis.
             * @todo Need to fix the layout behaviour.
             * Source issue: bcb0c8a8155ab77886102b9168cac5d3f945c308
             */
            tickFormat: () => " ".repeat(5),
            className: "muze-row-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          } : S ? J = {
            ...nt != null && { show: nt },
            tickFormat: S === `${V}` ? (st) => u ?? st.formattedValue : () => g,
            className: "muze-row-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          } : J = {
            ...nt != null && { show: nt },
            tickFormat: () => g,
            className: "muze-row-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          };
        }
        F.push({
          field: V,
          config: J
        });
      });
    let k = [];
    for (let W = 0; W < M; W++)
      t.colProjections.forEach((U) => {
        const J = U[1];
        let V = {};
        if (J && J.as() === "discrete") {
          const nt = J.toString() === ht ? !1 : void 0;
          v[0] && v[0].length > 0 ? V = {
            show: !1,
            className: "muze-row-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          } : V = {
            ...nt != null && { show: nt },
            tickFormat: () => g,
            className: "muze-row-grand-totals-label",
            showAxisName: !1,
            sourceType: ye
          };
        }
        k.push(V);
      });
    const O = U1(v, {
      topAxisInfo: F,
      bottomAxisInfo: k
    }), P = e.columns.facets, L = P?.fields[S], q = L ? L.formatter : P.formatter, $ = O.map((W) => W.map((U, J) => {
      const V = t.colFacets[J];
      return `${V}` === S ? {
        value: U,
        rawValue: U,
        format: q ? Ma(q, n) : () => U,
        key: `${V}-${U}-Total`,
        sourceType: ye
      } : J === 0 ? {
        value: g,
        format: () => g,
        sourceType: ye,
        rawValue: I
      } : {
        value: "",
        format: () => "",
        sourceType: ye,
        rawValue: I
      };
    }));
    return {
      rowKeys: T.map(
        (W, U) => W.map(() => U === 0 ? g : "")
      ),
      columnKeys: $,
      columnAxisInfo: {
        topAxisInfo: F,
        bottomAxisInfo: k
      },
      columnFacetsInfo: {
        topFacetsInfo: F,
        bottomFacetsInfo: k
      },
      dataModelMatrix: H.map((W) => W.map((U) => ({
        ...U,
        suppliedLayers: N.map((J) => ({
          className: "muze-layer-row-grand-totals",
          ...J
        })),
        metaInfo: {
          totals: {
            type: Aa
          }
        }
      }))),
      rowTotalsDSWithAll: R,
      matrixModelInst: G
    };
  }
}, D7 = ({
  columnTotalsDSWithAll: e,
  detailedFacetProjectionInfo: t,
  columnTotalString: i,
  columnTotalSplitField: n,
  rowTotalSplitField: s
}) => {
  const A = [
    ...new Set(
      [
        ...t.discreteRowProjections,
        ...t.rowFacets,
        ...t.discreteColumnProjections,
        ...t.colFacets
      ].flatMap(
        (d) => typeof d == "string" ? d : d.getMembers()
      ).filter((d) => d !== ht)
    )
  ], o = [
    ...t.continuousColumnProjections,
    ...t.continuousRowProjections,
    ...t.continuousOptionalProjections
  ].filter((d) => e.getSchema().find((f) => f.name === `${d}`)?.type === Ct.DIMENSION), a = e.getSchema().map(
    (d) => d.subtype === "temporal" && o.findIndex(
      (u) => `${u}` === d.name
    ) === -1 ? { ...d, subtype: "categorical" } : d
  ), r = e.project(
    a.map((d) => d.name)
  ), { data: l, schema: c } = r.getData({
    excludeFields: [pt.ROW_ID],
    shouldSanitize: !0
  });
  r.dispose();
  const g = A.filter(
    (d) => `${d}` !== n && `${d}` !== s
  );
  return new K(
    {
      data: Ye(l),
      schema: c
    },
    {
      creatorIdentifier: e.getCreatorIdentifier(),
      ...e._model._config
    }
  ).openBroadcastChannel().select(
    lr(
      [g, g.map(() => i)],
      e
    )
  );
}, x7 = ({
  dataStore: e,
  globalConfig: t,
  facetsAndProjections: i,
  columnTotalsDSWithAll: n,
  detailedFacetProjectionInfo: s,
  suppliedLayers: A,
  canvasHelpers: o
}) => {
  let {
    sort: a,
    facetSortConfig: r,
    columns: {
      totals: {
        grandTotals: {
          layers: l,
          splitTotal: { field: c }
        },
        data: { greatGrandTotalsDM: g, totalString: h }
      }
    },
    rows: {
      totals: {
        grandTotals: {
          splitTotal: { field: d }
        }
      }
    }
  } = t;
  const u = {
    globalSortConfig: a,
    facetSortConfig: r,
    globalConfig: t,
    canvasHelpers: o
  }, f = (p) => p != ht, C = [
    ...s.discreteRowProjections.filter(
      f
    ),
    ...s.rowFacets
  ], I = [
    ...s.colFacets,
    ...s.discreteColumnProjections.filter(
      f
    )
  ], E = C.find((p) => `${p}` === c)?.toString() ?? void 0, B = I.find((p) => `${p}` === d)?.toString() ?? void 0;
  let m;
  if (g && g.getData().data.length > 0) {
    const p = e.getSchema().find(({ name: w }) => w === ht);
    if (g.setCreatorIdentifier(e.getCreatorIdentifier()).openBroadcastChannel(), p) {
      const [w] = e.getField(ht).domain();
      if (g.getDataMeta().rows === 0) {
        const Q = K.DataModel(), y = g.getSchema().filter(({ name: D }) => D !== pt.ROW_ID).concat({
          name: ht,
          type: mi
        });
        g = new Q({
          schema: y,
          data: [[]]
        });
      } else
        g = g.calculateVariable(
          {
            name: ht,
            type: mi
          },
          g.getSchema().filter(({ name: Q }) => Q !== ht).map(({ name: Q }) => Q),
          () => w
        );
    } else
      g = g.project(
        g.getSchema().filter(({ name: w }) => w !== pt.ROW_ID).map(({ name: w }) => w)
      );
    m = new K(g, {
      creatorIdentifier: e.getCreatorIdentifier(),
      ...e._model._config
    });
  } else
    m = D7({
      columnTotalsDSWithAll: n,
      detailedFacetProjectionInfo: s,
      columnTotalString: h,
      columnTotalSplitField: E,
      rowTotalSplitField: B
    });
  if (m && !m.isEmpty()) {
    const {
      rowKeys: p,
      columnKeys: w,
      dataModelMatrix: Q
    } = new Su().getMatrixModel(
      m,
      i,
      u
    ), y = l == null ? A : Sc(l);
    return {
      rowKeys: p,
      columnKeys: w,
      dataModelMatrix: Q.map((D) => D.map((_) => ({
        ..._,
        suppliedLayers: y.map((x) => ({
          className: "muze-layer-great-grand-totals",
          ...x
        })),
        metaInfo: {
          totals: {
            type: "greatGrandTotals"
          }
        }
      }))),
      greatTotalsDS: m
    };
  }
}, S7 = ({
  detailedFacetProjectionInfo: e,
  facetsAndProjections: t,
  globalConfig: i,
  dataStore: n
}) => {
  const { colFacets: s } = t;
  let {
    rows: {
      totals: {
        subTotals: {
          enabled: A,
          splitTotal: { field: o }
        } = { enabled: !1, splitTotal: {} },
        grandTotals: {
          enabled: a,
          splitTotal: r
        },
        data: {
          dataModel: l,
          subTotalsDM: c,
          totalString: g
        }
      }
    }
  } = i;
  const h = r?.field, d = i.rows.facets?.interaction?.collapse?.enabled || i.columns.facets?.interaction?.collapse?.enabled, u = [
    ...e.discreteColumnProjections,
    ...s || [],
    ...e.continuousColumnProjections
  ].filter((C) => C && n.getSchema().find(({ name: I }) => I === `${C}`).type === Ct.DIMENSION && C !== ht);
  if (!u.length)
    return null;
  const f = u.find((C) => `${C}` === o)?.toString() ?? void 0;
  if (c) {
    const C = n.getSchema().find(({ name: I }) => I === ht);
    if (c.setCreatorIdentifier(n.getCreatorIdentifier()).openBroadcastChannel(), C) {
      const [I] = n.getField(ht).domain();
      if (c.getDataMeta().rows === 0) {
        const E = K.DataModel(), B = c.getSchema().filter(({ name: m }) => m !== pt.ROW_ID).concat({
          name: ht,
          type: Ct.DIMENSION
        });
        c = new E({
          schema: B,
          data: [[]]
        });
      } else
        c = c.calculateVariable(
          {
            name: ht,
            type: Ct.DIMENSION
          },
          c.getSchema().filter(({ name: E }) => E !== pt.ROW_ID).map(({ name: E }) => E),
          () => I
        );
    } else
      c = c.project(
        c.getSchema().filter(({ name: I }) => I !== pt.ROW_ID).map(({ name: I }) => I)
      );
    return new K(c, {
      creatorIdentifier: n.getCreatorIdentifier(),
      ...n._model._config
    });
  } else if (l) {
    const C = n.getSchema().find(({ name: m }) => m === ht);
    if (l.setCreatorIdentifier(n.getCreatorIdentifier()).openBroadcastChannel(), C) {
      const [m] = n.getField(ht).domain();
      if (l.getDataMeta().rows === 0) {
        const p = K.DataModel(), w = l.getSchema().filter(({ name: Q }) => Q !== pt.ROW_ID).concat({
          name: ht,
          type: Ct.DIMENSION
        });
        l = new p({
          schema: w,
          data: [[]]
        });
      } else
        l = l.calculateVariable(
          {
            name: ht,
            type: Ct.DIMENSION
          },
          l.getSchema().filter(({ name: p }) => p !== pt.ROW_ID).map(({ name: p }) => p),
          () => m
        );
    } else
      l = l.project(
        l.getSchema().filter(({ name: m }) => m !== pt.ROW_ID).map(({ name: m }) => m)
      );
    const I = [
      ...e.continuousColumnProjections,
      ...e.continuousOptionalProjections
    ].map((m) => `${m}`).filter((m) => n.getSchema().find(({ name: p }) => p === m).type === Ct.DIMENSION), E = [
      ...s.map((m) => `${m}`),
      ...e.discreteColumnProjections.map(
        (m) => `${m}`
      ),
      ...I
    ].filter(
      (m) => m !== f && (a ? m !== h : !0)
    ).map((m) => ({
      field: m,
      value: g,
      operator: "eq"
    }));
    l = l.select(
      {
        operator: "and",
        conditions: E
      },
      {
        mode: "inverse"
      }
    );
    const B = K.DataModel();
    return l instanceof B ? new K(l, {
      creatorIdentifier: n.getCreatorIdentifier(),
      ...n._model._config
    }) : l;
  } else if (d || A) {
    const { rowFacets: C, colFacets: I } = t, E = [];
    for (let m = I.length - 1; m >= 0; m--) {
      const p = I.slice(0, m + 1);
      if (A && `${p[p.length - 1]}` == `${f}`)
        continue;
      const w = [
        ...e.continuousColumnProjections,
        ...e.continuousRowProjections,
        ...e.continuousOptionalProjections
      ].map((T) => `${T}`).filter((T) => n.getSchema().find(({ name: v }) => v === T).type === Ct.DIMENSION), Q = n.groupBy([
        .../* @__PURE__ */ new Set([
          ...p.map((T) => `${T}`),
          ...I.map((T) => `${T}`),
          ...e.discreteRowProjections.map(
            (T) => `${T}`
          ),
          ...e.discreteOptionalProjections,
          ...C.map((T) => `${T}`),
          ...A && f ? [f] : [],
          ...w
        ])
      ]);
      let y = [
        ...Ka(I, p),
        ...e.discreteColumnProjections
      ];
      if (A && `${p[p.length - 1]}` != `${f}` && (y = y.filter(
        (T) => `${T}` !== f
      )), y.length === 0)
        continue;
      const { data: D, schema: _ } = Q.getData({
        excludeFields: [
          pt.ROW_ID,
          ...y.map((T) => `${T}`)
        ]
      }), x = Ye(D), S = y.map(
        () => new Array(D.length).fill(0).map(() => g)
      ), b = [...x, ...S], R = [
        ..._,
        ...y.map((T) => ({
          name: `${T}`,
          type: Ct.DIMENSION,
          subtype: ot.CATEGORICAL
        }))
      ], G = new K(
        {
          data: b,
          schema: R
        },
        {
          creatorIdentifier: n.getCreatorIdentifier(),
          ...n._model._config
        }
      );
      E.push(G);
    }
    const B = Nn(E);
    return E.forEach((m) => m.dispose()), E.length = 0, B && (B.setCreatorIdentifier(n.getCreatorIdentifier()).openBroadcastChannel(), B.model.rowSubtotal = !0), B;
  }
}, _7 = ({
  facetsAndProjections: e,
  detailedFacetProjectionInfo: t,
  dataStore: i,
  globalConfig: n
}) => {
  const { rowFacets: s, colFacets: A } = e;
  let {
    columns: {
      totals: {
        subTotals: {
          enabled: o,
          splitTotal: { field: a }
        } = { enabled: !1, splitTotal: {} },
        grandTotals: {
          enabled: r,
          splitTotal: l
        },
        data: {
          subTotalsDM: c,
          dataModel: g,
          totalString: h
        }
      }
    }
  } = n;
  const d = l?.field, u = n.columns.facets?.interaction?.collapse?.enabled || n.rows.facets?.interaction?.collapse?.enabled, f = [
    ...t.discreteRowProjections,
    ...s || [],
    ...t.continuousRowProjections
  ].filter((I) => I && i.getSchema().find(({ name: E }) => E === `${I}`).type === Ct.DIMENSION && I !== ht);
  if (!f.length)
    return null;
  const C = f.find((I) => `${I}` === a)?.toString() ?? void 0;
  if (c) {
    const I = i.getSchema().find(({ name: E }) => E === ht);
    if (c.setCreatorIdentifier(i.getCreatorIdentifier()).openBroadcastChannel(), I) {
      const [E] = i.getField(ht).domain();
      if (c.getDataMeta().rows === 0) {
        const B = K.DataModel(), m = c.getSchema().filter(({ name: p }) => p !== pt.ROW_ID).concat({
          name: ht,
          type: Ct.DIMENSION
        });
        c = new B({
          schema: m,
          data: [[]]
        });
      } else
        c = c.calculateVariable(
          {
            name: ht,
            type: Ct.DIMENSION
          },
          c.getSchema().filter(({ name: B }) => B !== pt.ROW_ID).map(({ name: B }) => B),
          () => E
        );
    } else
      c = c.project(
        c.getSchema().filter(({ name: E }) => E !== pt.ROW_ID).map(({ name: E }) => E)
      );
    return new K(c, {
      creatorIdentifier: i.getCreatorIdentifier(),
      ...i._model._config
    });
  } else if (g) {
    const I = i.getSchema().find(({ name: p }) => p === ht);
    if (g.setCreatorIdentifier(i.getCreatorIdentifier()).openBroadcastChannel(), I) {
      const [p] = i.getField(ht).domain();
      if (g.getDataMeta().rows === 0) {
        const w = K.DataModel(), Q = g.getSchema().filter(({ name: y }) => y !== pt.ROW_ID).concat({
          name: ht,
          type: Ct.DIMENSION
        });
        g = new w({
          schema: Q,
          data: [[]]
        });
      } else
        g = g.calculateVariable(
          {
            name: ht,
            type: Ct.DIMENSION
          },
          g.getSchema().filter(({ name: w }) => w !== pt.ROW_ID).map(({ name: w }) => w),
          () => p
        );
    } else
      g = g.project(
        g.getSchema().filter(({ name: p }) => p !== pt.ROW_ID).map(({ name: p }) => p)
      );
    const E = [
      ...t.continuousRowProjections,
      ...t.continuousOptionalProjections
    ].map((p) => `${p}`).filter((p) => i.getSchema().find(({ name: w }) => w === p).type === Ct.DIMENSION), B = [
      ...s.map((p) => `${p}`),
      ...t.discreteRowProjections.map((p) => `${p}`),
      ...E
    ].filter(
      (p) => p !== C && (r ? p !== d : !0)
    ).map((p) => ({
      field: p,
      value: h,
      operator: "eq"
    }));
    g = g.select(
      {
        operator: "and",
        conditions: B
      },
      {
        mode: "inverse"
      }
    );
    const m = K.DataModel();
    return g instanceof m ? new K(g, {
      creatorIdentifier: i.getCreatorIdentifier(),
      ...i._model._config
    }) : g;
  } else if (u || o) {
    const I = [];
    for (let B = s.length - 1; B >= 0; B--) {
      const m = s.slice(0, B + 1);
      if (o && `${m[m.length - 1]}` == `${C}`)
        continue;
      const p = [
        ...t.continuousRowProjections,
        ...t.continuousColumnProjections,
        ...t.continuousOptionalProjections
      ].map((G) => `${G}`).filter((G) => i.getSchema().find(({ name: T }) => T === G).type === Ct.DIMENSION), w = i.groupBy([
        .../* @__PURE__ */ new Set([
          ...m.map((G) => `${G}`),
          ...s.map((G) => `${G}`),
          ...t.discreteColumnProjections.map(
            (G) => `${G}`
          ),
          ...A.map((G) => `${G}`),
          ...t.discreteOptionalProjections,
          ...o && C ? [C] : [],
          ...p
        ])
      ]);
      let Q = [
        ...Ka(s, m),
        ...t.discreteRowProjections
      ];
      if (o && `${m[m.length - 1]}` !== C && (Q = Q.filter(
        (G) => `${G}` !== C
      )), Q.length === 0)
        continue;
      const { data: y, schema: D } = w.getData({
        excludeFields: [
          pt.ROW_ID,
          ...Q.map((G) => `${G}`)
        ]
      }), _ = Ye(y), x = Q.map(
        () => new Array(y.length).fill(0).map(() => h)
      ), S = [..._, ...x], b = [
        ...D,
        ...Q.map((G) => ({
          name: `${G}`,
          type: Ct.DIMENSION,
          subtype: ot.CATEGORICAL
        }))
      ], R = new K(
        {
          data: S,
          schema: b
        },
        {
          creatorIdentifier: i.getCreatorIdentifier(),
          ...i._model._config
        }
      );
      I.push(R);
    }
    const E = Nn(I);
    return I.forEach((B) => B.dispose()), I.length = 0, E && (E.setCreatorIdentifier(i.getCreatorIdentifier()).openBroadcastChannel(), E.model.colSubTotal = !0), E;
  }
}, b7 = ({
  facetsAndProjections: e,
  detailedFacetProjectionInfo: t,
  dataStore: i,
  columnSubTotalsDM: n,
  globalConfig: s
}) => {
  const { rowFacets: A, colFacets: o } = e;
  let {
    rows: {
      totals: {
        subTotals: {
          enabled: a,
          splitTotal: { field: r }
        } = { enabled: !1, splitTotal: {} }
      } = {}
    } = {},
    columns: {
      totals: {
        subTotals: {
          enabled: l,
          splitTotal: { field: c }
        } = { enabled: !1, splitTotal: {} },
        data: {
          greatSubTotalsDM: g,
          dataModel: h,
          totalString: d
        }
      }
    }
  } = s;
  const u = s.columns.facets?.interaction?.collapse?.enabled || s.rows.facets?.interaction?.collapse?.enabled, C = [
    ...t.discreteRowProjections,
    ...A || [],
    ...t.continuousRowProjections
  ].filter((B) => B && i.getSchema().find(({ name: m }) => m === `${B}`).type === Ct.DIMENSION && B !== ht).find((B) => `${B}` === c)?.toString() ?? void 0, E = [
    ...t.discreteColumnProjections,
    ...o || [],
    ...t.continuousColumnProjections
  ].filter((B) => B && i.getSchema().find(({ name: m }) => m === `${B}`).type === Ct.DIMENSION && B !== ht).find((B) => `${B}` === r)?.toString() ?? void 0;
  if (g) {
    const B = i.getSchema().find(({ name: m }) => m === ht);
    if (g.setCreatorIdentifier(i.getCreatorIdentifier()).openBroadcastChannel(), B) {
      const [m] = i.getField(ht).domain();
      if (g.getDataMeta().rows === 0) {
        const p = K.DataModel(), w = g.getSchema().filter(({ name: Q }) => Q !== pt.ROW_ID).concat({
          name: ht,
          type: Ct.DIMENSION
        });
        g = new p({
          schema: w,
          data: [[]]
        });
      } else
        g = g.calculateVariable(
          {
            name: ht,
            type: Ct.DIMENSION
          },
          g.getSchema().filter(({ name: p }) => p !== pt.ROW_ID).map(({ name: p }) => p),
          () => m
        );
    } else
      g = g.project(
        g.getSchema().filter(({ name: m }) => m !== pt.ROW_ID).map(({ name: m }) => m)
      );
    return {
      greatSubTotalsDataModel: new K(g, {
        creatorIdentifier: i.getCreatorIdentifier(),
        ...i._model._config
      })
    };
  } else if (h) {
    if (!n)
      return null;
    const B = [];
    for (let m = A.length - 1; m >= 0; m--) {
      const p = A.slice(0, m + 1);
      if (!(l && `${p[p.length - 1]}` == `${C}`))
        for (let w = 0; w < o.length; w++) {
          const Q = o.slice(0, w + 1);
          if (a && `${Q[Q.length - 1]}` == `${E}`)
            continue;
          let y = [
            ...Ka(
              [...A, ...o],
              [...p, ...Q]
            ),
            ...t.discreteRowProjections,
            ...t.discreteColumnProjections
          ];
          if (a && `${Q[Q.length - 1]}` != `${E}` && (y = y.filter(
            (S) => `${S}` !== E
          )), l && `${p[p.length - 1]}` != `${C}` && (y = y.filter(
            (S) => `${S}` !== C
          )), y.length < 2)
            continue;
          const D = [
            ...t.continuousColumnProjections,
            ...t.continuousOptionalProjections
          ].map((S) => `${S}`).filter((S) => i.getSchema().find(({ name: b }) => b === S).type === Ct.DIMENSION), _ = [
            ...p.map((S) => `${S}`),
            ...Q.map((S) => `${S}`),
            ...D,
            ...t.discreteOptionalProjections.filter((S) => !y.includes(`${S}`)).map((S) => `${S}`)
          ].map((S) => ({
            field: S,
            value: d,
            operator: "neq"
          })), x = y.map((S) => ({
            field: `${S}`,
            value: d,
            operator: "eq"
          }));
          B.push({
            operator: "and",
            conditions: [..._, ...x]
          });
        }
    }
    return {
      greatSubTotalsDMQuery: {
        operator: "or",
        conditions: B
      },
      greatSubTotalsDataModel: B.length ? n.select({
        operator: "or",
        conditions: B
      }) : n.createEmptyDm()
    };
  } else if (u || l && a) {
    const B = i.getSchema(), m = [];
    for (let w = A.length - 1; w >= 0; w--) {
      const Q = A.slice(0, w + 1);
      if (!(l && `${Q[Q.length - 1]}` == `${C}`))
        for (let y = 0; y < o.length; y++) {
          const D = o.slice(0, y + 1);
          if (a && `${D[D.length - 1]}` == `${E}`)
            continue;
          const _ = [
            ...t.continuousRowProjections,
            ...t.continuousColumnProjections,
            ...t.continuousOptionalProjections
          ].map((M) => `${M}`).filter((M) => B.find(({ name: F }) => F === M).type === Ct.DIMENSION), x = i.groupBy([
            .../* @__PURE__ */ new Set([
              ...Q.map((M) => `${M}`),
              ...D.map((M) => `${M}`),
              ...t.discreteOptionalProjections,
              ..._,
              ...a && E ? [E] : [],
              ...l && C ? [C] : []
            ])
          ]);
          let S = [
            ...Ka(
              [...A, ...o],
              [...Q, ...D]
            ),
            ...t.discreteRowProjections,
            ...t.discreteColumnProjections
          ];
          if (a && `${D[D.length - 1]}` != `${E}` && (S = S.filter(
            (M) => `${M}` !== E
          )), l && `${Q[Q.length - 1]}` != `${C}` && (S = S.filter(
            (M) => `${M}` !== C
          )), S.length < 2)
            continue;
          const { data: b, schema: R } = x.getData({
            excludeFields: [
              pt.ROW_ID,
              ...S.map((M) => `${M}`)
            ]
          }), G = Ye(b), T = S.map(
            () => new Array(b.length).fill(0).map(() => d)
          ), v = [...G, ...T], H = [
            ...R,
            ...S.map((M) => ({
              name: `${M}`,
              type: Ct.DIMENSION,
              subtype: ot.CATEGORICAL
            }))
          ], N = new K(
            {
              data: v,
              schema: H
            },
            {
              creatorIdentifier: i.getCreatorIdentifier(),
              ...i._model._config
            }
          );
          m.push(N);
        }
    }
    const p = Nn(m);
    return m.forEach((w) => w.dispose()), m.length = 0, p && (p.model.setCreatorIdentifier(i.getCreatorIdentifier()).openBroadcastChannel(), p.model.greatSubTotal = !0), { greatSubTotalsDataModel: p };
  }
}, { CONTINUOUS: M7 } = ft, ey = (e) => e.getMembers(), iy = (e) => (t) => {
  const i = e[t] || {}, n = Go(
    i.ordering,
    MW
  );
  return { name: t, sortConfig: n };
}, N7 = (e) => ({ name: t, sortConfig: i, totalString: n, subTotalsPosition: s }) => [
  t,
  zd({ name: t }, i, e, {
    totalString: n,
    subTotalsPosition: s
  })
];
class F7 {
  /**
   * Creates an instance of MatrixResolver.
   * @param {Object} dependencies needed to run the resolver
   * @memberof MatrixResolver
   */
  constructor(t) {
    this._registry = {}, this._dependencies = t, this._facets = { rowFacets: [], colFacets: [] }, this._projections = { rowProjections: [], colProjections: [] };
    const { store: i, registry: n, smartlabel: s, throwback: A } = t, o = n.componentSubRegistry.layers.get();
    this._matrix = new u7({
      store: i,
      throwback: A,
      cellRegistry: n.componentSubRegistry.cells.get(),
      smartLabel: s,
      VisualUnit: n.components.VisualUnit,
      layerRegistry: o,
      interactions: n.interactions,
      DataStore: t.DataStore
    }), en.setLayerRegistry(o), this._axes = {
      radius: [],
      angle: [],
      angle0: [],
      color: [],
      shape: [],
      size: [],
      backgroundColor: []
    }, this._placeholderInfo = null, this._groupedData = null, this._rowGrandTotalsDataModel = null, this._columnGrandTotalsDataModel = null, this._greatGrandTotalsDataModel = null, this._matrixModel = new Su(), this._rowSubTotalsDataModel = null, this._columnSubTotalsDataModel = null, this._greatSubTotalsDataModel = null, this._facetFormatters = {}, this._facetHyperLinkFormatters = {}, ve(this, this.constructor.getterSetters());
  }
  units() {
    const t = this._matrix.geom(), i = [];
    return t.forEach((n, s, A) => {
      !i[s] && (i[s] = []), i[s][A] = n.source();
    }), i;
  }
  context(t) {
    return t ? (this._context = t, this) : this._context;
  }
  static getterSetters() {
    return FW;
  }
  /**
   * Used to set the layer config from outside or get current layer info
   *
   * @param {Object} type configuration of layer provided externally
   * @return {Object} either the layer or current instance
   * @memberof MatrixResolver
   */
  axes(...t) {
    return t.length ? (this._axes = Object.assign({}, this._axes, t[0]), this) : this._axes;
  }
  facets(...t) {
    return t.length ? (Object.entries(t[0]).forEach((i) => {
      this._facets[i[0]] = i[1];
    }), this) : this._facets;
  }
  projections(...t) {
    return t.length ? (Object.entries(t[0]).forEach((i) => {
      this._projections[i[0]] = i[1];
    }), this) : this._projections;
  }
  rowGrandTotalsDataModel(t) {
    return t == null ? this._rowGrandTotalsDataModel : (this._rowGrandTotalsDataModel = t, this);
  }
  columnGrandTotalsDataModel(t) {
    return t == null ? this._columnGrandTotalsDataModel : (this._columnGrandTotalsDataModel = t, this);
  }
  greatGrandTotalsDataModel(t) {
    return t == null ? this._greatGrandTotalsDataModel : (this._greatGrandTotalsDataModel = t, this);
  }
  optionalProjections() {
    const t = {}, i = [], n = [], s = [wA, yA, po], A = this.context(), o = {
      [yA]: A.color(),
      [ur]: A.opacity(),
      [wA]: A.size(),
      [po]: A.shape(),
      [Th]: A.detail()
    }, { simpleEncoder: a } = this.encoder(), r = this.layerConfig(), l = A.data(), c = l.getSchema();
    s.forEach((h) => {
      if (o[h] && o[h].field) {
        const d = o[h];
        t[h] = d.field, i.push(d.field), d.as == null ? n.push({
          ...d,
          as: bi(l.getField(d.field))
        }) : n.push(d);
      }
    }), o[Th] && (i.push(...o.detail), o.detail.forEach(
      (h) => n.push({
        field: h,
        as: bi(l.getField(h))
      })
    ));
    const g = a.getProjectionFields(
      r,
      c
    );
    return i.push(...g), n.push(
      ...g.map((h) => ({ field: h, as: bi(l.getField(h)) }))
    ), this.projections({ optionalProjections: i }), this._optionalProjections = i, this._detailedOptionalProjections = n, t;
  }
  setFacetsAndProjections(t) {
    const { fields: i, type: n } = t, { simpleEncoder: s } = this.encoder(), { facets: A, projections: o } = s.getFacetsAndProjections(
      i,
      n
    );
    return this.facets({ [`${n}Facets`]: A }), this.projections({ [`${n}Projections`]: o }), { facets: A, projections: o, fields: i };
  }
  /**
   * return the normalized set of rows and facets and projections
   *
   * @param {Object} rows parameters needed to set horizontal axis consisiting of rows
   * @return {Object} facets, projections and normalized rows
   * @memberof MatrixResolver
   */
  horizontalAxis(t) {
    return t ? (this._horizontalAxis = this.setFacetsAndProjections({
      type: Oi,
      fields: t
    }), this) : this._horizontalAxis;
  }
  /**
   * return the normalized set of columns and facets and projections
   *
   * @param {Object} columns parameters needed to set vertical axis consisiting of columns
   * @return {Object} facets, projections and normalized columns
   * @memberof MatrixResolver
   */
  verticalAxis(t) {
    return t ? (this._verticalAxis = this.setFacetsAndProjections({
      type: zA,
      fields: t
    }), this) : this._verticalAxis;
  }
  getAllFields() {
    const t = this.projections();
    return Object.entries(this.facets()).forEach((i) => {
      t[i[0]] = i[1];
    }), t;
  }
  setRetinalAxisDomain() {
    const t = this.context(), i = t._encoders.retinalEncoder, n = t.getAllRetinalEncodings(
      this._resolvedEncodedLayers.flatMap(
        ({ def: A }) => Array.isArray(A) ? A.map(({ encoding: o }) => o) : A.encoding
      )
    ), s = {
      domains: t.matrix().geom().getRetinalFieldsDomain(t.config()),
      axes: this.getRetinalAxes(),
      encoding: n,
      resolver: this
    };
    return s.axes.size.forEach((A) => {
      const { field: o, type: a, as: r } = A.config(), l = Z(s.domains, o, r);
      a === Gh && l && (s.domains[o][r] = l.sort((c, g) => c > g ? 1 : -1));
    }), i.setCommonDomain(s), this;
  }
  getRetinalAxes() {
    const { color: t, opacity: i, shape: n, size: s, backgroundColor: A } = this.axes();
    return {
      color: [...t],
      opacity: [...i],
      backgroundColor: [...A],
      shape: [...n],
      size: [...s]
    };
  }
  /**
   * Creates the color, shape and size axes.
   *
   * @param {DataModel} dm Root DataModel instance which is passed to canvas.data method.
   * @param {object} config { color: colorFieldConfig, shape: shapeFieldConfig, size: sizeFieldConfig }.
   */
  createRetinalAxes(t, i) {
    const s = this.context()._encoders.retinalEncoder.createAxis(t, {
      config: i,
      axes: this.axes(),
      childEventManagerCreator: () => this.context().createChildEventManager(),
      globalConfig: this.context().config()
    });
    return this.axes(s), Object.entries(s).forEach(([, A]) => {
      A.forEach((o) => o.setupValuesSorter(t));
    }), this;
  }
  createHeaders(t) {
    let i = [], n = [];
    const { rows: s, columns: A } = t, o = this.context(), { smartlabel: a } = this.dependencies(), r = o.config(), { showHeaders: l, classPrefix: c, facet: g } = r, { TextCell: h, BlankCell: d } = o.registry().componentSubRegistry.cells.get(), [u, f] = s, [C, I] = A, { fields: E } = this.horizontalAxis(), B = (y) => new d().config({ show: y.config().show });
    jI(g);
    const m = {
      left: qI(
        u,
        E[0],
        l ? h : d,
        { classPrefix: c, labelManager: a }
      ),
      right: qI(
        f,
        E[1],
        l ? h : d,
        { classPrefix: c, labelManager: a }
      )
    }, p = {
      left: u.length > 0 ? u[0].map(B) : [],
      right: f.length > 0 ? f[0].map(B) : []
    }, [w, Q] = [Je, oi].map(
      (y) => C.map((D, _) => _ === C.length - 1 ? m[y] : p[y])
    );
    return C.length === 0 ? [i, n] = [Je, oi].map(
      (y) => I.map((D, _) => _ === 0 ? m[y] : p[y])
    ) : (i = I.map(
      () => u.length > 0 ? u[0].map(B) : []
    ), n = I.map(
      () => f.length > 0 ? f[0].map(B) : []
    )), { topLeft: w, topRight: Q, bottomLeft: i, bottomRight: n };
  }
  updateMatrices(t, i, n) {
    let {
      rowKeys: s,
      columnKeys: A,
      dataModelMatrix: o,
      grandTotalsCoordinates: a,
      updateInfo: r
    } = this._matrixModel.updateMatrixModelForTargetPath(
      t,
      i,
      this._matrixInfo,
      this.context(),
      this.encoder().simpleEncoder,
      this._suppliedLayers,
      this._columnSubTotalsDataModel,
      this._rowSubTotalsDataModel
    );
    const { colProjections: l, rowProjections: c, rowFacets: g, colFacets: h } = this.getAllFields();
    let { rowHeaderKeys: d, columnHeaderKeys: u, rowAxisInfo: f, columnAxisInfo: C } = ty({
      rowKeys: s,
      columnKeys: A,
      rowFacets: g,
      colFacets: h,
      rowProjections: c,
      colProjections: l,
      facetFormatters: this.facetFormatters(),
      rowCollapseStatus: this._matrixModel._rowCollapseStatus,
      columnCollapseStatus: this._matrixModel._columnCollapseStatus,
      globalConfig: n
    }), I = d.map((v) => ({
      keys: v,
      type: UA
    })), E = u.map((v) => ({
      keys: v,
      type: UA
    })), B = f.leftAxisInfo.length;
    const m = {
      colHeaderKeysLength: u.length,
      colTopAxisLength: C.topAxisInfo.length,
      colBottomAxisLength: C.bottomAxisInfo.length,
      rowHeaderKeysLength: d.length,
      rowLeftAxisLength: f.leftAxisInfo.length,
      rowRightAxisLength: f.rightAxisInfo.length
    };
    a.length && (o = (i === "row" ? this._rowGrandTotalMatrixInst : this._columnGrandTotalMatrixInst).updateGrandTotalsMatrix(
      a,
      o,
      this.context(),
      this.encoder().simpleEncoder,
      this._suppliedLayers
    ));
    const {
      beforeGrandTotalsInfo: {
        rowHeaderKeysLength: p,
        colHeaderKeysLength: w,
        rowLeftAxisLength: Q,
        rowRightAxisLength: y,
        colTopAxisLength: D,
        colBottomAxisLength: _
      },
      allRowHeaderKeys: x,
      allColumnHeaderKeys: S,
      allRowAxisInfo: b,
      allColumnAxisInfo: R
    } = this._matrixInfo, G = e1(
      this.context().config(),
      x.length - p
    ), T = i1(
      this.context().config(),
      S.length - w
    );
    x.splice(
      G,
      p,
      ...I
    ), S.splice(
      T,
      w,
      ...E
    ), b.leftAxisInfo.splice(
      G,
      Q,
      ...f.leftAxisInfo
    ), b.rightAxisInfo.splice(
      G,
      y,
      ...f.rightAxisInfo
    ), R.topAxisInfo.splice(
      T,
      D,
      ...C.topAxisInfo
    ), R.bottomAxisInfo.splice(
      T,
      _,
      ...C.bottomAxisInfo
    ), I = x, E = S, f = {
      ...b
    }, C = {
      ...R
    }, B = f.leftAxisInfo.length, this._matrixInfo = {
      allRowHeaderKeys: I,
      rowKeys: s,
      allRowAxisInfo: f,
      allColumnHeaderKeys: E,
      columnKeys: A,
      allColumnAxisInfo: C,
      totalRowItemCount: B,
      totalRowFacetCount: s.length,
      rowsPerFacet: c.length,
      dataModelMatrix: o,
      completeDataModelMatrix: o,
      updateInfo: r,
      beforeGrandTotalsInfo: m
    };
  }
  generateMatrices() {
    const t = this.getAllFields(), { fields: i } = this.horizontalAxis(), { fields: n } = this.verticalAxis(), s = this.context(), A = s.config(), {
      groupBy: o,
      facetsUserConfig: a,
      rows: {
        facets: r,
        totals: {
          data: { totalString: l }
        }
      },
      columns: {
        facets: c,
        totals: {
          data: { totalString: g }
        }
      }
    } = A, { rowFacets: h, colFacets: d, colProjections: u, rowProjections: f } = t, C = u.flat(), I = f.flat(), E = h.length > 0 || d.length > 0;
    E && (A.isFacet = !0);
    const B = E && jI(a), m = s._encoders.simpleEncoder, p = m.serializeLayerConfig(this.context().layers()).map((gt) => Object.assign({ isBold: !1 }, gt));
    this._suppliedLayers = p;
    const w = p.length > 0 ? p.some(({ mark: gt }) => gt !== "text") : !0, Q = [
      ...I,
      ...C
    ].some((gt) => gt.as() === M7), y = [...f, ...u].some(
      (gt) => gt.length > 1
    ), D = w || Q || y ? "svg" : "html";
    this._cellRenderer = D;
    const _ = p.flatMap((gt) => {
      const { detail: xt } = gt.encoding;
      return xt && Array.isArray(xt.field) ? xt.field : [];
    });
    t.optionalProjections.push(..._);
    const x = this._groupedData = $M(
      s.data(),
      {
        facetsAndProjections: t,
        suppliedLayers: p,
        globalConfig: A
      },
      this
    );
    m.data(x), this._resolvedEncodedLayers = m.getResolvedEncodings(
      {
        columnFields: C,
        rowFields: I,
        dataStore: x
      },
      p,
      A,
      s
    );
    const S = s.getAllRetinalEncodings(
      this._resolvedEncodedLayers.flatMap(
        ({ def: gt }) => Array.isArray(gt) ? gt.map(({ encoding: xt }) => xt) : gt.encoding
      )
    );
    this._retinalConfig = S;
    const b = iy(
      r.fields
    ), R = iy(
      c.fields
    ), G = N7(s.data()), T = A.rows.totals.subTotals.position, v = A.columns.totals.subTotals.position, H = h.flatMap(ey).map(b).map(
      ({ name: gt, sortConfig: xt }) => G({
        name: gt,
        sortConfig: xt,
        totalString: g,
        subTotalsPosition: v
      })
    ), N = d.flatMap(ey).map(R).map(
      ({ name: gt, sortConfig: xt }) => G({
        name: gt,
        sortConfig: xt,
        totalString: l,
        subTotalsPosition: T
      })
    ), M = {
      row: Object.fromEntries(H),
      column: Object.fromEntries(N)
    };
    this._detailedFacetProjectionInfo = {
      colFacets: d,
      rowFacets: h,
      ...XM({
        rowProjections: I,
        colProjections: C,
        optionalProjections: this._detailedOptionalProjections
      })
    };
    const {
      columnTotalString: F,
      rowTotalString: k,
      colSubTotalsSplitField: O,
      rowSubTotalsSplitField: P
    } = tA(s.config());
    this.greatGrandTotalsDataModel() && (this.greatGrandTotalsDataModel().dispose(), this._greatGrandTotalsDataModel = null), this.columnGrandTotalsDataModel() && (this.columnGrandTotalsDataModel().dispose(), this._columnGrandTotalsDataModel = null), this.rowGrandTotalsDataModel() && (this.rowGrandTotalsDataModel().dispose(), this._rowGrandTotalsDataModel = null), this._greatSubTotalsDataModel && (this._greatSubTotalsDataModel.dispose(), this._greatSubTotalsDataModel = null), this._columnSubTotalsDataModel && (this._columnSubTotalsDataModel.dispose(), this._columnSubTotalsDataModel = null), this._rowSubTotalsDataModel && (this._rowSubTotalsDataModel.dispose(), this._rowSubTotalsDataModel = null), this._rowSubTotalsDataModel = S7({
      detailedFacetProjectionInfo: this._detailedFacetProjectionInfo,
      facetsAndProjections: t,
      globalConfig: Object.assign({ facetSortConfig: M }, A),
      dataStore: s.data()
    }), this._columnSubTotalsDataModel = _7({
      detailedFacetProjectionInfo: this._detailedFacetProjectionInfo,
      facetsAndProjections: t,
      globalConfig: Object.assign({ facetSortConfig: M }, A),
      dataStore: s.data()
    });
    const { greatSubTotalsDMQuery: L = null, greatSubTotalsDataModel: q = null } = b7({
      detailedFacetProjectionInfo: this._detailedFacetProjectionInfo,
      facetsAndProjections: t,
      globalConfig: Object.assign({ facetSortConfig: M }, A),
      dataStore: s.data(),
      columnSubTotalsDM: this._columnSubTotalsDataModel
    }) ?? {};
    if (this._greatSubTotalsDataModel = q, this._columnSubTotalsDataModel)
      if (L) {
        let gt = this._columnSubTotalsDataModel.select(
          L,
          { mode: "inverse" }
        );
        gt && gt.getData().data.length === 0 ? gt = null : this._columnSubTotalsDataModel = gt;
      } else {
        const gt = PB(
          this._columnSubTotalsDataModel,
          {
            discreteRowProjections: this._detailedFacetProjectionInfo.discreteRowProjections,
            discreteColumnProjections: this._detailedFacetProjectionInfo.discreteColumnProjections,
            rowFacets: [],
            colFacets: []
          },
          P,
          O,
          F,
          !1
        );
        let xt = gt ? this._columnSubTotalsDataModel.select(gt) : null;
        xt && xt.getData().data.length === 0 ? xt = null : this._columnSubTotalsDataModel = xt;
      }
    const { rowKeys: $, columnKeys: W, dataModelMatrix: U } = this._matrixModel.getMatrixModel(x, t, {
      facetSortConfig: M,
      globalConfig: A,
      rowTotalsDM: this._rowSubTotalsDataModel,
      columnTotalsDM: this._columnSubTotalsDataModel,
      greatTotalsDM: this._greatSubTotalsDataModel,
      canvasHelpers: s._canvasHelpers
    });
    this.createRetinalAxes(s.data(), { ...S });
    const { classPrefix: J, showHeaders: V } = A, Y = this._matrix;
    this.resolveAxisBandwidthConfig();
    let nt = {};
    const tt = p.find(({ mark: gt }) => gt === "text");
    if (tt && tt.encoding && tt.encoding.text && tt.encoding.text.field) {
      const gt = tt.encoding.text.field, xt = x.getField(gt);
      nt = {
        dmField: xt,
        as: tt.encoding.text.as || bi(xt)
      };
    }
    const st = this.getDirectSortEnabledInfo({
      cellRenderer: D,
      textLayerInfo: nt
    });
    Y.config({
      rows: {
        isBold: !1,
        renderer: D,
        directSortEnabledInfo: st,
        sanitizeCheckBorder: B,
        isColumnsCompact: s.config().axes.x.compact,
        isRowsCompact: s.config().axes.y.compact,
        ...this.prepareRowMatrixConfig({ show: !0 })
      },
      columns: {
        isBold: !1,
        renderer: D,
        directSortEnabledInfo: st,
        sanitizeCheckBorder: B,
        firstSuppliedTextLayerInfo: nt,
        isColumnsCompact: s.config().axes.x.compact,
        isRowsCompact: s.config().axes.y.compact,
        ...this.prepareColumnMatrixConfig({ show: !0 })
      },
      headerTitle: {
        renderer: D,
        rowHeaders: i,
        showHeaders: V,
        classPrefix: J,
        columnHeaders: n,
        sanitizeCheckBorder: B
      },
      geoms: {
        alias: s.alias(),
        coord: m.constructor.type(),
        encoder: m,
        unitConfig: OM(A || {}),
        retinalAxes: this.getRetinalAxes(),
        valueParser: this.valueParser(),
        renderer: D,
        retinalConfig: S,
        sanitizeCheckBorder: B,
        visualGroupConfig: A,
        detailFields: s.detail(),
        dataModelTransform: s.transform(),
        interactions: s.interactionRegistry(),
        facetsAndProjections: t,
        columnTotalString: F,
        rowTotalString: k
      }
    });
    const { rowHeaderKeys: lt, columnHeaderKeys: at, rowAxisInfo: Dt, columnAxisInfo: Qt } = ty({
      rowKeys: $,
      columnKeys: W,
      colFacets: d,
      rowFacets: h,
      rowProjections: f,
      colProjections: u,
      facetFormatters: this.facetFormatters(),
      rowCollapseStatus: this._matrixModel._rowCollapseStatus,
      columnCollapseStatus: this._matrixModel._columnCollapseStatus,
      globalConfig: A
    }), St = p7({
      detailedFacetProjectionInfo: this._detailedFacetProjectionInfo,
      facetsAndProjections: t,
      globalConfig: Object.assign({ facetSortConfig: M }, A),
      suppliedLayers: p,
      dataStore: s.data(),
      canvasHelpers: s._canvasHelpers,
      subTotalsInfo: {
        rowSubTotalsDS: this._rowSubTotalsDataModel,
        columnSubTotalsDS: this._columnSubTotalsDataModel,
        greatSubTotalsDS: this._greatSubTotalsDataModel
      }
    });
    St && St.columnTotalsDSWithAll && (this.columnGrandTotalsDataModel(
      St.columnTotalsDSWithAll
    ), this._columnGrandTotalMatrixInst = St.matrixModelInst);
    const At = w7({
      detailedFacetProjectionInfo: this._detailedFacetProjectionInfo,
      facetsAndProjections: t,
      globalConfig: Object.assign({ facetSortConfig: M }, A),
      suppliedLayers: p,
      dataStore: s.data(),
      canvasHelpers: s._canvasHelpers,
      subTotalsInfo: {
        rowSubTotalsDS: this._rowSubTotalsDataModel,
        columnSubTotalsDS: this._columnSubTotalsDataModel,
        greatSubTotalsDS: this._greatSubTotalsDataModel
      }
    });
    At && At.rowTotalsDSWithAll && (this.rowGrandTotalsDataModel(At.rowTotalsDSWithAll), this._rowGrandTotalMatrixInst = At.matrixModelInst);
    let Vt = lt.map((gt) => ({
      keys: gt,
      type: UA
    })), _t = at.map((gt) => ({
      keys: gt,
      type: UA
    })), zt = Dt, te = Qt;
    const ei = {
      colHeaderKeysLength: at.length,
      colTopAxisLength: Qt.topAxisInfo.length,
      colBottomAxisLength: Qt.bottomAxisInfo.length,
      rowHeaderKeysLength: lt.length,
      rowLeftAxisLength: Dt.leftAxisInfo.length,
      rowRightAxisLength: Dt.rightAxisInfo.length
    };
    if (At) {
      _t = [
        ...at.map((Ft) => ({
          keys: Ft,
          type: UA
        }))
      ];
      const gt = [
        ...At.columnKeys.map((Ft, se) => ({
          keys: Ft,
          type: MI,
          config: (
            // Check if rowGrandTotalMatrixInfo.columnFacetsInfo.topFacetsInfo[i] exists
            // if it is an Array check for length else just check if it's truthy
            ((Array.isArray(
              At.columnFacetsInfo.topFacetsInfo[se]
            ) ? At.columnFacetsInfo.topFacetsInfo[se].length : At.columnFacetsInfo.topFacetsInfo[se]) ? (
              // if rowGrandTotalMatrixInfo.columnFacetsInfo.topFacetsInfo[i] exists, then
              // that else rowGrandTotalMatrixInfo.columnFacetsInfo.bottomFacetsInfo[i]
              At.columnFacetsInfo.topFacetsInfo[se]
            ) : At.columnFacetsInfo.bottomFacetsInfo[se]).config
          )
        }))
      ], xt = A.rows.totals.grandTotals.position;
      xt === "start" ? _t.unshift(...gt) : _t.push(...gt), xt === "start" ? (te.topAxisInfo = [
        ...At.columnAxisInfo.topAxisInfo,
        ...te.topAxisInfo
      ], te.bottomAxisInfo = [
        ...At.columnAxisInfo.bottomAxisInfo,
        ...te.bottomAxisInfo
      ]) : (te.topAxisInfo = [
        ...te.topAxisInfo,
        ...At.columnAxisInfo.topAxisInfo
      ], te.bottomAxisInfo = [
        ...te.bottomAxisInfo,
        ...At.columnAxisInfo.bottomAxisInfo
      ]);
    }
    let ki;
    if (St) {
      ki = x7({
        dataStore: s.data(),
        globalConfig: Object.assign({ facetSortConfig: M }, A),
        facetsAndProjections: t,
        detailedFacetProjectionInfo: this._detailedFacetProjectionInfo,
        columnTotalsDSWithAll: St.columnTotalsDSWithAll,
        suppliedLayers: p,
        canvasHelpers: s._canvasHelpers,
        subTotalsInfo: {
          rowSubTotalsDS: this._rowSubTotalsDataModel,
          columnSubTotalsDS: this._columnSubTotalsDataModel,
          greatSubTotalsDS: this._greatSubTotalsDataModel
        }
      }), ki && ki.greatTotalsDS && this.greatGrandTotalsDataModel(ki.greatTotalsDS);
      const gt = A.columns.totals.grandTotals.position;
      Vt = [
        ...lt.map((Ft) => ({
          keys: Ft,
          type: UA
        }))
      ];
      const xt = St.rowKeys.map(
        (Ft, se) => ({
          keys: Ft,
          type: MI,
          config: (
            // Check if columnGrandTotalMatrixInfo.columnFacetsInfo.topFacetsInfo[i] exists
            // if it is an Array check for length else just check if it's truthy
            ((Array.isArray(
              St.rowFacetsInfo.leftFacetsInfo[se]
            ) ? St.rowFacetsInfo.leftFacetsInfo[se].length : St.rowFacetsInfo.leftFacetsInfo[se]) ? (
              // if columnGrandTotalMatrixInfo.rowFacetsInfo.leftFacetsInfo[i] exists, then
              // that else columnGrandTotalMatrixInfo.rowFacetsInfo.rightFacetsInfo[i]
              St.rowFacetsInfo.leftFacetsInfo[se]
            ) : St.rowFacetsInfo.rightFacetsInfo[se]).config
          )
        })
      );
      gt === "start" ? Vt.unshift(...xt) : Vt.push(...xt), zt.leftAxisInfo = [...zt.leftAxisInfo], gt === "start" ? zt.leftAxisInfo.unshift(
        ...St.rowAxisInfo.leftAxisInfo
      ) : zt.leftAxisInfo.push(
        ...St.rowAxisInfo.leftAxisInfo
      ), zt.rightAxisInfo = [
        ...zt.rightAxisInfo,
        ...St.rowAxisInfo.rightAxisInfo
      ];
    }
    const ue = zt.leftAxisInfo.length;
    let It = U, dt;
    if (At) {
      dt = At.dataModelMatrix;
      const gt = A.rows.totals.grandTotals.position;
      It = t1(
        U,
        dt,
        gt
      );
    }
    if (St) {
      const gt = St.dataModelMatrix;
      let xt;
      ki && (xt = ki.dataModelMatrix);
      const Ft = A.columns.totals.grandTotals.position, se = A.rows.totals.grandTotals.position;
      It = ZM(
        It,
        {
          columnGrandTotalDataMatrix: gt,
          greatGrandTotalDataMatrix: xt,
          rowGrandTotalDataMatrix: dt
        },
        Ft,
        se
      );
    }
    let Jt = It;
    (A.pagination.enabled && !A.pagination.unionAxisDomainPerPage || !A.pagination.enabled) && (Jt = nA(
      KA(
        this.context(),
        this.encoder().simpleEncoder,
        It,
        this._suppliedLayers
      ),
      A
    )), this._matrixInfo = {
      allRowHeaderKeys: Vt,
      rowKeys: $,
      allRowAxisInfo: zt,
      allColumnHeaderKeys: _t,
      columnKeys: W,
      allColumnAxisInfo: te,
      totalRowItemCount: ue,
      totalRowFacetCount: $.length,
      rowsPerFacet: t.rowProjections.length,
      dataModelMatrix: Jt,
      completeDataModelMatrix: Jt,
      beforeGrandTotalsInfo: ei
    };
  }
  handleZebraTypeConfig(t) {
    const {
      geom: { _matrix: i },
      row: {
        _matrices: {
          axes: {
            _cells: { left: n, right: s }
          }
        }
      }
    } = t._matrices, { AxisCell: A } = this.context().registry().componentSubRegistry.cells.get(), o = (a) => a instanceof A;
    n.filter(o).reduce((a, r) => {
      const l = r.source(), c = l.domain().length;
      return l.config({ firstRowZebraType: a }), c % 2 === 0 ? a : a === "odd" ? "even" : "odd";
    }, "odd"), s.filter(o).reduce((a, r) => {
      const l = r.source(), c = l.domain().length;
      return l.config({ firstRowZebraType: a }), c % 2 === 0 ? a : a === "odd" ? "even" : "odd";
    }, "odd"), i.reduce((a, r) => xi(
      r.map((c) => (c.source().layers().forEach((d) => {
        d.config(
          Object.assign(d.config(), { firstRowZebraType: a })
        );
      }), c)).map((c) => {
        const g = c.source(), { y: h } = g.axes();
        return xi(h.map((d) => d.domain().length));
      })
    ) % 2 === 0 ? a : a === "odd" ? "even" : "odd", "odd");
  }
  facetFormatters(t) {
    return t != null && (this._facetFormatters = t), this._facetFormatters;
  }
  facetHyperLinkFormatters(t) {
    return t != null && (this._facetHyperLinkFormatters = t), this._facetHyperLinkFormatters;
  }
  generateMatrixInstance(t) {
    this._paginatedMatrixInfo = t;
    const i = this.getAllFields(), n = this.context().config(), {
      sort: s,
      facets: A,
      rows: { facets: o },
      columns: { facets: a }
    } = n, r = this.context(), { colProjections: l, rowProjections: c } = i, { fields: g } = this.horizontalAxis(), { fields: h } = this.verticalAxis(), d = this._matrix, u = this._cellRenderer;
    t.dataModelMatrix = t.dataModelMatrix.map((S) => S.map((b) => ({
      ...b,
      layerDataModels: Object.keys(b.layerDataModels).reduce(
        (R, G) => (R[G] = b.layerDataModels[G].project(
          b.dataStore.getSchema().filter((T) => T.name !== pt.ROW_ID).map((T) => T.name)
        ), R),
        {}
      )
    })));
    const {
      allRowHeaderKeys: f,
      rowKeys: C,
      allRowAxisInfo: I,
      allColumnAxisInfo: E,
      allColumnHeaderKeys: B,
      columnKeys: m,
      dataModelMatrix: p
    } = t;
    d.generateMatrices({
      facets: this.facets(),
      facetsConfig: A,
      rowFacetsConfig: o,
      colFacetsConfig: a,
      facetFormatters: this.facetFormatters(),
      facetHyperLinkFormatters: this.facetHyperLinkFormatters(),
      headers: {
        rowKeys: f,
        columnKeys: B
      },
      axesInfo: {
        x: {
          facetKeys: m,
          axisFields: l,
          // NOTE:
          // columnTitle: context.config().axesHeaders.column,
          columnTitle: r.config().columns.headers,
          columnAxisInfo: E
        },
        y: {
          facetKeys: C,
          axisFields: c,
          rowTitle: r.config().rows.headers,
          rowAxisInfo: I
        }
      },
      dataModelMatrix: p,
      layerDomains: this._layerDomains,
      childEventManagerCreator: () => r.createChildEventManager(),
      canvasActions: r._canvasHelpers,
      rootGroupedData: r._encoders.simpleEncoder.data(),
      rootMatrixInfo: this._matrixInfo,
      paginatedMatrixInfo: t,
      totalsData: {
        columns: this.columnGrandTotalsDataModel(),
        rows: this.rowGrandTotalsDataModel(),
        greatGrandTotals: this.greatGrandTotalsDataModel()
      },
      globalConfig: r.config()
    }), d.registerHooksEvents(r), d.setCanvasDimensionsToAxes(r), d.setAxisDomains(
      n.uniformAxisDomains,
      {
        rootModel: r.data(),
        columnGTRootModel: this.columnGrandTotalsDataModel() == null ? r.data() : this.columnGrandTotalsDataModel(),
        rowGTRootModel: this.rowGrandTotalsDataModel() == null ? r.data() : this.rowGrandTotalsDataModel()
      },
      {
        sort: s,
        unionAxisDomainPerPage: n.pagination.unionAxisDomainPerPage && n.pagination.enabled
      }
    ), u === "html" && this.handleZebraTypeConfig(d), this.setRetinalAxisDomain();
    const w = d.getMatrices(), Q = WI(g), y = WI(h), D = {}, _ = w.columns, x = w.rows;
    return _ && (D.columns = _), x && (D.rows = x), Object.assign(w, D, {
      // @todo get isRowSizeEqual from rows and column matrix
      values: w.values,
      cellRenderer: u,
      isRowSizeEqual: Q,
      isColumnSizeEqual: y,
      priorityMinWidths: {
        row: Q ? null : 0.25
      },
      priorityMaxWidths: {
        row: Q ? null : 0.5
      }
    });
  }
  updateMatrixInstance(t, i, { targetPath: n = [] } = {}) {
    this._paginatedMatrixInfo = t;
    const s = this.getAllFields(), A = this.context().config(), {
      sort: o,
      rows: {
        facets: a,
        totals: {
          subTotals: {
            enabled: r,
            splitTotal: { field: l }
          }
        }
      },
      columns: {
        facets: c,
        totals: {
          subTotals: {
            enabled: g,
            splitTotal: { field: h }
          }
        }
      },
      pagination: { enabled: d }
    } = A, u = this.context(), { colProjections: f, rowProjections: C } = s, I = this._matrix, E = this._cellRenderer, {
      allRowHeaderKeys: B,
      rowKeys: m,
      allRowAxisInfo: p,
      allColumnAxisInfo: w,
      allColumnHeaderKeys: Q,
      columnKeys: y,
      dataModelMatrix: D,
      updateInfo: _
    } = t;
    I.updateMatrices({
      facets: this.facets(),
      rowFacetsConfig: a,
      colFacetsConfig: c,
      facetFormatters: this.facetFormatters(),
      facetHyperLinkFormatters: this.facetHyperLinkFormatters(),
      headers: {
        rowKeys: B,
        columnKeys: Q
      },
      axesInfo: {
        x: {
          facetKeys: y,
          axisFields: f,
          columnTitle: u.config().columns.headers,
          columnAxisInfo: w
        },
        y: {
          facetKeys: m,
          axisFields: C,
          rowTitle: u.config().rows.headers,
          rowAxisInfo: p
        }
      },
      dataModelMatrix: D,
      layerDomains: this._layerDomains,
      canvasActions: u._canvasHelpers,
      rootGroupedData: u._encoders.simpleEncoder.data(),
      rootMatrixInfo: this._matrixInfo,
      paginatedMatrixInfo: t,
      totalsData: {
        columns: this.columnGrandTotalsDataModel(),
        rows: this.rowGrandTotalsDataModel(),
        greatGrandTotals: this.greatGrandTotalsDataModel()
      },
      subTotalsInfo: {
        isColSubTotalsEnabled: g,
        isRowSubTotalsEnabled: r,
        rowSplitSubtotalsField: l,
        colSplitSubtotalsField: h,
        rowSubTotalsDS: this._rowSubTotalsDataModel,
        colSubTotalsDS: this._columnSubTotalsDataModel
      },
      updateInfo: _,
      facetType: i,
      paginated: d,
      targetPath: n
    }), I.registerHooksEvents(u), I.setCanvasDimensionsToAxes(u, i), I.setAxisDomains(
      A.uniformAxisDomains,
      {
        rootModel: u.data(),
        columnGTRootModel: this.columnGrandTotalsDataModel() == null ? u.data() : this.columnGrandTotalsDataModel(),
        rowGTRootModel: this.rowGrandTotalsDataModel() == null ? u.data() : this.rowGrandTotalsDataModel()
      },
      {
        sort: o,
        unionAxisDomainPerPage: A.pagination.unionAxisDomainPerPage && A.pagination.enabled
      }
    ), E === "html" && this.handleZebraTypeConfig(I), this.setRetinalAxisDomain();
    const x = I.getMatrices(), S = {}, b = x.columns, R = x.rows;
    return b && (S.columns = b), R && (S.rows = R), Object.assign(x, S, {
      values: x.values
    });
  }
  setPaginatedMatrixInfo(t) {
    this._paginatedMatrixInfo = t, this._matrix.setPaginatedMatrixInfo(t);
  }
  arcMarkFound() {
    return !!(this.context().layers() || []).find((i) => i.mark === "arc");
  }
  resolveAxisBandwidthConfig() {
    let t = this.context().config();
    const i = this.context().layers() || [], { size: n } = this.axes();
    let s = 0, A = 0;
    if (i.find((r) => r.mark === "arc") && (s = U_), i.find((r) => r.mark === "bar")) {
      const r = n.filter((l) => l.config().field).map((l) => l.range());
      if (r.length) {
        const l = [
          Math.min(...r.map((c) => c[0])),
          Math.max(...r.map((c) => c[1]))
        ];
        A = l[1] + l[1] / 3;
      }
    }
    const o = Math.max(s, A), a = t.axes;
    o && [Cc, gu].forEach((r) => {
      a[r].bandwidth || (a[r].bandwidth = o);
    });
  }
  prepareRowMatrixConfig(t) {
    const i = this.encoder().simpleEncoder, n = this.context().config(), s = et(
      n.rows.facets
      // globalConfig.facets.rows
    );
    return {
      headers: Object.assign(
        {
          facet: {
            ...bW,
            ...i._headerFrom
          },
          takeHeaderFrom: i._headerFrom.row,
          useExternalCSS: n.useExternalCSS,
          facetConfig: s,
          interaction: et(
            {},
            {
              directSortSelect: {
                sideEffects: {
                  "toggle-sort-dropdown": {
                    hook: Yg.getRowHeaderSortingHook(this)
                  }
                }
              }
            },
            n.rows.headers.interaction
          )
        },
        t
      ),
      axes: {
        axisFrom: i._axisFrom.row,
        // @todo Remove this global config
        globalConfig: n,
        interaction: {
          directSortSelect: {
            sideEffects: {
              "toggle-sort-dropdown": {
                hook: Yg.getYAxisSortingHook(this)
              }
            }
          }
        }
      },
      interaction: n.rows.interaction,
      sourceCanvasAlias: this.context().alias(),
      globalBorderConfig: n.border
    };
  }
  prepareColumnMatrixConfig(t) {
    const i = this.encoder().simpleEncoder, n = this.context().config(), s = et(
      n.columns.facets
      // globalConfig.facets.columns
    );
    return {
      headers: Object.assign(
        {
          facet: i._headerFrom,
          takeHeaderFrom: i._headerFrom.column,
          useExternalCSS: n.useExternalCSS,
          facetConfig: s,
          interaction: n.columns.headers.interaction
        },
        t
      ),
      axes: {
        axisFrom: i._axisFrom.column,
        globalConfig: n,
        interaction: {
          directSortSelect: {
            sideEffects: {
              "toggle-sort-dropdown": {
                hook: Yg.getXAxisSortingHook(this)
              }
            }
          }
        }
      },
      interaction: n.columns.interaction,
      sourceCanvasAlias: this.context().alias()
    };
  }
  getDirectSortEnabledInfo({ cellRenderer: t, textLayerInfo: i }) {
    const s = this.context().config(), A = s.rows.headers.enableDirectSort, o = [
      s.axes.x.enableDirectSort,
      s.axes.y.enableDirectSort
    ].map((a) => a ? t === "html" ? i.as === ft.CONTINUOUS : t === "svg" : !1);
    return {
      rowsHeaders: A,
      axes: {
        x: o[0],
        y: o[1]
      }
    };
  }
  clear() {
    this._matrix.clear(), this._groupedData != null && this._groupedData.dispose(), this.greatGrandTotalsDataModel() != null && this.greatGrandTotalsDataModel().dispose(), this.columnGrandTotalsDataModel() != null && this.columnGrandTotalsDataModel().dispose(), this.rowGrandTotalsDataModel() != null && this.rowGrandTotalsDataModel().dispose(), this._greatSubTotalsDataModel && (this._greatSubTotalsDataModel.dispose(), this._greatSubTotalsDataModel = null), this._columnSubTotalsDataModel && (this._columnSubTotalsDataModel.dispose(), this._columnSubTotalsDataModel = null), this._rowSubTotalsDataModel && (this._rowSubTotalsDataModel.dispose(), this._rowSubTotalsDataModel = null);
  }
  getRowGrandTotalsDataModelInfo(t, i, n = {}) {
    const { rowTotalsSplitField: s, rowGrandTotalsPosition: A } = tA(i), o = this.getMatrixInfoFromRelativeRowIndex(t);
    let a = -1, r;
    const l = this.facets().colFacets.find(
      (c) => `${c}` === s
    );
    if (s in n && l) {
      if (r = n[s], A === "start") {
        for (let c = 0; c <= o.length - 1; c++)
          if (o[c].columnFacetValues.findIndex(
            (h) => `${h}` == `${r}`
          ) >= 0) {
            a = c;
            break;
          }
      } else
        for (let c = o.length - 1; c >= 0; c--)
          if (o[c].columnFacetValues.findIndex(
            (h) => `${h}` == `${r}`
          ) >= 0) {
            a = c;
            break;
          }
    } else
      A === "start" ? a = 0 : a = o.length - 1;
    return {
      dataStore: o[a].dataStore,
      rowFacets: this._detailedFacetProjectionInfo?.rowFacets || {},
      colFacets: this._detailedFacetProjectionInfo?.colFacets || {},
      discreteColumnProjections: this._detailedFacetProjectionInfo?.discreteColumnProjections || {},
      discreteRowProjections: this._detailedFacetProjectionInfo?.discreteRowProjections || {},
      splitFieldInfo: {
        field: s,
        value: r
      }
    };
  }
  getAbsoluteRowIndexFromRelativeRowIndex(t) {
    return t + (this._paginatedMatrixInfo.pageStartIndex || 0);
  }
  getMatrixInfoFromRelativeRowIndex(t) {
    const i = this._paginatedMatrixInfo.completeDataModelMatrix, n = this.getAbsoluteRowIndexFromRelativeRowIndex(t);
    return i[n];
  }
  getColumnGrandTotalsDataModelInfo(t, i, n = {}) {
    const { columnTotalsSplitField: s, columnGrandTotalsPosition: A } = tA(i), o = n[s];
    let a = -1, r = null;
    const l = this.facets().rowFacets.find(
      (c) => `${c}` === s
    );
    if (o && l) {
      if (A === "start") {
        for (let c = 0; c <= this._paginatedMatrixInfo.completeDataModelMatrix.length - 1; c++)
          if (this._paginatedMatrixInfo.completeDataModelMatrix[c][t].rowFacetValues.findIndex(
            (d) => `${d}` == `${o}`
          ) >= 0) {
            a = c;
            break;
          }
      } else
        for (let c = this._paginatedMatrixInfo.completeDataModelMatrix.length - 1; c >= 0; c--)
          if (this._paginatedMatrixInfo.completeDataModelMatrix[c][t].rowFacetValues.findIndex(
            (d) => `${d}` == `${o}`
          ) >= 0) {
            a = c;
            break;
          }
      r = this._paginatedMatrixInfo.completeDataModelMatrix[a];
    } else
      A === "start" ? a = 0 : a = this._paginatedMatrixInfo.completeDataModelMatrix.length - 1, r = this._paginatedMatrixInfo.completeDataModelMatrix[a];
    return {
      dataStore: r[t].dataStore,
      rowFacets: this._detailedFacetProjectionInfo?.rowFacets || {},
      colFacets: this._detailedFacetProjectionInfo?.colFacets || {},
      discreteColumnProjections: this._detailedFacetProjectionInfo?.discreteColumnProjections || {},
      discreteRowProjections: this._detailedFacetProjectionInfo?.discreteRowProjections || {},
      splitFieldInfo: {
        field: s,
        value: o
      }
    };
  }
  getGreatGrandTotalsDataModelInfo(t, i = {}) {
    const {
      rowTotalsSplitField: n,
      columnTotalsSplitField: s,
      rowGrandTotalsPosition: A,
      columnGrandTotalsPosition: o
    } = tA(t);
    let a = -1, r = -1;
    const l = this.facets().rowFacets.find(
      (d) => `${d}` === s
    ), g = this.facets().colFacets.find(
      (d) => `${d}` === s
    ) ? i[n] : null, h = l ? i[s] : null;
    if (g && !h) {
      a = this._matrixInfo.completeDataModelMatrix.length - 1;
      let d = this._matrixInfo.completeDataModelMatrix[a];
      if (A === "start") {
        for (let u = 0; u <= d.length - 1; u++)
          if (d[u].columnFacetValues.findIndex(
            (C) => `${C}` == `${g}`
          ) >= 0) {
            r = u;
            break;
          }
      } else
        for (let u = d.length - 1; u >= 0; u--)
          if (d[u].columnFacetValues.findIndex(
            (C) => `${C}` == `${g}`
          ) >= 0) {
            r = u;
            break;
          }
      r = r === -1 ? d.length - 1 : r;
    } else if (!g && h) {
      if (o === "start")
        for (let d = 0; d <= this._matrixInfo.completeDataModelMatrix.length - 1; d++) {
          const u = this._matrixInfo.completeDataModelMatrix[d];
          if (u[u.length - 1].rowFacetValues.findIndex(
            (C) => `${C}` == `${h}`
          ) >= 0) {
            a = d;
            break;
          }
        }
      else
        for (let d = this._matrixInfo.completeDataModelMatrix.length - 1; d >= 0; d--) {
          const u = this._matrixInfo.completeDataModelMatrix[d];
          if (u[u.length - 1].rowFacetValues.findIndex(
            (C) => `${C}` == `${h}`
          ) >= 0) {
            a = d;
            break;
          }
        }
      a = a === -1 ? this._matrixInfo.completeDataModelMatrix.length - 1 : a, r = this._matrixInfo.completeDataModelMatrix[a].length - 1;
    } else if (g && h)
      if (o === "start" && A === "start")
        for (let d = 0; d < this._matrixInfo.completeDataModelMatrix.length; d++) {
          for (let u = 0; u < this._matrixInfo.completeDataModelMatrix[d].length; u++) {
            const f = this._matrixInfo.completeDataModelMatrix[d][u], C = f.rowFacetValues.findIndex(
              (E) => `${E}` == `${h}`
            ), I = f.columnFacetValues.findIndex(
              (E) => `${E}` == `${g}`
            );
            if (C >= 0 && I >= 0) {
              a = d, r = u;
              break;
            }
          }
          if (a !== -1 && r !== -1)
            break;
        }
      else if (o === "start" && A !== "start")
        for (let d = 0; d < this._matrixInfo.completeDataModelMatrix.length; d++) {
          for (let u = this._matrixInfo.completeDataModelMatrix[d].length - 1; u >= 0; u--) {
            const f = this._matrixInfo.completeDataModelMatrix[d][u], C = f.rowFacetValues.findIndex(
              (E) => `${E}` == `${h}`
            ), I = f.columnFacetValues.findIndex(
              (E) => `${E}` == `${g}`
            );
            if (C >= 0 && I >= 0) {
              a = d, r = u;
              break;
            }
          }
          if (a !== -1 && r !== -1)
            break;
        }
      else if (o !== "start" && A === "start")
        for (let d = this._matrixInfo.completeDataModelMatrix.length - 1; d >= 0; d--) {
          for (let u = 0; u < this._matrixInfo.completeDataModelMatrix[d].length; u++) {
            const f = this._matrixInfo.completeDataModelMatrix[d][u], C = f.rowFacetValues.findIndex(
              (E) => `${E}` == `${h}`
            ), I = f.columnFacetValues.findIndex(
              (E) => `${E}` == `${g}`
            );
            if (C >= 0 && I >= 0) {
              a = d, r = u;
              break;
            }
          }
          if (a !== -1 && r !== -1)
            break;
        }
      else
        for (let d = this._matrixInfo.completeDataModelMatrix.length - 1; d >= 0; d--) {
          for (let u = this._matrixInfo.completeDataModelMatrix[d].length - 1; u >= 0; u--) {
            const f = this._matrixInfo.completeDataModelMatrix[d][u], C = f.rowFacetValues.findIndex(
              (E) => `${E}` == `${h}`
            ), I = f.columnFacetValues.findIndex(
              (E) => `${E}` == `${g}`
            );
            if (C >= 0 && I >= 0) {
              a = d, r = u;
              break;
            }
          }
          if (a !== -1 && r !== -1)
            break;
        }
    else
      a = o === "start" ? 0 : this._matrixInfo.completeDataModelMatrix.length - 1, r = A === "start" ? 0 : this._matrixInfo.completeDataModelMatrix[a].length - 1;
    return {
      dataStore: this._matrixInfo.completeDataModelMatrix[a][r].dataStore,
      rowFacets: this._detailedFacetProjectionInfo?.rowFacets || {},
      colFacets: this._detailedFacetProjectionInfo?.colFacets || {},
      discreteColumnProjections: this._detailedFacetProjectionInfo?.discreteColumnProjections || {},
      discreteRowProjections: this._detailedFacetProjectionInfo?.discreteRowProjections || {},
      splitFieldInfo: {
        column: {
          field: s,
          value: h
        },
        row: {
          field: n,
          value: g
        }
      }
    };
  }
  getColumnsubTotalsDataModelInfo(t, i, n) {
    const {
      columnTotalString: s,
      colSubTotalsSplitField: A,
      columnSubTotalsPosition: o
    } = tA(t), r = this.getMatrixInfoFromRelativeRowIndex(
      i.unitRowIndex
    )[i.unitColIndex].rowFacetValues;
    let l = r.findIndex(
      (u) => u === s
    ), c = this.getAbsoluteRowIndexFromRelativeRowIndex(
      i.unitRowIndex
    ), g = i.unitRowIndex;
    if (l === 0 || l === 1 || !r.length)
      return this.getColumnGrandTotalsDataModelInfo(
        i.unitColIndex,
        t,
        i.facets
      );
    let h = this.getMatrixInfoFromRelativeRowIndex(
      i.unitRowIndex
    );
    if (l === -1 && this._detailedFacetProjectionInfo?.discreteRowProjections.every(
      (u) => n.dataObj[u] === s
    ) || l >= 0 || this._detailedFacetProjectionInfo.discreteRowProjections.findIndex(
      (u) => u === A
    ) >= 0) {
      let u = r.slice();
      for (let f = u.length - 1; f >= 0; f--)
        if (u[f] !== s && `${this._detailedFacetProjectionInfo.rowFacets[f]}` !== A) {
          u[f] = s;
          break;
        }
      if (u = u.join("-"), o === "start") {
        for (let f = c - 1; f >= 0; f--)
          if (this._matrixInfo.completeDataModelMatrix[f][i.unitColIndex].rowFacetValues.join("-") === u) {
            g = f, h = this._paginatedMatrixInfo.completeDataModelMatrix[g];
            break;
          }
      } else
        for (let f = c + 1; f < this._matrixInfo.completeDataModelMatrix.length; f++)
          if (this._matrixInfo.completeDataModelMatrix[f][i.unitColIndex].rowFacetValues.join("-") === u) {
            g = f, h = this._paginatedMatrixInfo.completeDataModelMatrix[g];
            break;
          }
    }
    return {
      dataStore: h[i.unitColIndex].dataStore,
      rowFacets: this._detailedFacetProjectionInfo?.rowFacets || {},
      colFacets: this._detailedFacetProjectionInfo?.colFacets || {},
      discreteColumnProjections: this._detailedFacetProjectionInfo?.discreteColumnProjections || {},
      discreteRowProjections: this._detailedFacetProjectionInfo?.discreteRowProjections || {},
      selectRequiredOnDataStore: !0,
      colSubTotalsSplitField: A,
      columnTotalString: s
    };
  }
  getRowsubTotalsDataModelInfo(t, i, n) {
    const { rowTotalString: s, rowSubTotalsSplitField: A, rowSubTotalsPosition: o } = tA(t), a = this.getAbsoluteRowIndexFromRelativeRowIndex(
      i.unitRowIndex
    ), l = this._matrixInfo.completeDataModelMatrix[a][i.unitColIndex].columnFacetValues;
    let c = l.findIndex(
      (d) => d === s
    ), g = i.unitColIndex;
    if (c === 0 || c === 1 || !l.length)
      return this.getRowGrandTotalsDataModelInfo(
        i.unitRowIndex,
        t,
        i.facets
      );
    if (c === -1 && this._detailedFacetProjectionInfo?.discreteColumnProjections.every(
      (d) => n.dataObj[d] === s
    ) || c >= 0 || this._detailedFacetProjectionInfo.discreteColumnProjections.findIndex(
      (d) => d === A
    ) >= 0) {
      let d = l.slice();
      for (let u = d.length - 1; u >= 0; u--)
        if (d[u] !== s && `${this._detailedFacetProjectionInfo.colFacets[u]}` !== A) {
          d[u] = s;
          break;
        }
      if (d = d.join("-"), o === "start") {
        for (let u = i.unitColIndex - 1; u >= 0; u--)
          if (this._matrixInfo.completeDataModelMatrix[a][u].columnFacetValues.join("-") === d) {
            g = u;
            break;
          }
      } else
        for (let u = i.unitColIndex + 1; u < this._matrixInfo.completeDataModelMatrix[a].length; u++)
          if (this._matrixInfo.completeDataModelMatrix[a][u].columnFacetValues.join("-") === d) {
            g = u;
            break;
          }
    }
    return {
      dataStore: this._matrixInfo.completeDataModelMatrix[a][g].dataStore,
      rowFacets: this._detailedFacetProjectionInfo?.rowFacets || {},
      colFacets: this._detailedFacetProjectionInfo?.colFacets || {},
      discreteColumnProjections: this._detailedFacetProjectionInfo?.discreteColumnProjections || {},
      discreteRowProjections: this._detailedFacetProjectionInfo?.discreteRowProjections || {},
      selectRequiredOnDataStore: !0,
      rowSubTotalsSplitField: A,
      rowTotalString: s
    };
  }
}
const Y1 = (e, t) => {
  const i = e[0] / (e[0] - t[0]), n = e[1] / (e[1] - t[1]);
  let s = !1;
  return t[0] > 0 && t[1] > 0 && t[1] > 0 && e[1] > 0 && (s = !0, t[0] = 0, t[1] = 0), t[0] < 0 && t[1] < 0 && t[1] < 0 && e[1] < 0 && (s = !0, e[0] = 0, e[1] = 0), !s && i !== n && !Number.isNaN(i) && !Number.isNaN(n) && (i <= 0 && n >= 1 ? (e[0] = Math.max(e[0], -t[0]), t[1] = Math.min(t[1], -e[1])) : i >= 1 && n <= 0 ? (t[0] = Math.min(t[0], -e[0]), e[1] = Math.max(e[1], -t[1])) : i < n ? t[1] = t[0] / e[0] * e[1] : t[0] = t[1] / e[1] * e[0]), [
    [t[0], e[0]],
    [t[1], e[1]]
  ];
}, J1 = (e, t) => {
  [yA, ur, po, wA, Gl].forEach((i) => {
    const n = e[i];
    if (n) {
      const s = n.find((A) => A.isGlobal);
      t.forEach((A) => {
        A.encoding = A.encoding || {}, !A.encoding[i] && (A.encoding[i] = {});
        let o = A.encoding[i].field;
        !o && s && (o = s.field, A.encoding[i].field = s.field, A.encoding[i].as = s.as);
        const a = [s, ...n].filter(Boolean).find((r) => r.field === o);
        A.encoding[i].splitBy = a ? Z(a, "splitBy", "field") : null;
      });
    }
  });
}, K1 = (e, t) => {
  const i = e.as(), n = t.as(), s = e.subtype(), A = t.subtype();
  let o;
  return i === ft.DISCRETE || n === ft.DISCRETE ? o = N_ : s === er && i === ft.CONTINUOUS || A === er && n === ft.CONTINUOUS ? o = F_ : o = R_, o;
}, R7 = (e, t, i) => {
  const n = e.getField(i);
  return n && n.subtype() === vh && (t.subtype = vh, t.binSize = n.getBinSize(), t.bins = n.getAllBins()), t;
}, V1 = (e, t, i = [], n) => {
  const { axisType: s } = t, A = [], o = s1[s];
  return i.forEach((a) => {
    const { field: r, values: l = {} } = a.splitBy || {}, c = a.field;
    if (a.type = a.type ? a.type : WM(e, c || null, a.as), a.fieldAs = a.as, a = R7(e, a, c), r)
      e.getField(r).uniques().forEach((h) => {
        const d = new o(
          {
            ...a,
            splitFieldValue: h,
            ...l[h] || {}
          },
          n()
        );
        d.isGlobal && d.isGlobal(!!a.isGlobal), A.push(d);
      });
    else {
      const g = new o(a, n());
      g.isGlobal && g.isGlobal(!!a.isGlobal), A.push(g);
    }
  }), A;
}, iC = (e, t) => {
  let i = 0, n = -1;
  for (; n === -1 && i < e.length; )
    e[i].toString() === t.toString() && (n = i), i++;
  return n;
}, W1 = (e, t, i) => i.filter((n) => {
  const s = n instanceof Array ? n : [n], A = [].concat(
    ...s.map((c) => c.encoding).filter((c) => c !== void 0)
  );
  if (!A.length)
    return !0;
  const o = [].concat(...A.map((c) => [c.x && c.x.field, c.x0 && c.x0.field])).filter((c) => c != null), a = [].concat(...A.map((c) => [c.y && c.y.field, c.y0 && c.y0.field])).filter((c) => c != null);
  if (!o.length && !a.length)
    return !0;
  const r = o.length ? o.every((c) => e.indexOf(c) !== -1) : !1, l = a.length ? a.every((c) => t.indexOf(c) !== -1) : !1;
  return o.length && a.length ? r && l : r || l;
}), k7 = (e, t, i) => {
  const { rowIndex: n, columnIndex: s, axesObj: A } = i, { config: o, facetFields: a, resolver: r } = e, l = r.axes(), { RADIUS: c, ANGLE: g } = Gt;
  [c, g, M_].forEach((h) => {
    const d = l[h];
    d[n] || (d[n] = []), d[n][s] = A[h];
    const u = Z(o.axes, h) || {};
    A[h].forEach((f, C) => {
      let I = u;
      u instanceof Function && (I = u(n, s, {
        axisFields: [t[h][C]],
        facetFields: a
      })), f.config(I);
    });
  });
}, v7 = (e, t, i) => Object.keys(e.sort).filter((n) => n !== "autoSort").length !== 0 ? e.sort[t] : i.defaultSort, Sc = (e) => {
  const t = [];
  return e.length && e.forEach((i, n) => {
    const s = en.sanitizeLayerConfig(i);
    s.order = n, t.push(s);
  }), t;
}, T7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createRetinalAxis: V1,
  getAdjustedDomain: Y1,
  getDefaultMark: K1,
  getIndex: iC,
  getLayerConfFromFields: W1,
  getSortingConfig: v7,
  resolveAxisConfig: k7,
  serializeLayerConfig: Sc,
  setRetinalFieldsInLayer: J1
}, Symbol.toStringTag, { value: "Module" })), G7 = va.CARTESIAN, q1 = (e, t, i) => {
  let n = [], s = [], A = 0;
  const o = [], a = [], r = e[0], l = e[1], c = r.length, g = l.length;
  for (let h = 0; h < c; h++) {
    let d = [r[h]];
    const u = r[h];
    if (u.isContinuous()) {
      const f = l[A];
      f && f.isContinuous() && (A++, d = [u, f]), s.push(d);
    } else
      n.push(u), o.push(u);
  }
  if (g > A)
    for (let h = A; h < g; h++) {
      const d = l[h], u = [d];
      d.isContinuous() ? s.push(u) : (n.push(d), a.push(d));
    }
  if ((o.length || a.length) && !s.length)
    if (t = t === zA ? Ec : t, (i[t] === Je || i[t] === Pe) && o.length) {
      const h = o.length - 1, d = o[h];
      s = [[d]];
      const u = iC(a, d);
      u > -1 && (s = [[d, d]], a.splice(u, 1)), o.splice(h, 1);
    } else {
      const d = a[0];
      s = [[d]];
      const u = iC(o, d);
      u > -1 && (s = [[d, d]], o.splice(u, 1)), a.splice(0, 1);
    }
  return n = [...o, ...a], n = n.filter(
    (h, d, u) => d === u.findIndex((f) => f.toString() === h.toString())
  ), {
    facets: n,
    projections: s
  };
};
class j1 extends TB {
  static type() {
    return G7;
  }
  getFacetsAndProjections(t, i) {
    const n = this.axisFrom();
    return q1(t, i, n);
  }
  fieldSanitizer(t, i) {
    return super.fieldSanitizer(t, i);
  }
  serializeLayerConfig(t) {
    return Sc(t);
  }
  setRetinalFieldsInLayers(t, i) {
    const n = [];
    return i.forEach((s) => {
      const A = Bn(s.def);
      J1(t, A), n.push(s);
    }), n;
  }
  getResolvedEncodings(t, i, n, s) {
    const A = [], { columnFields: o, rowFields: a, dataStore: r } = t, { sort: l, useUTC: c } = n, g = ([d, u]) => u.as == null ? [
      d,
      u.field == null ? { ...u } : {
        ...u,
        as: bi(r.getField(u.field))
      }
    ] : [d, u], h = (d) => ({
      ...d,
      encoding: Object.fromEntries(
        Object.entries(d.encoding).map(g)
      )
    });
    return o.forEach((d) => {
      if (zn(d))
        return;
      const u = d.toString(), f = d.as();
      a.forEach((C) => {
        if (zn(C))
          return;
        let I = [];
        const E = C.toString(), B = C.as(), m = {
          x: {
            field: u,
            as: f,
            var: d
          },
          y: {
            field: E,
            as: B,
            var: C
          }
        }, p = K1(d, C), w = [
          {
            mark: p,
            def: {
              mark: p,
              encoding: m,
              transform: Object.assign({}, { sort: l }),
              useUTC: c
            }
          }
        ], Q = W1(
          d.getMembers(),
          C.getMembers(),
          i || []
        );
        Q.length ? I = Q.map((y) => {
          let D = y;
          if (y.mark === "text") {
            let S;
            const b = s.data();
            if (y.encoding.text?.field) {
              S = r.getField(y.encoding.text.field);
              const T = b.getField(y.encoding.text.field);
              b.getField(y.encoding.text.field).subtype() !== S.subtype() && S.subtype() === ot.CATEGORICAL && (S = T);
            }
            const R = bi(S), G = S ? y.encoding.text.as === kh || R === kh ? "right" : "left" : "center";
            D = Object.assign({ align: G }, y);
          }
          const _ = et(
            et({}, w[0].def),
            D
          ), x = en.getSerializedConf(
            _.mark,
            _
          );
          return {
            mark: _.mark,
            order: _.order,
            def: Array.isArray(x) ? x.map(h) : x
          };
        }) : I = w, A.push(...I);
      });
    }), A.length ? A : i.map((d) => ({
      mark: d.mark,
      def: d
    }));
  }
}
const ny = (e, { field: t, as: i, splitField: n, splitFieldValue: s }) => {
  const A = e.context().config(), {
    rows: {
      totals: {
        grandTotals: { enabled: o }
      }
    },
    columns: {
      totals: {
        grandTotals: { enabled: a }
      }
    }
  } = A, r = e._rowSubTotalsDataModel, l = e._columnSubTotalsDataModel, c = e._greatSubTotalsDataModel, g = e._columnGrandTotalsDataModel, h = e._rowGrandTotalsDataModel, d = e._greatGrandTotalsDataModel, u = e._groupedData;
  let f = [];
  return [
    r,
    l,
    c,
    a ? g : null,
    o ? h : null,
    a && o ? d : null
  ].forEach((I) => {
    if (I) {
      let E;
      if (n) {
        const p = I.select({
          field: n,
          value: s,
          operator: "eq"
        });
        E = p.getField(t).domain(), p.dispose();
      } else
        E = I.getField(t).domain();
      const B = I.getField(t).subtype(), m = u.getField(t).subtype();
      B === ot.CATEGORICAL && B !== m && (m === ot.TEMPORAL || m === ot.BINNED) && (E = E.map((p) => us(p))), f.push(E);
    }
  }), we(f, i);
}, sy = (e, { field: t, as: i, splitField: n, splitFieldValue: s }) => {
  const A = e._groupedData;
  let o;
  if (n) {
    const a = A.select({
      field: n,
      value: s,
      operator: "eq"
    });
    o = a.getDomain(t, i), a.dispose();
  } else
    o = A.getDomain(t, i);
  return o;
};
class z1 extends TB {
  createAxis(t, i) {
    const { config: n, childEventManagerCreator: s, globalConfig: A } = i, o = {};
    return [yA, ur, po, wA, Gl].forEach((a) => {
      if (o[`${a}`] = V1(
        t,
        { axisType: a },
        n[a],
        s
      ), !A.legend.includeTotalDomain) {
        const r = s1[a], l = A.legend.totalsColor;
        switch (a) {
          case yA:
          case Gl:
            o[`${a}`].push(
              new r(
                {
                  range: [l],
                  metaInfo: {
                    isTotalsAxis: !0
                  }
                },
                s()
              )
            );
            break;
          case wA:
            o[`${a}`].push(
              new r(
                {
                  metaInfo: {
                    isTotalsAxis: !0
                  }
                },
                s()
              )
            );
            break;
        }
      }
    }), o;
  }
  static type() {
    return "retinal";
  }
  setCommonDomain(t) {
    const { domains: i, axes: n, encoding: s, resolver: A } = t, a = A._context.config().legend.includeTotalDomain;
    return Object.entries(s).forEach(([r, l]) => {
      l.forEach((c) => {
        if (c.field) {
          const g = n[r].find(
            (u) => u.config().field === c.field && (c.as ? u.config().fieldAs === c.as : !0)
          );
          let h = Z(i, c.field, c.as);
          const d = h && h.splitDomains;
          if (d)
            n[r].filter(
              (f) => f.config().field === c.field
            ).forEach((f) => {
              const C = f.config().splitFieldValue;
              let I = d[C], E;
              a ? E = ny(A, {
                field: c.field,
                as: c.as,
                splitField: f.config().splitBy?.field,
                splitFieldValue: C
              }) : (E = [], I = sy(A, {
                field: c.field,
                as: c.as,
                splitField: f.config().splitBy?.field,
                splitFieldValue: C
              })), I = we(
                [E, I],
                c.as
              ), f.updateDomain(I);
            });
          else if (!c.domain && h) {
            let u;
            a ? u = ny(A, {
              field: c.field,
              as: c.as
            }) : (u = [], h = sy(A, {
              field: c.field,
              as: c.as
            })), h = we([u, h], c.as), g.updateDomain(h);
          }
        }
      });
    }), n;
  }
}
const $1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CartesianEncoder: j1,
  RetinalEncoder: z1,
  VisualEncoder: TB,
  getFacetsAndProjections: q1
}, Symbol.toStringTag, { value: "Module" }));
class L7 {
  /**
       * This method is used to set or get the DataModel instance.
       *
       * @param {DataModel | undefined} dataModel Instance of datamodel.
  
       * @memberof  SimpleGroup
       */
  data() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * This method is used to set or get the group specific configuration
   * properties
   *
   * @param {Object | undefined} configObj The input configuration.
   *                                or instance of visual group.
   * @memberof  SimpleGroup
   */
  config() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * This method is used to return a serialized representation of the
   * instance's properties.
   *
   * @memberof  SimpleGroup
   */
  serialize() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * This method is used to get or set the measurement object which houses
   * layout properties like width and height.
   *
   * @param {Object  | undefined} mObj The measurement properties.
   * @memberof  SimpleGroup
   */
  measurement() {
    throw new Error(yt.INTERFACE_IMPL);
  }
}
const U7 = (e) => {
  const [t] = zh.getState();
  e.store().append(Ld, t);
}, H7 = (e) => {
  const t = e.constructor.getState()[0];
  e.store().append(Ya, t);
}, O7 = (e) => {
  e.store().append(TD, {});
}, sd = (e, t = {}) => {
  const { recalculateDomains: i = !1 } = t, n = e.config(), s = e.store(), A = e._lockAxisDomain, o = e.resolver();
  let a = wt(
    t.unionAxisDomainPerPage,
    n.pagination.enabled && n.pagination.unionAxisDomainPerPage
  );
  e._unionAxisDomainPerPage = a, i && o._matrix.setPaginatedMatrixInfo({
    ...o._paginatedMatrixInfo,
    dataModelMatrix: nA(
      o._paginatedMatrixInfo.dataModelMatrix.map(
        (r, l) => r.map((c, g) => {
          const h = o.units()[l][g];
          return {
            ...c,
            layerDataModels: h.layers().reduce((d, u) => (d[u.id()] = u.data(), d), {})
          };
        })
      ),
      n
    )
  }), A || (s.lockModel(), e.matrix().setAxisDomains(
    n.uniformAxisDomains,
    {
      rootModel: e.data(),
      columnGTRootModel: o.columnGrandTotalsDataModel() == null ? e.data() : o.columnGrandTotalsDataModel(),
      rowGTRootModel: o.rowGrandTotalsDataModel() == null ? e.data() : o.rowGrandTotalsDataModel()
    },
    {
      sort: n.sort,
      unionAxisDomainPerPage: a
    }
  ), e.matrix().extendAxisDomainsIfNeeded(), s.unlockModel());
}, Ay = (e) => {
  e.store().registerChangeListener(
    [`${Ld}.domain`],
    () => {
      e._triggerDomainChangeListener && sd(e), e._triggerDomainChangeListener = !0;
    },
    !1,
    "unionDomain"
  );
}, oy = (e) => {
  e.store().unsubscribe("unionDomain");
}, P7 = {
  alias: {},
  data: {
    preset: (e) => {
      e._prevData = null;
    }
  },
  cornerMatrices: {
    defaultValue: {
      topLeft: [],
      topRight: [],
      bottomLeft: [],
      bottomRight: []
    }
  },
  metaData: {
    defaultValue: {
      border: {}
    }
  },
  resolver: {},
  valueParser: {
    defaultValue: (e) => e
  },
  [w_]: {},
  [D_]: {},
  [x_]: {},
  [yA]: {},
  [ur]: {},
  [po]: {},
  [wA]: {},
  [Th]: {},
  [S_]: {},
  [__]: {},
  [Gl]: {}
};
class Y7 {
  _context;
  _matrixInfo;
  _totalItemCount;
  _totalRowFacetCount;
  _pageSize;
  _currentPageIndex;
  _pageCount;
  _pages;
  constructor(t, i, n) {
    this._pageSize = 100, this._context = t, this._matrixInfo = i, this._currentPageIndex = 0, this._pages = [], this.config(n), this.createPageConfig();
  }
  config(t) {
    t && (this._pageSize = t.pageSize, this._currentPageIndex = wt(t.pageNumber, 1) - 1);
  }
  createPageConfig() {
    const t = this._matrixInfo, { totalRowItemCount: i, totalRowFacetCount: n } = t, s = Math.ceil(n / this._pageSize);
    this._totalItemCount = i, this._totalRowFacetCount = n, this._pageCount = s, this._currentPageIndex > s - 1 && (this._currentPageIndex = 0);
  }
  _updatePageConfig() {
    const t = this._matrixInfo, { totalRowItemCount: i, totalRowFacetCount: n } = t, s = Math.ceil(n / this._pageSize);
    this._totalItemCount = i, this._totalRowFacetCount = n, this._pageCount = s;
  }
  nextPage() {
    if (this._currentPageIndex === this._pageCount - 1)
      return this;
    this._currentPageIndex++;
  }
  previousPage() {
    if (this._currentPageIndex === 0)
      return this;
    this._currentPageIndex--;
  }
  goToPage(t) {
    if (t > this._pageCount)
      return this;
    this._currentPageIndex = t - 1;
  }
  goToLastPage() {
    this._currentPageIndex = this._pageCount - 1;
  }
  setMatrixInfo(t) {
    this._matrixInfo = t;
  }
  getUpdatedCurrentPageData(t, i) {
    if (i === "column") {
      this._pages = [];
      const n = this.getCurrentPageData(), s = n.updateInfo.updateSet.filter(
        ([A]) => A >= n.pageStartIndex && A < n.pageEndIndex
      ).map(([A, o]) => [
        A - n.pageStartIndex,
        o
      ]);
      return n.updateInfo.updateSet = s, {
        currentPageChanged: !1,
        matrixInfo: n
      };
    } else {
      this._updatePageConfig();
      const {
        updateInfo: { updateSet: n, exitSet: s, splitFieldUniques: A, splitFieldIdx: o },
        rowsPerFacet: a
      } = this._matrixInfo, [r] = n[0], l = this._pageSize * a, c = Math.floor(r / l);
      if (c === this._currentPageIndex) {
        const g = c * l, h = n.map(([B, m]) => [B - g, m]).filter((B) => B[0] < l);
        let d = s[0].map(
          (B) => B !== -1 ? B - g : -1
        );
        d = d[0] > l - 1 ? [-1, -1] : [
          d[0],
          Math.min(
            d[1],
            l - (o >= 0 ? A.length : 1)
          )
        ];
        const u = this._pages[this._currentPageIndex].dataModelMatrix.length;
        this._pages = [];
        const f = this.getCurrentPageData(), C = f.dataModelMatrix.length, I = [];
        if (t[t.length - 1].collapsed) {
          const B = d[0] !== -1 ? d[1] - d[0] + 1 : 0, m = u - B;
          for (let p = m; p < C; p++)
            for (let w = 0; w < f.dataModelMatrix[p].length; w++)
              I.push([p, w]);
        } else {
          let B = h[h.length - 1][0] - h[0][0];
          o >= 0 && (B -= Math.max(A.length - 1, 0)), d = B !== 0 && f.pageEndIndex < this._matrixInfo.dataModelMatrix.length ? [C - B, u - 1] : d;
        }
        return f.updateInfo = {
          ...f.updateInfo,
          updateSet: h,
          exitSet: [d, [-1, -1]],
          entrySet: I
        }, {
          currentPageChanged: !1,
          matrixInfo: f,
          currentRowIndex: h[0][0]
        };
      } else
        return this._currentPageIndex = c, this._pages = [], {
          currentPageChanged: !0,
          matrixInfo: this.getCurrentPageData(),
          currentRowIndex: r - c * l
        };
    }
  }
  getCurrentPageData() {
    if (this._pages[this._currentPageIndex])
      return this.getPageData(this._currentPageIndex);
    const t = this._matrixInfo, {
      allRowHeaderKeys: i,
      rowKeys: n,
      allRowAxisInfo: s,
      allColumnAxisInfo: A,
      allColumnHeaderKeys: o,
      columnKeys: a,
      dataModelMatrix: r,
      totalRowItemCount: l,
      rowsPerFacet: c,
      updateInfo: g
    } = t, h = t.totalRowFacetCount || 1, d = this._currentPageIndex * this._pageSize * c;
    let u = 0;
    this._currentPageIndex === this._pageCount - 1 && (u = l % h);
    const f = Math.min(
      d + this._pageSize * c + u,
      this._totalItemCount
    ), C = i.slice(d, f), I = {
      leftAxisInfo: s.leftAxisInfo.slice(d, f),
      rightAxisInfo: s.rightAxisInfo.slice(d, f)
    }, E = r.slice(d, f);
    return this._pages[this._currentPageIndex] = {
      allRowHeaderKeys: C,
      allRowAxisInfo: I,
      rowKeys: n.slice(d, f),
      allColumnAxisInfo: A,
      allColumnHeaderKeys: o,
      columnKeys: a,
      dataModelMatrix: E,
      facetCount: (E.length - u) / c,
      completeDataModelMatrix: r,
      rowsCount: E.flat().reduce(
        (B, m) => B + m.dataStore.getRowsCount(),
        0
      ),
      pageStartIndex: d,
      pageEndIndex: f,
      updateInfo: g
    }, this.getPageData(this._currentPageIndex);
  }
  getPageData(t) {
    const i = this._pages[t], { dataModelMatrix: n } = i;
    return {
      ...i,
      dataModelMatrix: n.map((s) => s.map((A) => ({
        ...A,
        dataStore: A.dataStore.project(
          A.dataStore.getSchema().filter((o) => o.name !== pt.ROW_ID).map((o) => o.name)
        )
      })))
    };
  }
  getTotalPageCount() {
    return this._pageCount;
  }
  getTotalFacetCount() {
    return this._totalRowFacetCount;
  }
  getFacetCountForCurrentPage() {
    return this._pages[this._currentPageIndex].facetCount;
  }
  getCurrentPageNumber() {
    return this._currentPageIndex + 1;
  }
  getRowsCount() {
    return this._pages[this._currentPageIndex].rowsCount;
  }
  getPaginatedValues(t) {
    const { pageStartIndex: i, pageEndIndex: n } = this._pages[this._currentPageIndex];
    return t.slice(i, n);
  }
}
const J7 = (e, t, i, n) => {
  let s = {};
  if (n && (e || t)) {
    const { facetsUserConfig: A = {}, border: o } = n, { isBorderPresent: a = {}, isGridLinePresent: r = {} } = A, l = Object.keys(r).length, {
      width: c,
      color: g,
      style: h,
      showValueBorders: d,
      showRowBorders: u,
      showColBorders: f
    } = o;
    let C = {}, I = {};
    Object.keys(a).length === 0 || !a.width ? I = {
      width: F0[nB]
    } : Object.assign(
      I,
      c ? { width: c } : null,
      g ? { color: g } : null,
      d ? { showValueBorders: d } : null,
      u ? { showRowBorders: u } : null,
      f ? { showColBorders: f } : null,
      h ? { style: h } : null
    ), l <= 0 && (C = {
      x: {
        show: !1
      }
    }), s = {
      border: I,
      gridLines: C
    };
  } else i === "html" && (s = {
    border: {
      width: F0[L_]
    }
  });
  return s;
};
class Ad extends ci(L7).with(Lo) {
  /**
   * Creates an instance of VisualGroup. Requires dependencies and other registry options for placeholders
   * and layers that create individual units.
   *
   * @param {Object} registry Key value pair of compostions for the group
   * @param {Object} dependencies Dependencies needed to run the group
   * @memberof VisualGroup
   */
  constructor(t, i, n) {
    super(), this.eventManager(n), this._registry = t, this._dependencies = i, ve(this, this.constructor.getterSetters()), this.store(i.store), this._encoders = {
      simpleEncoder: this.createEncoderInstance(),
      retinalEncoder: new z1()
    }, this._data = [], this._prevData = null, this._groupedDataModel = [], this._mount = null, this._placeholderInfo = {}, this._lockAxisDomain = !1;
    const s = new F7({
      registry: t,
      ...this._dependencies,
      store: this.store()
    });
    s.encoder(this._encoders), s.context(this), this.resolver(s);
  }
  static getState() {
    return [
      {
        domain: {
          x: null,
          y: null,
          radius: null,
          angle: null,
          angle0: null
        }
      },
      {}
    ];
  }
  store(...t) {
    return t.length ? (this._store = t[0], H7(this), U7(this), O7(this), this) : this._store;
  }
  static formalName() {
    return "VisualGroup";
  }
  static getterSetters() {
    return P7;
  }
  registry() {
    return this._registry;
  }
  /**
   * Return the instances of matrices created by the visual group.
   *
   * @return {Object} Instance of matrices.
   */
  matrixInstance(...t) {
    return t.length ? this : this.composition().matrices;
  }
  /**
   * Returns the composition of visual group.
   *
   * @public
   *
   * @return {Object} Composition of visual group. It contains instance of matrices {@link ValueMatrix}
   * and instances of axis.
   * ```
   *          {
   *              matrices: {
   *                  value: // Instance of center value matrix.
   *                  left: // Instance of left value matrix
   *                  right: // Instance of right value matrix
   *                  bottom: // Instance of bottom value matrix
   *                  top: // Instance of top value matrix.
   *              },
   *              axes: {
   *                  x: // Array of x axis.
   *                  y: // Array of y axis
   *                  color: // Array of color axis
   *                  shape: // Array of shape axis
   *                  size: // Array of size axis.
   *              }
   *          }
   * ```
   */
  composition(...t) {
    return t.length ? this : this._composition;
  }
  /**
   * Returns the channel name of the variable. Channels are rows, columns, color, shape and size.
   *
   * @public
   * @param {string} variable Name of the variable.
   *
   * @return {string} Name of the channel.
   */
  where(t) {
    return VM(t, this.resolver().getAllFields());
  }
  /**
   * Gets the axis instances of the visual group based on the given axis type.
   *
   * @public
   * @param {string} type Type of axis. X,Y or retinal axes.
   *
   * @return {Array} Array of axis instances.
   */
  getAxes(t) {
    if (t === b_)
      return this.resolver().getRetinalAxes();
    const i = this.matrix(), n = i.row(), s = i.column();
    return t === "x" ? s.getAxes() : t === "y" ? n.getAxes() : [];
  }
  /**
   * Returns the grouped datamodel prepared by visual group. If there is no group by performed, then it returns the
   * original data model passed to visual group.
   *
   * @return {DataModel} Grouped data model.
   */
  getGroupByData() {
    return this.resolver()._groupedData;
  }
  placeholderInfo() {
    return this._placeholderInfo;
  }
  updateMatrices(t, i) {
    const n = this.resolver(), { simpleEncoder: s } = this._encoders, A = this.config();
    n.updateMatrices(t, i, A), this._paginationInstance?.setMatrixInfo(n._matrixInfo);
    const o = this._paginationInstance?.getUpdatedCurrentPageData(
      t,
      i
    ), a = o?.matrixInfo ?? n._matrixInfo;
    let r;
    o?.currentPageChanged ? (r = this.generatePlaceholderInfo(), this.cornerMatrices(this._placeholderInfo.headerTitles)) : r = this.updatePlaceholderInfo(i, a, {
      targetPath: t
    });
    const l = o?.currentRowIndex ?? a.updateInfo.updateSet?.[0]?.[0], c = a.updateInfo.updateSet?.[0]?.[1], g = $I(r, s, {
      showXAxesLine: A.axes.x.showAxisLine,
      showYAxesLine: A.axes.y.showAxisLine
    });
    return this.metaData({
      border: g
    }), {
      rowIndex: l ?? 0,
      columnIndex: c ?? 0,
      currentPageChanged: o?.currentPageChanged
    };
  }
  createMatrices() {
    const t = this.layers(), i = this.resolver(), n = this.config(), {
      rows: { facets: s },
      columns: { facets: A }
    } = n;
    this._triggerDomainChangeListener = !0, this._lockAxisDomain = !1;
    const { simpleEncoder: o } = this._encoders, a = o.sanitizeFields(this.data(), {
      rows: this.rows(),
      columns: this.columns()
    });
    o.setAxisAndHeaders(n.axisFrom, a), i.layerConfig(t).valueParser(this.valueParser()).horizontalAxis(a.rows).verticalAxis(a.columns).optionalProjections({
      rows: a.rows,
      columns: a.columns
    });
    const { rowFacets: r, colFacets: l, colProjections: c, rowProjections: g } = i.getAllFields(), h = r.length > 0 || l.length > 0, d = h ? JM(
      {
        row: s,
        column: A
      },
      this.data()
    ) : {}, u = h ? KM(
      {
        row: s,
        column: A
      },
      this.data()
    ) : {};
    i.facetFormatters(d), i.facetHyperLinkFormatters(u), i.generateMatrices(), this._paginationInstance = null, n.pagination.enabled ? this._paginationInstance = new Y7(
      this,
      i._matrixInfo,
      n.pagination
    ) : n.pagination.enabled = !1;
    const f = this.generatePlaceholderInfo();
    this.cornerMatrices(this._placeholderInfo.headerTitles);
    const C = r.length > 0 || l.length > 0, I = c.length > 1 || g.length > 1;
    et(
      n,
      J7(
        C,
        I,
        f.cellRenderer,
        n
      )
    );
    const E = $I(f, o, {
      showXAxesLine: n.axes.x.showAxisLine,
      showYAxesLine: n.axes.y.showAxisLine
    });
    return this.metaData({
      border: E
    }), !E.showValueBorders.left && !n.axes.y.showAxisLine && this.matrix()._matrices.row._matrices.axes._cells.left.forEach((B) => {
      B.source().config({
        tickSize: 0
      });
    }), !E.showValueBorders.right && !n.axes.y.showAxisLine && this.matrix()._matrices.row._matrices.axes._cells.right.forEach(
      (B) => {
        B.source().config({
          tickSize: 0
        });
      }
    ), this;
  }
  goToNextPage() {
    this.getPaginationInstance().nextPage(), this.generatePlaceholderInfo();
  }
  goToPreviousPage() {
    this.getPaginationInstance().previousPage(), this.generatePlaceholderInfo();
  }
  goToPage(t) {
    this.getPaginationInstance().goToPage(t), this.generatePlaceholderInfo();
  }
  goToLastPage() {
    this.getPaginationInstance().goToLastPage(), this.generatePlaceholderInfo();
  }
  getPaginationInstance() {
    return this._paginationInstance;
  }
  generatePlaceholderInfo(t) {
    oy(this);
    const i = this.resolver(), n = this.config(), {
      rows: { facets: s } = {},
      columns: { facets: A } = {}
    } = n, {
      interaction: { collapse: { enabled: o } = {} } = {}
    } = s ?? {}, {
      interaction: { collapse: { enabled: a } = {} } = {}
    } = A ?? {};
    let r;
    if (this._paginationInstance) {
      const l = this._paginationInstance.getCurrentPageData();
      n.pagination.enabled && n.pagination.unionAxisDomainPerPage && (l.dataModelMatrix = nA(
        KA(
          i.context(),
          i.encoder().simpleEncoder,
          l.dataModelMatrix,
          i._suppliedLayers
        ),
        n
      )), r = this._placeholderInfo = i.generateMatrixInstance(
        l,
        t
      );
    } else o || a ? r = this._placeholderInfo = i.generateMatrixInstance(
      {
        ...i._matrixInfo,
        dataModelMatrix: i._matrixInfo.dataModelMatrix.map(
          (l) => l.map((c) => ({
            ...c,
            dataStore: ed(
              c.dataStore,
              c.dataStore
            )
          }))
        )
      }
    ) : r = this._placeholderInfo = i.generateMatrixInstance(
      i._matrixInfo
    );
    return this._dependencies.throwback.commit(ka.MATRIX_CREATED, !0), Ay(this), r;
  }
  updatePlaceholderInfo(t, i, { targetPath: n = [] } = {}) {
    oy(this);
    const s = this.resolver();
    return this._placeholderInfo = {
      ...this._placeholderInfo,
      ...s.updateMatrixInstance(i, t, { targetPath: n })
    }, this._dependencies.throwback.commit(ka.MATRIX_CREATED, !0), Ay(this), this._placeholderInfo;
  }
  remove() {
    const t = this.placeholderInfo();
    this.resolver()._matrix.dispose(), this.resolver().clear(), t.rows = null, t.columns = null, t.values = null;
  }
  createEncoderInstance() {
    return this.layers(), qM();
  }
  groupedData(...t) {
    return t.length ? (this._groupedDataModel = t[0], this) : this.getGroupByData();
  }
  resetData() {
    const t = this._originalGroupedData;
    return t && (this._groupedDataModel = t), this;
  }
  matrix() {
    return this.resolver()._matrix;
  }
  /**
   * Get all the retinal encodings across global one and layer specific ones
   * for a specific encoding type (color, shape and size).
   *
   *  @return {Object} The encodings.
   */
  extractAllRetinalEncodingsFor(t, i) {
    const n = this[t]();
    let s;
    const A = {};
    let o = Object.keys(
      {
        color: Ll,
        opacity: Ph,
        shape: Jh,
        size: Ul,
        backgroundColor: Ll
      }[t]
    );
    const a = Z(this.config(), "legend", t) || {}, r = Rg(o, a);
    i.forEach((c = {}) => {
      let g = c[t];
      if (typeof g == "object" && g !== null || (g = { field: g }), g.field) {
        let h = g.as || bi(this.data().getField(g.field));
        A[g.field] = Object.assign(
          {},
          A[g.field],
          { [h]: !0 }
        );
      }
    }), n.field && (s = n.as || bi(this.data().getField(n.field)), A[n.field] = Object.assign(
      {},
      A[n.field],
      { [s]: !0 }
    ));
    const l = [{ field: null, ...r }];
    return Object.keys(A).forEach((c) => {
      const g = A[c];
      [ft.CONTINUOUS, ft.DISCRETE].forEach((h) => {
        if (g[h]) {
          const d = Z(a, "fields", c) || {}, u = Z(d, h) || {};
          let f;
          this.data().getField(c).type() !== ha ? f = o.filter((I) => I !== "splitBy") : f = o;
          const C = et(
            { ...r },
            et(
              Rg(f, d),
              Rg(f, u)
            )
          );
          if (!C.ordering) {
            const I = this.config();
            C.ordering = Z(I.axes, "x", "fields", c, "ordering") || Z(I.axes, "y", "fields", c, "ordering") || Z(
              I.columns,
              "facets",
              "fields",
              c,
              "ordering"
            ) || Z(
              I.rows,
              "facets",
              "fields",
              c,
              "ordering"
            ) || {};
          }
          l.push({
            field: c,
            as: h,
            isGlobal: c === n.field && h === s,
            ...C
          });
        }
      });
    }), l;
  }
  getAllColorEncodings(t) {
    return this.extractAllRetinalEncodingsFor("color", t);
  }
  getAllOpacityEncodings(t) {
    return this.extractAllRetinalEncodingsFor("opacity", t);
  }
  getAllShapeEncodings(t) {
    return this.extractAllRetinalEncodingsFor("shape", t);
  }
  getAllSizeEncodings(t) {
    return this.extractAllRetinalEncodingsFor("size", t);
  }
  getAllBackgroundColorEncodings(t) {
    return this.extractAllRetinalEncodingsFor("backgroundColor", t);
  }
  getAllRetinalEncodings(t) {
    return {
      color: this.getAllColorEncodings(t),
      opacity: this.getAllOpacityEncodings(t),
      shape: this.getAllShapeEncodings(t),
      size: this.getAllSizeEncodings(t),
      backgroundColor: this.getAllBackgroundColorEncodings(t)
    };
  }
  interactionRegistry(...t) {
    return t.length ? (this._interactionRegistry = t[0], this) : this._interactionRegistry;
  }
  findUnitByPayload(t) {
    const i = this.matrix().geom();
    let n = i.findUnitByPayload(t);
    return n || (n = i.getUnits()[0]), n;
  }
}
const K7 = () => {
  const e = /* @__PURE__ */ new Map();
  return {
    get: (t) => t ? e.get(t) : e,
    save: (t, i) => {
      e.set(t, i);
    },
    remove: (t) => {
      e.delete(t);
    },
    clear: () => {
      e.clear();
    }
  };
}, V7 = "4.7.6", W7 = {
  version: V7
}, q7 = "drag", j7 = "hover", z7 = "click", od = "legendTextHover", ad = "stepLegendItemHover", X1 = "brush", _u = "highlight", Z1 = "select", rd = "legendHighlight", Ms = "muze", $7 = {
  [ba]: {
    target: [
      `.${Ms}-legend-columns`,
      `.${Ms}-step-legend-icon`
    ],
    behaviours: [QB]
  },
  [Ol]: {
    target: [`.${Ms}-legend-columns`],
    behaviours: ["inverse-select"]
  },
  [od]: {
    target: [
      `.${Ms}-legend-title-text`,
      `.${Ms}-legend-item-info-text`,
      `.${Ms}-legend-pagination-handle`,
      `.${Ms}-step-legend-ticks-v`,
      `.${Ms}-step-legend-ticks-h`
    ],
    behaviours: [rd]
  },
  [ad]: {
    target: [`.${Ms}-step-legend-icon`],
    behaviours: [rd]
  }
}, tN = "selectionBox", YB = "marker", nC = "legendTextTooltip", sC = "stepLegendTooltip", X7 = {
  [X1]: [tN],
  [Z1]: [],
  [_u]: [],
  [rd]: [
    nC,
    sC
  ]
}, Z7 = (e) => (t) => {
  let i = {}, n = {}, s;
  const A = hr(), o = e.context, a = o.measurement().gradientDimensions, r = o.config().align === "horizontal" ? "x" : "y", l = o.axis().source().scale(), c = l.range()[r === "x" ? 0 : 1];
  t.call(
    A().on("start", () => {
      const g = bt();
      i = {
        x: g.x,
        y: g.y
      };
    }).on("drag", () => {
      const g = bt();
      n = {
        x: g.x,
        y: g.y
      }, n.x = Math.max(0, Math.min(n.x, a.width)), n.y = Math.max(0, Math.min(n.y, a.height)), s = {
        criteria: {
          range: {
            [o.fieldName()]: [
              l.invert(i[r] + c * 2),
              l.invert(n[r] + c * 2)
            ].sort((h, d) => h - d)
          }
        }
      }, e.triggerPhysicalAction("drag", s);
    }).on("end", () => {
      const g = bt();
      n = {
        x: g.x,
        y: g.y
      }, n.x = Math.max(0, Math.min(n.x, a.width)), n.y = Math.max(0, Math.min(n.y, a.height)), i[r] === n[r] ? s = {
        criteria: null
      } : s = {
        criteria: {
          range: {
            [o.fieldName()]: [
              l.invert(i[r] + c * 2),
              l.invert(n[r] + c * 2)
            ].sort((h, d) => h - d)
          }
        }
      }, e.triggerPhysicalAction("drag", s);
    })
  );
}, tq = (e) => (t) => {
  const i = function(n) {
    const s = e.context.getCriteriaFromData(n), A = {
      criteria: {
        dimensions: s
      },
      fields: Object.keys(s)
    };
    e.triggerPhysicalAction("hover", A);
  };
  t.on("mouseover", i).on("mousemove", i).on("mouseout", () => {
    e.triggerPhysicalAction("hover", {
      criteria: null
    });
  });
}, eq = (e) => (t) => {
  const i = function(n) {
    const s = e.context.getCriteriaFromData(n), A = {
      criteria: {
        dimensions: s
      },
      fields: Object.keys(s)
    };
    e.triggerPhysicalAction("click", A);
  };
  t.on("click", i);
}, JB = "muze", Ve = "width", ai = "height", iq = "#d8d8d8", eN = 2, ld = {
  // approximately the (size needed) * Math.PI value
  outline: 6,
  circle: 6,
  square: 6,
  default: 6
}, KB = "step", cd = "gradient", nq = {
  size: "getSize",
  shape: "getShape",
  color: "getColor"
}, Ds = "top", nn = "left", xs = "right", Hn = "bottom", _e = "horizontal", Qi = "vertical", Jl = "center", $A = "value", sq = "path", cg = "shape", Kl = "rect", Aq = "start", oq = "end", ji = "size", VB = "discrete", aq = "default", rq = "color", gg = "circle", AC = "square", lq = "outline", gd = "continuous", cq = "visibility", gq = {
  [nn]: Qi,
  [xs]: Qi,
  [Ds]: _e,
  [Hn]: _e
}, hq = {
  [nn]: xs,
  [xs]: nn
}, dq = "margin", iN = "padding", uq = "display", nN = "max-width", fq = "padding-right", Iq = "flex", Cq = "align-items", WB = 34, ay = 140, ry = 140, oC = 70, Eq = 70, Bq = WB, mq = WB, pq = 0.25, sN = 30 * 4, Qq = WB, yq = 0.3, hd = 32, wq = 24, Dq = 5, xq = "WW", aC = "WWWWWWWWWW", Sq = "WWWWWWW", _q = 5, bq = "-legend-pagination-handle", Mq = "-legend-title-text", Nq = "-legend-item-info-text", Fq = JB + "-legend-prop-float-left", Vg = 5, Rq = 0.15, kq = 5, bf = 2, vq = 3, il = 5, Tq = 0.15, Wg = "binned", Gq = (e) => (t) => {
  const i = function() {
    const n = bt(), A = X(n.currentTarget).node(), o = e.context, { classPrefix: a } = o.config(), r = A.classList?.[0] || null, c = {
      showTooltip: !0,
      tooltipText: null,
      tooltipAnchorBox: Rn(A)
    };
    switch (r) {
      case `${a}${Nq}`:
      case `${a}${Mq}`:
      case `${a}-step-second-tick`:
      case `${a}-step-first-tick`:
        A.offsetWidth < A.scrollWidth && (c.tooltipText = A.innerText, e.triggerPhysicalAction(od, c));
        break;
    }
  };
  t.on("mouseover", i).on("mousemove", i).on("mouseout", () => {
    const n = bt();
    e.triggerPhysicalAction(od, {
      showTooltip: !1
    }), n.stopPropagation();
  });
}, Lq = (e) => (t) => {
  const i = function(n) {
    const s = bt(), A = e.context.getCriteriaFromData(n);
    e.triggerPhysicalAction(ad, {
      showTooltip: !0,
      isStepLegend: !0,
      event: s,
      firebolt: e
    }), e.triggerPhysicalAction("hover", {
      criteria: {
        dimensions: A
      },
      fields: Object.keys(A)
    });
  };
  t.on("mouseover", i).on("mousemove", i).on("mouseout", () => {
    const n = bt();
    e.triggerPhysicalAction(ad, {
      showTooltip: !1,
      isStepLegend: !0
    }), n.stopPropagation();
  });
}, Uq = {
  [q7]: Z7,
  [j7]: tq,
  [z7]: eq,
  [od]: Gq,
  [ad]: Lq
}, ly = (e, t, i) => {
  let n = [];
  const { axisScale: s, axisType: A } = t, { startPos: o, endPos: a, selectionBoxMeasure: r, drawingInfMeasure: l, offset: c } = i, g = e[A];
  return o[A] === a[A] ? n = [] : g + r >= l + c ? n = [
    s.invert(l + c - r),
    s.invert(l + c)
  ] : g - c < c ? n = [
    s.invert(c * 2),
    s.invert(r + c * 2)
  ] : n = [
    s.invert(g),
    s.invert(g + r)
  ], A === "x" || n.reverse(), n;
}, Hq = (e) => (t, i) => {
  let n = {}, s, A, o, a, r, l;
  const c = {}, g = hr(), h = e.context;
  let d = {};
  t.call(
    g().on("start", function() {
      const u = bt();
      n = _h(this, u.sourceEvent), d = u.subject, r = h.axis().source().scale(), l = h.config().align === _e ? "x" : "y", A = h.measurement().gradientDimensions[l === "x" ? Ve : ai], o = r.range()[l === "x" ? 0 : 1], a = {
        drawingInfMeasure: A,
        offset: o
      };
    }).on("drag", () => {
      const u = bt(), f = d[l === "x" ? Ve : ai];
      d.x += u.dx, d.y += u.dy, a.selectionBoxMeasure = f, a.startPos = n, a.endPos = c;
      const C = ly(
        d,
        { axisScale: r, axisType: l },
        a
      );
      s = {
        criteria: {
          range: {
            [h.fieldName()]: C
          }
        },
        fadeOut: !0
      }, e.dispatchBehaviour(i[0], s);
    }).on("end", () => {
      const u = bt(), f = d[l === "x" ? Ve : ai];
      a.selectionBoxMeasure = f, a.startPos = n, a.endPos = c;
      const C = ly(
        u,
        { axisScale: r, axisType: l },
        a
      );
      s = {
        criteria: {
          range: {
            [h.fieldName()]: C
          }
        },
        fadeOut: !0,
        config: {
          transition: {
            duration: 200
          }
        }
      }, e.dispatchBehaviour(i[0], s);
    })
  );
}, wo = {
  HORIZONTAL: "horizontal",
  VERTICAL: "vertical"
}, Oq = {
  height: 30,
  width: 30,
  maxWidth: 1 / 0,
  maxHeight: 1 / 0,
  padding: 2,
  margin: 2,
  marginHorizontal: 3,
  paddingRight: 4,
  border: 1
}, Pq = {
  text: "",
  orientation: (e) => e === nn || e === xs ? nn : Jl,
  style: {
    "font-size": "14px",
    "font-family": '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif',
    "font-weight": "600",
    "font-style": "normal",
    "font-variant": "tabular-nums"
  }
}, qB = {
  buffer: {
    [wo.HORIZONTAL]: 10,
    [wo.VERTICAL]: 10
  },
  classPrefix: "muze",
  borderStyle: "solid",
  borderColor: "rgba(0,0,0,0)",
  formatter: {
    bounds: {
      lower: "less than",
      upper: "more than"
    }
  },
  marker: {
    text: {
      // @TODO: font-variant returns wrong text width the second time
      // @TODO: multiple font-family types specified were not getting applied, so only "Source Sans Pro" is kept
      formatter: (e) => e.formattedValue,
      style: {
        "font-size": "12px",
        "font-family": '"Source Sans Pro"',
        "font-weight": "400",
        "font-style": "normal"
        // "font-variant": "tabular-nums",
      }
    }
  },
  item: {
    text: {
      orientation: "right",
      width: 10,
      formatter: (e) => e.formattedValue,
      style: {
        "font-size": "12px",
        "font-family": '"Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif',
        "font-weight": "400",
        "font-style": "normal",
        "font-variant": "tabular-nums"
      }
    },
    icon: {
      className: "legend-icon",
      height: 20,
      width: 20,
      color: "rgba(192,192,192,0.6)",
      type: "square"
    }
  },
  transition: {
    disabled: !0
  }
  // stops: 5,
}, Yq = et({}, qB, {
  buffer: {
    [wo.HORIZONTAL]: 0
  },
  step: !0
}), Jq = (e) => e && typeof e == "string" ? cc(e) : e, XA = {
  size: 8,
  BUFFER: 4,
  ROTATE_HORIZONTAL: 180,
  shape: "triangle"
};
class Kq extends Ir {
  constructor(...t) {
    super(...t), this._graphicElems = {
      rect: null
    };
  }
  static formalName() {
    return tN;
  }
  /**
   * It returns the default configuration needed by selectionbox.
   * @return {Object} Default configuration of the selection box.
   */
  static defaultConfig() {
    return {
      className: "legend-selection-box",
      classPrefix: JB
    };
  }
  static target() {
    return "all";
  }
  /**
   * Draws the selectionbox with the specified dimensions.
   */
  /* istanbul ignore next */
  apply(t, i) {
    let n, s, A, o;
    const a = this.firebolt, r = a.context, l = this.config(), c = r.axis().source(), g = `${l.classPrefix}-${l.className}`, { criteria: h } = i, { rect: d } = this._graphicElems;
    if (h === null)
      return d && d.remove(), this;
    const { range: u } = h, f = u[a.context.fieldName()], C = c.scale(), I = f ? [c.getScaleValue(f[0]), c.getScaleValue(f[1])] : [], E = r.config().align === _e ? "x" : "y", B = a.context.measurement().gradientDimensions[E === "x" ? ai : Ve], m = C.range()[E === "x" ? 0 : 1], p = r.getDrawingContext().svgContainer, w = z(
      p,
      "g",
      [1],
      `${l.classPrefix}-selection-box-group`
    ), { size: Q, BUFFER: y } = XA;
    a.context.config().align === _e ? (n = I[0] - m || 0, s = Q + y, A = I[1] - I[0] || 0, o = B) : (n = Q + y, s = I[1] - m || 0, o = I[0] - I[1] || 0, A = B);
    const _ = z(
      w,
      Kl,
      [{ domain: f, x: n, y: s, width: A, height: o }],
      g,
      { enter: function(x) {
        Hq(a)(x, ["brush"]);
      } }
    );
    return _.attr("y", s).attr("x", n).attr(Ve, A).attr(ai, o), this._graphicElems.rect = _, this;
  }
}
class Vq extends pe {
  constructor(...t) {
    super(...t), this._styles = /* @__PURE__ */ new Map();
  }
  static formalName() {
    return "legend-highlighter";
  }
  apply(t, i, { rules: n }) {
    const s = (o) => {
      let a;
      return o instanceof Function ? a = o(
        {
          payload: i,
          entryExitSet: t
        },
        this.firebolt
      ) : typeof o == "string" && (a = o === "entrySet" ? t.entrySet : t.exitSet), a;
    };
    [
      ...n,
      {
        target: "entrySet",
        className: "muze-legend-item-hover"
      }
    ].forEach((o, a) => {
      const r = s(o.target);
      if (!r)
        return;
      const l = `${i.action}-${a}`;
      if (i.criteria === null)
        this.applyInteractionStyle(t.completeSet, {
          apply: !1,
          interactionType: l,
          className: o.className,
          style: o.style
        }), this._styles.delete(l);
      else {
        const c = {
          apply: !0,
          interactionType: l,
          className: o.className,
          style: o.style
        }, g = this._styles.get(l);
        g && this.applyInteractionStyle(
          {
            uids: qd(g.targetSet.uids, r.uids)
          },
          { ...g.config, apply: !1 }
        ), this.applyInteractionStyle(r, c), this._styles.set(l, {
          targetSet: r,
          config: c
        });
      }
    });
  }
}
const Ss = (e) => {
  const t = e.constructor.type(), i = e.uniqueValues(), n = e.config(), s = n.stops, A = nq[t];
  return { scaleType: t, domain: i, steps: s, scaleFn: A, as: n.as };
}, Wq = (e, t, i, n) => {
  let s, A;
  const o = n[n.length - 1], a = e.measureParam, r = e.smartLabelCalc, l = i[a] / o;
  if (i[a] >= t[a])
    return n;
  s = r.getOriSize(n[0])[a];
  for (let c = 1; c < n.length - 1; c++)
    A = Math.floor(
      s / l + n[c - 1]
    ), n[c] < A && (n.splice(c, 1), c -= 1), s = r.getOriSize(n[c])[a];
  return n;
}, qq = (e, t) => {
  let i, n, s, A = e[e.length - 1], o = Math.ceil(e[1] - e[0]);
  const a = Math.ceil(A - e[0]), { alignment: r } = t, l = t.smartLabel, c = t.measures, g = t.minTickDistance, { height: h, width: d } = l.getOriSize(A);
  return Number.isInteger(A) || (A = A.toFixed(2)), o = o < 1 ? 1 : o, n = Math.abs(a) / Math.abs(o) * (d + g.width), n -= Math.abs(a), s = Math.abs(a) / Math.abs(o) * h, s -= Math.abs(a), r === Ds || r === Hn ? i = Ve : i = ai, e = Wq(
    {
      smartLabelCalc: l,
      measureParam: i
    },
    {
      height: s,
      width: n
    },
    {
      height: c.maxHeight,
      width: c.maxWidth
    },
    e
  ), e;
}, jq = (e, t, i) => {
  let n = 0;
  const s = i.smartLabel, { maxWidth: A, maxHeight: o } = i.measures, { alignment: a } = i, r = s.getOriSize(e[1].toFixed(2));
  return t = Math.round(t), t = t < 1 ? t + 1 : t, a === Ds || a === Hn ? n = Math.floor(A / r.width) : n = Math.floor(o / r.height), t = Math.min(t, n), rr(e, t);
}, zq = (e, t, i, n, s) => {
  const { border: A, padding: o } = n, { align: a, buffer: r } = s, l = e.labelManager();
  l.setStyle(i.style);
  const c = z(
    t,
    "div",
    [1],
    `${s.classPrefix}-legend-title`
  ), g = i.max_width;
  if (s.title && s.title.show === !1) {
    a === _e ? c.style(Ve, `${g}px`) : c.remove();
    return;
  }
  return a === Qi ? c.style(
    "border-bottom",
    `${A}px ${s.borderStyle} ${s.borderColor}`
  ) : c.style(fq, `${r[_e]}px`), l.useEllipsesOnOverflow(!0), c.style(Ve, `${g}px`).style(ai, "auto"), c.style(
    "text-align",
    i.orientation instanceof Function ? i.orientation(s.position) : i.orientation
  ), l.setStyle(e._computedStyle), z(
    c,
    "div",
    [i],
    `${s.classPrefix}-legend-title-text`
  ).style("padding", `${o}px`).text(i.text).style("text-align", "left").style("white-space", "nowrap").style("overflow", "hidden").style("text-overflow", "ellipsis").style("line-height", "100%").node();
}, AN = (e) => {
  const t = [], i = e.data(), n = e._labelManager;
  return i.forEach((s, A) => {
    const { height: o, width: a } = n.getOriSize(s.formattedValue);
    t[A] = { height: o, width: a };
  }), t;
}, $q = (e, t, i) => {
  let n = 0, s = 0, A = {
    width: 0,
    height: 0
  };
  const {
    effPadding: o,
    titleWidth: a,
    labelSpaces: r,
    titleHeight: l,
    maxWidth: c,
    maxHeight: g
  } = t, h = o, { item: d, align: u } = e, { icon: f, text: C } = d, I = C.orientation, E = [], B = [];
  let m = 0;
  return r.forEach((p, w) => {
    const Q = { width: 0, height: 0 }, y = { width: 0, height: 0 }, D = i[w] || {};
    I === nn || I === xs ? (p.width += o, y.width = (D.size ? 2 * D.size : f.width) + o, m = Math.max(y.width, m), Q.width = p.width + m, p.height = Math.max(p.height, f.height) + o, y.height = p.height, Q.height = p.height) : (p.width = Math.max(p.width, D.size ? 2 * D.size : f.width) + o, y.width = p.width, Q.width = p.width, m = Math.max(y.width, m), p.height += o, y.height = f.height + o, Q.height = p.height + y.height), u === "horizontal" ? n = Math.max(n, Q.height) : (n += Q.height, s = Math.max(s, Q.width)), A = {
      width: Math.max(Q.width, A.width),
      height: Math.max(Q.height, A.height)
    }, E.push(Q), B.push(y);
  }), E.forEach((p, w) => {
    if (u === "horizontal")
      p.height = n, I === nn || I === xs ? (r[w].height = n, B[w].height = n, E[w].width = r[w].width + B[w].width + 2 * o) : (r[w].width = B[w].width, E[w].width = B[w].width, r[w].width = B[w].width), s += E[w].width;
    else if (I === Ds || I === Hn)
      r[w].width = s, B[w].width = s, m = s;
    else {
      const Q = r[w].width, y = A.width - m;
      B[w].width = m, E[w].width = Q + m, r[w].width = Math.max(Q, y), s = Math.max(s, p.width);
    }
  }), u === Qi ? (s = Math.ceil(Math.max(s, a)) + o + h, n += l + o + h) : (s = Math.ceil(a) + Math.ceil(s) + o + h, n += o + h), u === "horizontal" ? s = s > c ? c : s : n = n > g ? g : n, n = Math.ceil(n), s = Math.ceil(s), {
    totalHeight: n,
    totalWidth: s,
    itemSpaces: E,
    iconSpaces: B,
    maxItemSpaces: A,
    maxIconWidth: m
  };
}, Xq = (e) => {
  let t = 0, i = 0;
  const n = e.logicalSpace(), s = e.config(), { orientation: A, xOffset: o, yOffset: a } = s;
  A === Ze && (t = o === void 0 ? n.width : o), A === Se && (i = a === void 0 ? n.height : a), e.renderConfig({ xOffset: t, yOffset: i });
}, Zq = (e, t, i, n) => {
  let s = 0, A = [], { numberOfTicks: o } = n.config();
  const r = i.scale().ticks().length, l = n._minTickDistance.width;
  return s = r, r * (t + l) > e && (s = Math.floor(e / (t + l))), o = o || s, s = Math.min(
    o,
    Math.max(Mh, s)
  ), A = i.scale().ticks(s), A.length > s && (A = A.filter((c, g) => c === 0 ? !0 : g % 2 === 0)), s === Mh && (A = i.scale().ticks(KS), A = [A[0], A[A.length - 1]]), A;
}, tj = (e, t, i) => {
  let n, s;
  const A = e.domain(), o = e._minTickDistance.width, { tickSize: a, tickDimensions: r, axisNameDimensions: l } = t, { axisNamePadding: c } = e.config(), g = e.getTickValues(), { showAxisName: h } = e.renderConfig(), { height: d } = l, { height: u, width: f } = r;
  if (n = i && i.length ? i[1] - i[0] : (f + o) * 3, s = 0, g) {
    const C = e.getMinTickDifference(), [I, E] = [
      Math.min(...g, ...A),
      Math.max(...g, ...A)
    ];
    n = (E - I) / Math.abs(C) * (f + e._minTickDistance.width);
  }
  return !i || !i.length ? s = Math.max(f, u) : s = u, s += (h ? d + c : 0) + a, {
    width: n,
    height: s
  };
}, ej = (e, t) => {
  let i, n;
  const s = e.domain(), { tickSize: A, tickDimensions: o, axisNameDimensions: a } = t, { axisNamePadding: r } = e.config(), l = e.getTickValues(), { showAxisName: c } = e.renderConfig(), { height: g } = a, { height: h, width: d } = o;
  if (i = 0, n = d, l) {
    const u = e.getMinTickDifference(), [f, C] = [
      Math.min(...l, ...s),
      Math.max(...l, ...s)
    ];
    i = (C - f) / Math.abs(u) * h;
  }
  return n += (c ? g + 8 : 0) + A + (l ? r : 0), {
    height: i,
    width: n
  };
}, ij = (e) => {
  const t = e.range(), i = e.getAxisDimensions(), { orientation: n } = e.config(), { show: s, showAxisName: A } = e.renderConfig(), { axisNameDimensions: o } = i;
  if (s === !1)
    return {
      width: 0,
      height: 0
    };
  const { width: a } = o;
  if (n === Se || n === Ke) {
    const { width: g, height: h } = tj(
      e,
      i,
      t
    );
    return {
      width: Math.max(g, a),
      height: h
    };
  }
  const { width: r, height: l } = ej(
    e,
    i
  ), c = Math.max(l, A ? a : 0);
  return {
    width: r,
    height: c
  };
};
class nj extends Ln {
  constructor(t, i) {
    super(t, i);
  }
  getTickValues() {
    let t = 0;
    const { orientation: i } = this.config();
    let n = this.renderConfig().tickValues || this.scale().ticks();
    const s = this.range(), A = this.axis(), o = Math.abs(s[0] - s[1]), a = this.axisComponentDimensions().largestTickDimensions;
    return n || (t = a[i === Ke || i === Se ? "width" : "height"], n = Zq(o, t, A, this)), this.availableSpace() ? h_(this, n) : n;
  }
  getMinTickDifference() {
    const t = this.getTickValues();
    return Vd(t);
  }
  getLogicalSpace() {
    return this.logicalSpace() || this.logicalSpace(ij(this)), Xq(this), this.logicalSpace();
  }
}
const oN = (e) => typeof e[0].value == "number" ? e.reduce(
  (t, i) => [
    Math.min(i.value, t[0]),
    Math.max(i.value, t[1])
  ],
  [Number.MAX_VALUE, Number.MIN_VALUE]
) : e.map((t) => t.value), sj = (e) => {
  const t = e.axis(), i = e.scale(), n = i.getScaleRange();
  let s = [];
  if (n.length > 2)
    s = i.domain();
  else {
    const o = t.source().domain(), r = [...e.data().map((l) => l.value)];
    r.unshift(+o[0]), r.push(+o[1]), s = [...new Set(r)].sort((l, c) => l - c);
  }
  const A = s.map((o) => ({
    value: o
  }));
  return A.forEach((o, a) => o.id = a), A;
}, Aj = (e, t) => {
  const i = e.scale(), n = i.domain(), { scaleFn: s } = Ss(i), A = Math.min(...n), o = Math.max(...n);
  return t.map((a) => ({
    ...a,
    color: i[s](
      a.value > o ? o : a.value < A ? A : a.value
    )
  }));
}, oj = (e, t, i) => {
  const n = sj(e), s = oN(n), A = Aj(e, n), o = z(t, "defs", [1]), a = z(o, "linearGradient", [1]).attr("id", `linear-gradient-${i}`).attr("x1", "0%").attr("y2", "0%");
  return z(a, "stop", A, "stop-gradient").attr(
    "offset",
    (r) => `${(r.value - s[0]) * 100 / (s[1] - s[0]) || 1}%`
  ).attr("stop-color", (r) => r.color), a;
}, aj = (e) => {
  const t = e.fieldName(), i = e.metaData(), { subtype: n } = i.getField(t).schema(), s = e.data(), { useUTC: A } = e.config(), o = e._cells.AxisCell, { domain: a, stops: r } = e.config(), l = !!(Array.isArray(a) && a.length), c = !!(Array.isArray(r) && r.length), g = n === K.FieldSubtype.TEMPORAL ? fr : nj, h = new g(
    {
      id: `legend-${e._id}`,
      // orientation: align === ALIGN.VERTICAL ? BOTTOM : LEFT,
      // The ticks are at bottom for vertical gradient legend
      orientation: Hn,
      style: e._computedStyle,
      nice: !(l || c),
      showAxisName: !1,
      tickSize: 0,
      fixedBaseline: !1,
      labels: {
        rotation: null
      },
      tickFormat: (d, u) => {
        const f = e.metaData(), C = e.fieldName(), I = f.getField(C), E = aN(
          d.rawValue,
          I,
          {
            useUTC: e.config().useUTC,
            useShortFormatter: !0
          }
        );
        return e.config().item.text.formatter(
          {
            formattedValue: E,
            rawValue: d.rawValue
          },
          {
            context: e,
            itemMeta: {},
            itemIndex: u.tickIndex,
            allItems: u.allRawTicks,
            dataModel: e.metaData()
          }
        );
      },
      useUTC: A,
      transition: e.config().transition
    },
    { labelManager: e._labelManager }
  );
  return l ? h.domain(a) : h.domain(oN(s)), n === K.FieldSubtype.TEMPORAL ? (h.minDiff(
    i.getField(t).minimumConsecutiveDifference()
  ), h.logicalSpace(eB(h, !0)), Ic(h)) : h.range([1, 1]), new o().source(h).config({
    margin: { left: 0, bottom: 0, top: 0, right: 0 }
  });
}, rj = (e) => {
  const t = e.fieldName(), i = e.metaData(), { subtype: n } = i.getField(t).schema(), s = e.axis().source(), { _tickFormatter: A } = s, o = s.domain(), a = (+o[0] + +o[1]) / 2;
  let r = [o[0], a, o[1]];
  n === K.FieldSubtype.TEMPORAL && (r = r.map((g) => /* @__PURE__ */ new Date(+g)));
  const l = A(r);
  return r.map((g) => l(g));
};
function aN(e, t, i) {
  const { subtype: n } = t.schema();
  let s;
  return n === K.FieldSubtype.TEMPORAL ? s = pA(
    e,
    t.minimumConsecutiveDifference(),
    {
      useUTC: i.useUTC,
      useShortFormatter: i.useShortFormatter
    }
  ) : s = e, Zi(s);
}
const lj = (e, t, i, n) => {
  const { align: s } = e.config(), { padding: A } = e.measurement(), o = rj(e), a = e.fieldName(), r = e.metaData(), { subtype: l } = r.getField(a).schema(), c = z(
    t,
    "div",
    [1],
    `${i}-legend-body`
  );
  let g, h, d, u, f;
  if (s === wo.HORIZONTAL) {
    let p = (e.mount().style.width.replace("px", "") - 2 * A) / 2 * Rq;
    p += 2 * kq, g = z(
      c,
      "div",
      [1],
      `${i}-gradient-ticks`
    ), d = z(
      g,
      "div",
      [1],
      `${i}-gradient-first-tick`
    ), d.text(o[0]).style("padding", "5px").style("max-width", `${p}px`).style("text-align", "right"), h = z(
      g,
      "svg",
      [1],
      `${i}-gradient`
    ), u = z(
      g,
      "div",
      [1],
      `${i}-gradient-second-tick`
    ), u.text(o[2]), u.style("padding", "5px"), u.style("max-width", `${p}px`);
  } else if (h = z(
    c,
    "svg",
    [1],
    `${i}-gradient`
  ), g = z(
    c,
    "div",
    [1],
    `${i}-gradient-ticks`
  ), g.style("justify-content", "space-between"), d = z(
    g,
    "div",
    [1],
    `${i}-gradient-first-tick`
  ), d.text(o[0]), d.style("padding", "5px 0"), l !== K.FieldSubtype.TEMPORAL && (u = z(
    g,
    "div",
    [1],
    `${i}-gradient-second-tick`
  ), u.text(o[1]), u.style("padding", "5px 0")), f = z(
    g,
    "div",
    [1],
    `${i}-gradient-third-tick`
  ), f.text(o[2]), f.style("padding", "5px 0"), l !== K.FieldSubtype.TEMPORAL) {
    const { width: B } = e.labelManager().getOriSize(o[0]), { width: m } = e.labelManager().getOriSize(o[1]), { width: p } = e.labelManager().getOriSize(o[2]), w = g.style("width").replace("px", "");
    B + 10 + m + 10 + p > w && u.style("display", "none");
  }
  [d, u, f].forEach((B) => {
    B && B.classed(`${i}-gradient-tick`, !0);
  }), g.style("display", "flex"), g.style("align-items", "center");
  const C = z(
    h,
    "g",
    [1],
    `${i}-gradient-group`
  ), I = oj(e, h, n), E = z(
    C,
    "rect",
    [1],
    `${i}-gradient-rect`
  );
  return {
    legendContainer: c,
    legendTicksContainer: g,
    legendGradCont: C,
    legendGradSvg: h,
    linearGradient: I,
    legendRect: E
  };
}, cy = (e, t, i, n) => {
  const s = e.axis();
  s.setAvailableSpace(n, i), s.render(t.node());
}, cj = (e, t) => {
  const { align: i, classPrefix: n, item: s } = e.config(), { legendContainer: A, legendGradSvg: o, linearGradient: a, legendRect: r } = lj(e, t, n, e._id), {
    padding: l,
    margin: c,
    border: g,
    titleSpaces: h,
    maxItemSpaces: d,
    maxHeight: u,
    maxWidth: f,
    height: C,
    width: I
  } = e.measurement(), E = {}, B = Math.floor(
    Math.min(C, u) - (h.height + 2 * c + 2 * g)
  ), m = Math.floor(
    Math.min(I, f) - (c * 2 + g * 2)
  );
  if (i === wo.HORIZONTAL) {
    const w = m - 2 * l, Q = e.mount().style.width.replace("px", "") - 2 * l;
    E.height = s.icon.height, E.width = w, a.attr("x2", "100%").attr("y1", "0%"), e._legendContainer.style.flexDirection = "row", e._legendContainer.style.alignItems = "center";
    const y = parseFloat(A.style("width"));
    cy(
      e,
      A,
      B - s.icon.height - l,
      y
    ), Ji(A, {
      // height: `${maxItemSpaces.height - 2 * border - 2 * padding}px`,
      // width: `${parentWidth}px`,
      padding: `${l}px`,
      display: "flex"
    });
    const D = Q;
    r.attr("height", s.icon.height), r.attr("width", Math.ceil(D / 2));
    const _ = s.icon.height;
    Ji(o, {
      height: `${_}px`
      // width: `${legendGradSvgWidth}px`,
    }), o.attr("height", _), o.attr("width", Math.ceil(D / 2));
  } else {
    const w = m - 2 * l, Q = e.mount().style.width.replace("px", "") - 2 * l;
    E.height = s.icon.height, E.width = w, a.attr("x2", "100%").attr("y1", "0%"), e._legendContainer.style.flexDirection = "column", cy(
      e,
      A,
      B - s.icon.height - l,
      Q
    ), Ji(A, {
      height: `${d.height + g + l}px`,
      // width: `${parentWidth}px`,
      padding: `${l}px`,
      margin: "5px 0"
    });
    const y = Q;
    r.attr("height", s.icon.height), r.attr("width", y);
    const D = s.icon.height;
    Ji(o, {
      height: `${D}px`,
      width: `${y}px`
    });
  }
  const p = A.select(`.${n}-axis-cell`);
  return Ji(p, {
    display: "none",
    width: "100%"
  }), Ji(r, {
    fill: `url(#linear-gradient-${e._id})`,
    width: "100%"
  }), e.measurement({
    gradientDimensions: E
  }), e._legendGradientSvg = o, e;
}, gj = Math.sqrt(3) * 3, gy = 1, hy = 10, Mf = 6, hj = (e, t, i) => {
  const { TextCell: n } = i, s = new n(
    {
      type: "text",
      className: `${e}-text`
    },
    {
      labelManager: t()
    }
  ).config({ maxLines: 1, padding: 0 });
  return s._minTickDiff = { height: 0, width: 0 }, s;
}, dj = (e, t) => ({
  top: t.getBoundingClientRect().top - e.getBoundingClientRect().top,
  left: t.getBoundingClientRect().left - e.getBoundingClientRect().left
});
class uj extends yu {
  constructor(...t) {
    super(...t), this._graphicElements = {
      legendMarkerGroup: null,
      legendMarkerElement: null,
      markerElement: null,
      legendMarkerTextContainer: null,
      legendMarkerText: null
    };
  }
  static formalName() {
    return YB;
  }
  /**
   * It returns the default configuration needed by legend-marker.
   * @return {Object} Default configuration of the legend-marker.
   */
  static defaultConfig() {
    return {
      className: "legend-marker",
      classPrefix: JB,
      size: XA.size,
      shape: XA.shape
    };
  }
  apply(t, i) {
    const n = `${this.config().classPrefix}-${this.config().className}`, s = this.firebolt.context.config().splitFieldInfo, A = i.targetData && i.targetData[0].findIndex(
      (o) => o === s.field
    );
    if (i.criteria && // !payload.criteria.dimensions.some((arr) =>
    //   arr.some((d) => DataStore.isInvalid(d))
    // ) &&
    i.targetData && i.targetData[0].some((o) => o === this.firebolt.context.fieldName()) && i.targetData[1][A] === s.value) {
      const o = this.firebolt, a = o.context.labelManager, r = o.context, l = o.context.config(), c = o.context.scale(), { formatter: g } = l.marker.text, h = this.config(), d = r.axis().source(), u = r.metaData(), f = c.domain(), C = r.fieldName(), I = u.getField(C), { subtype: E } = I.schema(), B = i.metaData, m = B?.layersInfo?.find(
        (at) => at.id() === i.layerId
      );
      if (!B.includeTotalDomain && m && vx(
        {
          axes: m.axes(),
          totalsAxis: m.metaInf().totalsAxis
        },
        i.targetData[1].some(
          (at) => at === m.metaInf().rowTotalString || m.metaInf().colTotalString
        )
      ))
        return;
      let p = i.targetData[0].findIndex(
        (at) => at === C
      ), w = null;
      if (p !== -1 && (w = parseFloat(i.targetData[1][p])), Number.isNaN(w))
        return;
      const Q = r.scale(), { scaleFn: y } = Ss(Q), D = Q[y](w), _ = r.getDrawingContext().svgContainer, { width: x, height: S } = _.node().getBoundingClientRect(), b = E === "temporal" ? w : +w.toFixed(1), R = l.fields && l.fields[C]?.marker?.text?.formatter ? w : b;
      let G, T = vq;
      R > f[f.length - 1] ? (G = f[f.length - 1], T = 1) : R < f[0] ? (G = f[0], T = 1) : G = R;
      const v = f.length > 2 && r.config().step ? Rx(
        [T, x - T],
        f.length
      ) : [T, x - T];
      d.range(v);
      const H = d.getScaleValue(G), N = {
        top: 0,
        left: 0
      }, M = r.mount(), { top: F, left: k } = dj(
        M,
        _.node()
      ), O = g(
        {
          formattedValue: aN(R, I, {
            useUTC: r.config().useUTC,
            useShortFormatter: !0
          }),
          rawValue: R
        },
        {
          context: r,
          domain: f,
          dataModel: u
        }
      );
      a().setStyle(r.config().marker.text.style);
      const { oriTextWidth: P } = a().getSmartText(O);
      let L, q, $;
      const { size: W } = h, { align: U, position: J } = r.config();
      L = H - Math.sqrt(W / gj) + gy, q = 5, $ = XA.ROTATE_HORIZONTAL + XA.ROTATE_HORIZONTAL, N.top = F + q + 2 * hy;
      const V = P + Mf, Y = L + k + Mf, nt = L + k - P - Mf;
      U === _e || J === nn ? L < V ? N.left = Y : N.left = nt : L < V ? x - L < V ? N.left = nt : N.left = Y : N.left = nt, this._graphicElements.legendMarkerTextContainer || (this._graphicElements.legendMarkerTextContainer = z(
        M,
        "div",
        [1],
        `${n}-text-container`
      ), this._graphicElements.legendMarkerTextContainer.style("position", "absolute").style("left", "0px").style("top", "0px").style("width", "100%").style("height", "100%").style("z-index", "999"), this._graphicElements.legendMarkerText = z(
        this._graphicElements.legendMarkerTextContainer,
        "div",
        [1],
        `${n}-text-${this.firebolt.id()}`
      ), this._graphicElements.legendMarkerGroup = z(
        this._graphicElements.legendMarkerTextContainer,
        "svg",
        [1],
        `${n}-group-${this.firebolt.id()}`
      ), this._graphicElements.legendMarkerGroup.attr(
        "class",
        `${n}-group ${n}-group-${this.firebolt.id()}`
      ), this._graphicElements.legendMarkerElement = z(
        this._graphicElements.legendMarkerGroup,
        "g",
        [1],
        `${n}-element`
      )), this._graphicElements.legendMarkerGroup.style("position", "absolute").style("top", `${F - bf / 2}px`).style("left", `${k}px`).style("width", `${x}px`).style(
        "height",
        `${S + bf}px`
      ), this._graphicElements.markerElement || (this._graphicElements.markerElement = z(
        this._graphicElements.legendMarkerElement,
        "path",
        [{ value: null }],
        n
      ));
      const tt = hj(
        n,
        a,
        r._cells
      );
      this._graphicElements.markerElement.data([{ value: i.criteria }]).attr("transform", `translate(${L},0) rotate(${$})`).attr(
        "d",
        `M 0,0 v ${S + bf}`
      ).classed(`${n}-show`, !0).classed(`${n}-hide`, !1);
      const st = CA(D).rgb(), lt = 0.2126 * (st.r / 255) + 0.7152 * (st.g / 255) + 0.0722 * (st.b / 255);
      this._graphicElements.markerElement.style("stroke-width", "2px"), lt <= 0.5 ? (this._graphicElements.markerElement.style("stroke", "white"), this._graphicElements.legendMarkerText.attr(
        "class",
        `${n}-text ${n}-text-secondary ${n}-text-${this.firebolt.id()}`
      )) : (this._graphicElements.markerElement.style("stroke", "black"), this._graphicElements.legendMarkerText.attr(
        "class",
        `${n}-text ${n}-text-${this.firebolt.id()}`
      )), tt.source(O), tt.render(this._graphicElements.legendMarkerText.node()), this._graphicElements.legendMarkerText.style("top", `${N.top - 4 * hy + gy}px`).style("left", `${N.left}px`), this._graphicElements.legendMarkerTextContainer.classed(`${n}-show`, !0).classed(`${n}-hide`, !1), this._graphicElements.legendMarkerText.classed(`${n}-show`, !0).classed(`${n}-hide`, !1), this._graphicElements.legendMarkerGroup.classed(`${n}-show`, !0).classed(`${n}-hide`, !1);
    } else this._graphicElements.legendMarkerText && this._graphicElements.legendMarkerGroup && this._graphicElements.markerElement && (this._graphicElements.legendMarkerTextContainer.classed(`${n}-show`, !1).classed(`${n}-hide`, !0), this._graphicElements.legendMarkerText.classed(`${n}-show`, !1).classed(`${n}-hide`, !0), this._graphicElements.legendMarkerGroup.classed(`${n}-show`, !1).classed(`${n}-hide`, !0), this._graphicElements.markerElement.data([{ value: null }]).classed(`${n}-show`, !1).classed(`${n}-hide`, !0));
  }
}
class fj extends pe {
  constructor(...t) {
    super(...t);
  }
  static formalName() {
    return nC;
  }
  apply(t, { showTooltip: i, tooltipText: n, tooltipAnchorBox: s, isStepLegend: A }) {
    if (this._tooltipRenderer == null && (this._tooltipRenderer = new nr(document.body, {
      creatorName: [nC]
    }), this._tooltipRenderer.extent({
      x: 0,
      y: 0
    }), this._tooltipRenderer.config({
      content: {
        rowMargin: "0 10px 5px 10px",
        className: this.firebolt.context._className
      }
    })), !i || A) {
      this._tooltipRenderer.hide();
      return;
    }
    const o = n;
    this._tooltipRenderer.content("tooltip", [{ data: [o] }]), this._tooltipRenderer.offset({
      x: 0,
      y: 0
    }), this._tooltipRenderer.positionRelativeTo(s);
  }
}
class Ij extends pe {
  constructor(...t) {
    super(...t), this._outlineElement = null;
  }
  static formalName() {
    return sC;
  }
  apply(t, { showTooltip: i, event: n, firebolt: s }) {
    if (!this._tooltipRenderer) {
      this._tooltipRenderer = new nr(
        document.body,
        {
          creatorName: [sC]
        },
        {
          showPointerArrow: !0
        }
      );
      const u = document.querySelector("html").clientWidth, f = document.querySelector("html").clientHeight;
      this._tooltipRenderer.extent({
        x: 0,
        y: 0,
        width: u,
        height: f
      }), this._tooltipRenderer.config({
        content: {
          rowMargin: "0 10px 5px 10px",
          className: this.firebolt.context._className
        }
      });
    }
    if (!i) {
      this._tooltipRenderer.hide(), this._outlineElement?.style("display", "none");
      return;
    }
    if (!n || !s)
      return;
    const A = X(n.currentTarget), o = A.node(), a = Rn(o), r = s.context.mount(), { classPrefix: l } = s.context.config(), c = A.attr("width"), g = A.attr("x"), h = A.datum();
    if (!this._outlineElement) {
      const u = X(r).select(
        `.${l}-legend-svg-container`
      );
      this._outlineElement = z(
        u,
        "div",
        [1],
        `${l}-step-legend-item-outline`
      ).style("position", "absolute").style("width", `${c}px`).style("height", `${a.height + 2}px`).style("top", "-1px").style("pointer-events", "none").style("border", "1px solid black");
    }
    const d = `Min-Max: ${h?.formattedValue}`;
    this._tooltipRenderer.content("tooltip", [{ data: [d] }]), this._tooltipRenderer.offset({
      x: 0,
      y: 0
    }), this._tooltipRenderer.positionRelativeTo(a, {
      orientation: "vertical",
      priority: "top"
    }), this._outlineElement.style("display", "block").style("left", `${g}px`);
  }
  dispose() {
    this._tooltipRenderer.remove();
  }
}
const Cj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LegendHighlighter: Vq,
  LegendMarker: uj,
  LegendTextTooltip: fj,
  SelectionBox: Kq,
  StepLegendTooltip: Ij
}, Symbol.toStringTag, { value: "Module" }));
class Ej extends xc {
  constructor(...t) {
    super(...t), this._applyChecker = {
      source: () => !0
    };
  }
  static formalName() {
    return Z1;
  }
  setSelectionSet(t, i) {
    if (t === null)
      i.reset();
    else if (t.length) {
      const n = this.context.getPropagationInf(), s = i._entrySet, A = t.filter((o) => s.has(o));
      if (n.sourceId) {
        i.reset(), i.add(t);
        const o = Cs(
          [i.getCompleteSet()],
          [i.getEntrySet()]
        );
        i.remove(o);
      } else {
        if (A.length)
          i.remove(A);
        else if (i.add(t), !i.getExitSetLength()) {
          const a = Cs(
            [i.getCompleteSet()],
            [i.getEntrySet(), i.getExitSet()]
          );
          i.remove(a);
        }
        const o = i.getCompleteSetLength();
        (i.getExitSetLength() === o || i.getEntrySetLength() === o) && i.reset();
      }
    } else
      i.remove(i.getCompleteSet());
    return this;
  }
}
class Bj extends sn {
  static formalName() {
    return rd;
  }
  dispatch(t) {
    return this._payload = t, this;
  }
}
const mj = db, pj = ub, Qj = fb, yj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BrushBehaviour: pj,
  HighlightBehaviour: mj,
  InverseSelectBehaviour: Qj,
  LegendHighlightBehaviour: Bj,
  SelectBehaviour: Ej
}, Symbol.toStringTag, { value: "Module" })), Hr = {
  physicalBehaviouralMap: $7,
  behaviourEffectMap: X7,
  physicalActions: Uq,
  sideEffects: Cj,
  behaviours: yj
}, wj = (e, t) => {
  const i = e.context, n = i.metaData(), s = i.constructor.type(), A = i.fieldName(), o = n.getField(A).type(), a = {}, r = e.actions().behavioural[t], l = r.getSelectionSet(), c = r.getPayload(), g = l.getEntrySet(), h = i.data();
  let d;
  if (c.criteria === null || l.resetted())
    d = {
      identifiers: null
    };
  else if (s === KB || s === VB && o === "measure") {
    const Q = i.data().filter((y) => g.has(y.id)).map((y) => y.range);
    d = {
      identifiers: {
        [A]: Q
      },
      interpolated: !0
    };
  } else if (s === cd) {
    const Q = c.criteria.range;
    d = {
      identifiers: Object.keys(Q).reduce((D, _) => (D[_] = Q[_].map((x) => +x), D), {}),
      interpolated: !0
    };
  } else {
    const Q = [...g].map((y) => K.isInvalid(y) ? null : h[h.findIndex((D) => D.rawVal === y)].rawVal);
    Q.push(...i.config().hiddenDomain), d = {
      fields: Object.keys(c.criteria.dimensions),
      identifiers: Q
    };
  }
  a.sourceAction = t;
  const u = i.config().interaction;
  a.targetActions = Z(u, t, "target"), a.sourceInfo = {
    canvasId: i.canvasAlias(),
    type: "legend"
  }, a.propagationSourceId = e.id();
  const f = Object.assign({}, a, {
    sourceId: e.id(),
    criteria: d.identifiers,
    sourceAction: t,
    interpolated: d.interpolated,
    fields: [A]
  }), C = Object.keys(a.targetActions).some(
    (Q) => Q.filter
  ), I = e._globalContext;
  let E = n.getPropagationQuery(d.identifiers, {
    fields: c.fields,
    interpolated: d.interpolated,
    resolveId: !1,
    type: s,
    domain: e.context.scale().domain()
  });
  if (d.interpolated && s === cd) {
    const Q = e.context.config().splitFieldInfo;
    Q.field && (E = {
      conditions: [
        {
          field: Q.field,
          value: Q.value,
          operator: "eq"
        },
        E
      ],
      operator: "and"
    });
  }
  const B = I.interactionFilters.get(
    e.sourceCanvas()
  ), m = {
    ...B,
    legend: {
      identifiers: E,
      fields: [A]
    }
  };
  let p = !1;
  C && (!B && I.interactionFilters.size && (p = !0), !c.criteria && p ? I.interactionFilters.remove(e.sourceCanvas()) : I.interactionFilters.save((void 0).sourceCanvas(), m));
  const w = [
    {
      criteria: m.legend.identifiers,
      fields: m.legend.fields
    }
  ];
  n.propagate(w, { ...f, resetFilterAction: p });
}, dy = {
  __default: (e, t) => {
    if (e === null)
      return Object.assign({}, t, {
        criteria: null
      });
    const i = e.getData({
      excludeFields: [pt.ROW_ID]
    });
    let n = i.schema;
    const s = Object.assign({}, t);
    n = i.schema;
    const A = i.data, o = n.map((a) => a.name);
    return s.criteria = {
      dimensions: [o, ...A]
    }, s;
  },
  brush: (e, t) => {
    const { criteria: i } = t, n = Object.assign({}, t);
    return n.criteria = i ? { range: i.range } : null, n;
  }
};
class Dj extends Yo {
  constructor(...t) {
    super(...t), this._propagationDms = {}, this.initializeSideEffects(), this._lastInteraction = /* @__PURE__ */ new Map(), this._interactionStates = /* @__PURE__ */ new Map();
  }
  propagate(t, i, n) {
    wj(this, t);
  }
  getAddSetFromCriteria(t) {
    let i, n;
    const s = this.context.constructor.type(), A = this.context.fieldName(), o = this.data().getField(A).type();
    if (t === null)
      return {
        uids: null,
        model: null
      };
    const { dimensions: a } = t;
    if (s === VB && o === "measure")
      i = Object.values(a), n = this.context.data().filter((r) => i.indexOf(r.range) !== -1).map((r) => r.id);
    else if (s === KB)
      i = Object.values(a), n = this.context.data().filter((r) => i.indexOf(r.range) !== -1).map((r) => r.id);
    else if (s === cd)
      n = [];
    else if (i = a, i instanceof Array) {
      n = [], i = i.slice(1, i.length);
      for (let r = 0; r < i.length; r++) {
        const l = i[r];
        n.push(l);
      }
    } else
      i = i[A], n = this.context.data().filter((r) => i.indexOf(r.rawVal) !== -1).map((r) => r.rawVal);
    return {
      uids: n,
      model: null
    };
  }
  onDataModelPropagation() {
    return (t, i) => {
      if (!t && i.propagateDm === !1 && i.criteria !== null && i.sourcePropQuery && (t = this.data().select(i.sourcePropQuery)), this._propagationDms[i.sourceAction] && this._propagationDms[i.sourceAction].dispose(), this._propagationDms[i.sourceAction] = t, !this.context.mount())
        return;
      const A = (dy[i.action] || dy.__default)(t, i), { propagationSourceId: o } = i, a = {
        propagate: !1,
        data: t,
        sourceId: o
      }, r = i.sourceId === this.id(), l = A.action;
      if (!r && Z(i.sourceInfo, "type") !== "legend") {
        if (i.criteria === null && i.resetAllInteractions)
          return this.resetAllInteractions(i), this;
        l === "highlight" && this.dispatchBehaviour(l, A, a);
      }
    };
  }
  dispatchBehaviour(t, i, n, s) {
    i.criteria !== null ? this.saveInteractionState({
      action: t,
      payload: i,
      propagationInf: n,
      forceDispatch: s
    }) : this.removeInteractionState({
      action: t
    }), super.dispatchBehaviour(t, i, n, s), this._saveSerializedInteractionState(this.getSerializedInteractions());
  }
  applyExistingInteractions() {
    this._interactionStates.forEach(
      ({ action: i, payload: n, propagationInf: s, forceDispatch: A }) => {
        const o = this._behaviourEffectMap[i] || [], a = this.getApplicableSideEffects(
          o,
          n,
          s,
          A
        );
        this.actions().behavioural[i].entryExitSet() && this.dispatchSideEffects(
          i,
          { ...n, sideEffects: a },
          s,
          !0
        );
      }
    );
  }
  resetAllInteractions(t) {
    const i = this._lastInteraction, n = [], s = this.context.config().interaction;
    i.forEach(({ behaviour: A, sideEffects: o }, a) => {
      const r = Z(s, A, "target", "layer") || {};
      (A.includes("filter") || r.filter) && !t.resetFilterAction || (this.dispatchBehaviour(
        A,
        {
          criteria: null,
          sideEffects: o,
          sourceInfo: {}
        },
        { propagate: !1 },
        !0
      ), n.push(a));
    }), n.forEach((A) => i.delete(A));
  }
  data() {
    return this.context.metaData();
  }
  id() {
    return `legend-${this.context._id}`;
  }
  sourceCanvas() {
    return this.context.canvasAlias();
  }
  beforeDispatchBehaviour(t) {
    const i = this.context.metaData();
    if (this.shouldResetAllInteractions(t)) {
      const n = this.getEntryExitSet(t);
      if (!Z(n, "entrySet", "length")) {
        const s = [{ criteria: null, fields: [] }];
        i.propagate(s, { criteria: null, resetAllInteractions: !0 });
      }
    }
  }
  onPhysicalActionTrigger(t) {
    const { payload: i, behaviours: n } = t;
    n.forEach((s) => {
      this.beforeDispatchBehaviour(s), this.dispatchBehaviour(s, { ...i, action: s });
    });
  }
  shouldResetAllInteractions(t) {
    return this.getBehaviouralAction(
      t
    ).shouldResetOtherActionsOnTrigger();
  }
  getSerializedInteractions() {
    const { behavioural: t } = this._actions, i = {};
    for (let n in t) {
      const s = t[n];
      if (n !== _u && s.entryExitSet()) {
        let A;
        if (n === X1)
          A = s._payload.criteria;
        else {
          const o = s.getInteractedSet();
          A = o ? {
            dimensions: {
              [this.context.fieldName()]: [...o]
            }
          } : null;
        }
        i[n] = {
          criteria: A,
          fields: s._payload.fields
        };
      }
    }
    return i;
  }
}
const xj = {
  config: {
    sanitization: (e, t) => et(
      {},
      qB,
      e._config || {},
      t
    ),
    onset: (e, t) => {
      const i = e.firebolt(), n = Object.keys(t.interaction).reduce(
        (s, A) => {
          const o = t.interaction[A].sideEffects;
          return s[A] = Object.keys(o).map((a) => ({
            name: a,
            ...o[a]
          })), s;
        },
        {}
      );
      i.mapSideEffects(n);
    }
  },
  data: {
    onset: (e, t) => {
      e.createFireboltSelectionSet({
        data: t,
        prevData: e._prevData
      }), e._prevData = t;
    }
  },
  fieldName: {},
  legendContainer: {},
  measurement: {
    sanitization: (e, t) => {
      const i = et(e._measurement, t);
      return ["padding", "border", "margin"].forEach((n) => {
        i[n] = Math.min(
          i[n] > 0 ? i[n] : 0,
          i.maxWidth * 0.1,
          i.maxHeight * 0.1
        );
      }), i;
    }
  },
  logicalSpace: {},
  metaData: {
    onset: (e, t) => {
      const i = e.firebolt();
      i.attachPropagationListener(t), i.clearInteractionState();
    }
  },
  range: {
    sanitization: (e, t) => (e.scale().range(t), e.resetLogicalSpace(), e.store().commit("range", t), t)
  },
  scale: {},
  smartTicks: {},
  store: {},
  title: {
    sanitization: (e, t) => et(e._title || {}, t)
  },
  labelManager: {},
  minTickDistance: {},
  valueParser: {
    defaultValue: (e) => e
  }
};
class _c extends ci().with(
  Lo
) {
  /**
   * Creates an instance of Legend.
   * @param {Object} dependencies Set of dependencies required by the legend
   * @memberof Legend
   */
  constructor(t, i, n) {
    super(), this.eventManager(n);
    const { interactions: s } = t.registry;
    this._data = [], this._metaData = [], this._mount = null, this._fieldName = null, this._title = Object.assign({}, Pq), this._metaData = null, this._labelManager = t.labelManager, this._cells = t.cells, this._id = Zt(), this._measurement = Object.assign(
      {},
      this.constructor.defaultMeasurement()
    ), this._config = et({}, this.constructor.defaultConfig());
    const A = t.labelManager.getOriSize("w");
    this._minTickDistance = {
      width: A.width * 3 / 4,
      height: A.height / 2
    }, ve(this, xj), this._computedStyle = Ls(
      X("body"),
      `${this.config().classPrefix}-legend-item-info`
    ), this._firebolt = new Dj(
      this,
      {
        behavioural: s.behaviours.get(),
        physical: s.physicalActions.get(),
        physicalBehaviouralMap: s.physicalBehaviouralMap.get()
      },
      s.sideEffects.get(),
      s.behaviourEffectMap.get()
    ), this.emitSelfHooks(
      mt.INITIALIZED,
      null,
      this.genAssociatedHookComponentPaths(i)
    );
  }
  genAssociatedHookComponentPaths(t) {
    return [
      [
        Ht.LEGEND,
        t || this.scale().constructor.type()
      ],
      [Ht.LEGEND]
    ];
  }
  associatedHookComponentPaths() {
    return this.genAssociatedHookComponentPaths();
  }
  id() {
    return this._id;
  }
  /**
   * Initializes an instance of the class
   *
   * @static
   * @param {Object} dependencies Set of dependencies required by the legend
   * @return {Instance} returns a new instance of Legend
   * @memberof Legend
   */
  static create(t, i) {
    return new _c(t, i);
  }
  /**
   *
   *
   * @static
   *
   * @memberof SimpleLegend
   */
  static defaultConfig() {
    return qB;
  }
  /**
   *
   *
   * @static
   *
   * @memberof SimpleLegend
   */
  static defaultMeasurement() {
    return Oq;
  }
  /**
   *
   *
   * @readonly
   * @memberof SimpleLegend
   */
  firebolt(...t) {
    return t.length ? this : this._firebolt;
  }
  /**
   *
   *
   *
   * @memberof Legend
   */
  elemType() {
    return sq;
  }
  canvasAlias(...t) {
    return t.length ? (this._canvasAlias = t[0], this) : this._canvasAlias;
  }
  /**
   *
   *
   *
   * @memberof Legend
   */
  mount(...t) {
    return t.length ? (this._mount = t[0], this.render(), this) : this._mount;
  }
  /**
   *
   *
   * @param {*} effPadding
   * @param {*} align
   *
   * @memberof Legend
   */
  getLabelSpaces() {
    const { classPrefix: t } = this.config();
    return this._labelManager.setStyle(
      Ls(
        X("body"),
        `${t}-legend-item-info`
      )
    ), AN(this);
  }
  /**
   * Sets the height and width of a legend based on provided max
   * height and width and based on its contents
   *
   * @return {Instance} Current instance
   * @memberof Legend
   */
  setLegendMeasures() {
    const { width: t, height: i, maxWidth: n, maxHeight: s, padding: A, margin: o, border: a } = this.measurement(), { align: r } = this.config(), l = A * 2, c = a * 2, g = o * 2;
    this.data(this.dataFromScale());
    const h = this.getTitleSpace(), d = h.height > 0 ? h.height + l : 0, u = h.width + l, f = this.getLabelSpaces(l, r), {
      totalHeight: C,
      totalWidth: I,
      itemSpaces: E,
      iconSpaces: B,
      maxItemSpaces: m,
      maxIconWidth: p
    } = $q(
      this.config(),
      {
        effPadding: l,
        titleWidth: u,
        labelSpaces: f,
        titleHeight: d,
        maxWidth: n * 0.8,
        // max height of legend should be 80% of the chart height/width
        maxHeight: s * 0.8
      },
      this.data()
    );
    return this.measurement({
      width: Math.max(I, t) + g + c,
      height: Math.max(C, i) + g + c,
      labelSpaces: f,
      iconSpaces: B,
      itemSpaces: E,
      maxItemSpaces: m,
      maxIconWidth: p,
      titleSpaces: {
        width: Math.min(n, this.measurement().width) - g - c,
        height: d
      }
    }), this;
  }
  /**
   * Returns the space occupied by the legend title
   *
   * @return {Object} Space occupied by title
   * @memberof Legend
   */
  getTitleSpace() {
    return this._labelManager.setStyle(
      Ls(
        X("body"),
        `${this.config().classPrefix}-legend-title`
      )
    ), this._labelManager.getOriSize(
      this.title().text ? this.title().text : ""
    );
  }
  /**
   * Creates the title for the legend
   *
   * @param {DOM} container Container made for the title
   * @return {Selection} Title and it's node
   * @memberof Legend
   */
  renderTitle(t, i) {
    const { availableWidth: n } = i, { titleSpaces: s, border: A, padding: o, maxWidth: a } = this.measurement(), { borderStyle: r, borderColor: l } = this.config();
    return zq(
      this,
      t,
      this.title(),
      {
        height: s.height,
        border: A,
        padding: o,
        alignment: gq[this.config().position]
      },
      this.config()
    );
  }
  /**
   * Render the legend with its title
   *
   * @param {DOM} mountPoint Point where the legend and title are to be appended
   * @return {Instance} Current instance of legend
   * @memberof Legend
   */
  render() {
    const { classPrefix: t, borderStyle: i, borderColor: n, align: s, xAlign: A } = this.config(), { border: o } = this.measurement(), a = X(this.mount()), r = z(
      a,
      "div",
      [1],
      `${t}-legend-box`
    );
    r.classed(`${t}-legend-box-${this._id}`, !0), r.style("width", "100%").style("height", "100%").style("display", "flex").style("border", `${o}px ${i} ${n}`), s === Qi ? r.style("flex-direction", "column") : (r.style("flex-direction", "row").style("align-items", "center"), A && r.style("justify-content", A)), this.legendContainer(r.node());
    const l = parseFloat(a.style("width"));
    return this.renderTitle(r, { availableWidth: l }), this.firebolt().attachPropagationListener(this.metaData()), r;
  }
  /**
   *
   *
   * @param {*} data
   *
   * @memberof SimpleLegend
   */
  getCriteriaFromData(t) {
    const i = this.fieldName();
    return this.metaData().getSchema()[0].type === "measure" ? {
      [i]: t.range
    } : {
      [i]: [t.rawVal]
    };
  }
  getRangeFromIdentifiers({ fields: t, entrySet: i }) {
    const s = this.data().reduce((A, o) => (A[o.id] = o, A), {});
    return t.reduce((A, o) => (A[o] = i.reduce((a, r) => (r in s && a.push(s[r].range), a), []), A), {});
  }
  setParentInfo(t) {
    this._canvasMount = t.canvasRoot;
  }
  dispose() {
    this.firebolt().dispose();
  }
  applyInteractionStyle(t, i) {
    const { className: n, style: s } = t, A = this.config().classPrefix, o = X(this.mount()).selectAll(`.${A}-legend-columns`).filter((a) => i.has(a.id)).selectAll("div");
    if (o.classed(n, t.apply), s)
      for (let a in s)
        o.style(a, s[a]);
  }
}
const hg = {
  [_e]: {
    datasets: (e) => ({
      row: [1],
      column: e
    }),
    itemContainerMeasures: (e, t) => {
      const { iconSpaces: i, itemSpaces: n, labelSpaces: s } = e, {
        padding: A,
        buffer: o,
        item: {
          text: { orientation: a }
        },
        step: r
      } = t, l = n.reduce((h, d) => h + d.width + A + o[_e], 0).toString().concat("px"), c = a === Ds || a === Hn ? n.reduce((h, d, u) => {
        const f = Math.max(
          s[u].width,
          i[u].width
        );
        return Math.max(h, f);
      }, 0) : s.reduce((h, d, u) => {
        const f = s[u].width + A + i[u].width + o[_e];
        return Math.max(h, f);
      }, 0), g = r ? c.toString().concat("px") : (h, d) => `${n[d].width + A + o[_e]}px`;
      return {
        row: {
          width: l,
          padding: "0px"
        },
        column: {
          width: g,
          padding: "0px"
        }
      };
    },
    getStepSpacesInfo: (e) => {
      const { maxItemSpaces: t, height: i } = e;
      return {
        iconHeight: i,
        iconWidth: t.width,
        stepPadding: {
          horizontal: !0,
          vertical: !1
        }
      };
    }
  },
  [Qi]: {
    datasets: (e) => ({
      row: e,
      column: (t) => [t]
    }),
    itemContainerMeasures: (e, t) => {
      const { iconSpaces: i, itemSpaces: n, labelSpaces: s } = e, {
        padding: A,
        buffer: o,
        item: {
          text: { orientation: a }
        }
      } = t;
      let r = a === Ds || a === Hn ? n.reduce((l, c, g) => {
        const h = Math.max(
          s[g].width,
          i[g].width
        );
        return Math.max(l, h);
      }, 0) : s.reduce((l, c, g) => {
        const h = s[g].width + A + i[g].width + o[Qi];
        return Math.max(l, h);
      }, 0);
      return {
        row: {
          // width: `${width}px`,
          width: "100%",
          padding: `${A}px`
        },
        column: {
          width: `${r}px`,
          padding: "0px"
        }
      };
    },
    getStepSpacesInfo: (e) => {
      const { maxItemSpaces: t, width: i } = e;
      return {
        iconHeight: t.height,
        iconWidth: i,
        stepPadding: {
          horizontal: !1,
          vertical: !0
        }
      };
    }
  }
}, Sj = {
  [nn]: hg[Qi],
  [xs]: hg[Qi],
  [Ds]: hg[_e],
  [Hn]: hg[_e]
}, _j = {
  [nn]: oq,
  [xs]: Aq,
  [Ds]: Jl,
  [Hn]: Jl
}, bj = (e) => ({
  [nn]: e.reverse(),
  [xs]: e.reverse(),
  [Ds]: e,
  [Hn]: e
}), Mj = {
  [nn]: [$A, cg],
  [xs]: [cg, $A],
  [Ds]: [$A, cg],
  [Hn]: [cg, $A]
}, Nj = {
  circle: (e) => e * e * Math.PI,
  square: (e) => e * e,
  cross: (e) => e * 2 * (e * 2) * 5,
  diamond: (e) => e,
  star: (e) => {
    var t = 0.8908130915292852;
    return e * e / t;
  },
  triangle: (e) => e,
  wye: (e) => {
    var t = 1 / Math.sqrt(12), i = (t / 2 + 1) * 3;
    return e * e * i;
  }
}, jB = (e, t, i, n = null, s = 0, A) => {
  if (!n) {
    const a = X(e.mount()), r = parseFloat(a.style("width")), l = parseFloat(
      Fx(
        a.select(`.${t}-legend-title`),
        "width"
      ) || 0
    );
    n = r - l, parseFloat(A.row.width) > n && i.length > 4 && (n -= hd);
  }
  const o = i.length >= 4 ? wq : 100 / i.length;
  return n * o / 100 - s;
};
function Fj(e, t, i) {
  const { classPrefix: n } = e.config(), s = parseFloat(
    X(e.mount()).style("width")
  ), { itemSpaces: A } = e.measurement();
  let o = 0;
  const a = i.select(`.${n}-legend-title`);
  a.node() && (o = parseFloat(a.style("width")));
  let r = s - o;
  r -= hd;
  const l = jB(
    e,
    n,
    A,
    r,
    0,
    t
  ), { optimizedItemSpaces: c, rowWidth: g } = Rj(e, A, l);
  if (g <= r)
    return null;
  e.config().pagination = !0, e.config().availableBodyWidth = r;
  const h = [
    {
      type: "previous",
      icon: g4
    },
    {
      type: "next",
      icon: c4
    }
  ], d = z(
    i,
    "div",
    [1],
    `${n}-legend-pagination-container`
  );
  d.style("width", `${hd}px`).style("height", "16px").style("display", "flex").style("flex-direction", "row").style("align-items", "center");
  const u = z(
    d,
    "div",
    h,
    `${n}${bq}`
  );
  u.each(function(E) {
    X(this).classed(E.type, !0);
  }), u.style("flex", "1").style("height", "100%").style("display", "flex").style("flex-direction", "row").style("justify-content", "center").style("align-items", "center").style("cursor", "pointer"), z(
    u,
    "img",
    (E) => [E.icon],
    `${n}-legend-pagination-icon`
  ).attr("src", (E) => E);
  const C = kj(
    e,
    c,
    r
  );
  let I = 0;
  return u.on("click", (E) => {
    const { type: B } = E;
    let m = I;
    B === "previous" ? m = Math.max(I - 1, 0) : m = Math.min(I + 1, C.length - 1), I !== m && Tj(e, C[m], c, i), I = m;
  }), {
    opimizedRowWidth: g,
    firstPage: C[0]
  };
}
function Rj(e, t, i) {
  const { buffer: n, padding: s } = e.config();
  let A = 0;
  return {
    optimizedItemSpaces: t.map((a) => {
      const r = A, l = a.width + n[_e] + s, c = l < i ? l : i;
      return A += c, {
        width: l,
        height: a.height,
        position: r,
        actualWidth: c
      };
    }),
    rowWidth: A
  };
}
function kj(e, t, i) {
  const n = [];
  let s = -1, A = {
    end: -1
  };
  const { scaleType: o, as: a } = Ss(e.scale());
  for (; !(A.end + 1 >= t.length); ) {
    s++;
    const l = vj(
      e,
      t,
      s,
      A,
      i,
      o,
      a
    );
    n.push(l), A = l;
  }
  return n;
}
function vj(e, t, i, n, s, A, o) {
  const a = n.end + 1;
  let r = a;
  const l = t[a].position, c = l + s, g = A === ji && o === gd ? "width" : "actualWidth";
  for (let d = a; d < t.length; d++) {
    const u = t[d], f = u.position, C = f + u[g];
    if (!(f >= l && C <= c))
      break;
    r = d;
  }
  return {
    start: a,
    end: r
  };
}
function Tj(e, t, i, n) {
  const { classPrefix: s } = e.config(), A = n.selectAll(`.${s}-legend-overflow`);
  A.selectAll(`.${s}-legend-columns`).each(function(r, l) {
    Gj(t, l) ? X(this).style("visibility", "visible") : X(this).style("visibility", "hidden");
  });
  const a = i[t.start].position;
  A.style("margin-left", `-${a}px`);
}
function Gj(e, t) {
  return t >= e.start && t <= e.end;
}
const Lj = (e, t, i, n, s) => {
  const { classPrefix: A, align: o } = t.config(), { itemSpaces: a } = t.measurement(), { scaleType: r, as: l } = Ss(t.scale()), c = z(
    e,
    "div",
    i.row,
    `${A}-legend-row`
  );
  c.style(ai, (h, d) => `${a[d].height}px`), c.style(
    Ve,
    s && !(r === ji && l === gd) ? s.opimizedRowWidth.toString().concat("px") : n.row.width
  ), c.style(iN, n.row.padding);
  const g = z(
    c,
    "div",
    i.column,
    `${A}-legend-columns`
  );
  return o === Qi ? g.style("width", "100%").style("display", "flex").style("flex-direction", "row").style("align-items", "center") : (g.style("width", n.column.width).style("padding", n.column.padding).style("display", "flex").style("flex-direction", "row").style("align-items", "center"), s && g.style(cq, (h, d) => d <= s.firstPage.end ? "visible" : "hidden"), r === ji && l === gd || g.style(
    nN,
    `${jB(
      t,
      A,
      a,
      null,
      0,
      n
    )}px`
  )), g;
}, Uj = (e, t, i, n) => {
  const s = e.measurement(), { align: A } = e.config();
  let o = z(
    t,
    "div",
    [1],
    `${i}-legend-body`
  );
  A === Qi ? o.style("width", "100%").style("height", "auto").style("flex", "1").style("overflow-x", "hidden").style("overflow-y", "auto") : o.style("height", "100%").style("overflow", "hidden").style("margin", "auto 0"), o.select(`.${i}-legend-overflow`).remove();
  const a = e.config(), r = Sj[a.position], l = r.datasets(n), c = r.itemContainerMeasures(
    s,
    a,
    e
  ), g = z(
    o,
    "div",
    [1],
    `${i}-legend-overflow`
  );
  A === Qi && g.style("width", "100%");
  let h;
  return A === _e && (g.style(ai, "100%"), g.style(uq, Iq), g.style(Cq, Jl), h = Fj(e, c, t)), { legendItem: Lj(
    g,
    e,
    l,
    c,
    h
  ), measures: c };
}, Hj = (e, t) => {
  const { classPrefix: i, item: n } = e.config(), s = n.text.orientation, A = Mj[s], o = z(
    t,
    "div",
    (r, l) => A.map((c) => [
      c,
      r[c],
      r.color,
      r.size,
      r.value,
      e.fieldName(),
      l,
      r.formattedValue
    ]),
    `${i}-legend-item-info`
  );
  o.each(function(r) {
    r[0] === $A && X(this).style("overflow", "hidden").style("flex", "1");
  });
  const a = _j[s];
  return o.classed(a, !0), { itemSkeleton: o };
}, uy = (e, t, i, n) => {
  const { padding: s, labelSpaces: A, iconSpaces: o, maxIconWidth: a } = n.measurement(), { align: r } = n.config(), l = 0, c = n.scale().constructor.type();
  if (e[0] === $A)
    return `${A[e[6]][t]}px`;
  if (c === ji) {
    if (t === "width" && r === Qi)
      return `${a}px`;
    if (t === "width" && r === _e)
      return `${e[3]}px`;
  }
  return `${o[e[6]][t] - l}px`;
}, Oj = (e) => !!(/^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(e) && /[\dz]$/i.test(e) && e.length > 4), fa = function(e, t, i, n) {
  const s = t, A = e[1] || i, o = ld[A] || ld[aq];
  let a = e[3] || o;
  const { scaleType: r } = Ss(n.scale());
  if (r === ji && A === AC && (a = a * 2), A instanceof Promise)
    A.then((l) => (e.shape = l, fa(e, t, i, n)));
  else if (A instanceof Element) {
    let l = A.cloneNode(!0);
    if (l.nodeName.toLowerCase() === "img") {
      const g = l.src || l.href;
      l = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "image"
      ), l.setAttribute("href", g);
    }
    return X(l).attr("transform", `scale(${a / 100})`), X(s.node().appendChild(l));
  } else if (typeof A == "string") {
    let l;
    if (Oj(A))
      l = A;
    else {
      const c = A ? Nj[A](a) : a;
      l = Jq(A).size(c)();
    }
    return z(s, "path", (c) => [c]).attr(
      "d",
      l
    );
  }
  return e[1] = "circle", fa(e, t, "circle", n);
}, Pj = (e, t, i, n, s) => {
  const { classPrefix: A, iconHeight: o, padding: a, color: r, iconWidth: l, align: c, scale: g } = n;
  let { maxIconWidth: h } = n;
  c === _e && (h = l + 2 * a);
  const d = z(
    t,
    "svg",
    (f) => [f],
    `${A}-legend-icon-svg`
  ).attr(Ve, h).attr(ai, o).style(Ve, `${Math.ceil(h)}px`).style(ai, `${o}px`), u = h / 2 - a;
  if (e !== Kl) {
    const f = z(
      d,
      "g",
      [i[1]],
      `${A}-legend-icon`
    );
    if (g === rq && (e === gg || e === AC)) {
      e = gg;
      const C = z(
        d,
        "g",
        [i[1]],
        `${A}-legend-icon-outline`
      );
      i[3] = ld[gg] - 2, fa(i, f, e, s).attr("transform", `translate(${u} ${o / 2})`).attr("fill", i[2] || r).attr("stroke", i[2] || r), i[3] = ld[lq], fa(i, C, e, s).attr("transform", `translate(${u} ${o / 2})`).attr("fill", "transparent").attr("stroke", iq);
    } else g === ji && c === Qi && (e === gg || e === AC) ? fa(i, f, e, s).attr("transform", `translate(0 ${o / 2})`).attr("fill", i[2] || r).attr("stroke", i[2] || r) : fa(i, f, e, s).attr("transform", `translate(${u} ${o / 2})`).attr("fill", i[2] || r).attr("stroke", i[2] || r);
  } else
    z(d, Kl, [i[1]], `${A}-legend-icon`).attr("x", 0).attr("y", 0).attr(Ve, h).attr(ai, o).attr("fill", i[2] || r);
}, Yj = (e, t, i, n) => {
  const s = e._labelManager, { item: A, classPrefix: o, shape: a, align: r } = e.config(), {
    maxIconWidth: l,
    padding: c,
    // margin,
    // border,
    maxItemSpaces: g,
    itemSpaces: h,
    iconSpaces: d
  } = e.measurement(), { width: u, height: f, color: C, className: I } = A.icon, E = A.text.orientation;
  s.useEllipsesOnOverflow(!0), Ji(t, {
    width: (_) => uy(_, Ve, !1, e),
    height: (_) => uy(_, ai, !1, e),
    "text-align": Jl,
    padding: `${c}px`
  });
  const B = eN;
  s.setStyle(e._computedStyle);
  const m = hq[E] || nn;
  let p = 0;
  const { scaleType: w, as: Q } = Ss(e.scale()), y = !(w === ji && Q === gd);
  let D;
  y && r === _e && (D = jB(
    e,
    o,
    h,
    null,
    0,
    i
  )), t.each(function(_, x) {
    if (_[0] === $A) {
      const S = _[7], b = gS("span", this).classed(`${o}-legend-item-info-text`, !0).text(S);
      b.style("white-space", "nowrap"), b.style("overflow", "hidden"), b.style("text-overflow", "ellipsis"), b.style("line-height", `${g.height}px`);
      const R = X(this);
      R.style(`padding-${m}`, "0px"), r === _e ? (R.style(`margin-${m}`, `${B}px`), y && R.style(
        nN,
        `${D - d[p].width - B - c}px`
      )) : R.style(`margin-${m}`, "5px"), p++;
    } else {
      X(this).classed(`${o}-${I}`, !0), X(this).classed(`${o}-${I}-${x}`, !0);
      let S = 2 * _[3] || u;
      e.scale().constructor.type() === ji && (S = _[3]), Pj(
        a,
        X(this),
        _,
        {
          classPrefix: o,
          iconWidth: S,
          iconHeight: f,
          maxIconWidth: l,
          padding: c,
          color: C,
          align: r,
          scale: n
        },
        e
      );
    }
  });
};
class Li extends _c {
  constructor(...t) {
    super(...t);
  }
  /**
   * Initializes an instance of the class
   *
   * @static
   * @param {Object} dependencies Set of dependencies required by the legend
   * @return {Instance} returns a new instance of Legend
   * @memberof Legend
   */
  static create(...t) {
    return new Li(...t);
  }
  /**
   *
   *
   * @static
   *
   * @memberof DiscreteLegend
   */
  static type() {
    return VB;
  }
  /**
   *
   *
   * @param {*} scale
   *
   * @memberof DiscreteLegend
   */
  dataFromScale() {
    const { MEASURE: t } = K.FieldType, { TEMPORAL: i } = K.FieldSubtype, n = this.scale(), { scaleType: s, domain: A, scaleFn: o, steps: a, as: r } = Ss(n), l = this.fieldName(), c = this.metaData().getField(l), { type: g, subtype: h } = c.schema();
    let d = [];
    const u = this.config();
    if (r === ft.DISCRETE)
      d = [...new Set(A)];
    else if (s === ji && g === t)
      d = Array.isArray(a) ? a : rr(A, A.length);
    else if (h === i) {
      d = [...new Set(c.data())];
      const C = d.find((I) => K.isInvalid(I));
      d = [
        ...d.filter((I) => !K.isInvalid(I))
      ], C && d.push(C);
    } else
      d = [...new Set(A)];
    const f = d.length;
    if (d = d.map((C, I) => {
      let E = 0, B = 0;
      const m = d[I];
      if (g === t) {
        E = parseFloat(d[I], 10);
        const p = parseInt(
          d[I + 1] ? d[I + 1] : d[I],
          10
        );
        B = [Math.floor(E), I === f - 1 ? p : p - 1], Number.isInteger(E) || (E = new Number(E).toFixed(2));
      } else {
        let p = K.getActualValue(m);
        h === i ? (p = pA(
          d[I],
          c.minimumConsecutiveDifference(),
          { useUTC: u.useUTC }
        ), E = p, B = [p]) : (E = p, B = [p]);
      }
      return {
        [s]: n[o](C),
        value: E,
        id: m,
        range: B,
        rawVal: m
      };
    }).filter((C) => C.value !== null), s === ji)
      d = d.sort(
        (C, I) => C[s] - I[s]
      );
    else if (r === ft.CONTINUOUS)
      d = d.sort(
        (C, I) => CE("asc", C.rawVal, I.rawVal)
      );
    else if (r === ft.DISCRETE) {
      const I = n.sortValues(
        d.map((E) => E.rawVal)
      ).reduce((E, B, m) => (E.set(B, m), E), /* @__PURE__ */ new Map());
      d = d.sort((E, B) => {
        const m = I.get(E.rawVal), p = I.get(B.rawVal);
        return m - p;
      });
    }
    return this.calculateFormattedValue(d);
  }
  setLegendMeasures() {
    super.setLegendMeasures();
    const { itemSpaces: t, padding: i, maxIconWidth: n, width: s, labelSpaces: A } = this.measurement(), o = this.getTitleSpace(), { align: a, item: r } = this.config(), l = i * 2, { scaleType: c } = Ss(this.scale()), g = this._labelManager;
    let h = {};
    if (a === Qi) {
      const d = t.reduce((I, E) => I + E.height, 0), u = o.height > 0 ? o.height + l + 5 : 0, f = d + u;
      let C = g.getOriSize(
        Sq
      ).width;
      if (C = Math.min(o.width, C), h = {
        ...h,
        height: f,
        maxHeight: f,
        minHeight: sN
      }, c === ji) {
        let I = s - n / 2;
        I = Math.max(C, I);
        let E = g.getOriSize(
          aC
        ).width, B = o.width;
        I = Math.max(I, Math.min(B, E)), h = {
          ...h,
          maxIconWidth: n / 2,
          width: I
        };
      } else {
        let I = g.getOriSize(
          aC
        ).width;
        const E = g.getOriSize(
          xq
        ).width, B = A.reduce((y, D) => Math.max(y, D.width), Number.MIN_VALUE) + _q, m = r.icon.width + eN;
        let p = Math.min(B, I);
        p = Math.max(p, E);
        let w = p + m + Dq + Vg;
        w = Math.max(C, w);
        let Q = o.width;
        w = Math.max(w, Math.min(Q, I)), h = {
          ...h,
          width: w,
          maxWidth: w,
          minWidth: w
        };
      }
    } else {
      const d = Qq;
      if (h = {
        ...h,
        height: d,
        maxHeight: d,
        minHeight: d
      }, c === ji) {
        const u = this.data().map((f, C) => {
          const I = f.size, { width: E } = g.getOriSize(
            f.formattedValue
          );
          return {
            width: I + E,
            height: t[C].height
          };
        });
        h = {
          ...h,
          itemSpaces: u
        };
      }
    }
    return this.measurement(h), this;
  }
  calculateFormattedValue(t) {
    const { formatter: i } = this.config().item.text;
    return t.map((n, s) => {
      const A = Zi(n.value);
      return n.formattedValue = i(
        {
          formattedValue: A,
          rawValue: n.rawVal
        },
        {
          context: this,
          itemMeta: n,
          itemIndex: s,
          allItems: t,
          dataModel: this.metaData()
        }
      ), n;
    });
  }
  /**
   * Render the legend with its title
   *
   * @param {DOM} mountPoint Point where the legend and title are to be appended
   * @return {Instance} Current instance of legend
   * @memberof Legend
   */
  render() {
    this.emitSelfHooks(mt.BEFORE_RENDERED);
    const t = Js(), i = this.firebolt(), n = this.data(), s = this.scale().constructor.type(), { classPrefix: A, align: o, title: a } = this.config(), r = super.render(this.mount()), { legendItem: l, measures: c } = Uj(
      this,
      r,
      A,
      n
    ), { itemSkeleton: g } = Hj(this, l);
    return Yj(this, g, c, s), r.selectAll("div").filter(
      (h, d, u) => !u[d].classList.contains(`${A}-legend-body`)
    ).classed(Fq, !0), o === _e && a.show, i.mapActionsAndBehaviour(), this.emitSelfHooks(mt.AFTER_RENDERED), t.onAllCallbacksCalled().then(() => {
      this.emitSelfHooks(mt.ANIMATION_END);
    }), i.applyExistingInteractions(), r;
  }
  createFireboltSelectionSet({ data: t, prevData: i }) {
    const n = this.firebolt(), s = i ? i.map((o) => o.rawVal) : [], A = t.map((o) => o.rawVal);
    !eo("Array")(A, s) && n.createSelectionSet({
      keys: A
    });
  }
}
class Vl extends _c {
  constructor(...t) {
    super(...t);
  }
  /**
   * Initializes an instance of the class
   *
   * @static
   * @param {Object} dependencies Set of dependencies required by the legend
   * @return {Instance} returns a new instance of Legend
   * @memberof Legend
   */
  static create(...t) {
    return new Vl(...t);
  }
  /**
   *
   *
   * @static
   *
   * @memberof GradientLegend
   */
  static type() {
    return cd;
  }
  /**
   *
   *
   * @param {*} axis
   *
   * @memberof GradientLegend
   */
  axis(...t) {
    return t.length ? (this._axis = t[0], this) : this._axis;
  }
  setLegendMeasures() {
    super.setLegendMeasures();
    const { align: t } = this.config();
    if (t === "vertical") {
      const i = ay, n = oC;
      this.measurement({
        width: i,
        height: n,
        maxWidth: i,
        maxHeight: n,
        minWidth: i,
        minHeight: n
      });
    } else {
      const i = ay, n = Bq;
      this.measurement({
        width: i,
        height: n,
        maxWidth: i,
        maxHeight: n,
        minWidth: i,
        minHeight: n
      });
    }
    return this;
  }
  /**
   *
   *
   * @param {*} scale
   *
   * @memberof GradientLegend
   */
  dataFromScale() {
    let t = [];
    const i = this.scale(), n = this.config(), s = this.metaData().getField(this.fieldName()), { subtype: A } = s.schema(), { scaleType: o, domain: a, steps: r, scaleFn: l } = Ss(i), c = {
      smartLabel: this.labelManager(),
      measures: this.measurement(),
      alignment: this.config().position,
      minTickDistance: this.minTickDistance()
    };
    Array.isArray(n.domain) && n.domain.length >= 2 ? t = n.domain.map((h) => h) : Array.isArray(r) ? (a[0] < r[0] && (t[0] = a[0]), t = [...t, ...r], a[a.length - 1] > r[r.length - 1] && t.push(a[1]), t = [...new Set(t)].sort((h, d) => h - d), t = qq(t, c)) : t = jq(a, r - 1, c);
    const g = /* @__PURE__ */ new Set();
    return t = t.map((h, d) => {
      const u = t[d];
      return {
        [o]: o === ji ? i[l](h) * i.getScaleFactor() : i[l](h),
        value: A === K.FieldSubtype.TEMPORAL ? u : +u.toFixed(1),
        id: d
      };
    }).filter((h) => h.value === null || g.has(h.value) ? !1 : (g.add(h.value), !0)).sort((h, d) => h.value - d.value), this.firebolt().createSelectionSet({
      keys: this.data().map((h) => h.id)
    }), t;
  }
  /**
   *
   *
   * @param {*} effPadding
   * @param {*} align
   *
   * @memberof Legend
   */
  getLabelSpaces(t) {
    this.config({
      item: {
        text: {
          orientation: this.config().position
        }
      }
    });
    const { subtype: i } = this.metaData().getField(this.fieldName()).schema();
    let n = [];
    const s = XA.size + XA.BUFFER, A = aj(this);
    if (i === K.FieldSubtype.TEMPORAL)
      n = A.source().axisDimensions().allTickDimensions || [];
    else {
      const o = A.getLogicalSpace(), a = {
        width: o.width - t,
        height: o.height - t
      }, r = A.source().domain().length;
      n = new Array(r).fill(a);
    }
    return n = n.map((o) => ({
      width: o.width + s,
      height: o.height
    })), this.axis(A), n;
  }
  /**
   *
   *
   *
   * @memberof GradientLegend
   */
  getDrawingContext() {
    return {
      svgContainer: this._legendGradientSvg
    };
  }
  /**
   * Render the legend with its title
   *
   * @param {DOM} mountPoint Point where the legend and title are to be appended
   * @return {Instance} Current instance of legend
   * @memberof Legend
   */
  render() {
    this.emitSelfHooks(mt.BEFORE_RENDERED);
    const t = Js(), { classPrefix: i, align: n } = this.config(), s = this.firebolt(), A = super.render(this.mount());
    return cj(this, A), A.selectAll("div").style("float", nn), A.selectAll(`.${i}-legend-body`).style("display", "flex").style("float", "none").style("flex-direction", "column").style("overflow", "hidden"), n === Qi && A.selectAll(`.${i}-legend-body`).style("width", "100%").style("flex", "1"), s.mapActionsAndBehaviour(), s.mapSideEffects({
      [_u]: [YB]
    }), s.applyExistingInteractions(), this.emitSelfHooks(mt.AFTER_RENDERED), t.onAllCallbacksCalled().then(() => {
      this.emitSelfHooks(mt.ANIMATION_END);
    }), A;
  }
  createFireboltSelectionSet({ data: t, prevData: i }) {
    const n = this.firebolt(), s = i ? i.map((o) => o.id) : [], A = t.map((o) => o.id);
    !eo("Array")(A, s) && n.createSelectionSet({
      keys: A
    });
  }
  /**
   *
   *
   * @param {*} data
   *
   * @memberof SimpleLegend
   */
  getCriteriaFromData(t) {
    return [[this.fieldName()], [t.value]];
  }
  getRangeFromIdentifiers({ fields: t, criteria: i }) {
    return t.reduce((n, s) => (n[s] = i[s], n), {});
  }
}
const Jj = (e) => {
  const t = e.fieldName(), i = e.metaData(), { subtype: n } = i.getField(t).schema(), s = e.axis().source(), { _tickFormatter: A } = s, o = s.domain();
  let a = [o[0], o[1]];
  n === K.FieldSubtype.TEMPORAL && (a = a.map((c) => /* @__PURE__ */ new Date(+c)));
  const r = A(a);
  return a.map((c) => r(c));
}, Kj = (e, t, i, n, s, A, o, a) => {
  let { height: r } = s.icon, l = z(
    e,
    "div",
    [1],
    `${t}-legend-body`
  );
  l.style(iN, `${A}px`).style(dq, "5px 0");
  let c, g, h, d;
  return i === wo.HORIZONTAL ? (c = z(
    l,
    "div",
    [1],
    `${t}-step-legend-ticks`
  ), g = z(
    c,
    "div",
    [1],
    `${t}-step-first-tick`
  ), g.text(o[0]), g.style("padding", `${il}px`).style("max-width", `${a}px`).style("text-align", "right"), g.classed(`${t}-step-legend-ticks-h`, !0), h = z(
    c,
    "div",
    [1],
    `${t}-legend-steps-container`
  ), d = z(
    c,
    "div",
    [1],
    `${t}-step-second-tick`
  ), d.text(o[1]), d.style("padding", `${il}px`).style("max-width", `${a}px`), d.classed(`${t}-step-legend-ticks-h`, !0)) : (l.style("width", `${n}px`), h = z(
    l,
    "div",
    [1],
    `${t}-legend-steps-container`
  ), h.style("flex", "1"), h.style("display", "flex"), c = z(
    l,
    "div",
    [1],
    `${t}-step-legend-ticks`
  ), c.style("justify-content", "space-between"), g = z(
    c,
    "div",
    [1],
    `${t}-step-first-tick`
  ), g.text(o[0]), g.style("padding-top", `${il}px`), g.classed(`${t}-step-legend-ticks-v`, !0), d = z(
    c,
    "div",
    [1],
    `${t}-step-second-tick`
  ), d.text(o[1]), d.style("padding-top", `${il}px`), d.classed(`${t}-step-legend-ticks-v`, !0)), c.style("display", "flex"), c.style("align-items", "center"), h.style("position", "relative"), z(
    h,
    "div",
    [1],
    `${t}-legend-svg-container`
  ).style(ai, `${r}px`);
}, Vj = (e, t, i, n, s, A) => {
  let { height: o, color: a } = A.icon;
  const r = n / i.length, l = z(
    t,
    "svg",
    [1],
    `${s}-step-legend-icon-svg`
  ).attr(Ve, Math.ceil(n)).attr(ai, o).style(Ve, `${Math.ceil(n)}px`).style(ai, `${o}px`), c = z(
    l,
    "g",
    [1],
    `${s}-step-legend-icon-group`
  );
  z(
    c,
    Kl,
    i,
    `${s}-step-legend-icon`
  ).attr("x", (h, d) => d * r).attr("y", 0).attr(Ve, r).attr(ai, o).attr("fill", (h) => h.color || a), e._stepLegendSvg = l;
}, Wj = (e, t, i, n, s, A, o, a) => {
  if (a === wo.VERTICAL)
    return {
      availableWidth: Math.min(t, i) - (A + n + 2 * s)
    };
  {
    const l = (e.mount().style.width.replace("px", "") - 2 * A) / 2, c = l * Tq;
    return {
      availableWidth: l,
      // -
      // leftTickWidth -
      // rightTickWidth -
      // 4 * STEP_LEGEND_TICK_PADDING,
      maxTickWidth: c + 2 * il
    };
  }
}, qj = (e, t) => {
  const { classPrefix: i, position: n, align: s, item: A } = e.config(), o = bj(e.data())[n] ?? [], { width: a, maxWidth: r, padding: l, paddingRight: c, border: g } = e.measurement(), h = Jj(e), { availableWidth: d, maxTickWidth: u } = Wj(
    e,
    a,
    r,
    c,
    g,
    l,
    h,
    s
  ), f = Kj(
    t,
    i,
    s,
    d,
    A,
    l,
    h,
    u
  );
  Vj(
    e,
    f,
    o,
    d,
    i,
    A
  );
};
function jj(e, t, i) {
  const { subtype: n } = t.schema();
  let s;
  return n === K.FieldSubtype.TEMPORAL ? s = pA(
    e,
    t.minimumConsecutiveDifference(),
    {
      useUTC: i.useUTC,
      useShortFormatter: i.useShortFormatter
    }
  ) : s = e, Zi(s);
}
const zj = (e) => {
  const t = e.fieldName(), i = e.metaData(), { subtype: n } = i.getField(t).schema(), s = e.data(), { useUTC: A } = e.config(), o = e._cells.AxisCell, { domain: a, stops: r } = e.config(), l = !!(Array.isArray(r) && r.length), c = !l && !!(Array.isArray(a) && a.length), g = n === K.FieldSubtype.TEMPORAL ? fr : Ln, h = new g(
    {
      id: `legend-${e._id}`,
      // orientation:  align === ALIGN.VERTICAL ? BOTTOM : LEFT,
      // The ticks are at bottom for vertical step legend
      orientation: Hn,
      style: e._computedStyle,
      nice: !(c || l || n === Wg),
      showAxisName: !1,
      tickSize: 0,
      fixedBaseline: !1,
      labels: {
        rotation: null
      },
      tickFormat: (d, u) => {
        const f = e.metaData(), C = e.fieldName(), I = f.getField(C), E = jj(
          d.rawValue,
          I,
          {
            useUTC: e.config().useUTC,
            useShortFormatter: !0
          }
        );
        return e.config().item.text.formatter(
          {
            formattedValue: E,
            rawValue: d.rawValue
          },
          {
            context: e,
            itemMeta: {},
            itemIndex: u.tickIndex,
            allItems: u.allRawTicks,
            dataModel: e.metaData()
          }
        );
      },
      useUTC: A,
      transition: e.config().transition
    },
    { labelManager: e._labelManager }
  );
  if (c)
    h.domain(a);
  else {
    let d;
    s && s.length ? d = [s[0]?.range?.[0], s[s.length - 1]?.range?.[1]] : d = [], h.domain(d);
  }
  return n === K.FieldSubtype.TEMPORAL ? (h.minDiff(
    i.getField(t).minimumConsecutiveDifference()
  ), h.logicalSpace(eB(h, !0)), Ic(h)) : h.range([1, 1]), new o().source(h).config({
    margin: { left: 0, bottom: 0, top: 0, right: 0 }
  });
};
class dd extends _c {
  constructor(...t) {
    super(...t);
  }
  /**
   * Initializes an instance of the class
   *
   * @static
   * @param {Object} dependencies Set of dependencies required by the legend
   * @return {Instance} returns a new instance of Legend
   * @memberof Legend
   */
  static create(...t) {
    return new dd(...t);
  }
  /**
   *
   *
   * @static
   *
   * @memberof StepLegend
   */
  static type() {
    return KB;
  }
  /**
   *
   *
   * @static
   *
   * @memberof StepLegend
   */
  static defaultConfig() {
    return Yq;
  }
  /**
   * function to recalculate steps on providing more number of stops than canvas can accomodate.
   * @param  {Array} domain - Array
   * @param  {Array} steps - Array
   * @param  {Array} range - range from scale
   * @return {Array} - recalculated Step Array
   */
  getInterpolatedData(t, i, n) {
    if (i instanceof Array)
      return i;
    const { domain: s, stops: A } = this.config(), o = !!(Array.isArray(A) && A.length), a = !o && !!(Array.isArray(s) && s.length);
    return rr(
      t,
      i,
      !0,
      n,
      !(o || a)
    );
  }
  /**
   *
   *
   * @param {*} scale
   *
   * @memberof StepLegend
   */
  dataFromScale() {
    let t = [];
    const i = this.scale(), { scaleType: n, domain: s, steps: A, scaleFn: o } = Ss(i), a = this.metaData().getField(this.fieldName()), { subtype: r } = a.schema(), l = this.config(), c = i.getScaleRange();
    Array.isArray(l.stops) && l.stops.length >= 2 ? t = l.stops.map((d) => d) : Array.isArray(A) && r !== Wg ? (s[0] < A[0] && (t[0] = s[0]), t = [...t, ...A], s[s.length - 1] > A[A.length - 1] && t.push(s[1]), t = [...new Set(t)].sort((d, u) => d - u)) : r === Wg && !A ? t = uE(s, a.getAllBins()) : (t = this.getInterpolatedData(s, A, c), t = [...new Set(t)].sort((d, u) => d - u)), t.length === 1 && t.push(K.createInvalid(r)), t = [...new Set(t)].sort((d, u) => d - u);
    const h = [];
    for (let d = 0; d < t.length - 1; d++) {
      let u = t[d];
      const f = u, C = t[d + 1];
      let I = [f, C];
      if (r === Wg && !A && C - f > a._schema.binSize) {
        const B = f + a._schema.binSize;
        I = [f, B];
      }
      const E = I.map((B) => r === K.FieldSubtype.TEMPORAL ? pA(B, a.minimumConsecutiveDifference(), {
        useUTC: l.useUTC
      }) : `${+Number(B).toFixed(1)}`).join(ph);
      h.push({
        [n]: n === ji ? i[o](u) * i.getScaleFactor() : i[o](u),
        value: E,
        id: d + 1,
        range: I
      });
    }
    return this.calculateFormattedValue(h);
  }
  calculateFormattedValue(t) {
    const { formatter: i } = this.config().item.text;
    return t.map((n, s) => {
      const A = Zi(n.value);
      return n.formattedValue = i(
        {
          formattedValue: A,
          rawValue: n.range
        },
        {
          context: this,
          itemMeta: n,
          itemIndex: s,
          allItems: t,
          dataModel: this.metaData()
        }
      ), n;
    });
  }
  /**
   *
   *
   * @param {*} effPadding
   * @param {*} align
   *
   * @memberof Legend
   */
  getLabelSpaces() {
    return this.config({
      item: {
        text: {
          orientation: this.config().position
        }
      }
    }), AN(this);
  }
  setLegendMeasures() {
    super.setLegendMeasures();
    const { align: t } = this.config();
    if (t === "vertical") {
      const i = ry, n = Eq;
      this.measurement({
        width: i,
        height: n,
        maxWidth: i,
        maxHeight: n,
        minWidth: i,
        minHeight: n
      });
    } else {
      const i = ry, n = mq;
      this.measurement({
        width: i,
        height: n,
        maxWidth: i,
        maxHeight: n,
        minWidth: i,
        minHeight: n
      });
    }
    return this;
  }
  /**
   *
   *
   *
   * @memberof Legend
   */
  elemType() {
    return Kl;
  }
  axis(...t) {
    return t.length ? (this._axis = t[0], this) : this._axis;
  }
  getDrawingContext() {
    return {
      svgContainer: this._stepLegendSvg
    };
  }
  /**
   * Render the legend with its title
   *
   * @param {DOM} mountPoint Point where the legend and title are to be appended
   * @return {Instance} Current instance of legend
   * @memberof Legend
   */
  render() {
    this.emitSelfHooks(mt.BEFORE_RENDERED);
    const t = Js(), i = this.firebolt(), n = super.render(this.mount());
    return this.axis(zj(this)), qj(this, n), this.axis().source().domain(this.scale().domain()), i.mapActionsAndBehaviour(), i.mapSideEffects({
      [_u]: [YB]
    }), this.emitSelfHooks(mt.AFTER_RENDERED), t.onAllCallbacksCalled().then(() => {
      this.emitSelfHooks(mt.ANIMATION_END);
    }), i.applyExistingInteractions(), n;
  }
  createFireboltSelectionSet({ data: t, prevData: i }) {
    const n = this.firebolt(), s = i ? i.map((o) => o.id) : [], A = t.map((o) => o.id);
    !eo("Array")(A, s) && n.createSelectionSet({
      keys: A
    });
  }
  getCriteriaFromData(t) {
    return {
      [this.fieldName()]: t.range
    };
  }
}
const Wl = "rows", Na = "columns", rN = "data", ks = "color", $j = "opacity", Ia = "backgroundColor", go = "shape", vs = "size", lN = "detail", cN = "layers", gN = "transform", $i = "width", Xi = "height", hN = "padding", dN = "border", uN = "margin", Xj = "config", rC = "legend", zB = "topLegend", $B = "bottomLegend", XB = "leftLegend", ZB = "rightLegend", Mi = "title", $n = "subtitle", ds = "columnHeader", NA = "linear", $s = "ordinal", ZA = "muze", dg = "show", Zj = ["script", "style"], fy = {
  SQUARE: "square",
  CIRCLE: "circle"
}, tz = {
  true: fy.CIRCLE,
  false: fy.SQUARE
}, ez = {
  [`${$s}-true-${ks}`]: Li,
  [`${$s}-true-${Ia}`]: Li,
  [`${$s}-true-${vs}`]: Li,
  [`${$s}-true-${go}`]: Li,
  [`${$s}-false-${ks}`]: Li,
  [`${$s}-false-${Ia}`]: Li,
  [`${$s}-false-${go}`]: Li,
  [`${$s}-false-${vs}`]: Li,
  [`${NA}-false-${vs}`]: Li,
  [`${NA}-true-${vs}`]: Li,
  [`${NA}-false-${go}`]: Li,
  [`${NA}-true-${ks}`]: dd,
  [`${NA}-true-${Ia}`]: dd,
  [`${NA}-false-${ks}`]: Vl,
  [`${NA}-false-${Ia}`]: Vl
}, li = "left", _s = "right", aA = "bottom", iz = "center", Re = "top", ug = "group", Iy = "layout", nz = "retinal", ql = "vertical", Do = "horizontal", sz = "h-center", Az = "extended-h-center", Cy = "extended-v-center", Ey = "hidden", Nf = "overflow", By = "auto", oz = "visible", fN = "verticalScrollBar", IN = "horizontalScrollBar", sr = "grid", az = "point", ud = "message", rz = "Insufficient data or incorrect configurations", CN = "area", EN = "line", lz = (...e) => new $h(...e.map((t) => new RB(t)));
function BN(e) {
  if (e.nodeType === Node.ELEMENT_NODE)
    if (Zj.indexOf(e.tagName.toLowerCase()) !== -1)
      e.parentNode.removeChild(e);
    else
      for (const t of e.childNodes)
        BN(t);
}
function cz(e, ...t) {
  let i = "";
  const n = t.length;
  let s = 0;
  for (; s < n; ++s)
    i += e[s] + t[s];
  i += e[s];
  const A = document.createDocumentFragment(), o = document.createElement("div");
  A.appendChild(o), o.innerHTML = i, BN(o);
  const { innerHTML: a } = o;
  return () => a;
}
const gz = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  html: cz,
  share: lz
}, Symbol.toStringTag, { value: "Module" })), my = {
  // Action on source canvas
  highlight: {
    // Action on target canvas
    highlight: {
      sideEffects: {
        "plot-highlighter": {
          rules: [
            {
              target: "exitSet",
              style: {
                fill: {
                  a: -0.3
                }
              }
            }
          ]
        }
      }
    }
  },
  select: {
    filter: {
      sideEffects: ["filter"]
    }
  }
}, hz = (e) => {
  let t = e;
  return Array.isArray(e) && (t = e.reduce((i, n) => {
    let s;
    return typeof n == "string" ? (s = n, i[s] = {}) : (s = n.name, i[s] = n), i;
  }, {})), t;
}, dz = (e) => {
  let t = {};
  for (let i in my) {
    t[i] = {
      target: {}
    };
    const n = my[i];
    e.forEach((s) => {
      t[i].target[s.alias()] = n;
    });
  }
  return t;
}, uz = (e, t) => {
  const i = Ix({}, t, e);
  for (let n in i) {
    const { target: s } = i[n];
    for (let A in s) {
      const o = s[A];
      for (let a in o)
        o[a].sideEffects = hz(
          o[a].sideEffects
        );
    }
  }
  return i;
}, fz = (e) => {
  const t = e.map((i) => i.alias());
  return {
    behaviours: {
      "*": (i) => i.canvasId ? t.indexOf(i.canvasId) !== -1 : !0
    },
    sideEffects: {
      "*": (i) => i.canvasId ? t.indexOf(i.canvasId) !== -1 : !0
    }
  };
}, Zo = (e) => {
  const t = {};
  for (const i in e) {
    const n = e[i];
    t[n.formalName()] = n;
  }
  return t;
};
class Iz {
  constructor() {
    this._registrableComponents = [], this._registry = {
      visualGroup: {
        behaviours: {
          ...Zo(yB),
          [f0.formalName()]: f0
        },
        physicalActions: Bb,
        sideEffects: Zo(xB),
        behaviourEffectMap: {},
        physicalBehaviouralMap: WV
      },
      legend: {
        behaviours: {
          ...Zo(Hr.behaviours)
        },
        physicalActions: Hr.physicalActions,
        sideEffects: Zo(Hr.sideEffects),
        behaviourEffectMap: Hr.behaviourEffectMap,
        physicalBehaviouralMap: Hr.physicalBehaviouralMap
      }
    };
  }
  /**
   * Takes an array of canvases on which the physical and behavioural actions will get registered.
   *
   * @public
   * @param  {Canvas} components Array of canvases
   *
   * @return {ActionModel} Instance of action model.
   */
  for(...t) {
    return this._registrableComponents = t, this._registrableComponents.forEach((i) => {
      i.once("afterDisposed", () => {
        this._registrableComponents = this._registrableComponents.filter(
          (n) => n !== i
        );
      });
    }), this;
  }
  /**
   * Registers physical actions on the canvases. It takes an object with key as the name of action and value having
   * the definition of the action.
   *
   * To register a {@link PhysicalAction},
   * ```
   *  const ActionModel = muze.ActionModel;
   *  ActionModel
   *       // Physical actions will be registered on these canvases.
   *      .for(canvas)
   *      .registerPhysicalActions({
   *          // Key is the name of physical action.
   *          ctrlClick: (firebolt) => (targetEl, behaviours) => {
   *              targetEl.on('click', function (data) {
   *                  const event = utils.getEvent();
   *                  const pos = utils.getClientPoint(event, this);
   *                  // Get the data point nearest to the mouse position.
   *                  const nearestPoint = firebolt.context.getNearestPoint(pos, {
   *                      data
   *                  });
   *                  // Prepare the payload
   *                  const payload = {
   *                      criteria: nearestPoint.id
   *                  };
   *                  behaviours.forEach((behaviour) => firebolt.dispatchBehaviour(behaviour, payload));
   *              });
   *          }
   *      });
   * ```
   * @public
   *
   * @param {Object} action Names of physical actions and their definitions.
   *
   * @return {ActionModel} Instance of the action model.
   */
  registerPhysicalActions(t) {
    return this._registrableComponents.forEach((n) => {
      n._registry.interactions.visualGroup.physicalActions.register(
        t
      );
    }), this;
  }
  /**
   * Registers behavioural actions on the canvases. It takes definitions of the behavioural actions and registers
   * them on the canvases. Every behavioural action must inherit the {@link GenericBehaviour} class.
   *
   * To register a behavioural action
   * ```
   *  // Define a new behavioural action
   *  class SingleSelectBehaviour extends GenericBehaviour {
   *      static formalName () {
   *          return 'singleSelect';
   *      }
   *
   *      setSelectionSet (addSet, selectionSet) {
   *          if (addSet === null) {
   *              selectionSet.reset();
   *          } else if (addSet.length) {
   *              const existingAddSet = selectionSet.getExistingEntrySet(addSet);
   *              if (existingAddSet.length){
   *                  selectionSet.reset();
   *              } else {
   *               selectionSet.add(addSet);
   *              }
   *          } else {
   *              selectionSet.reset();
   *          }
   *      }
   * }
   * muze.ActionModel.registerBehaviouralActions(SingleSelectBehaviour);
   * ```
   *
   * @public
   *
   * @param {GenericBehaviour} actions Definition of behavioural actions.
   *
   * @return {ActionModel} Instance of action model.
   */
  registerBehaviouralActions(...t) {
    return this._registrableComponents.forEach((n) => {
      n._registry.interactions.visualGroup.behaviours.register(
        Zo(t)
      );
    }), this;
  }
  /**
   * Registers the mapping of physical and behavioural actions. This mapping is used to establish which behavioural
   * actions should be dispatched on any triggering of physical actions.
   *
   * To map physical actions with behavioural actions,
   * ```
   *  muze.ActionModel.registerPhysicalBehaviouralMap({
   *      ctrlClick: {
   *          behaviours: ['select'] // This array must be the formal names of the behavioural actions.
   *      }
   *  });
   * ```
   *
   * @public
   * @param {Object} map Contains the physical and behavioural action map.
   * ```
   *   {
   *      // Name of the physical action
   *      click: {
   *          // Target element selector. This is an optional field. If not passed, then by default takes the
   *          // container element of visual unit.
   *          target: '.muze-layers-area path',
   *          // Behaviours which should be dispatched on triggering of the mapped physical action.
   *          behaviours: ['select']
   *      }
   *   }
   * ```
   *
   * @return {ActionModel} Instance of action model.
   */
  registerPhysicalBehaviouralMap(t, i = "visualGroup") {
    return this._registrableComponents.forEach((n) => {
      if (i === "legend") {
        const s = n._registry.interactions.legend.physicalBehaviouralMap.get();
        for (let A in t) {
          const o = s[A];
          o && (o.behaviours = [
            .../* @__PURE__ */ new Set([...o.behaviours, ...t[A].behaviours])
          ]);
        }
      } else
        n.firebolt().registerPhysicalBehaviouralMap(t);
    }), this;
  }
  /**
   * Registers what behaviour to propagate on dispatch of a certain behavioural action. By default, when any
   * behavioural action is dispatched, then the same behavioural action gets propagated to all the other canvases.
   * This can be changed using this api.
   *
   * To register what behaviour should be propagated on dispatch of any behavioural action,
   * ```
   *  ActionModel.for(canvas1, canvas2).registerPropagationBehaviourMap({
   *      select: 'filter',
   *      brush: 'filter'
   *  });
   * ```
   *
   * @public
   * @param {Object} map Propagation behaviour map.
   *
   * @return {ActionModel} Instance of action model.
   */
  registerPropagationBehaviourMap(t) {
    return this._registrableComponents.forEach(
      (i) => i.firebolt().registerPropagationBehaviourMap(t)
    ), this;
  }
  /**
   * Registers the mapping of side effects and behavioural actions. It takes an object which contains key as the
   * name of behavioural action and the side effects which will be linked to it.
   *
   * To map side effects to select behaviour,
   * ```
   *  muze.ActionModel.mapSideEffects({
   *      select: ['infoBox'] // This array must be the formal names of the side effects
   *  });
   * ```
   *
   * To map side effects to select behaviour, but disable all the default side effects attached with this behaviour,
   * ```
   *  muze.ActionModel.mapSideEffects({
   *      select: {
   *          effects: ['infoBox'],
   *          preventDefaultActions: true
   *      }
   *  });
   * @public
   * @param {Object} map Mapping of behavioural actions and side effects.
   * ```
   *     {
   *          select: ['infoBox']
   *     }
   * ```
   * @return {ActionModel} Instance of action model.
   */
  mapSideEffects(t) {
    return this._registrableComponents.forEach((i) => {
      i.firebolt().mapSideEffects(t);
    }), this;
  }
  registry() {
    return this._registry;
  }
  /**
   * Registers the side effects on the registered canvases. It takes definitions of side effects and registers them
   * on the canvases. Every side effect must inherit the base class {@link GenericSideEffect} or
   * {@link SpawnableSideEffect} or {@link SurrogateSideEffect} class.
   *
   * ```
   * // Define a custom side effect
   *  class InfoBox extends SpawnableSideEffect {
   *      static formalName () {
   *          return 'infoBox';
   *      }
   *
   *      apply (selectionSet) {
   *      }
   *  }
   *  muze.ActionModel.registerSideEffects(InfoBox);
   * ```
   * @public
   * @param  {GenericSideEffect} sideEffects Definition of side effects.
   *
   * @return {ActionModel} Instance of action model.
   */
  registerSideEffects(...t) {
    return this._registrableComponents.forEach((n) => {
      n._registry.interactions.visualGroup.sideEffects.register(
        Zo(t)
      );
    }), this;
  }
  /**
   * Breaks the link between behavioural actions and physical actions. It takes an array of behavioural action
   * and it's physical action.
   *
   * To dissociate behavioural actions from physical actions
   * ```
   *  muze.ActionModel.dissociateBehaviour(['select', 'click'], ['highlight', 'hover']);
   * ```
   * @public
   * @param  {Array} maps Array of behavioural action and physical action.
   *
   * @return {ActionModel} Instance of action model.
   */
  dissociateBehaviour(...t) {
    return this._registrableComponents.forEach((i) => {
      t.forEach(([n, s, A]) => {
        if (A === "legend") {
          const a = i._registry.interactions.legend.physicalBehaviouralMap.get()[s];
          a && (a.behaviours = a.behaviours.filter(
            (r) => r !== n
          ));
        } else
          i.firebolt().dissociateBehaviour([n, s]);
      });
    }), this;
  }
  /**
   * Breaks the link between side effects and behavioural actions. It takes an array of formal names of the side
   * effects and it's linked behavioural action.
   *
   * To dissociate side effects from behavioural actions
   * ```
   *  muze.ActionModel.dissociateSideEffect(['crossline', 'highlight'], ['selectionBox', 'brush']);
   * ```
   * @public
   * @param  {Array} maps Array of side effects and behavioural actions.
   *
   * @return {ActionModel} Instance of action model.
   */
  dissociateSideEffect(...t) {
    return this._registrableComponents.forEach(
      (i) => i.firebolt().dissociateSideEffect(...t)
    ), this;
  }
  /**
   * By default cross interactivity is disabled between canvases. This enables cross interaction between the canvases
   * so that any action happening in one canvas gets dispatched on other canvases as well. An optional policy can also
   * be passed in this method. The policy can be used to control on which canvases the behavioural actions and
   * side effects gets dispatched.
   *
   * To just enable cross interactivity between two canvases,
   * ```
   *  ActionModel.for(canvas1, canvas2)
   *      .enableCrossInteractivity();
   * ```
   *
   * To enable cross interactivity but enable any behavioural action only when it is triggered from canvas1.
   * ```
   *  ActionModel.for(canvas1, canvas2)
   *      .enableCrossInteractivity({
   *          behaviours: {
   *              // Here * stands for any behavioural action name. We can also give any name of behavioural action
   *              // in place of this.
   *              '*': (propPayload, context) => {
   *                  return propPayload.sourceCanvas === canvas1.alias();
   *              }
   *          }
   *      });
   * ```
   *
   * To enable cross interactivity but enable tooltip effect if the action is propagated from canvas1,
   * ```
   *  ActionModel.for(canvas1, canvas2)
   *      .enableCrossInteractivity({
   *          sideEffects: {
   *              tooltip: (propPayload, context) => {
   *                  return propPayload.sourceCanvas === canvas1.alias();
   *              }
   *          }
   *      });
   * ```
   * @public
   * @param {Object} policy Policy definition.
   *
   * @return {ActionModel} Instance of action model.
   */
  enableCrossInteractivity(t = {}) {
    const i = this._registrableComponents, n = et(
      {},
      fz(i)
    );
    return i.forEach((s) => {
      const A = dz(
        i.filter((o) => o.alias() !== s.alias())
      );
      s.firebolt().interactionPolicy(n).crossInteractionConfig(
        uz(
          t[s.alias()],
          A
        )
      );
    }), this;
  }
}
const mN = new Iz();
class Cz {
  height;
  width;
  top;
  left;
}
class xo {
  _seed;
  _boundBox = new Cz();
  _renderAt;
  _alignWith;
  _alignment;
  _target;
  _position;
  _componentName;
  _className;
  _shouldRender;
  constructor(t, i, n) {
    this._seed = n, this._boundBox = {
      height: i.height,
      width: i.width,
      top: null,
      left: null
    }, this._renderAt = null, this._alignWith = null, this._alignment = null, this._target = null, this._position = null, this._componentName = t, this._className = null, this._shouldRender = !0;
  }
  getLogicalSpace() {
    throw new Error("getLogicalSpace is not defined");
  }
  // eslint-disable-next-line no-unused-vars
  setSpatialConfig() {
    throw new Error("setSpatialSpace is not defined");
  }
  name(t) {
    return t && (this._componentName = t), this._componentName;
  }
  target(t) {
    return t && (this._target = t), this._target;
  }
  position(t) {
    return t && (this._position = t), this._position;
  }
  alignment(t) {
    return t && (this._alignment = t), this._alignment;
  }
  alignWith(t) {
    return t && (this._alignWith = t), this._alignWith;
  }
  renderAt(t = null) {
    return t && (this._renderAt = t), this._renderAt;
  }
  boundBox(t = null) {
    return t && Object.assign(this._boundBox, t), this._boundBox;
  }
  className(t) {
    return t && (this._className = t), this._className;
  }
  // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars
  draw(t) {
    throw new Error("draw is not defined");
  }
  attachListener() {
    return this;
  }
  shouldRender(...t) {
    return t.length ? (this._shouldRender = t[0], this) : this._shouldRender;
  }
}
class Ez extends xo {
  getLogicalSpace() {
    return {
      width: this.boundBox().width,
      height: this.boundBox().height
    };
  }
  setSpatialConfig(t) {
    return this.boundBox({ top: t.y, left: t.x }), this.newDimensions = {
      width: t.width,
      height: t.height
    }, this.renderAt(t.renderAt), this;
  }
  draw() {
    if (!this.component)
      throw new Error(`Component not set for ${this.componentName}`);
    return this.component.mount(document.getElementById(this.renderAt)), this;
  }
}
const py = {
  enabled: !1,
  collapseAll: !1,
  state: []
}, tm = {
  classPrefix: ZA,
  theme: Yb,
  pagination: {
    enabled: !0,
    pageSize: 100,
    pageNumber: 1,
    unionAxisDomainPerPage: !1
  },
  interaction: {
    sideEffects: {
      tooltip: {
        common: !0
      },
      selectionBox: {}
    },
    highlight: {
      propagateDm: !1,
      applyOnVisibleUnits: !0,
      sideEffects: {
        tooltip: {
          // enabled: false,
          contents: [
            {
              name: "highlightSummary",
              setTransform: (e, t, i) => Z(
                i.firebolt.getPayload("brush"),
                "dragging"
              ) ? null : e
            },
            {
              name: "selectionSummary",
              setTransform: (e, t, i) => {
                if (Z(
                  i.firebolt.getPayload("brush"),
                  "dragging"
                ))
                  return null;
                const n = i.firebolt.getEntryExitSet("select"), s = i.firebolt.getEntryExitSet("brush");
                if (n || s) {
                  let A = /* @__PURE__ */ new Set(), o = null;
                  if (Z(n, "entrySet", "length") ? (A = n.entrySet.uids, o = n) : Z(s, "entrySet", "length") && (A = s.entrySet.uids, o = s), BE(e.entrySet.uids, A).size)
                    return o;
                }
                return null;
              }
            }
          ]
        },
        crossline: {},
        [wB]: {}
      }
    },
    select: {
      propagateDm: !0,
      sideEffects: {
        tooltip: {
          contents: [
            {
              name: "selectionSummary"
            }
          ]
        }
      }
    },
    contextMenu: {
      enabled: !1
    },
    brush: {
      propagateDm: !0,
      sideEffects: {
        selectionBox: {}
      }
    },
    tooltip: {
      includeDataFromAllLayers: !1
    }
  },
  scrollBar: {
    thickness: 10,
    speed: 2,
    buttons: {
      show: !0
    },
    vertical: {
      align: "right",
      initialScrollPercent: 0
    },
    horizontal: {
      align: "bottom",
      initialScrollPercent: 0
    }
  },
  legend: {
    includeTotalDomain: !0,
    show: !0,
    position: "right",
    height: 20,
    width: 20,
    interaction: {
      "inverse-select": {
        target: {
          layer: {
            // highlight: {
            //   sideEffects: {
            //     "plot-highlighter": {
            //       rules: [
            //         {
            //           target: "exitSet",
            //           style: {
            //             fill: { a: -0.8 },
            //             stroke: { a: -0.8 },
            //           },
            //         },
            //       ],
            //     },
            //   },
            // },
            filter: {
              sideEffects: {
                filter: {}
              }
            }
          }
        },
        sideEffects: {
          "legend-highlighter": {
            rules: [
              {
                target: "exitSet",
                className: "muze-legend-fadeout"
              }
            ]
          }
        }
      },
      brush: {
        target: {
          layer: {
            highlight: {
              sideEffects: {
                "plot-highlighter": {
                  rules: [
                    {
                      target: "exitSet",
                      style: {
                        fill: { a: -0.8 },
                        stroke: { a: -0.8 }
                      }
                    }
                  ]
                }
              }
            }
          }
        },
        sideEffects: {}
      },
      highlight: {
        target: {
          layer: {
            highlight: {
              sideEffects: {
                "plot-highlighter": {
                  rules: [
                    {
                      target: "exitSet",
                      style: {
                        fill: { a: -0.3 }
                      }
                    }
                  ]
                }
              }
            }
          }
        },
        sideEffects: {
          "legend-highlighter": {
            rules: [
              {
                target: "entrySet",
                className: "muze-legend-brighten"
              }
            ]
          }
        }
      },
      legendHighlight: {
        target: {
          //   layer: {
          //     highlight: {
          //       sideEffects: {
          //         "plot-highlighter": {
          //           rules: [
          //             {
          //               target: "exitSet",
          //               style: {
          //                 fill: { a: -0.3 },
          //               },
          //             },
          //           ],
          //         },
          //       },
          //     },
          //   },
        },
        sideEffects: {
          legendTextTooltip: {
            // rules: [
            //   {
            //     target: "entrySet",
            //     className: "muze-legend-brighten",
            //   },
            // ],
          }
        }
      }
    },
    totalsColor: "#6b7e6b",
    color: {
      padding: 1,
      margin: 3,
      border: 1,
      title: {
        show: !0
      }
    },
    shape: {
      padding: 1,
      margin: 3,
      border: 1,
      title: {
        show: !0
      }
    },
    size: {
      padding: 1,
      margin: 3,
      border: 1,
      title: {
        show: !0
      }
    },
    backgroundColor: {
      padding: 1,
      margin: 3,
      border: 1,
      title: {
        show: !0
      }
    }
  },
  showHeaders: !1,
  virtualScrolling: {
    disabled: !1
  },
  minWidth: 100,
  minHeight: 100,
  border: {
    style: "solid",
    color: "#d6d6d6",
    width: 2,
    collapse: !0,
    spacing: 0
  },
  autoGroupBy: {
    disabled: !1
  },
  invalidValues: {},
  sort: {
    autoSort: {
      disabled: !1
    }
  },
  axisFrom: {},
  axes: {
    x: {
      show: !0,
      compact: !1,
      enableDirectSort: !0,
      showAxisLine: !0,
      interaction: {
        contextMenu: {
          enabled: !1
        },
        menu: {
          showIcon: !1
        }
      }
    },
    y: {
      show: !0,
      compact: !1,
      enableDirectSort: !0,
      showAxisLine: !1,
      interaction: {
        contextMenu: {
          enabled: !1
        },
        menu: {
          showIcon: !1
        }
      }
    }
  },
  useExternalCSS: !1,
  useUTC: !1,
  rows: {
    totalMaxWidthRatio: 0.5,
    interaction: {
      resize: {
        enabled: !0,
        sideEffects: {
          "column-dimension-changer": {
            draggableOutsideChart: !0
          }
        }
      },
      headerTooltip: {
        enabled: !0,
        sideEffects: {
          "column-header-tooltip": {}
        }
      }
    },
    minWidth: 25,
    layout: [],
    totals: {
      subTotals: {
        enabled: !1,
        splitTotal: {
          text: "All"
        },
        text: "All"
      },
      grandTotals: {
        position: "end",
        interaction: {
          select: {
            sideEffects: {}
          }
        },
        enabled: !1,
        text: "Grand Total",
        splitTotal: {}
      },
      data: { totalString: "All" },
      position: "end",
      aggregations: {}
    },
    facets: {
      show: !0,
      format: null,
      className: "",
      labels: {
        align: li,
        style: {
          "font-size": "12px",
          "line-height": "15px",
          color: "#5f5f5f",
          "font-weight": "400",
          "font-family": "'Source Sans Pro','Helvetica Neue', Helvetica, Arial, sans-serif",
          "white-space": "nowrap",
          "transform-origin": "0 0"
        }
      },
      fields: {},
      interaction: {
        collapse: py,
        contextMenu: {
          enabled: !1
        }
      },
      hyperlink: {
        enabled: !1,
        sanitizeHyperlink: !0,
        encode: !0,
        defaultClassName: `${ZA}-hyperlink-text`,
        generateHref: (e) => ({
          target: "_blank",
          rel: "nofollow",
          url: e.formattedValue,
          styles: {},
          classNames: ""
        })
      }
    },
    headers: {
      // by default show === null, because for renderer === "html" ... to be continued
      show: null,
      position: Re,
      fields: {},
      charsAcross: {
        min: 4,
        max: 8
      },
      charsAlong: {
        min: 1,
        max: 1
      },
      enableDirectSort: !0,
      interaction: {
        directSortSelect: {
          sideEffects: {
            "toggle-sort-dropdown": {}
          }
        }
      }
    }
  },
  columns: {
    interaction: {
      resize: {
        enabled: !0,
        sideEffects: {
          "column-dimension-changer": {
            draggableOutsideChart: !0
          }
        }
      },
      headerTooltip: {
        enabled: !0,
        sideEffects: {
          "column-header-tooltip": {}
        }
      }
    },
    layout: [],
    minWidth: 16,
    totals: {
      subTotals: {
        enabled: !1,
        splitTotal: {
          text: "All"
        },
        text: "All"
      },
      grandTotals: {
        position: "top",
        enabled: !1,
        text: "Grand Total",
        splitTotal: {}
      },
      data: { totalString: "All" },
      position: "end",
      aggregations: {}
    },
    facets: {
      show: !0,
      format: null,
      className: "",
      labels: {
        align: li,
        style: {
          "font-size": "12px",
          "line-height": "15px",
          color: "#5f5f5f",
          "font-weight": "400",
          "font-family": "'Source Sans Pro','Helvetica Neue', Helvetica, Arial, sans-serif",
          "white-space": "nowrap",
          "transform-origin": "0 0"
        }
      },
      fields: {},
      interaction: {
        collapse: py,
        contextMenu: {
          enabled: !1
        }
      },
      charsAcross: {
        min: 4
      },
      hyperlink: {
        enabled: !1,
        sanitizeHyperlink: !0,
        encode: !0,
        defaultClassName: `${ZA}-hyperlink-text`,
        generateHref: (e) => ({
          target: "_blank",
          rel: "nofollow",
          url: e.formattedValue,
          styles: {},
          classNames: ""
        })
      }
    },
    headers: {
      show: !0,
      position: Re,
      align: iz,
      padding: 4,
      maxLines: 1,
      className: `${ZA}-column-header-container`,
      separator: "/",
      formatter: (e) => e.fieldNames,
      fields: {},
      charsAcross: {
        min: 4,
        max: 8
      },
      charsAlong: {
        min: 4,
        max: 8
      },
      interaction: {
        directSortSelect: {
          sideEffects: {
            "toggle-sort-dropdown": {}
          }
        }
      }
    }
  }
}, Bz = ["sort"], mz = 600, pz = 400, Qy = `${tm.classPrefix}-layout-container-component`, Qz = `${tm.classPrefix}-layout-container`;
class lC {
  constructor(t) {
    this._host = t.host || null, this._cut = t.cut || null, this._ratioWeight = t.ratioWeight === 0 ? 0 : t.ratioWeight || 1, this._preferred = t.preferred || !1, this._lanes = t.lanes || [], this._remainingHeight = 0, this._remainingWidth = 0;
  }
  host(t) {
    return t && (this._host = t), this._host;
  }
  preferred(t) {
    return t && (this._preferred = t), this._preferred;
  }
  cut(t) {
    return t && (this._cut = t), this._cut;
  }
  ratioWeight(t) {
    return t && (this._ratioWeight = t), this._ratioWeight;
  }
  lanes(t) {
    return t && (this._lanes = t), this._lanes;
  }
  remainingHeight(t) {
    return t && (this._remainingHeight = t), this._remainingHeight;
  }
  remainingWidth(t) {
    return t && (this._remainingWidth = t), this._remainingWidth;
  }
}
const yz = /* @__PURE__ */ (() => {
  let e = 0;
  return () => `${Qz}-${++e}`;
})();
function em(e) {
  let t = 0;
  if (e.getCutType() === "v")
    t = wz(e);
  else if (e.getCutType() === "h")
    e.children().forEach((i) => {
      t += em(i);
    });
  else if (e.model().host() && e.model().host().getLogicalSpace) {
    const i = e.boundBox().height, n = e.model().host().getLogicalSpace().height;
    t = i - n, t < 0 && (t = 0);
  } else
    t = 0;
  return t;
}
function wz(e) {
  let t = Number.MAX_SAFE_INTEGER;
  return e.children().forEach((i) => {
    const n = em(i);
    n < t && (t = n);
  }), t;
}
function im(e) {
  let t = 0;
  if (e.getCutType() === "h")
    t = Dz(e);
  else if (e.getCutType() === "v")
    e.children().forEach((i) => {
      t += im(i);
    });
  else if (e.model().host() && e.model().host().getLogicalSpace) {
    const i = e.boundBox().width, n = e.model().host().getLogicalSpace().width;
    t = i - n, t < 0 && (t = 0);
  } else
    t = 0;
  return t;
}
function Dz(e) {
  let t = Number.MAX_SAFE_INTEGER;
  return e.children().forEach((i) => {
    const n = im(i);
    n < t && (t = n);
  }), t;
}
function xz(e, t, i, n) {
  if (t) {
    const o = i[t - 1], { top: a, left: r, height: l, width: c } = o.boundBox();
    return {
      width: e.width,
      height: e.height,
      top: n.parentCut() === "h" ? a + l : a,
      left: n.parentCut() === "h" ? r : r + c
    };
  }
  const { top: s, left: A } = n.parent().boundBox();
  return {
    width: e.width,
    height: e.height,
    top: s,
    left: A
  };
}
function Sz(e) {
  e.targetComponentMap(/* @__PURE__ */ new Map()), e.componentMap().forEach((t) => {
    if (e.targetComponentMap().has(t.target()))
      e.targetComponentMap().get(t.target()).push(t);
    else {
      const i = [];
      i.push(t), e.targetComponentMap().set(t.target(), i);
    }
  });
}
function _z(e, t) {
  const i = e.find((n) => n.name() === t);
  return i && i !== -1 ? i : null;
}
function bz(e, t, i) {
  const n = new Ez(0, { height: e, width: t });
  return n.name("placeHolder"), n.position(i), n;
}
function cC(e, t, i = !1, n = !1) {
  let s = "", A = 1, o = 1, a = 0, r = 0;
  if (!t)
    return { first: e, second: e };
  const { height: l, width: c } = t.getLogicalSpace(), g = t.position();
  g === "top" || g === "bottom" ? (s = "h", A = l / e.remainingHeight(), a = e.remainingHeight() - l, r = e.remainingWidth()) : (s = "v", A = c / e.remainingWidth(), r = e.remainingWidth() - c, a = e.remainingHeight()), o = 1 - A, e.cut(s);
  const h = {
    host: t.name(),
    cut: null,
    ratioWeight: A,
    preferred: n ? !1 : i,
    lanes: []
  }, d = new lC(h);
  d.remainingHeight(l), d.remainingWidth(c);
  const u = {
    host: null,
    cut: null,
    ratioWeight: o,
    preferred: n ? !1 : !i,
    lanes: []
  }, f = new lC(u);
  return f.remainingHeight(a), f.remainingWidth(r), i ? e.lanes([d]) : g === "top" || g === "left" ? e.lanes([d, f]) : e.lanes([f, d]), { first: d, second: f };
}
function Mz(e, t) {
  let i = e;
  const n = t.length, s = n ? t[0].length : 0, A = t.reduce((o, a) => o + a[0].getLogicalSpace().height, 0);
  for (let o = 0; o < s; o++) {
    const a = o === s - 1, r = bz(
      A,
      t[0][o].getLogicalSpace().width,
      "left"
    ), { first: l, second: c } = cC(i, r, a);
    i = l;
    for (let g = 0; g < n; g++) {
      const h = g === n - 1;
      i = cC(i, t[g][o], h, !0).second;
    }
    i = c;
  }
  return i;
}
function gC(e) {
  let t, i = 0, n, s;
  const A = e.children().length;
  for (let o = 0; o < A; o++) {
    let a, r;
    const l = e.children()[o];
    if (l.parentCut() === "h" ? (a = em, n = "height", s = "width") : (a = im, n = "width", s = "height"), l.isPreferred()) {
      t = l;
      continue;
    }
    i += r = a(l), l.boundBox()[n] -= r, l.boundBox()[s] = l.parent().boundBox()[s], gC(l);
  }
  t && (t.boundBox()[n] += i, t.boundBox()[s] = t.parent().boundBox()[s], gC(t));
}
function pN(e) {
  e.children().forEach((t, i, n) => {
    const s = xz(t.boundBox(), i, n, t);
    t.boundBox(s), pN(t);
  });
}
function QN(e) {
  const t = e.children().map((i) => i.model().ratioWeight()).reduce((i, n) => i + n, 0);
  e.children().forEach((i, n, s) => {
    const A = s[n - 1], o = i.model().ratioWeight() / t;
    i.parentCut() === "h" ? i.boundBox({
      top: n ? A.boundBox().top + A.boundBox().height : 0,
      left: i.parent().boundBox().left,
      height: i.parent().boundBox().height * o,
      width: i.parent().boundBox().width
    }) : i.boundBox({
      top: i.parent().boundBox().top,
      left: n ? A.boundBox().left + A.boundBox().width : 0,
      height: i.parent().boundBox().height,
      width: i.parent().boundBox().width * o
    }), QN(i);
  });
}
let Nz = class {
  constructor(t) {
    this._model = t, this._parent = null, this._children = [], this._parentCut = null, this._boundBox = {
      top: null,
      left: null,
      height: null,
      width: null
    }, this._id = this._model.host() instanceof xo && this._model.host().renderAt() ? this._model.host().renderAt() : yz();
  }
  addChildren(t) {
    this._children.push(...t), t.forEach((i) => {
      i.parent(this);
    });
  }
  isRoot() {
    return this._parent === null;
  }
  isLeaf() {
    return !this._children.length;
  }
  getCutType() {
    return this._model.cut();
  }
  isPreferred() {
    return !!this._model.preferred();
  }
  children(t) {
    return t && (this._children = t), this._children;
  }
  parent(t) {
    return t && (this._parent = t), this._parent;
  }
  parentCut(t) {
    return t && (this._parentCut = t), this._parentCut;
  }
  id(t) {
    return t && (this._id = t), this._id;
  }
  model(t) {
    return t && (this._model = t), this._model;
  }
  boundBox(t) {
    return t && (this._boundBox = {
      top: t.top,
      left: t.left,
      height: t.height,
      width: t.width
    }), this._boundBox;
  }
  /**
     * function to search a node and update it with the config provided.
     * @param  {Object} nodeconfig
     */
  updateNode(t) {
    this._id === t._id ? (this._model.cut(t.cut), this._model.ratioWeight(t.ratioWeight)) : this._children.forEach((i) => {
      if (i._id === t._id) {
        i.model.cut(t.cut), i.model.ratioWeight(t.ratioWeight);
        return;
      }
      this.searchNode(i, t);
    });
  }
  // Recursive function to search a node
  searchNode(t, i) {
    t.children().forEach((n) => {
      n.id() === i._id ? (n.model().cut(i.cut), n.model().ratioWeight(i.ratioWeight)) : this.searchNode(n, i);
    });
  }
  /**
     * function to delete a node from tree Structure.
     * @param  {String} nodeId - node Id of the Node
     */
  delete(t) {
    this._children.forEach((i) => {
      if (i.id() === t) {
        const n = this._children.indexOf(i);
        this._model.lanes().splice(n, 1);
      }
      this.deleteSearchNode(i, t);
    });
  }
  // Recursive function to search a node
  deleteSearchNode(t, i) {
    t.children().forEach((n) => {
      if (n.id() === i) {
        const s = t.children().indexOf(n);
        t.model().lanes().splice(s, 1);
      } else
        this.deleteSearchNode(n, i);
    });
  }
};
class nm {
  constructor(t, i) {
    this._measurements = t, this._config = i, this._root = this.createTree(this._config, null), this.setBoundBox();
  }
  createTree(t, i) {
    const n = new Nz(t);
    i ? (n.parentCut(i.getCutType()), i.addChildren([n])) : this._root = n;
    for (const s of t.lanes())
      this.createTree(s, n);
    return this._root;
  }
  setBoundBox() {
    this._root.boundBox({
      top: 0,
      left: 0,
      width: this._measurements.width,
      height: this._measurements.height
    }), QN(this._root);
  }
  setHostPosition(t) {
    t.children().forEach((i) => {
      nm.setHostSpatialConfig(i), this.setHostPosition(i);
    });
  }
  static setHostSpatialConfig(t) {
    const i = t.boundBox(), n = t.model().host();
    if (n && n.setSpatialConfig) {
      const s = {
        x: i.left,
        y: i.top,
        width: i.width,
        height: i.height,
        renderAt: t.id()
      };
      n.setSpatialConfig(s);
    }
  }
  negotiate() {
    return gC(this._root), pN(this._root), this;
  }
  broadcast() {
    return this.setHostPosition(this._root), this;
  }
  tree() {
    return this._root;
  }
}
const Fz = {
  top: 0,
  center: 1,
  bottom: 2
}, uA = {
  0: "top",
  1: "center",
  2: "bottom"
}, Cr = {
  0: "left",
  1: "middle",
  2: "right"
}, Rz = "width", kz = "height", vz = "border", Tz = "rowPointer", Gz = "columnPointer", Lz = "isRowSizeEqual", Uz = "isColumnSizeEqual", Hz = "unitWidth", Oz = "unitHeight", Pz = "style", Yz = "color", DA = "width", Jz = "collapse", Kz = "spacing", Vz = "distribution", Wz = "gutterSpace", qz = "breakPage", fd = "height", Jn = "column", Kn = "row", In = "top", Vn = "left", Wn = "right", Cn = "bottom", Ai = "center", hC = "rowSpan", dC = "colSpan", jz = "rowRoot", zz = "columnRoot", Xs = "primary", ta = "secondary", yN = "vertical", wN = "horizontal", $z = "grid", Xz = "pagination", Zz = "buffer", t$ = "holistic", e$ = "scroll", Ff = "middle", fg = null, i$ = "maxWidthAvailableForColumnMatrix", n$ = "columnMatrix", s$ = "maxHeightAvailableForRowMatrix", A$ = "rowMatrix", o$ = 3, a$ = 3;
class uC {
  static isDOMElement(t) {
    return t instanceof Element;
  }
  static getID(t) {
    return t.id;
  }
  static getElement(t) {
    return document.getElementById(t);
  }
  static findContainer(t) {
    return t.filter((i) => i.parent == null)[0];
  }
  /**
   * static method to remove the div
   * @param  {} divId - div ID to be removed.
   */
  static removeDiv(t) {
    document.getElementById(t) !== null && document.getElementById(t).remove();
  }
}
class r$ {
  constructor(t) {
    this._node = t, this._className = t.model().host() instanceof xo ? t.model().host().className() : Qy;
  }
  node() {
    return this._node;
  }
  hasHost() {
    return this._node.model().host() instanceof xo;
  }
  className() {
    return this._className || Qy;
  }
}
const DN = (e, t) => {
  const i = new r$(e);
  t.push(i), e.children().forEach((n) => {
    DN(n, t);
  });
};
class l$ {
  constructor(t) {
    this._data = t;
  }
  defaultDataPointLogic() {
    const t = [];
    return DN(this._data, t), t;
  }
}
class c$ extends l$ {
  getCoordinates() {
    return super.defaultDataPointLogic();
  }
}
class g$ {
  initRenderer() {
  }
}
class h$ extends g$ {
  constructor(t) {
    super(), this._data = t, this._coordinates = new c$(this._data).getCoordinates();
  }
  createhtml(t, i) {
    const n = t;
    super.initRenderer(n, this._data), this.parentDiv = this.createAndCustomiseParent(i), this._coordinates.forEach((s) => {
      if (s.hasHost()) {
        const A = s.node();
        this.parentDiv.appendChild(
          this.createAndPositionDiv({
            ...A.boundBox(),
            id: A.id(),
            className: s.className()
          })
        );
      }
    }), n.appendChild(this.parentDiv);
  }
  createAndPositionDiv(t) {
    const { top: i, left: n, height: s, width: A, className: o, id: a } = t, l = document.getElementById(a) || document.createElement("div");
    return l.style.position = "absolute", l.style.left = `${n}px`, l.style.top = `${i}px`, l.style.height = `${s}px`, l.style.width = `${A}px`, l.id = a, l.className = o, l;
  }
  createAndCustomiseParent(t) {
    const i = uC.findContainer(this._coordinates), n = i.node(), s = this.createAndPositionDiv({
      ...n.boundBox(),
      id: n.id(),
      className: i.className()
    });
    return s.className = t, s.style.position = "relative", s;
  }
  destroyParent() {
    this.parentDiv.remove();
  }
  coordinates() {
    return this._coordinates;
  }
}
const fl = (e, t) => e.renderer().coordinates().find((i) => i.node().id() === t), d$ = (e) => {
  e.renderer(new h$(e.data())), e.renderer().createhtml(e.mount(), e.className());
}, u$ = (e) => d$(e), xN = (e) => {
  e.children().forEach((t) => {
    const i = t.model().host();
    i instanceof xo && i.shouldRender() && i.draw(), xN(t);
  });
}, f$ = (e) => {
  e && X(`#${e}`).remove();
}, I$ = (e, t, i) => {
  let n = {};
  const { node: s, refNode: A } = i;
  switch (t) {
    case "left":
      n = {
        top: s.top,
        left: A.left,
        height: s.height,
        width: Math.abs(s.width - Math.abs(A.left - s.left))
      };
      break;
    case "right":
      n = {
        top: s.top,
        left: s.left,
        height: s.height,
        width: Math.abs(
          s.width - Math.abs(s.left + s.width - (A.left + A.width))
        )
      };
      break;
    case "top":
      n = {
        top: A.top,
        left: s.left,
        height: Math.abs(s.height - Math.abs(A.top - s.top)),
        width: s.width
      };
      break;
    case "bottom":
      n = {
        top: s.top,
        left: s.left,
        height: Math.abs(s.top - A.top + A.height),
        width: s.width
      };
      break;
    case "h-center":
      n = {
        top: s.top,
        left: A.left,
        height: s.height,
        width: A.width
      };
      break;
    case "v-center":
      n = {
        top: A.top,
        left: s.left,
        height: A.height,
        width: s.width
      };
      break;
    case "extended-h-center": {
      const o = e.componentMap().get(`${uA[1]}-${Cr[0]}`), a = o && fl(e, o.renderAt()).node().boundBox(), r = e.data().boundBox(), l = e.componentMap().get("rightLegend"), c = l && fl(e, l.renderAt()).node().boundBox(), g = c && !Number.isNaN(c.width) ? c.width : 0, h = r.width - a.left - g;
      n = {
        top: s.top,
        left: a.left,
        height: s.height,
        width: h
      };
      break;
    }
    case "extended-v-center": {
      let a = e.data().boundBox().height - A.top;
      const r = e.componentMap().get("title");
      if (r && r.position() === Cn) {
        const l = fl(e, r.renderAt()).node().boundBox();
        a -= Number.isNaN(l.height) ? 0 : l.height;
      }
      n = {
        top: A.top,
        left: s.left,
        height: a,
        width: s.width
      };
      break;
    }
  }
  return n;
}, SN = (e, t) => {
  t.children().forEach((i) => {
    const n = i.model().host();
    if (n instanceof xo && n.alignWith()) {
      const s = e.componentMap().get(n.alignWith());
      if (s) {
        const A = fl(e, i.id()).node(), o = A.boundBox(), a = fl(e, s.renderAt()).node().boundBox(), r = I$(e, n.alignment(), {
          node: o,
          refNode: a
        });
        Object.assign(r, {
          id: A.id(),
          className: n.className()
        }), e.renderer().createAndPositionDiv(r), e.componentMap().get(n.name()).setSpatialConfig({
          x: r.left,
          y: r.top,
          height: r.height,
          width: r.width
        });
      }
    }
    SN(e, i);
  });
};
class C$ {
  constructor(t, i, n) {
    this._data = t.tree, this._componentMap = t.componentMap, this._layoutClassName = t.layoutClassName, this._renderer = i, this._mount = uC.isDOMElement(n) ? n : uC.getElement(n);
  }
  destroyRoot() {
    this.renderer().destroyParent && this.renderer().destroyParent();
  }
  draw() {
    return u$(this), SN(this, this._data), xN(this._data), this;
  }
  data(t) {
    return t ? (this._data = t, this) : this._data;
  }
  componentMap(t) {
    return t ? (this._componentMap = t, this) : this._componentMap;
  }
  className(t) {
    return t ? (this._layoutClassName = t, this) : this._layoutClassName;
  }
  renderer(t) {
    return t && (this._renderer = t), this._renderer;
  }
  mount(t) {
    return t && (this._mount = t), this._mount;
  }
}
class E$ {
  constructor(t, i, n, s) {
    this._componentMap = t, this._prioritySequence = i, this._totalHeight = n, this._totalWidth = s, this._targetComponentMap = null;
  }
  // create the config model
  generateConfigModel() {
    Sz(this);
    const t = this._targetComponentMap.get("canvas"), i = new lC({});
    let n = i;
    i.remainingHeight(this._totalHeight), i.remainingWidth(this._totalWidth);
    let s = null;
    return this._prioritySequence.forEach((A) => {
      s = _z(t, A), A !== "grid" ? n = cC(n, s).second : n = Mz(n, s.component);
    }), i;
  }
  componentMap(t) {
    return t && (this._componentMap = t), this._componentMap;
  }
  targetComponentMap(t) {
    return t && (this._targetComponentMap = t), this._targetComponentMap;
  }
}
function _N(e, t) {
  const i = t.host();
  t.lanes() && t.lanes().length && t.lanes().forEach((n) => _N(e, n)), i != null && typeof i == "string" && e.componentMap().get(i) !== void 0 && t.host(e.componentMap().get(i));
}
function B$(e) {
  const { height: t, width: i } = e.dimension();
  return new E$(
    e.layoutDef().componentMap(),
    e.prioritySequence(),
    t,
    i
  ).generateConfigModel();
}
class m$ {
  constructor() {
    this._componentMap = /* @__PURE__ */ new Map(), this._layoutDefinition = null;
  }
  addComponent(t) {
    this._componentMap.set(t.name(), t);
  }
  layoutDefinition(t) {
    return t && (this._layoutDefinition = t), this._layoutDefinition;
  }
  addMultipleComponent(t) {
    t.forEach((i) => {
      this.addComponent(i);
    });
  }
  sanitizedDefinition() {
    return _N(this, this._layoutDefinition), this.layoutDefinition();
  }
  componentMap() {
    return this._componentMap;
  }
  resetComponentMap() {
    this._componentMap.clear();
  }
}
class p$ {
  constructor(t) {
    this._renderAt = t.renderAt, this._layoutClassName = t.className, this._dimension = {
      width: t.width || mz,
      height: t.height || pz
    }, this._skeletonType = t.skeletonType || "html", this._layoutDefinition = null, this._layoutDef = new m$(), this._drawingManager = null, this._prioritySequence = [], this.tree = null, this._rootNodeID = null;
  }
  layoutDef(t) {
    return t && (this._layoutDef = t), this._layoutDef;
  }
  prioritySequence(t) {
    return t && (this._prioritySequence = t), this._prioritySequence;
  }
  dimension(t) {
    return t && Object.assign(this._dimension, t), this._dimension;
  }
  addComponent(t) {
    this._layoutDef.addComponent(t);
  }
  addMultipleComponent(t) {
    this._layoutDef.addMultipleComponent(t);
  }
  resetNode(t) {
    this.con && this.con.resetNode(t);
  }
  /**
   * function to update the node and rerender the layout.
   * @param  {} config - node configuration to change.
   */
  updateNode(t) {
    this.tree.updateNode(t), this._layoutDefinition = this.tree.model, this.compute();
  }
  compute() {
    this._layoutDefinition = B$(this), this._layoutDef.layoutDefinition(this._layoutDefinition), this._layoutDefinition = this._layoutDef.sanitizedDefinition(), this._layout = new nm(
      {
        width: this._dimension.width,
        height: this._dimension.height
      },
      this._layoutDefinition
    ), this.tree = this._layout.negotiate().tree(), this._layout.broadcast(), this._drawingManager ? this._drawingManager.data(this.tree).componentMap(this._layoutDef.componentMap()).className(this._layoutClassName) : this._drawingManager = new C$(
      {
        tree: this.tree,
        componentMap: this._layoutDef.componentMap(),
        layoutClassName: this._layoutClassName
      },
      this._skeletonType,
      this._renderAt
    ), this._rootNodeID ? this.tree.id(this._rootNodeID) : this._rootNodeID = this.tree.id();
  }
  render() {
    this._drawingManager.draw();
  }
  getRootNodeId() {
    return this._rootNodeID;
  }
  /**
   * This function takes the LayoutComponents and Register them in component store
   * @param {Array<LayoutComponent>} layoutComponents
   */
  registerComponents(t) {
    return this._prioritySequence.length = 0, this._layoutDef.resetComponentMap(), t.forEach((i) => {
      i && (this._prioritySequence.push(i.name()), this.addComponent(i), i.name() === "grid" && i.component.forEach((n) => {
        n.forEach((s) => {
          this.addComponent(s);
        });
      }));
    }), this;
  }
  getComponent(t) {
    return this._layoutDef.componentMap().get(t);
  }
  deleteElement(t, i) {
    this._layoutDef.componentMap().delete(i);
    const n = t.renderAt();
    return t.remove(), f$(n);
  }
  removeComponent(t) {
    const i = this.getComponent(t);
    return i ? t === $z ? i.component.map(
      (n) => n.map((s) => this.deleteElement(s, s.name()))
    ) : this.deleteElement(i, t) : this;
  }
  removeAllComponents() {
    const t = this.layoutDef().componentMap().keys();
    this._drawingManager != null && this._drawingManager.destroyRoot();
    for (const i of t)
      this.removeComponent(i);
  }
  renderAt(t) {
    return t && (this._renderAt = t), this._renderAt;
  }
}
class So extends xo {
  newDimensions;
  getLogicalSpace() {
    const { width: t, height: i } = this.boundBox();
    return { width: t, height: i };
  }
  // @ts-expect-error
  setSpatialConfig(t) {
    this.boundBox({ top: t.y, left: t.x }), this.newDimensions = {
      width: t.width,
      height: t.height
    }, this.renderAt(t.renderAt);
  }
  getBoundBox() {
    return this.boundBox();
  }
  // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars
  updateWrapper(t) {
    throw Error("Update is not implemented");
  }
  // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars
  setParams(t) {
    throw Error("set params is not implemented");
  }
  // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars
  setComponentInfo(t) {
    throw Error("setComponentInfo is not implemented");
  }
  remove() {
    return this;
  }
}
const yy = (e) => Array.from(Array(e.length).keys()), wy = (e, t, i = {}) => {
  let { order: n, keyFn: s } = i;
  const A = t.slice(), o = e.slice(), a = o.slice();
  if (n = n || Array.from(Array(A.length).keys()), s = s || ((h) => h), o.length === 0) {
    const h = [];
    return n.forEach((d) => {
      h.push(A[d]);
    }), { prevStack: a, currStack: A, arr: h };
  }
  let r = "", l = "";
  const c = [];
  for (let h = n.length - 1; h >= 0; h--) {
    const d = n[h];
    if (r += s(A[d]), l += s(o[d]), r === l)
      c[d] = null;
    else {
      l = "";
      for (let u = h; u < n.length; u++) {
        const f = n[u], C = A[f];
        c[f] = C, o[f] = C, l = r;
      }
    }
  }
  const g = [];
  return n.forEach((h) => {
    g.push(c[h]);
  }), { prevStack: a, currStack: o, arr: g };
}, Dy = (e, t, i, n) => {
  if (!e)
    return () => null;
  const s = {
    row: (A) => i[n + A] && i[n + A][t],
    column: (A) => i[n][t + A]
  };
  return (A) => {
    let o = 1, a = !1;
    for (; !a; )
      s[A](o) === null ? o += 1 : a = !0;
    return o;
  };
}, Ig = (e, t) => ({
  row: () => {
    let i = [];
    return e.map((n) => {
      const { currStack: s, arr: A } = wy(i, n, {
        keyFn: (o) => o.key(),
        order: t
      });
      return i = s, A;
    });
  },
  column: () => {
    let i = [];
    const n = [];
    return e.length && e[0].forEach((s, A) => {
      const o = [];
      e.forEach((l) => {
        o.push(l[A]);
      });
      const { currStack: a, arr: r } = wy(i, o, {
        keyFn: (l) => l.key(),
        order: t
      });
      i = a, e.forEach((l, c) => {
        n[c] = n[c] || [], n[c][A] = r[c];
      });
    }), n;
  }
}), Cg = (e) => ({
  row: () => {
    const t = [];
    return e.forEach((i, n) => {
      t[n] = t[n] || [], i.forEach((s, A) => {
        if (e[n][A]) {
          const o = Dy(s, A, e, n)("row");
          o && t[n].push(o);
        }
      });
    }), t;
  },
  column: () => e.map(
    (t, i) => t.map((n, s) => Dy(n, s, e, i)("column")).filter((n) => n !== null)
  )
}), Eg = () => ({
  row: (e) => yy(e[0]),
  column: (e) => yy(e)
}), Q$ = {
  [`${In}-1`]: {
    orderGetter: Eg()[Jn],
    viewMatrixMaker: (...e) => Ig(...e)[Jn],
    spanMaker: (...e) => Cg(...e)[Jn]
  },
  [`${Cn}-1`]: {
    orderGetter: Eg()[Jn],
    viewMatrixMaker: (...e) => Ig(...e)[Jn],
    spanMaker: (...e) => Cg(...e)[Jn]
  },
  [`${Ai}-0`]: {
    orderGetter: Eg()[Kn],
    viewMatrixMaker: (...e) => Ig(...e)[Kn],
    spanMaker: (...e) => Cg(...e)[Kn]
  },
  [`${Ai}-2`]: {
    orderGetter: Eg()[Kn],
    viewMatrixMaker: (...e) => Ig(...e)[Kn],
    spanMaker: (...e) => Cg(...e)[Kn]
  }
}, y$ = (e) => {
  const t = Q$[e];
  return t || {
    orderGetter: () => null,
    viewMatrixMaker: (i) => () => i,
    spanMaker: () => () => null
  };
};
function bN(e, t, i) {
  let n = null, s = e;
  const { orderGetter: A, viewMatrixMaker: o, spanMaker: a } = y$(
    `${t}-${i}`
  );
  if (e.length) {
    const r = A(e);
    s = o(e, r)(), n = a(s)();
  }
  return { viewMatrix: s, spans: n };
}
const w$ = (e = 1, t, i, n, s) => {
  const A = t.availHeight(), o = t.availWidth(), a = i.border.width, { unitWidths: r, unitHeights: l } = i.dimensions, { row: c, col: g } = n, { startRowIdx: h = 0, startColIdx: d = 0 } = s;
  return {
    [hC]() {
      const u = l.primary[h + c];
      if (e > 1) {
        let f = 0;
        for (let C = c; C < c + e; C++)
          f += l.primary[h + C] - a;
        t.setAvailableSpace(o, f + a);
      } else u && (t.setAvailableSpace(o, u - a), X(this).style("height", `${u}px`));
      X(this).style("width", `${o}px`);
    },
    [dC]() {
      const u = r.primary[d + g];
      if (e > 1) {
        let f = 0;
        for (let C = g; C < g + e; C++)
          f += r.primary[d + C] - a;
        t.setAvailableSpace(f + a, A);
      } else u && t.setAvailableSpace(u - a, A);
      X(this).style("height", `${A}px`);
    }
  };
}, Bg = (e, t, i, n, s) => {
  let A = 0;
  e.attr(s, function(o, a) {
    a === 0 && (A = 0);
    const r = t[o.rowIndex][a], l = o.placeholder, c = {
      row: o.rowIndex,
      col: A
    };
    return w$(r, l, i, c, n)[s].bind(this)(), A += r, r;
  });
}, D$ = {
  [`${In}-0`]: null,
  [`${In}-1`]: (...e) => Bg(...e, dC),
  [`${In}-2`]: null,
  [`${Ai}-0`]: (...e) => Bg(...e, hC),
  [`${Ai}-1`]: null,
  [`${Ai}-2`]: (...e) => Bg(...e, hC),
  [`${Cn}-0`]: null,
  [`${Cn}-1`]: (...e) => Bg(...e, dC),
  [`${Cn}-2`]: null
}, MN = (e, t, i, n, s) => {
  const A = D$[n];
  A && A(e, t, i, s || {});
}, x$ = (e, t) => ({
  [`${In}-${Vn}`]: e && t ? Vn : fg,
  [`${In}-${Ff}`]: Jn,
  [`${In}-${Wn}`]: e && t ? Wn : fg,
  [`${Ai}-${Vn}`]: e ? `${Ai}${Vn}` : Kn,
  [`${Ai}-${Ff}`]: Ai,
  [`${Ai}-${Wn}`]: e ? `${Ai}${Wn}` : Kn,
  [`${Cn}-${Vn}`]: fg,
  [`${Cn}-${Ff}`]: Jn,
  [`${Cn}-${Wn}`]: fg
}), S$ = (e) => {
  const { type: t, borderWidth: i, borderStyle: n, cells: s, color: A } = e;
  s.style(`border-${t}`, `${i}px ${n} ${A}`);
}, FA = (e) => {
  const { borderTypes: t, showBorders: i, cells: n, borderInfo: s, name: A, isFacet: o } = e, {
    color: a,
    style: r,
    width: l
  } = s;
  t.forEach((c) => {
    S$({
      cells: n,
      color: i[c] ? a : "transparent",
      type: c,
      borderWidth: l,
      borderStyle: r
    });
  });
}, _$ = (e, t, i, n) => {
  const {
    showRowBorders: s,
    showColBorders: A,
    showValueBorders: o
  } = t;
  return {
    [Kn]: () => FA({
      borderTypes: [In, Cn],
      showBorders: s,
      cells: e,
      borderInfo: t,
      name: i,
      isFacet: n
    }),
    [Jn]: () => FA({
      borderTypes: [Vn, Wn],
      showBorders: A,
      cells: e,
      borderInfo: t,
      name: i,
      isFacet: n
    }),
    [Ai]: () => FA({
      borderTypes: [Vn, Wn, In, Cn],
      showBorders: o,
      cells: e,
      borderInfo: t,
      name: i,
      isFacet: n
    }),
    [Vn]: () => FA({
      borderTypes: [Vn],
      showBorders: s,
      cells: e,
      borderInfo: t,
      name: i,
      isFacet: n
    }),
    [Wn]: () => FA({
      borderTypes: [Wn],
      showBorders: s,
      cells: e,
      borderInfo: t,
      name: i,
      isFacet: n
    }),
    [`${Ai}${Vn}`]: () => FA({
      borderTypes: [Vn, In, Cn],
      showBorders: s,
      cells: e,
      borderInfo: t,
      name: i,
      isFacet: n
    }),
    [`${Ai}${Wn}`]: () => FA({
      borderTypes: [Wn, In, Cn],
      showBorders: s,
      cells: e,
      borderInfo: t,
      name: i,
      isFacet: n
    })
  };
}, NN = (e) => {
  const { cells: t, border: i, row: n, column: s, isFacet: A, showHeaders: o } = e, a = `${uA[Fz[n]]}-${Cr[s]}`, r = _$(t, i, a, A), l = x$(A, o)[a];
  l && r[l]();
}, b$ = (e) => {
  e.each(function(t) {
    t.placeholder.render(this);
  });
};
class FN extends So {
  constructor(t) {
    super(t.name, t.config.dimensions, 0), this.setParams(t), this.className(t.config.className), this._mount = null;
  }
  mount(...t) {
    return t.length ? (this._mount = t[0], this) : this._mount;
  }
  applyScroll(t) {
    const i = this.params.config.row, n = this.params.config.column, { horizontal: s, vertical: A } = this.params.config.scrollInfo;
    t.style(Nf, oz), t.style($i, By), t.style(Xi, By), s && n === 1 && (t.style(Nf, Ey), t.style($i, "100%")), A && i === Ai && (t.style(Nf, Ey), t.style(Xi, "100%"));
  }
  render() {
    const {
      classPrefix: t,
      row: i,
      column: n,
      dimensions: s,
      border: A,
      isFacet: o,
      showHeaders: a
    } = this.params.config, r = this.mount(), l = z(
      r,
      "div",
      [1],
      `${t}-grid-${i}-${n + 1}`
    ).classed(`${t}-grid-${i}`, !0).classed(`${t}-grid`, !0);
    this.applyScroll(l);
    const { viewMatrix: c, spans: g } = bN(this.component, i, n), { cells: h } = this.renderTable(
      l,
      `${t}-grid`,
      c
    );
    MN(h, g, { dimensions: s, border: A }, `${i}-${n}`), b$(h), h.exit().each((d) => {
      d.placeholder.remove();
    }), NN({ cells: h, border: A, row: i, column: n, isFacet: o, showHeaders: a });
  }
  renderTable(t, i, n) {
    const s = z(t, "table", ["layout"], `${i}-table`), A = z(s, "tbody", ["layout"], `${i}-body`), o = z(A, "tr", n, `${i}-tr`), a = z(
      o,
      "td",
      (r, l) => r.map((c, g) => ({ placeholder: c, rowIndex: l, colIndex: g })).filter((c) => c.placeholder !== null),
      `${i}-td`,
      {
        update: (r, l) => {
          const { externalClassname: c } = l.placeholder.config();
          c && c.map(
            (g) => r.classed(`${i}-${g}`, !0)
          );
        }
      },
      (r) => r.placeholder.id
    );
    return { table: s, body: A, rows: o, cells: a };
  }
  draw(t) {
    this.mount(t || document.getElementById(this.renderAt())), this.render();
  }
  updateWrapper(t) {
    return this.name(t.name), this.boundBox(t.config.dimensions), this.setParams(t), this;
  }
  setParams(t) {
    this.component = t.component, this.params = t, this.target(t.config.target), this.position(In), this.className(t.config.className);
  }
}
const M$ = "margin", Ci = "left", Ei = "right", Pi = "bottom", Yi = "top", N$ = "spaceFixer", En = "muze", F$ = "verticalAlign", R$ = "textAlign", k$ = "isOffset", v$ = "show", T$ = "center", fC = "header", RN = "headerTitle", HA = "rowFacetHeader", nl = "columnFacetHeader", Il = "height", Fa = "width", G$ = "maxLines", L$ = "minCharacters", U$ = "rotation", H$ = "text-cell", xy = "axis-cell", O$ = "geom-cell", P$ = "blank-cell", Y$ = "padding", kN = "headerPadding", J$ = "titlePadding", Id = "headerTitlePadding", IC = "facetHeaderPadding", vN = "facetHeaderPadding", TN = "facetHeaderPadding", K$ = "title", sm = "subtitle", VA = 5, Sy = "total", V$ = "simple", sl = "text", qg = "axis", jg = "geom", zg = "blank", W$ = "composite-text", GN = "SimpleCell", LN = "TextCell", UN = "AxisCell", HN = "BlankCell", ON = "GeomCell", _y = "CompositeTextCell";
class Er {
  /**
   * Creates an instance of SimpleCell.
   *
   * @param {*} config The input configuration.
   * @memberof SimpleCell
   */
  constructor(t) {
    this._id = Zt();
    const i = et({}, this.constructor.defaultConfig());
    this._config = et(i, t || {}), this._mount = null, this._source = null;
  }
  /**
   * Returns the type of the placehlder.
   *
   * @memberof SimpleCell
   */
  get type() {
    return V$;
  }
  static formalName() {
    return GN;
  }
  /**
   * Returns the type of the placehlder.
   *
   * @memberof SimpleCell
   * @return {Object} Default config for the placeholder
   */
  static defaultConfig() {
    return {};
  }
  /**
   * Returns the value contained by the SimpleCell.
   *
   * @memberof SimpleCell
   */
  valueOf() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Returns a unique identifier for the instance used
   * to control selective rendering.
   *
   * @memberof SimpleCell
   */
  get id() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  mount(t) {
    if (t == null)
      return this._mount;
    this._mount = t;
  }
  config(t) {
    if (t == null)
      return this._config;
    this._config = t;
  }
  source(t) {
    if (t == null)
      return this._source;
    this._source = t;
  }
  /**
   * Returns a serialized representation of the instance.
   *
   * @memberof SimpleCell
   */
  serialize() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Returns an object with width and height fields
   * specifying the space taken up by this method.
   *
   * @param {Object} config The config.
   * @param {boolean} config.useRawSpace Whether to consider the original dimensions without any smartTick.
   * @memberof SimpleCell
   */
  getLogicalSpace() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Method used to set the space available to render the SimpleCell
   *
   * @param {number} width The available width.
   * @param {number} height The available height.
   * @memberof SimpleCell
   */
  setAvailableSpace() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Render the SimpleCell inthe supplied mount point.
   *
   * @param {HTMLElement} mount The mount point to render in.
   * @memberof SimpleCell
   */
  render() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Render the SimpleCell inthe supplied mount point.
   *
   * @param {HTMLElement} mount The mount point to render in.
   * @memberof SimpleCell
   */
  remove() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  getMinMeasures(t = 0) {
    return t;
  }
  emitAllRenderHooksWhenRenderSkipped(t) {
    const i = this.source();
    !Nx(i) && i.emitAllRenderHooksWhenRenderSkipped && i.emitAllRenderHooksWhenRenderSkipped(t);
  }
}
const bc = {
  [M$]: {
    [Ci]: 0,
    [Ei]: 0,
    [Yi]: 0,
    [Pi]: 0
  },
  [N$]: 2,
  [k$]: !1,
  [F$]: null,
  [R$]: T$,
  [v$]: !0,
  [G$]: 0,
  [L$]: 0,
  [U$]: null,
  [Y$]: {
    [Ci]: 8,
    [Ei]: 8,
    [Yi]: 3,
    [Pi]: 0
  },
  [Id]: {
    [Ci]: 8,
    [Ei]: 5,
    [Yi]: 2,
    [Pi]: 3
  },
  [IC]: {
    [Ci]: 8,
    [Ei]: 5,
    [Yi]: 5,
    [Pi]: 0
  },
  [vN]: {
    [Ci]: 5,
    [Ei]: 5,
    [Yi]: 5,
    [Pi]: 0
  },
  [TN]: {
    [Ci]: 3,
    [Ei]: 3,
    [Yi]: kC,
    [Pi]: 0
  },
  [kN]: {
    [Ci]: 8,
    [Ei]: 5,
    [Yi]: 2,
    [Pi]: 1
  },
  [J$]: {
    [Ci]: 0,
    [Ei]: 0,
    [Yi]: 0,
    [Pi]: 0
  },
  numLines: {},
  numChars: {}
}, mg = {
  mount: {},
  availHeight: {},
  availWidth: {},
  config: {
    sanitization: (e, t) => et(e._config, t)
  },
  logicalSpace: {},
  minSpacing: {},
  source: {}
}, q$ = {
  caption: {},
  config: {}
}, j$ = {
  smartText: {},
  rawSource: {}
}, bu = {
  [jg]: et(q$, mg),
  [sl]: et(j$, mg),
  [qg]: mg,
  [zg]: mg
}, z$ = (e, t) => {
  let i, n;
  const s = e.source(), { spaceFixer: A, margin: o } = e.config(), a = e.overrideDimension();
  s.overrideDimension && s.overrideDimension(a);
  const { width: r, height: l } = s.getLogicalSpace(t), { show: c, orientation: g } = s.config();
  return c === !0 ? (a.height ? n = l : n = Math.floor(
    l + o.top + o.bottom + A
  ), a.width ? i = r : i = Math.floor(
    r + o.left + o.right + A
  ), e.config().renderer === "svg" && (g === Yi || g === Pi ? n += VA : (g === Ci || g === Ei) && (i += VA))) : [i, n] = [r, l], {
    width: i,
    height: n
  };
};
class Mu extends Er {
  /**
   * Creates an instance of AxisCell.
   *
   * @param {Object} config The input config.
   * @memberof AxisCell
   */
  constructor(t) {
    super(t), this._axis = null, this._availHeight = null, this._availWidth = null, this._logicalSpace = null, this._overriddenDimension = {}, ve(this, bu[qg]);
  }
  /**
   * return the type pf SimpleCell cell.
   *
   * @memberof AxisCell
   */
  get type() {
    return qg;
  }
  /**
   * This method return the value conatined by this SimpleCell.
   *
   * @return {SimpleAxis | ColorAxis} Instance of SimpleAxis or ColorAxis.
   * @memberof AxisCell
   */
  valueOf() {
    return this.source().id;
  }
  key() {
    return this.source().id;
  }
  /**
   * This method return the unique identififer of the axis
   *
   * @return {string} Id of the axis.
   * @memberof AxisCell
   */
  get id() {
    return this._id;
  }
  static formalName() {
    return UN;
  }
  /**
   * Retrns the serialized representation of this cell.
   *
   * @return {Object}Object with serializable props.
   * @memberof AxisCell
   */
  serialize() {
    return {
      type: qg,
      axis: this.source().serialize()
    };
  }
  /**
   * return the default configuration for the text cell
   *
   * @static
   * @return {Object} Default configuration of the cell
   * @memberof AxisCell
   */
  static defaultConfig() {
    return bc;
  }
  overrideDimension(t) {
    return t == null ? this._overriddenDimension : (this._overriddenDimension = t, this);
  }
  /**
   * Return the space taken up by an axis element in the dom.
   *
   * @param {Object} config The config.
   * @param {boolean} config.useRawSpace Whether to consider the original dimensions without any smartTick.
   *
   * @return {Object} Object with width and height fields.
   * @memberof AxisCell
   */
  getLogicalSpace(t) {
    if (t = t || {}, !this.logicalSpace()) {
      const i = z$(this, t);
      this.logicalSpace(i), this._implicitSpace = i;
    }
    return this.logicalSpace();
  }
  /**
   * This method is used to set the space availiable to render
   * the SimpleCell.
   *
   * @param {number} width The width of SimpleCell.
   * @param {number} height The height of SimpleCell.
   * @return {AxisCell} Returns current Instance
   * @memberof AxisCell
   */
  setAvailableSpace(t, i) {
    this.availWidth(t), this.availHeight(i);
    const { margin: n, isOffset: s } = this.config(), A = this.source(), { show: o, orientation: a } = A.config();
    if (t || i) {
      let r = t, l = i;
      o && this.config().renderer === "svg" && (a === Yi || a === Pi ? l = i > VA ? i - VA : i : (a === Ci || a === Ei) && (r = t > VA ? t - VA : t)), A.setAvailableSpace(r, l, n, s), A.logicalSpace(null);
    } else
      A.resetLogicalSpace();
    return this.logicalSpace(null), this;
  }
  /**
   * This method is used to render the axis inside the axis cell.
   *
   * @param {HTMLElement} mount The mount point.
   * @return {Selection} node where axis mounted
   * @memberof AxisCell
   */
  /* istanbul ignore next */
  render(t, i) {
    if (!t)
      return this;
    let n = 0, s = 0;
    const A = this.source(), o = this.availHeight(), a = this.availWidth(), { margin: r } = this.config(), { top: l, bottom: c, left: g, right: h } = r, { show: d, orientation: u } = A.config();
    this._wrapperDiv = z(
      X(t),
      "div",
      [this],
      `${En}-${xy}`
    );
    const f = z(
      this._wrapperDiv,
      this.config().renderer === "html" ? "div" : "svg",
      [1],
      `${En}-axis-container`
    );
    return this._wrapperDiv.classed(
      `${En}-${xy}-${u}`,
      !0
    ), f.classed(`${En}-axis-container-${u}`, !0), this.mount(t), f.attr(Fa, "100%").attr(Il, "100%").style(Fa, "100%").style(Il, "100%").style("overflow", "visible"), n = a, s = o, d || (n = u === Yi || u === Pi ? a : 0, s = u === Yi || u === Pi ? 0 : o), this._wrapperDiv.style(Fa, `${n}px`).style(Il, `${s}px`).style("margin-top", l).style("margin-bottom", c).style("margin-left", g).style("margin-right", h), d && this.config().renderer === "svg" && this._wrapperDiv.style(
      `padding-${u}`,
      `${VA}px`
    ), A.mount(f.node()), A.render(A.mount(), i), f;
  }
  /**
   * Disposes the cell
   *
   * @return {AxisCell} Current instance of AxisCell
   * @memberof AxisCell
   */
  remove() {
    return this._wrapperDiv?.datum(null), this._wrapperDiv?.remove(), this._wrapperDiv = null, this.source() && this.source().remove(), this.mount() && this.mount().remove(), this;
  }
  getMinWidth() {
    return this.getLogicalSpace().width;
  }
  getDataPath() {
    return [
      ...this.source().config().metaInf.facets,
      {
        field: this.source().config().fieldInstance,
        sourceType: this.source().config().metaInf.sourceType
      }
    ];
  }
}
class $$ extends Er {
  /**
   * Creates an instance of BLANK.
   * @param {Object} config The input configuration.
   * @memberof BLANK
   */
  constructor(t) {
    super(t), this._overriddenDimension = {}, ve(this, bu[zg]);
  }
  /**
   * return the type pf SimpleCell cell.
   *
   * @readonly
   * @memberof BlankCell
   */
  get type() {
    return zg;
  }
  /**
   * This method return the value contained by this SimpleCell.
   *
   * @return {string} The text value contained by this cell.
   * @memberof BlankCell
   */
  valueOf() {
    return this.id;
  }
  key() {
    return this.id;
  }
  /**
   * return the default configuration for the text cell
   *
   * @static
   * @return {Object} Default configuration of the cell
   * @memberof BlankCell
   */
  static defaultConfig() {
    return bc;
  }
  /**
   * This method is used to return a unique identifier for
   * the BLANK cell.
   *
   * @return {string} The unique identifier for the BLANK.
   * @memberof BlankCell
   */
  get id() {
    return this._id;
  }
  static formalName() {
    return HN;
  }
  /**
   * This method is used to obtain a serialized representation of this instance.
   *
   * @return {Object} Object with serilizable props.
   * @memberof BLANK
   */
  serialize() {
    return {
      type: zg
    };
  }
  overrideDimension(t) {
    return t == null ? this._overriddenDimension : (this._overriddenDimension = t, this);
  }
  /**
   * This method return the space taken up
   * by the text with the style applied.
   *
   * @return {Object} width and height taken up by the text.
   * @memberof BLANK
   */
  getLogicalSpace() {
    if (!this.logicalSpace()) {
      const t = {
        width: this.width || 0,
        height: this.height || 0
      };
      return this._implicitSpace = t, t;
    }
    return this.logicalSpace();
  }
  /**
   * This method is used to set the available space.
   *
   * @param {number} width The available width.
   * @param {number} height The available height.
   * @return {Instance} Returns current Instance
   * @memberof BlankCell
   */
  setAvailableSpace(t, i) {
    return this.availWidth(t), this.availHeight(i), this.logicalSpace(null), this;
  }
  /**
   * This method is used to render the BLANK cell inside
   * the provided mount point.
   *
   * @param {HTMLElement} mount The mount point for this cell.
   * @return {Instance} Returns current Instance
   * @memberof BLANK
   */
  /* istanbul ignore next */
  render(t) {
    if (t) {
      const { style: i } = this.config();
      this.mount(t);
      const n = X(t), s = z(n, "div", [this.id]);
      s.classed(`${En}-${P$}`, !0), s.style("width", `${this.availWidth()}px`), s.style("height", `${this.availHeight()}px`), s.html(""), i && Ji(s, i);
    }
    return this;
  }
  /**
   * Removes the cell(Disposal)
   *
   * @return {Instance} Returns current Instance
   * @memberof BlankCell
   */
  remove() {
    return this.mount() && this.mount().remove(), this;
  }
  getMinMeasures() {
    return 0;
  }
  getMinWidth() {
    return 0;
  }
  getDataPath() {
    const { metaInf: t } = this.config();
    return t == null || t.getDataPath == null ? [] : t.getDataPath();
  }
}
const X$ = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"> <rect width="24" height="24" fill="none" stroke="black"/> <path fill="currentColor" d="M5 11h14v2H5z"/> </svg>', Z$ = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"> <rect width="24" height="24" stroke="black" fill="none"/><path fill="currentColor" d="M12 5v6H6v2h6v6h2v-6h6v-2h-6V5h-2z"/></svg>', $g = 18, by = (e) => {
  const t = e.source(), { height: i, width: n } = e.minSpacing(), { margin: s, rotation: A } = e.config(), { left: o, right: a, top: r, bottom: l } = s, c = r + l + i, g = e.config().interaction?.collapse?.enabled, h = o + a + n + (g ? $g : 0), d = e.availHeight() - c, u = e.availWidth() - h, f = e.dependencies().labelManager;
  return f.setStyle(e._computedStyle), !A && e.smartText(
    f.getSmartText(t, u, d, !0)
  ), A && e.smartText(
    f.getSmartText(t, d, u, !0)
  ), e;
}, Am = (e) => {
  let t = !1;
  return (e === `${K$}` || e === `${sm}` || e === "columnHeader") && (t = !0), t;
}, tX = (e) => {
  const { labelManager: t } = e.dependencies(), { height: i, width: n } = e.minSpacing();
  let {
    margin: s,
    padding: A,
    show: o,
    numChars: { min: a, max: r },
    numLines: { max: l }
  } = e.config();
  const { left: c, right: g, top: h, bottom: d } = s, u = e.overrideDimension(), f = u.height ? 0 : h + d + i + A.top + A.bottom, C = u.width ? 0 : c + g + n + A.left + A.right, I = e.availHeight() - f, E = e.availWidth() - C, B = e.source(), m = e.smartText(), p = new Array(a).fill("W").join(""), w = t.getOriSize(p);
  let Q;
  if (r != null) {
    const _ = Array.from({ length: r }).fill("W").join("");
    Q = t.getOriSize(_);
  }
  if (e.config({ rotation: !1 }), m.width > (E || 0) && l && (m.height = m.oriTextHeight * l), E && E < m.width && (m.width = w.width), E && E < Math.min(w.width, m.oriTextWidth)) {
    const _ = t.getSmartText(
      B,
      I,
      w.height,
      !0
    ), { height: x, width: S } = _;
    m.width = S, m.height = x, e.smartText(_);
  }
  if (!E && Q) {
    let _ = m.width;
    _ > Q.width && (_ = Q.width), _ < w.width && (_ = w.width);
    const x = t.getSmartText(
      B,
      _,
      m.height,
      !0
    ), { maxWidth: S } = x;
    m.width = S, e.smartText(x);
  }
  const { subType: y, headerPadding: D } = e.config();
  return Am(y) || (m.width += D[Ci] + D[Ei]), o ? (u.height && (m.height = u.height), u.width && (m.width = u.width), {
    width: Math.ceil(m.width) + C,
    height: Math.ceil(m.height) + f
  }) : {
    width: 0,
    height: 0
  };
}, eX = (e) => {
  const { className: t, headerPadding: i, padding: n, type: s, titlePadding: A, availWidth: o } = e;
  let a;
  return Am(t) ? a = A : s === fC ? a = i : s === RN ? a = e[Id] : s === nl ? a = e[TN] : s === HA ? a = e[vN] : s === "rowFacetHeader" ? (a = Object.assign({}, n), o < a.left + a.right && (a.left = 0, a.right = 0)) : a = n, a;
}, iX = (e, t) => ([Yi, Pi, Ci, Ei].forEach((i) => {
  e.style(`padding-${i}`, `${t[i]}px`);
}), e), nX = "sub-total";
class _o extends Er {
  /**
   * Creates an instance of Text.
   * @param {Object} config The input configuration.
   * @param {Object} dependencies Dependencies for the class(labelManager)
   * @memberof Text
   */
  constructor(t, i) {
    super(t), this._config.isCollapseIconVisible = !0, this._dependencies = i, this._overriddenDimension = {}, this._className = this._config.className || (this._config.type === fC ? `${En}-${fC}-cell` : `${En}-${sl}-cell`), this._config.useExternalCSS === !1 ? this._computedStyle = this._config.style : this._computedStyle = Ls(
      X("body"),
      this._className
    ), this._dependencies.labelManager.setStyle(this._computedStyle), ve(this, bu[sl]);
    const n = Array.from({
      length: this._config?.numChars?.min ?? 1
    }).fill("w").join("");
    this._minTextSpace = this._dependencies.labelManager.getOriSize(n)?.width;
    const s = this._dependencies.labelManager.getOriSize("w");
    this.minSpacing({
      width: Math.floor(s.width * 3 / 4),
      height: Math.floor(s.height / 2)
    }), by(this);
  }
  hideCollapseIcon() {
    return this._config.isCollapseIconVisible = !1, this;
  }
  /**
   * return the type pf SimpleCell cell.
   *
   * @memberof TextCell
   */
  get type() {
    return sl;
  }
  /**
   * This method return the value contained by this SimpleCell.
   *
   * @return {string} The text value contained by this cell.
   * @memberof TextCell
   */
  valueOf() {
    return this.source();
  }
  key(...t) {
    return t.length ? (this._key = t[0], this) : (this._key || this.key(Zt()), this._key);
  }
  /**
   * This method is used to return a unique identifier for
   * the Text cell.
   *
   * @return {string} The unique identifier for the Text.
   * @memberof TextCell
   */
  get id() {
    return this._id;
  }
  /**
   * Returns the dependencies of the instance
   *
   * @return {Object} Dependencies needed by the class
   * @memberof TextCell
   */
  dependencies() {
    return this._dependencies;
  }
  /**
   * This method is used to obtain a serialized representation of this instance.
   *
   * @return {Object} Object with serilizable props.
   * @memberof TextCell
   */
  serialize() {
    return {
      text: this.source(),
      type: sl
    };
  }
  /**
   * return the default configuration for the text cell
   *
   * @static
   * @return {Object} Default configuration of the cell
   * @memberof TextCell
   */
  static defaultConfig() {
    return bc;
  }
  static formalName() {
    return LN;
  }
  overrideDimension(t) {
    return t == null ? this._overriddenDimension : (this._overriddenDimension = t, this);
  }
  /**
   * This method return the space taken up
   * by the text with the style applied.
   *
   * @return {Object} width and height taken up by the text.
   * @memberof Text
   */
  getLogicalSpace() {
    if (!this.logicalSpace()) {
      let t = tX(this);
      this.config().interaction?.collapse?.enabled && (t.width += $g), t.width = Math.max(
        this.getMinWidth(),
        t.width
      ), this.logicalSpace(t), this._implicitSpace = t;
    }
    return this.logicalSpace();
  }
  /**
   * This method is used to set the available space.
   *
   * @param {number} width The available width.
   * @param {number} height The available height.
   * @return {TextCell} Returns current Instance
   * @memberof TextCell
   */
  setAvailableSpace(t, i) {
    return this.availWidth(t), this.availHeight(i), by(this), this.logicalSpace(null), this;
  }
  /**
   * This method is used to render the Text cell inside
   * the provided mount point.
   *
   * @param {HTMLElement} mount The mount point for this cell.
   * @return {TextCell} Returns current Instance
   * @memberof Text
   */
  render(t) {
    const i = this.availWidth(), n = this.availHeight(), s = this.config(), {
      margin: A,
      show: o,
      verticalAlign: a,
      textAlign: r,
      rotation: l,
      padding: c,
      type: g,
      headerPadding: h,
      className: d,
      titlePadding: u,
      useExternalCSS: f,
      subType: C,
      facetsConfig: { hyperlink: I } = {}
    } = s, { display: E } = this._computedStyle;
    if (this.mount(t), o) {
      const B = X(t), m = Object.assign(
        {
          value: this.source()
        },
        this.config().metaInf
      );
      this._elem = z(
        B,
        "div",
        [m],
        `${En}-${H$}`
      );
      const p = a || l ? "middle" : "top", { width: w, height: Q } = this.smartText(), { height: y } = this.minSpacing(), D = {
        top: w + y / 2,
        middle: w / 2 + y,
        bottom: y
      };
      B.style("vertical-align", p), this._elem.classed(this._className, !0), f === !1 && Object.entries(this._computedStyle).forEach(([b, R]) => {
        this._elem.style(b, R);
      }), !E || E === "flex" ? this._elem.classed(`${En}-text-cell-prop-display-flex`, !0) : this._elem.style("display", E), this._elem.style(
        "transform",
        l ? `translate(${Q / 2}px,
                ${D[p]}px) rotate(-90deg)` : ""
      ), this._elem.style(Fa, i ? `${i}px` : "100%"), [Yi, Pi, Ci, Ei].forEach((b) => {
        B.style(`margin-${b}`, `${A[b]}px`);
      });
      const _ = eX({
        className: d,
        headerPadding: h,
        padding: c,
        type: g,
        titlePadding: u,
        [Id]: s[Id],
        [IC]: s[IC]
      });
      this._elem = iX(this._elem, _), this._className.split(" ").some((b) => b === "muze-grid-headers") && this._elem.style("justify-content", r), this._dependencies.labelManager.setStyle(this._computedStyle);
      const x = this.config().interaction?.collapse, S = this._dependencies.labelManager.getSmartText(
        this.source(),
        // The content width = [element width] - [left padding] - [right padding].
        i - _[Ci] - _[Ei] - (x?.enabled ? $g : 0),
        n,
        !0
      ).text;
      if (Am(C))
        this._elem.style("justify-content", r), this._elem.text(S);
      else if (g === RN) {
        const { sortStatus: b, directSortEnabled: R } = this.config().metaInf;
        ZS(this, {
          target: {
            type: VE,
            data: this._elem.datum(),
            meta: {}
          },
          targets: [this._elem.datum()],
          container: this._elem,
          sortStatus: b || null,
          text: {
            label: S,
            originalText: this.source(),
            align: "start"
          },
          isOverlay: !1,
          cellRender: "html",
          directSortEnabled: R
        });
      } else {
        if (this._divElem = z(
          this._elem,
          "div",
          [m],
          ".muze-facet-cell-container"
        ), this._divElem.style("display", "flex"), m?.sourceType !== Sy && (g === HA || g === nl)) {
          const G = x.expandIcon, T = x.collapseIcon, v = x.fields[this.config().fieldName].enabled, H = this.config().metaInf.canvasHelpers.getCanvasConfig(), N = wt(
            H.rows.totals.data.totalString,
            H.columns.totals.data.totalString
          ), M = s.metaInf.getDataPath().map((k) => `${k.value}`), F = g === HA ? s.metaInf.canvasHelpers.getRowCollapseState(
            M.slice(0, -1)
          ) : s.metaInf.canvasHelpers.getColumnsCollapseState(
            M.slice(0, -1)
          );
          if (v && !M.includes(N) && !F) {
            let k;
            if (g === HA ? k = s.metaInf.canvasHelpers.getRowCollapseState(M) : g === nl && (k = s.metaInf.canvasHelpers.getColumnsCollapseState(M)), M.length === 1) {
              const O = g === HA ? "columns" : "rows", L = this.config().globalConfig?.[O]?.totals?.grandTotals ?? { enabled: !1, splitTotal: {} };
              if (L.enabled) {
                const q = L.splitTotal?.field ?? null;
                q != null && this.config().fieldName === q && this.hideCollapseIcon();
              }
            }
            k ? (this._iconElem = z(
              this._divElem,
              "div",
              [m],
              ".muze-facet-expand-icon"
            ), this._iconElem.html(T || Z$)) : this.config().isCollapseIconVisible && (this._iconElem = z(
              this._divElem,
              "div",
              [m],
              ".muze-facet-collapse-icon"
            ), this._iconElem.html(G || X$)), this._iconElem?.style("display", "inline-block"), this._iconElem?.style("padding-right", "4px");
          }
        }
        let b = this._divElem;
        (I?.enabled || this.config().metaInf?.hyperlinkInfo) && (b = z(b, "a", (G) => [G]), uc(
          b,
          {
            hyperlinkInfo: this.config().metaInf.hyperlinkInfo
          },
          I
        ));
        const R = z(
          b,
          "div",
          [null],
          ".muze-facet-inner-text"
        );
        R.classed(
          m.sourceType === nX ? "muze-totals-label" : "",
          !0
        ), g === nl ? (R.text(S), this._divElem.style("position", "sticky"), this._divElem.style("left", "0")) : g === HA ? (R.text(S), this._elem.style("position", "sticky"), this._elem.style("top", "0")) : R.text(S);
      }
    }
    return this;
  }
  /**
   * Disposes the cell
   *
   * @return {TextCell} Returns current Instance
   * @memberof TextCell
   */
  remove() {
    return this._iconElem?.datum(null), this._iconElem?.remove(), this._iconElem = null, this._divElem?.datum(null), this._divElem?.remove(), this._divElem = null, this._elem?.datum(null), this._elem?.remove(), this._elem = null, this.mount() && this.mount().remove(), this._mount = null, this._source = null, this;
  }
  getMinWidth() {
    const {
      padding: { left: t, right: i } = {},
      type: n,
      metaInf: { sourceType: s } = {},
      facetsConfig: {
        interaction: { collapse: { enabled: A } = {} } = {}
      } = {}
    } = this.config(), o = A && s !== Sy && (n === HA || n === nl) ? $g : 0;
    if (!this.config().show)
      return 0;
    const a = t + i + this._minTextSpace;
    return (this._implicitSpace?.width ? Math.min(a, this._implicitSpace.width) : a) + o;
  }
  getDataPath() {
    return this.config().metaInf.getDataPath();
  }
}
const sX = (e, t) => Object.fromEntries(
  Object.entries(e).filter(([i]) => !t.includes(i))
);
function PN(e) {
  return {
    displayName: () => e,
    toString: () => e,
    virtual: !0
  };
}
function AX(e) {
  return "virtual" in e && e.virtual === !0;
}
function oX(e, t) {
  return () => t.slice(0, e + 1).map((i) => ({
    field: `${i.field}`,
    sourceType: AX(i.field) ? "virtual" : "normal"
  }));
}
function aX(e, t) {
  const i = [...t], n = e.map((s, A) => ({
    field: A < t.length ? t[A] : PN(s),
    formattedValue: s || "",
    allFields: i
  }));
  return n.map((s, A) => ({
    ...s,
    getDataPath: oX(A, n)
  }));
}
function rX(e, t, i) {
  return e.reduce(
    (n, s, A) => A === t.length - 1 ? [...n, s] : [
      ...n,
      s,
      {
        field: PN(i),
        formattedValue: i,
        allFields: s.allFields,
        getDataPath: () => []
      }
    ],
    []
  );
}
function lX(e, t) {
  const i = bc[kN];
  return e === 0 ? {
    ...i,
    [Ei]: 2
  } : e === t - 1 ? {
    ...i,
    [Ci]: 2
  } : {
    ...i,
    [Ci]: 2,
    [Ei]: 2
  };
}
class My extends Er {
  #i;
  #s;
  #n;
  #A;
  #o;
  #a;
  #r;
  #t;
  #e;
  constructor(t, i) {
    super(t), this.config(t), this.#s = i, this.#n = [], this.#A = null, this.#a = null, this.#r = null, this.#t = null, this.#e = null;
  }
  static formalName() {
    return _y;
  }
  static defaultConfig() {
    return {
      textAlign: "center",
      separator: " / ",
      numChars: {
        min: 0
      }
    };
  }
  get id() {
    return this._id;
  }
  get type() {
    return W$;
  }
  valueOf() {
    const t = this.source(), { separator: i } = this.config();
    return Array.isArray(t) ? t.join(i) : "";
  }
  key(t) {
    return t == null ? (this.#i == null && (this.#i = Zt()), this.#i) : (this.#i = t, this);
  }
  serialize() {
    return {
      text: this.valueOf(),
      type: this.type
    };
  }
  dependencies() {
    return this.#s;
  }
  children() {
    return this.#n;
  }
  source(t) {
    if (t == null)
      return this._source;
    const { texts: i, fields: n } = t;
    if (!Array.isArray(i) || !Array.isArray(n))
      return this._source;
    const s = aX(i, n);
    this._source = s.map((r) => r.formattedValue);
    const { separator: A } = this._config, o = this.#l(), a = rX(
      s,
      i,
      A ?? ""
    );
    return this.#n = this.#g(a, o), this;
  }
  config(t) {
    if (t == null)
      return this._config;
    et(this._config, t);
    const i = this.children();
    if (Array.isArray(i) && i.length > 0) {
      const n = this.#l();
      i.forEach((s, A) => {
        const o = s.config().metaInf, a = this.#c(
          {
            field: s.source(),
            formattedValue: s.source(),
            allFields: o?.allFields || [],
            getDataPath: o?.getDataPath || (() => [])
          },
          A,
          i.length,
          n
        );
        s.config(a);
      });
    }
    return this;
  }
  #l() {
    return {
      ...sX(this._config, ["separator"]),
      className: "muze-columnHeader-cell"
    };
  }
  #c(t, i, n, s) {
    const A = lX(i, n), o = `${t.field}` === this._config.separator, a = {
      ...s,
      padding: A,
      headerPadding: A
    };
    return o && (a.className = "muze-columnHeader-cell muze-column-header-separator"), a.metaInf = {
      getDataPath: t.getDataPath,
      allFields: t.allFields
    }, a;
  }
  #g(t, i) {
    return t.map((n, s) => {
      const A = this.#c(
        n,
        s,
        t.length,
        i
      );
      return new _o(A, this.#s).minSpacing({ width: 0, height: 0 }).source(n.formattedValue);
    }).map((n) => {
      const s = n.config().metaInf;
      return n.config({
        metaInf: {
          ...s,
          placeholder: n
        }
      }), n;
    });
  }
  minSpacing(t) {
    if (t == null)
      return this.#A;
    this.#A = t;
    const i = this.children();
    return Array.isArray(i) && i.length > 0 && i.forEach((n) => {
      n.minSpacing(t);
    }), this;
  }
  availWidth() {
    return this.#a;
  }
  availHeight() {
    return this.#r;
  }
  setAvailableSpace(t, i) {
    this.#a = t, this.#r = i;
    const n = this.#n, s = this.availHeight();
    let A = this.availWidth();
    for (let o = 0; o < n.length; o++) {
      const a = n[o], { width: r } = a.getLogicalSpace();
      if (A <= 0) {
        a.setAvailableSpace(0, s);
        continue;
      }
      r <= A ? (a.setAvailableSpace(r, s), A -= r) : (a.setAvailableSpace(A, s), A = 0);
    }
    return this.#o = null, this;
  }
  logicalSpace() {
    return this.#o;
  }
  getLogicalSpace() {
    const t = this.children().map((A) => (A.setAvailableSpace(), A.getLogicalSpace()));
    if (t.length <= 0) return { width: 0, height: 0 };
    let i = 0, n = 0;
    const s = t.length;
    for (let A = 0; A < s; A++) {
      const o = t[A];
      i += o.width, n = o.height > n ? o.height : n;
    }
    return this.#o = { width: i, height: n }, this.logicalSpace();
  }
  render(t) {
    const { className: i, textAlign: n } = this.config();
    this.mount(t);
    const s = X(t);
    s.style("height", "100%");
    const A = Object.assign({
      value: this.source()
    });
    return this.#t = z(
      s,
      "div",
      [A],
      `${En}-${_y}`
    ).classed(i, !0).style("display", "flex").style("justify-content", n), this.#e = z(
      this.#t,
      "div",
      this.children(),
      void 0,
      {
        update: (o, a) => {
          a.render(o.node());
        }
      }
    ), this;
  }
  remove() {
    return this.children().forEach((t) => t.remove()), this.#t?.datum(null), this.#t?.remove(), this.#t = null, this.#e?.datum(null), this.#e?.remove(), this.#e = null, this.mount() && this.mount().remove(), this._mount = null, this._source = null, this;
  }
}
const cX = (e) => {
  const t = e.source().config(), { width: i, height: n } = t;
  return {
    width: Math.ceil(i),
    height: Math.ceil(n + e.getCaptionSpace().height)
  };
};
class YN extends Er {
  /**
   * Creates an instance of GeomCell.
   * @param {Object} config The input configuration.
   * @memberof GeomCell
   */
  constructor(t) {
    super(t), this._unit = null, this._caption = null, ve(this, bu[jg]);
  }
  /**
   * return the type pf SimpleCell cell.
   *
   * @readonly
   * @memberof GeomCell
   */
  get type() {
    return jg;
  }
  /**
   * This method return the value contained by this cell.
   *
   * @return {VisualUnit} Instance of visual unit contained by visual unit.
   * @memberof GeomCell
   */
  valueOf() {
    return this.source();
  }
  key() {
    return this.source().id;
  }
  /**
   * This method is used to return the id of the
   * visual unit housed by this cell.
   *
   * @return {string} The unique id of the visual unit.
   * @memberof GeomCell
   */
  get id() {
    return this.source().id();
  }
  static formalName() {
    return ON;
  }
  /**
   * This method return a serialized representation of
   * this instance.
   *
   * @return {Object} Object with serializable props.
   * @memberof GeomCell
   */
  serialize() {
    return {
      type: jg,
      unit: this.source().serialize(),
      caption: this.caption()
    };
  }
  /**
   * return the default configuration for the geom cell
   *
   * @static
   * @return {Object} Default configuration of the cell
   * @memberof GeomCell
   */
  static defaultConfig() {
    return bc;
  }
  /**
   * It gives the space taken by the caption of the unit
   *
   * @return {Object} return the space taken by caption
   * @memberof GeomCell
   */
  getCaptionSpace() {
    const t = this.caption();
    let i = { width: 0, height: 0 };
    return t && (i = t.getLogicalSpace()), i;
  }
  /**
   * return the space taken up by the element in the dom.
   *
   * @return {Object} Object with width and height fields.
   * @memberof GeomCell
   */
  getLogicalSpace() {
    return this.logicalSpace() || this.logicalSpace(cX(this)), this.logicalSpace();
  }
  /**
   * This method is used to set the space available to
   * render the SimpleCell.
   *
   * @param {number} width The available width.
   * @param {number} height The available height.
   * @return {Instance} Returns current Instance
   * @memberof GeomCell
   */
  setAvailableSpace(t, i) {
    const n = this.source();
    return this.availWidth(t), this.availHeight(i), n.setSize(t, i - this.getCaptionSpace().height), this.logicalSpace(null), this;
  }
  /**
   * his method is used to render the visual unit inside the provided cell.
   *
   * @param {HTMLElement} mount The mountpoint in the table.
   * @return {Instance} Returns current Instance
   * @memberof GeomCell
   */
  render(t, i) {
    if (t) {
      this.mount(t);
      const n = this.availHeight(), s = this.availWidth(), A = this.caption(), o = z(
        X(t),
        "div",
        [1],
        `${En}-${O$}`
      );
      if (A) {
        const r = z(
          o,
          "div",
          [A],
          `${En}-unit-caption`
        ).node();
        A.render(r);
      }
      const a = z(
        o,
        "div",
        [1],
        `${En}-unit`
      );
      o.style(Fa, `${s}px`).style(Il, `${n}px`), a.style(Fa, `${s}px`).style(Il, `${n - this.getCaptionSpace().height}px`), this.source().mount(a.node()).render(this.source().mount(), i);
    }
    return this;
  }
  /**
   * Disposes the cell
   *
   * @return {Object} Current instance
   * @memberof GeomCell
   */
  remove() {
    return X(this.mount()).datum(null), this.mount() && this.mount().remove(), this.source().remove(), this._mount = null, this._source = null, this;
  }
}
const gX = {
  [GN]: Er,
  [LN]: _o,
  [UN]: Mu,
  [ON]: YN,
  [HN]: $$
}, om = () => {
  const e = gX;
  return {
    register: (t) => {
      const i = t.formalName();
      return i in e && (e[i] = t), om;
    },
    get: () => e
  };
}, hX = 250, Ny = 50, Fy = {
  leading: !0,
  trailing: !0
}, Cd = "vScrollPercent", Ed = "hScrollPercent", rA = "virtualScrolling", dX = 3, uX = (e, t, i, n, s, A, o, a, r, l, c, g, h, d) => {
  t.each(function(u) {
    const { placeholder: f, rowIndex: C, colIndex: I } = u, { startRowIdx: E, startColIdx: B } = i, { xDomainRanges: m, yDomainRanges: p } = a;
    let w, Q, y, D, _, x;
    const S = {
      rowIndex: E + C,
      colIndex: B + I
    };
    d.row === "center" && (y = l[S.rowIndex], _ = h[S.rowIndex]), d.column === 1 && (D = c[S.colIndex], x = g[S.colIndex]);
    const b = m ? m[I] : [null, null], R = p ? p[C] : [null, null], G = { x: b, y: R };
    f instanceof _o ? w = !0 : (IX(n, s) ? w = !ky(
      f._prevAxisDomainRanges,
      G
    ) : fX(
      S,
      n
    ) ? (Q = !0, w = !ky(
      f._prevAxisDomainRanges,
      G
    )) : w = !0, w = A || w), w = w || f.mount() !== this;
    const T = {
      transition: o.transition,
      axisDomainRanges: G,
      rowUnitPosition: y,
      colUnitPosition: D,
      scrollLeft: r.scrollLeft,
      scrollTop: r.scrollTop,
      unitWidth: x,
      unitHeight: _,
      viewport: e.getBoundBox(),
      viewportRange: s
    };
    w ? (f.render(this, T), f._prevAxisDomainRanges = G) : Q && f.emitAllRenderHooksWhenRenderSkipped(T);
  });
}, fX = (e, t) => {
  const { rowIndex: i, colIndex: n } = e, { rowRange: s, colRange: A } = t;
  return i >= s[0] && i <= s[1] && n >= A[0] && n <= A[1];
}, Ry = (e, t) => {
  const [i, n] = e, [s, A] = t;
  return [
    [i, s],
    [n, A]
  ].every(([o, a]) => o === null && a === null ? !0 : o === null && a !== null || o !== null && a === null ? !1 : o.startIdx === a.startIdx && o.endIdx === a.endIdx);
}, ky = (e, t) => {
  const { x: i, y: n } = e, { x: s, y: A } = t;
  return e && t && Ry(s, i) && Ry(A, n);
}, IX = (e, t) => e.rowRange[0] === t.rowRange[0] && e.rowRange[1] === t.rowRange[1] && e.colRange[0] === t.colRange[0] && e.colRange[1] === t.colRange[1], CX = (e, t) => {
  e.lockModel(), e.commit(
    `${re}.viewport.rowStart`,
    t.rowRange[0]
  ), e.commit(
    `${re}.viewport.rowEnd`,
    t.rowRange[1]
  ), e.commit(
    `${re}.viewport.colStart`,
    t.colRange[0]
  ), e.commit(
    `${re}.viewport.colEnd`,
    t.colRange[1]
  ), e.unlockModel();
}, JN = (e, { scrollLeft: t, viewPortInfo: i }) => {
  e.commit(
    `${re}.scrollLeft`,
    t
  ), e.commit(
    `${re}.viewport.colStart`,
    i?.colStart ?? 0
  ), e.commit(
    `${re}.viewport.colEnd`,
    i?.colEnd ?? 0
  );
}, KN = (e, { scrollTop: t, viewPortInfo: i }) => {
  e.commit(
    `${re}.scrollTop`,
    t
  ), e.commit(
    `${re}.viewport.rowStart`,
    i?.rowStart ?? 0
  ), e.commit(
    `${re}.viewport.rowEnd`,
    i?.rowEnd ?? 0
  );
}, vy = (e, { scrollLeft: t = 0, scrollTop: i = 0, viewPortInfo: n }) => {
  e.lockModel(), JN(e, {
    scrollLeft: t,
    viewPortInfo: n
  }), KN(e, {
    scrollTop: i,
    viewPortInfo: n
  }), e.unlockModel();
}, Ty = (e, t, i, n) => {
  const s = t - i;
  return s > 0 && Math.round(e) >= s ? n : 0;
}, VN = (e, t) => {
  e.lockModel(), e.commit(
    `${rA}.${Cd}`,
    t
  ), e.unlockModel();
}, WN = (e, t) => {
  e.lockModel(), e.commit(
    `${rA}.${Ed}`,
    t
  ), e.unlockModel();
}, EX = (e) => {
  VN(e, 0);
}, BX = (e) => {
  WN(e, 0);
}, qN = (e) => e.get(`${rA}.${Cd}`), jN = (e) => e.get(`${rA}.${Ed}`), mX = (e) => e.get(`${re}.viewport`), Gy = (e, t) => {
  const i = new Array(t);
  let n = 0;
  for (let s = 0; s < t; s++)
    i[s] = n, n += e[s];
  return {
    positions: i,
    totalMatrixContentDim: n
  };
}, Ly = (e, t, i, n = !1) => {
  let s = null, A = null, o = 0;
  if (n)
    s = 0, A = e.length - 1;
  else {
    for (let a = 0; a < e.length; a++) {
      const r = e[a], l = e[a + 1];
      if (a === e.length - 1) {
        s === null && (s = a), A === null && (A = a);
        break;
      }
      if (r <= t && l > t && (s = a), r < i + t && l >= i + t) {
        A = a;
        break;
      }
    }
    s = s === null ? 0 : s, A = A === null ? e.length - 1 : A, o = t - e[s];
  }
  return {
    startIdx: s,
    endIdx: A,
    shift: o
  };
}, pX = (e, t, i, n) => {
  const s = [];
  n.composition().visualGroup.matrix().geom().forEach((c) => {
    c.source().layers().filter((h) => {
      const { x: d, y: u } = h.axes();
      return d.id === i.id || u.id === i.id;
    }).forEach((h) => {
      (h.config().mark === EN || h.config().mark === CN) && s.push(h);
    });
  });
  const { domain: A } = i, o = s.map((c) => c.getNeighbourPointIndexForContinuationInVirtualScroll(
    e,
    A,
    (g) => g - 1
  )).filter((c) => c >= 0), a = s.map((c) => c.getNeighbourPointIndexForContinuationInVirtualScroll(
    t,
    A,
    (g) => g + 1
  )).filter((c) => c >= 0), r = Math.min(...o, e), l = Math.max(...a, t);
  return { newStartIdx: r, newEndIdx: l };
}, Uy = (e, t, i, n, s, A, o = !1, a = {
  includePointForLineContinuation: !1
}) => {
  const { step: r, paddingOuter: l, domain: c } = e;
  let g, h;
  if (o)
    g = 0, h = c.length - 1;
  else {
    if (t >= n)
      g = 0;
    else {
      let I = Math.floor(
        Math.max(n - t - l, 0) / r
      );
      I = Math.min(I, c.length - 1), g = I;
    }
    if (t + i <= n + s)
      h = c.length - 1;
    else {
      let I = c.length - Math.floor(
        Math.max(
          t + i - (n + s) - l,
          0
        ) / r
      ) - 1;
      I = Math.max(I, 0), h = I;
    }
  }
  const u = Math.max(h - g + 1, 0) * r + l;
  let f = l + g * r;
  const { includePointForLineContinuation: C } = a;
  if (C) {
    const { newStartIdx: I, newEndIdx: E } = pX(
      g,
      h,
      e,
      A
    );
    g = I, h = E;
  }
  return { startIdx: g, endIdx: h, translate: f, visibleCellDimension: u };
}, Hy = (e, t, i, n, s, A, o, a, r, l = { includePointForLineContinuation: !1 }) => {
  const c = [];
  for (let g = e; g <= t; g++) {
    const h = i[0][g], d = i[1][g], u = [];
    h && h.constructor.type() === "band" ? u.push(
      Uy(
        {
          id: h.id,
          field: h.config().field,
          step: h.getScaleStep(),
          paddingOuter: h.getScalePaddingOuter(),
          domain: h.domain()
        },
        n[g],
        s[g],
        A,
        o,
        a,
        r,
        l
      )
    ) : u.push(null), d && d.constructor.type() === "band" ? u.push(
      Uy(
        {
          id: d.id,
          field: d.config().field,
          step: d.getScaleStep(),
          paddingOuter: d.getScalePaddingOuter(),
          domain: d.domain()
        },
        n[g],
        s[g],
        A,
        o,
        a,
        r,
        l
      )
    ) : u.push(null), c.push(u);
  }
  return c;
};
class Ca extends FN {
  constructor(t) {
    super(t), this.renderingState = {
      rowPositions: [],
      colPositions: [],
      unitWidths: [],
      unitHeights: [],
      totalContentWidth: 0,
      totalContentHeight: 0,
      prevViewportRanges: {
        rowRange: [0, -1],
        colRange: [0, -1]
      }
    };
  }
  draw(t) {
    this.mount(t || document.getElementById(this.renderAt())), this.initializeRenderingState();
  }
  initializeRenderingState() {
    const { config: t, gridLayout: i } = this.params, { row: n, column: s } = t, A = i.viewInfo(), { layoutDimensions: o } = A, a = o.unitWidths.primary, r = o.unitHeights.primary, l = this.component;
    let c = [], g = [], h = 0, d = 0;
    if (l.length && n === "center") {
      const { positions: u, totalMatrixContentDim: f } = Gy(
        r,
        l.length
      );
      c = u, d = f;
    }
    if (l.length && s === 1) {
      const { positions: u, totalMatrixContentDim: f } = Gy(
        a,
        l[0].length
      );
      g = u, h = f;
    }
    this.renderingState = {
      rowPositions: c,
      colPositions: g,
      unitWidths: a,
      unitHeights: r,
      totalContentWidth: h,
      totalContentHeight: d,
      prevViewportRanges: {
        rowRange: [0, -1],
        colRange: [0, -1]
      }
    };
  }
  updateVirtualScrollContent(t, i, n, s, A) {
    const { row: o, column: a } = this.params.config, r = this.calculateViewableMatrix(
      i,
      n,
      A,
      t
    );
    o === "center" && a === 1 && CX(this.params.store, r), this.render({ ...r, ...s }, { scrollLeft: i, scrollTop: n }), this.renderingState.prevViewportRanges = {
      rowRange: r.rowRange,
      colRange: r.colRange
    };
  }
  calculateViewableMatrix(t, i, n, s) {
    const { row: A, column: o, border: a } = this.params.config, {
      virtualScrolling: { disabled: r }
    } = this.params.gridLayout._config, {
      rowPositions: l,
      colPositions: c,
      unitWidths: g,
      unitHeights: h,
      totalContentWidth: d,
      totalContentHeight: u
    } = this.renderingState, { width: f, height: C } = this.getBoundBox(), I = this.component, E = a.width, { xAxes: B, yAxes: m } = n;
    let p = 0, w = I.length - 1, Q = 0, y = I.length ? I[0].length - 1 : -1, D = 0, _ = 0, x = null, S = null;
    const b = !!(s.layers() && s.layers().filter(({ mark: R }) => R === EN || R === CN).length);
    if (I.length && A === "center") {
      const { startIdx: R, endIdx: G, shift: T } = Ly(
        l,
        i,
        C,
        r
      );
      p = R, w = G, D = T + Ty(
        i,
        u,
        C,
        E
      ), S = Hy(
        p,
        w,
        m,
        l,
        h,
        i,
        C,
        s,
        r,
        {
          includePointForLineContinuation: b
        }
      );
    }
    if (I.length && o === 1) {
      const { startIdx: R, endIdx: G, shift: T } = Ly(
        c,
        t,
        f,
        r
      );
      Q = R, y = G, _ = T + Ty(
        t,
        d,
        f,
        E
      ), x = Hy(
        Q,
        y,
        B,
        c,
        g,
        t,
        f,
        s,
        r,
        {
          includePointForLineContinuation: b
        }
      );
    }
    return {
      rowRange: [p, w],
      colRange: [Q, y],
      shifts: [D, _],
      xDomainRanges: x,
      yDomainRanges: S
    };
  }
  render(t, i) {
    const {
      classPrefix: n,
      row: s,
      column: A,
      dimensions: o,
      border: a,
      isFacet: r,
      showHeaders: l
    } = this.params.config, {
      rowPositions: c,
      colPositions: g,
      unitWidths: h,
      unitHeights: d,
      prevViewportRanges: u
    } = this.renderingState, f = z(
      this.mount(),
      "div",
      [1],
      `${n}-grid-${s}-${A + 1}`
    ).classed(`${n}-grid-${s}`, !0).classed(`${n}-grid`, !0);
    this.applyScroll(f);
    const C = `${n}-grid`, I = z(
      f,
      "table",
      ["layout"],
      `${C}-table`
    ), E = z(I, "tbody", ["layout"], `${C}-body`), {
      rowRange: B,
      colRange: m,
      shifts: p,
      xDomainRanges: w,
      yDomainRanges: Q,
      transition: y,
      forceRender: D
    } = t, [_, x] = B, [S, b] = m, [R, G] = p;
    let T = this.component.slice(_, x + 1).map((O, P) => {
      const L = O.slice(S, b + 1);
      return L._key = _ + P, L;
    }), { viewMatrix: v, spans: H } = bN(T, s, A);
    v = v.map((O, P) => (O._key = _ + P, O));
    const N = z(
      E,
      "tr",
      v,
      `${C}-tr`,
      {},
      (O) => O._key
    ), M = z(
      N,
      "td",
      (O, P) => O.map((L, q) => ({ placeholder: L, rowIndex: P, colIndex: q })).filter((L) => L.placeholder !== null),
      `${C}-td`,
      {
        update: (O, P) => {
          let { externalClassname: L } = P.placeholder.config();
          L = [...new Set(L)], L && L.map(
            (q) => O.classed(`${C}-${q}`, !0)
          );
        }
      },
      (O) => O.placeholder.id
    );
    M.each(function(O) {
      const { placeholder: P } = O;
      let L;
      P instanceof _o ? L = `${n}-grid-td-facet` : P instanceof Mu ? L = `${n}-grid-td-axis` : P instanceof YN && (L = `${n}-grid-td-geom`), L && X(this).classed(L, !0);
    }), MN(M, H, { dimensions: o, border: a }, `${s}-${A}`, {
      startRowIdx: _,
      startColIdx: S
    }), uX(
      this,
      M,
      {
        startRowIdx: _,
        startColIdx: S
      },
      u,
      {
        rowRange: B,
        colRange: m
      },
      D,
      {
        transition: y
      },
      {
        xDomainRanges: w,
        yDomainRanges: Q
      },
      i,
      c,
      g,
      h,
      d,
      this.params.config
    ), M.exit().each((O) => {
      O.placeholder.remove();
    });
    let F = M;
    const k = {};
    M.each((O) => {
      const { placeholder: P, colIndex: L } = O;
      k[L] === void 0 && (k[L] = !1), k[L] = k[L] || P.config().show;
    }), F = M.filter((O) => k[O.colIndex]), this.params.gridLayout.config().cellRenderer === "html" && (s === "center" && f.style(
      "border-bottom",
      `${a.width}px ${a.style} ${a.color}`
    ), a.showValueBorders.bottom = !1, a.showRowBorders.bottom = !1), NN({
      cells: F,
      border: a,
      row: s,
      column: A,
      isFacet: r,
      showHeaders: l
    }), s === "center" && f.property("scrollTop", R), A === 1 && f.property("scrollLeft", G);
  }
}
const Oy = (e, t, i, n) => {
  X(e).selectAll(`.${t}-grid`).property(n, i);
}, QX = (e, t) => {
  const i = t.params.config.classPrefix;
  return {
    horizontal: () => {
      [0, 1, 2].forEach((n) => {
        const s = t.component[n][1];
        s instanceof Ca || Oy(
          `#${s.renderAt()}`,
          i,
          e,
          "scrollLeft"
        );
      });
    },
    vertical: () => {
      [0, 1, 2].forEach((n) => {
        const s = t.component[1][n];
        s instanceof Ca || Oy(
          `#${s.renderAt()}`,
          i,
          e,
          "scrollTop"
        );
      });
    }
  };
};
class am extends So {
  constructor(t) {
    super(t.name, t.config.dimensions, 0), this.gridComponents = [], this.setParams(t), this._prevScrollLeft = null, this._prevScrollTop = null;
  }
  sanitizeGrid() {
    let t = 0, i = 0;
    const { viewMatricesInfo: n, layoutDimensions: s } = this.layout.viewInfo(), A = this.layout.scrollInfo(), { viewHeight: o, viewWidth: a, unitHeights: r, unitWidths: l } = s;
    for (let c = 0; c < 3; c++) {
      this.gridComponents.length && this.gridComponents[c] instanceof Array || (this.gridComponents[c] = []);
      for (let g = 0; g < 3; g++) {
        let h = {
          height: o[c],
          width: a[g],
          unitHeights: r,
          unitWidths: l
        };
        const d = n.matrices[`${uA[c]}`][g], u = `${uA[c]}-${Cr[g]}`, f = uA[c], C = g, I = {
          dimensions: h,
          border: s.border,
          classPrefix: this.params.config.classPrefix,
          scrollInfo: A,
          row: f,
          column: C
        };
        if ((f === "center" || C === 1) && (h = {
          height: o[c],
          width: a[g] + (A.horizontal || !s.border.showValueBorders.right ? 0 : s.border.width),
          unitHeights: r,
          unitWidths: l
        }, I.dimensions = h), this.gridComponents[c][g] instanceof So) {
          const { isFacet: E, showHeaders: B } = this.params.component.config();
          I.isFacet = E, I.showHeaders = B, this.gridComponents[c][g].updateWrapper({
            name: u,
            component: d,
            config: I,
            gridLayout: this.params.component,
            store: this.params.store
          });
        } else {
          const { isFacet: E, showHeaders: B } = this.params.component.config();
          I.isFacet = E, I.showHeaders = B;
          const m = f === "center" || C === 1 ? Ca : FN, p = new m({
            name: u,
            component: d,
            config: I,
            gridLayout: this.params.component,
            store: this.params.store
          });
          this.gridComponents[c].push(p);
        }
        c === 0 && (i += h.width), g === 0 && (t += h.height);
      }
    }
    this.boundBox({ height: t, width: i }), this.component = this.gridComponents, this.allComponents = this.gridComponents;
  }
  scrollBarManager(...t) {
    return t.length ? (this._scrollBarManager = t[0], this) : this._scrollBarManager;
  }
  /**
   * Attaches a mousewheel listener to the center matrix, based on which the scrolling can occur.
   * It uses the scroll component to change the position of the scroller, which ultimately scrolls the center matrix
   *
   *
   * @return {GridComponent} Instance of the GridComponent
   */
  attachScrollListener(t) {
    const { layoutRootNodeId: i, scrollableBoundBox: n } = t, s = this.scrollBarManager();
    let A = null, o = null;
    if (n)
      return X(`#${i}`).on("wheel", () => {
        const a = bt();
        A || (o = a.currentTarget.getBoundingClientRect()), clearTimeout(A), A = setTimeout(() => {
          A = null, o = null;
        }, hX);
        const { deltaX: r, deltaY: l, clientX: c, clientY: g } = a;
        let { left: h, top: d } = o;
        const u = c - h, f = g - d;
        if (u >= n.left && u <= n.left + n.width && f >= n.top && f <= n.top + n.height) {
          if (r !== 0 && Math.abs(r) > Math.abs(l)) {
            const I = s._scrollBarComponents.horizontal;
            if (I) {
              const E = I.component.logicalSpace().totalLength, B = s._dependencies.store.get(
                "virtualScrolling.scrollLeft"
              ), m = s._attachedComponents.grid.layout.viewInfo().layoutDimensions.viewWidth[1];
              (r > 0 && B >= 0 && Math.round(B) < E - m || r < 0 && B > 0 && Math.round(B) <= E - m) && s.preventBrowserScroll("horizontal", a);
            }
            s.triggerScrollBarAction("horizontal", r);
          }
          if (l !== 0 && Math.abs(r) < Math.abs(l)) {
            const I = s._scrollBarComponents.vertical;
            if (I) {
              const E = I.component.logicalSpace().totalLength, B = s._dependencies.store.get(
                "virtualScrolling.scrollTop"
              ), m = s._attachedComponents.grid.layout.viewInfo().layoutDimensions.viewHeight[1];
              (l > 0 && B >= 0 && Math.round(B) < E - m || l < 0 && B > 0 && Math.round(B) <= E - m) && s.preventBrowserScroll("vertical", a);
            }
            s.triggerScrollBarAction("vertical", l);
          }
        }
      }), this;
  }
  performScrollAction(t, i) {
    return QX(i, this)[t](), this;
  }
  getBoundBox() {
    const { top: t, left: i } = this.component[0][0].boundBox(), { height: n, width: s } = this.boundBox();
    return {
      top: t,
      left: i,
      height: n,
      width: s
    };
  }
  updateWrapper(t) {
    return this._prevScrollLeft = null, this._prevScrollTop = null, this.name(t.name), this.boundBox(t.config.dimensions), this.setParams(t), this;
  }
  setParams(t) {
    return this.component = t.component, this.params = t, this.layout = t.layout, this.target(t.config.target), this.className(t.config.className), this.sanitizeGrid(), this;
  }
  attachListener(t) {
    return this.attachScrollListener(t), this;
  }
  updateScrollableRowsCompsContent(t, i, n, s, A) {
    [1, 0, 2].forEach((o) => {
      const a = this.allComponents[1][o];
      a instanceof Ca && a.updateVirtualScrollContent(
        t,
        i,
        n,
        s,
        A
      );
    });
  }
  updateScrollableColumnsCompsContent(t, i, n, s, A) {
    [1, 0, 2].forEach((o) => {
      const a = this.allComponents[o][1];
      a instanceof Ca && a.updateVirtualScrollContent(
        t,
        i,
        n,
        s,
        A
      );
    });
  }
  updateScrollableAllCompsContent(t, i, n, s, A) {
    [1, 0, 2].forEach((o) => {
      [1, 0, 2].forEach((a) => {
        const r = this.allComponents[o][a];
        r instanceof Ca && r.updateVirtualScrollContent(
          t,
          i,
          n,
          s,
          A
        );
      });
    });
  }
  updateScrollableCompsContent(t, i, n, s = !1, A) {
    const o = this._prevScrollLeft, a = this._prevScrollTop, r = i !== o || n !== a, l = {
      forceRender: s
    };
    r && (o !== null || a !== null) && (l.transition = {
      disabled: !0
    }), i !== o && n !== a || s ? this.updateScrollableAllCompsContent(
      t,
      i,
      n,
      l,
      A
    ) : i !== o ? this.updateScrollableColumnsCompsContent(
      t,
      i,
      n,
      l,
      A
    ) : n !== a && this.updateScrollableRowsCompsContent(
      t,
      i,
      n,
      l,
      A
    ), this._prevScrollLeft = i, this._prevScrollTop = n;
  }
}
const zN = {
  position: "top",
  align: "left",
  padding: 4,
  className: `${ZA}-title-container`
}, $N = {
  position: "top",
  align: "left",
  padding: 4,
  maxLines: 2,
  className: `${ZA}-subtitle-container`
}, Cl = {
  className: `${ZA}-message-container`,
  baseFontLimit: 16,
  upperFontLimit: 24,
  baseSizeLimit: 100,
  upperSizeLimit: 300,
  fractionImage: 0.8,
  fractionChild: 0.7
}, Mc = "canvas", yX = {
  color: {},
  opacity: {},
  size: {},
  shape: {},
  backgroundColor: {}
}, Py = {
  [Wl]: {
    value: null,
    meta: {
      typeCheck: "constructor",
      typeExpected: "Array"
    }
  },
  [Na]: {
    value: null,
    meta: {
      typeCheck: "constructor",
      typeExpected: "Array"
    }
  },
  [ks]: {
    value: null,
    meta: {
      typeCheck: "constructor",
      typeExpected: "Object",
      sanitization: (e) => typeof e == "string" || !e ? {
        field: e
      } : e
    }
  },
  [$j]: {
    value: null,
    meta: {
      typeCheck: "constructor",
      typeExpected: "Object",
      sanitization: (e) => typeof e == "string" || !e ? {
        field: e
      } : e
    }
  },
  [Ia]: {
    value: null,
    meta: {
      typeCheck: "constructor",
      typeExpected: "Object",
      sanitization: (e) => typeof e == "string" || !e ? {
        field: e
      } : e
    }
  },
  [go]: {
    value: null,
    meta: {
      typeCheck: "constructor",
      typeExpected: "Object",
      sanitization: (e) => typeof e == "string" || !e ? {
        field: e
      } : e
    }
  },
  [vs]: {
    value: null,
    meta: {
      typeCheck: "constructor",
      typeExpected: "Object",
      sanitization: (e) => typeof e == "string" || !e ? {
        field: e
      } : e
    }
  },
  [lN]: {
    value: [],
    meta: {
      typeCheck: "constructor",
      typeExpected: "Array"
    }
  },
  [cN]: {
    value: [],
    meta: {
      typeCheck: "constructor",
      typeExpected: "Array"
    }
  },
  [gN]: {
    value: null,
    meta: {
      typeCheck: "constructor",
      typeExpected: "Object"
    }
  }
}, CC = {
  [Mi]: {
    value: [null, null],
    meta: {
      takesMultipleParams: !0,
      typeCheck: ([e, t]) => typeof e == "function" && typeof t == "object",
      sanitization: ([e, t]) => {
        let i = e;
        (typeof e == "string" || typeof e == "number" || !e) && (i = () => e);
        const n = et({}, zN);
        return [i, et(n, t)];
      }
    }
  },
  [$n]: {
    value: [null, null],
    meta: {
      takesMultipleParams: !0,
      typeCheck: ([e, t]) => typeof e == "function" && typeof t == "object",
      sanitization: ([e, t]) => {
        let i = e;
        (typeof e == "string" || typeof e == "number" || !e) && (i = () => e);
        const n = et({}, $N);
        return [i, et(n, t)];
      }
    }
  }
}, Nu = {
  distribution: [],
  classPrefix: "muze",
  isDistributionEqual: !0,
  unitMeasures: {
    height: 100,
    width: 100,
    border: 1
  },
  isTransposed: !1,
  facet: Xs,
  extraCellLengths: []
};
class rm extends So {
  components;
  params;
  constructor(t) {
    const i = t.config.position;
    super(t.name, t.config.measurement.legendSpace[i], 0), this.setParams(t);
  }
  renderLegend(t) {
    throw new Error(
      `It should be implemented by the child class: ${t}`
    );
  }
  draw(t) {
    this.renderLegend(t || document.getElementById(this.renderAt()));
  }
  updateWrapper(t) {
    const i = t.config.position;
    return this.name(t.name), this.boundBox(t.config.measurement.legendSpace[i]), this.setParams(t), this;
  }
  setParams(t) {
    this.components = t.component, this.params = t, this.target(t.config.target), this.position(t.config.position);
    const { alignWith: i, alignment: n } = wX(
      t.config.position
    );
    this.className(t.config.className), this.alignWith(t.config.alignWith || i), this.alignment(t.config.alignment || n);
  }
  setComponentInfo(t) {
    const { rootNode: i } = t;
    this.components.forEach((n) => {
      n.legend.setParentInfo({ canvasRoot: i });
    });
  }
}
function wX(e) {
  let t = null;
  const i = `${uA[1]}-${Cr[1]}`;
  switch (e) {
    case Re:
    case aA:
      t = Az;
      break;
    case li:
    case _s:
      t = Cy;
      break;
    default:
      t = Cy;
  }
  return { alignment: t, alignWith: i };
}
function XN(e) {
  let t = 0, i;
  return e.each((n, s) => {
    const A = n.legend, o = A.title(), { buffer: a, title: r } = A.config(), { padding: l } = A.measurement(), c = 2 * l + 1 + a[Do], g = A.labelManager();
    g.setStyle(o.style), s == 0 && (i = g.getOriSize(
      aC
    ).width, i += c);
    const { width: h } = r && r.show === !1 ? { width: 0 } : g.getOriSize(o.text);
    t = Math.max(t, h), t > 0 && (t += c);
  }), Math.min(t, i);
}
function DX(e) {
  const t = Nu.classPrefix;
  let i = 0, n = 0;
  const s = e.selectAll(
    `.${t}-gradient-first-tick`
  ), A = e.selectAll(
    `.${t}-gradient-second-tick`
  ), o = e.selectAll(
    `.${t}-step-first-tick`
  ), a = e.selectAll(
    `.${t}-step-second-tick`
  ), r = s._groups, l = A._groups, c = o._groups, g = a._groups;
  r.forEach((h) => {
    h.forEach((d) => {
      i = Math.max(i, d.clientWidth);
    });
  }), c.forEach((h) => {
    h.forEach((d) => {
      i = Math.max(i, d.clientWidth);
    });
  }), r.forEach((h) => {
    h.forEach((d) => {
      d.style.width = `${i}px`;
    });
  }), c.forEach((h) => {
    h.forEach((d) => {
      d.style.width = `${i}px`;
    });
  }), l.forEach((h) => {
    h.forEach((d) => {
      n = Math.max(n, d.clientWidth);
    });
  }), g.forEach((h) => {
    h.forEach((d) => {
      n = Math.max(n, d.clientWidth);
    });
  }), l.forEach((h) => {
    h.forEach((d) => {
      d.style.width = `${n}px`;
    });
  }), g.forEach((h) => {
    h.forEach((d) => {
      d.style.width = `${n}px`;
    });
  });
}
function xX(e, t) {
  const i = Nu.classPrefix;
  e.each(function(n) {
    const s = n.legend, { pagination: A } = s.config();
    if (A === !0) {
      const a = s.mount().querySelector(`.${i}-legend-body`);
      a.style[Ve] = `${t}px`;
    } else {
      const a = s.mount().querySelector(`.${i}-legend-body`);
      a.style[Ve] = `${t + hd}px`;
    }
  });
}
function SX(e) {
  const t = Nu.classPrefix;
  e.each(function(i, n) {
    const s = i.legend, { pagination: A, availableBodyWidth: o } = s.config();
    if (A === !0)
      return xX(e, o), !1;
    if (n == 0) {
      const r = e.selectAll(`.${t}-legend-body`)._groups;
      let l = 0;
      r.forEach((c) => {
        c.forEach((g) => {
          l = Math.max(l, g.clientWidth);
        });
      }), r.forEach((c) => {
        c.forEach((g) => {
          g.style[Ve] = `${l}px`;
        });
      });
    }
  }), XN(e);
}
const Yy = (e) => {
  const { DIMENSION: t } = K.FieldType;
  return e.some((i) => i.type() === t);
}, _X = (e) => {
  const { rowFacets: t, colFacets: i, rowProjections: n, colProjections: s } = e;
  if (t.length || i.length)
    return !0;
  const A = s.flat(), o = n.flat();
  return !!((Yy(A) || Yy(o)) && (A.length > 1 || o.length > 1));
}, bX = ({ firebolts: e, action: t }) => {
  let i;
  const n = {
    operator: "or",
    conditions: []
  };
  let s = !0;
  return e.forEach((A) => {
    const o = A.getPropagationIdentifiers(t);
    if (o) {
      const { query: a } = o;
      i = o.interpolated, n.conditions = [
        ...n.conditions,
        ...a.conditions
      ];
    }
    s = s && o === null;
  }), {
    propIdentifiers: s ? null : n.conditions.length ? n : null,
    interpolated: i
  };
}, Jy = (e) => {
  if (e.context.composition().visualGroup) {
    const n = e.interactionPolicy(), s = n.behaviours, A = n.sideEffects;
    e.applyPropagationPolicy({
      behaviours: s,
      sideEffects: A
    });
  }
}, Ky = {
  tooltip: (e, t) => {
    const i = t.context.composition().visualGroup.resolver().getAllFields();
    return _X(i) ? {
      selectionSummary: {
        order: 1,
        className: "tooltip-content-container-selectionSummary-crosstab",
        showMultipleMeasures: !0
      },
      highlightSummary: {
        order: 0,
        className: "tooltip-content-container-highlightSummary-crosstab"
      }
    } : {
      selectionSummary: {
        order: 0,
        className: "tooltip-content-container-selectionSummary-default",
        showMultipleMeasures: !1
      },
      highlightSummary: {
        order: 1,
        className: "tooltip-content-container-highlightSummary-default"
      }
    };
  },
  selectionBox: (e, t) => {
    const i = t.context.composition().visualGroup.resolver().getAllFields(), n = Z(
      e.sideEffects,
      "selectionBox",
      "persistent"
    ), s = {};
    return n === void 0 && (iZ(i) ? s.persistent = !0 : s.persistent = !1), s;
  }
}, Vy = (e, t, i) => {
  const n = wt(
    t[e],
    t.sideEffects[e]
  );
  if (e in Ky) {
    const s = Ky[e](t, i);
    return et(s, n);
  }
  return n || {};
}, MX = (e, t, i) => {
  const n = t.context.composition().visualGroup, s = t.sideEffects();
  for (const A in s) {
    const o = s[A], a = Vy(A, e, t);
    o.config(a);
  }
  n.matrix().geom().forEach((A) => {
    const o = A.source().firebolt();
    o.groupFirebolt(t), o.config(
      Object.assign({}, e, {
        valueParser: n.valueParser()
      })
    );
    const a = o.sideEffects();
    for (const r in a) {
      const l = a[r], c = Vy(r, e, t);
      l.config(c);
    }
    i && o.sideEffects().tooltip.disable();
  });
}, NX = (e) => {
  const t = e.context.config().interaction, i = e.context.composition().visualGroup, { rowProjections: n, colProjections: s } = i.resolver().getAllFields(), A = n.flat(), o = s.flat(), a = o.flat().filter(
    (h) => h.subtype() === "temporal" && h.as() === "continuous"
  ), r = A.flat().filter(
    (h) => h.subtype() === "temporal" && h.as() === "continuous"
  );
  if (a.length && md(A) || r.length && md(o)) {
    const h = t.brush, d = t.sideEffects.selectionBox;
    h.mode = wt(h.mode, a.length ? "x" : "y"), d.persistent = wt(d.persistent, !0);
  }
  e.config(
    Object.assign({}, t, {
      valueParser: i.valueParser()
    })
  );
  const l = e.sideEffects(), c = t.sideEffects.tooltip.common;
  let g = !1;
  c ? (l.tooltip.enable(), g = !0) : l.tooltip.disable(), MX(t, e, g);
}, Rf = (e, t) => {
  const i = t.context.composition();
  return i ? i.visualGroup.findUnitByPayload(e) : null;
}, Wy = (e, t) => {
  e.dissociateBehaviour(t);
}, qy = (e, t) => {
  e.registerPhysicalBehaviouralMap({
    hover: {
      behaviours: [t]
    }
  });
}, Bd = (e, t, i) => (i.set(`${e}`, t), i), EC = (e, t) => t.get(`${e}`), jy = (e) => {
  if (e) {
    const t = (n) => {
      const { field: s, value: A, collapsed: o, children: a } = n, r = /* @__PURE__ */ new Map();
      return a && a.length > 0 && a.forEach((l) => {
        Bd(l.value, t(l), r);
      }), { field: s, value: A, collapsed: o, children: r };
    }, i = /* @__PURE__ */ new Map();
    return e.forEach((n) => {
      Bd(n.value, t(n), i);
    }), i;
  }
  return null;
}, zy = (e, t) => {
  let i = e;
  for (let n = 0; n < t.length; n++) {
    const { field: s, collapsed: A } = t[n];
    let { value: o } = t[n];
    o = K.getActualValue(o);
    const a = EC(o, i);
    if (a)
      a.field === s && a.value === o && (typeof A == "boolean" && Bd(o, { ...EC(o, i), collapsed: A }, i), i = a.children);
    else {
      const r = /* @__PURE__ */ new Map();
      Bd(
        o,
        {
          field: s,
          value: o,
          collapsed: A,
          children: r
        },
        i
      ), i = r;
    }
  }
}, ZN = (e, t) => {
  let i = null, n = e;
  t = t.map(
    (s) => K.isInvalid(s) ? K.getActualValue(s) : s.toString()
  );
  for (let s = 0; s < t.length; s++) {
    const A = t[s], o = EC(A, n);
    if (o)
      i = o, n = o.children;
    else {
      i = null;
      break;
    }
  }
  return i ? i.collapsed : null;
}, FX = (e, t) => {
  const i = e.props.rows.expandCollapseState || /* @__PURE__ */ new Map();
  if (!t)
    return i;
  if (!t.length)
    return !1;
  const n = ZN(i, t), { collapseAll: s } = e.config().rows.facets.interaction.collapse;
  return n === null && s ? !0 : n;
}, BC = (e, t) => {
  const i = e.props.columns.expandCollapseState || /* @__PURE__ */ new Map();
  if (!t)
    return i;
  if (!t.length)
    return !1;
  const n = ZN(i, t), { collapseAll: s } = e.config().columns.facets.interaction.collapse;
  return n === null && s ? !0 : n;
}, { CONTINUOUS: RX } = ft, { getFacetsAndProjections: $y } = $1, { getHeaderAxisFrom: Xy } = n1, kX = (e, t) => {
  if (!(e && t.getField(e)))
    return !0;
  const i = t.getField(e).subtype();
  return !(i === ot.CONTINUOUS || i === ot.TEMPORAL);
}, Zy = (e, t) => e === "" || e && !t.getField(e), vX = (e, t) => {
  let i, n, s;
  const A = [e.columns(), e.rows()].flat(2).map((a) => ke(a) ? a.field instanceof $h ? a.field.getMembers() : a.field : a instanceof $h ? a.getMembers() : a);
  for (let a = 0; a < A.length; a++) {
    const r = A[a];
    if (Array.isArray(A[a]))
      for (let c = 0; c < r.length; c++) {
        const g = r[c];
        if (Zy(g, e.data())) {
          s = g;
          break;
        }
        if (kX(g, e.data())) {
          n = g;
          break;
        }
      }
    else if (Zy(r, e.data())) {
      s = r;
      break;
    }
  }
  const o = s || s === "";
  return t.forEach((a) => {
    const r = e[a]();
    switch (a) {
      case Wl:
      case Na:
        (o || n) && (i = {
          message: o ? "Field not found in DataModel schema" : n ? "Unsupported field in shared axis" : "",
          cause: `Unsupported field name: ${s || n ? s || n : ""}`
        });
        break;
      case rN: {
        const l = r instanceof K ? r.isEmpty() : !r.hasOneValue(), c = r.isDisposed();
        (l || c) && (i = {
          message: "Insufficient data passed",
          cause: "Insufficient data passed"
        });
        break;
      }
      default:
        return {};
    }
  }), i;
}, TX = (e) => {
  const t = e.config(), i = e.props;
  t.rows.layout && (i.rows.layout = t.rows.layout), t.columns.layout && (i.columns.layout = t.columns.layout);
  const { enabled: n, state: s } = t.rows.facets.interaction.collapse;
  n ? (!i.rows.expandCollapseState || i.rows.expandCollapseState.size === 0) && s && (i.rows.expandCollapseState = jy(
    s
  )) : i.rows.expandCollapseState = null;
  const { enabled: A, state: o } = t.columns.facets.interaction.collapse;
  A ? (!i.columns.expandCollapseState || i.columns.expandCollapseState.size === 0) && o && (i.columns.expandCollapseState = jy(
    o
  )) : i.columns.expandCollapseState = null, i.legend = et({}, yX);
}, GX = (e) => {
  const t = e._registry.components;
  return [new t.VisualGroup(
    e._registry,
    Object.assign(
      {
        throwback: e._throwback,
        store: e._store
      },
      e.dependencies()
    ),
    e.createChildEventManager()
  )];
}, LX = (e) => {
  if (e) {
    const t = {}, { border: i, gridLines: n } = e;
    return n && (t.x = !!n.x, t.y = !!n.y), {
      facetsUserConfig: {
        isBorderPresent: i || {},
        isGridLinePresent: t,
        format: e.facets && e.facets.format ? e.facets.format : (A) => A
      },
      isFacet: !1
    };
  }
  return {};
}, UX = (e) => (e.scrollBar.thickness = Math.min(
  50,
  Math.max(
    e.scrollBar.buttons.show ? 10 : 4,
    e.scrollBar.thickness
  )
), e), HX = (e) => {
  ["color", "shape", "size"].forEach((t) => {
    e.legend?.[t]?.fields && (e.legend[t].fields = {});
  });
}, OX = (e, t) => {
  const i = {};
  return t.forEach((n) => {
    e && e[n] && Object.keys(e[n]).length && (i[n] = {});
  }), i;
}, PX = (e) => {
  const t = e._layoutManager, i = t.getComponent(sr), n = t.getComponent(rC), s = i && i.getBoundBox(), A = e.composition().visualGroup, o = X(
    `#${t.getRootNodeId()}`
  ).node();
  n && n.setComponentInfo({ rootNode: o }), A.matrix().parentContainerInf({
    el: o,
    dimensions: s
  });
}, YX = (e) => (t, i) => {
  const n = [...t].reduce((o, a) => {
    const { target: r } = a, l = `${r.map((c) => `${c.field}-${c.value}`)}`;
    return o.set(l, a), o;
  }, /* @__PURE__ */ new Map());
  e.props[i].layout = [...n.values()], (i === "rows" ? e.yAxes() : e.xAxes()).forEach((o) => o.resetRenderConfig(o.config())), e.computeLayout({
    recomputeGridSpace: !1,
    extendDomain: !1,
    skipPeripheralComponentsLayout: !0
  }), e.composition().componentWrappers.forEach((o) => {
    o instanceof rm && o.shouldRender(!1);
  });
}, JX = (e) => {
  const t = Object.keys(e).filter((i) => i !== $i && i !== Xi).reduce((i, n) => (i[n] = [e[n][0], e[n][1]], i), {});
  return !tF(Object.keys(t), Object.values(t)) && (e[$i][1] !== e[$i][0] || e[Xi][1] !== e[Xi][0]);
}, KX = (e) => {
  if (e.composition() == null) return;
  const t = e.composition().visualGroup, i = e.registry().interactions.visualGroup;
  e.firebolt().registerPhysicalActions(i.physicalActions.get()).registerBehaviouralActions(i.behaviours.get()).registerSideEffects(i.sideEffects.get());
  const n = e._allOptions;
  for (const A in n)
    if (Object.prototype.hasOwnProperty.call(n, A)) {
      const o = e[A]();
      o !== null && t[A] && t[A](o);
    }
  const { invalidValues: s } = e.config();
  t.valueParser(fE(s)), t.interactionRegistry(e.firebolt().getInteractions()), t._canvasHelpers = {
    updateColumnWidths: YX(e),
    getColumnWidthState: (A, o) => {
      const a = e.composition().layout[o ? "_rowMatrix" : "_columnMatrix"];
      e.once("afterLayout", () => {
        A && A({
          serialize: () => a.blueprints()
        });
      });
    },
    getMinTargetDimensions: (A, o) => {
      const a = e.config()[o ? "rows" : "columns"].minWidth;
      return e.composition().layout[o ? "_rowMatrix" : "_columnMatrix"].getMinTargetDimensions(A, { minWidth: a });
    },
    isDisposed: () => !!e._disposed,
    afterDisposed: (A) => e.on("afterDisposed", A),
    disableBehaviour: (A) => {
      Wy(e.firebolt(), A);
    },
    disableLegendBehaviour: (A) => {
      const { color: o, shape: a, size: r } = e.composition().legend;
      [o, a, r].forEach((l = []) => {
        l.forEach((c) => {
          Wy(c.firebolt(), A);
        });
      });
    },
    enableBehaviour: (A) => {
      qy(e.firebolt(), A);
    },
    enableLegendBehaviour: (A) => {
      const { color: o, shape: a, size: r } = e.composition().legend;
      [o, a, r].forEach((l = []) => {
        l.forEach((c) => {
          qy(c.firebolt(), A);
        });
      });
    },
    getMatrixDimensions: () => {
      const A = e.composition().layout.viewInfo().layoutDimensions;
      return {
        heights: A.viewHeight,
        widths: A.viewWidths
      };
    },
    onHScroll: (A) => {
      const { hScrollBar: o } = e.composition();
      o && o.component.onScroll(A);
    },
    propagateIdentifiers: ({ payload: A }) => {
      const o = e.composition().visualGroup.resolver(), a = o.columnGrandTotalsDataModel(), r = o.rowGrandTotalsDataModel(), l = o.greatGrandTotalsDataModel(), c = e.data(), g = A.data && A.data.contextData.data ? A.data.contextData.data.getDataPath() : null, h = g ? g.map(({ field: d }) => `${d}`) : [];
      [c, r, a, l].forEach(
        (d) => {
          d && d.propagate(
            [
              {
                criteria: g ? {
                  conditions: g.map(({ field: u, value: f }) => ({
                    field: `${u}`,
                    value: f,
                    operator: "eq"
                  })),
                  operator: "and"
                } : null,
                fields: h
              }
            ],
            {
              sourceInfo: {
                canvasId: e.alias()
              },
              fields: h,
              targetActions: {
                layer: A.targetActions.layer
              },
              ...A,
              forceDispatch: !0
            }
          );
        }
      );
    },
    onVScroll: (A) => {
      const { vScrollBar: o } = e.composition();
      o && o.component.onScroll(A);
    },
    setCanvasConfig: (A) => {
      e.config(A);
    },
    getCanvasConfig: () => e.config(),
    getFieldInfo: (A) => e.data().getField(A),
    getCanvasDimensions: () => ({
      width: e.width(),
      height: e.height()
    }),
    getRowCollapseState: (A) => FX(e, A),
    getColumnsCollapseState: (A) => BC(e, A),
    setRowCollapseState: (A) => {
      e.setRowCollapseState(A);
    },
    setColumnsCollapseState: (A) => {
      e.setColumnsCollapseState(A);
    },
    getRootData: () => e.data(),
    getGrandTotalsInfo: (A, o, a) => {
      const r = e.composition().visualGroup, l = e.config();
      switch (A) {
        case "rowGrandTotals":
          return r.resolver().getRowGrandTotalsDataModelInfo(o, l, a);
        case "columnGrandTotals":
          return r.resolver().getColumnGrandTotalsDataModelInfo(o, l, a);
        case "greatGrandTotals":
          return r.resolver().getGreatGrandTotalsDataModelInfo(l, a);
      }
    },
    getSubTotalsInfo: (A, o, a) => {
      const r = e.composition().visualGroup, l = e.config();
      switch (A) {
        case "column":
          return r.resolver().getColumnsubTotalsDataModelInfo(l, o, a);
        case "row":
          return r.resolver().getRowsubTotalsDataModelInfo(l, o, a);
      }
    }
  }, t.createMatrices(), e._cachedProps = {};
}, tF = (e, t) => {
  let i = () => !1;
  return !e.every((n, s) => {
    switch (n) {
      case Wl:
      case Na:
      case lN:
      case Mi:
      case sm:
      case cN:
        i = eo("Array");
        break;
      case go:
      case vs:
      case ks:
      case rN:
      case gN:
      case Xj:
        i = eo("Object");
        break;
      case $i:
      case Xi:
        i = eo("number");
        break;
      default:
        i = () => !0;
        break;
    }
    const A = t[s][0], o = t[s][1];
    return i(A, o);
  });
}, VX = (e) => e.length > 0 ? e.some(({ mark: t }) => t !== "text") : !0, WX = (e) => e.some(
  (t) => t.as() === RX
), qX = (e) => e.some((t) => t.length > 1), jX = (e) => {
  const t = e._store, i = Object.keys(e._allOptions), n = [...i, ...Object.keys(CC)], s = [...i, ...Object.keys(CC)].map(
    (A) => `${iE}.${A}`
  );
  t.registerChangeListener(
    s,
    (...A) => {
      const o = e.data();
      if (o) {
        let a = !1;
        const { rows: r, columns: l } = HM(o, {
          rows: e.rows() ?? [],
          columns: e.columns() ?? []
        }), [, c] = Xy(
          "row",
          r,
          e.config().axisFrom ?? {}
        ), [, g] = Xy(
          "column",
          l,
          e.config().axisFrom ?? {}
        ), {
          axes: {
            showUnivariateAxis: h,
            x: { showUnivariateAxis: d }
          }
        } = e.config(), u = {
          row: c,
          column: g
        }, { projections: f } = $y(
          r,
          "row",
          u
        ), { projections: C } = $y(
          l,
          "col",
          u
        ), I = [...f, ...C], E = !(VX(e.layers()) || WX(I.flat()) || qX(I));
        if ([Wl, Na].forEach((m) => {
          const p = e[m]();
          tZ(p) && (m === Na && E && (d || h) ? e[m]([[ht]]) : e[m]([ht]), a = !0);
        }), !![Wl, Na].find((m) => {
          const p = e[m]();
          return !!eZ(p);
        }) && !o.getField(ht)) {
          let m;
          if (E) {
            const w = e.layers().find((_) => _.mark === "text")?.encoding?.text, Q = typeof w == "object" ? w?.field ?? null : w;
            let D = (Q == null ? { displayName: () => 1 } : o.getField(Q)).displayName();
            m = o.calculateVariable(
              {
                name: ht,
                type: mi
              },
              [ml],
              () => D
            );
          } else
            m = o.calculateVariable(
              {
                name: ht,
                type: mi
              },
              [ml],
              () => 1
            );
          e.data(m);
        }
        e.renderSkipped = a;
      } else
        e.renderSkipped = !0;
      if (!e.renderSkipped) {
        const a = tF(
          n,
          n.map((c, g) => [e._prevProps[c], A[g][1]])
        ), r = JX(
          n.reduce((c, g, h) => (c[g] = [e._prevProps[g], A[h][1]], c), {})
        );
        n.forEach((c, g) => {
          e._prevProps[c] = A[g][1];
        });
        const l = vX(e, n);
        if (l && l.message)
          throw new Gn(l.message, {
            cause: `${l.cause}`
          });
        r ? e.updateSize() : a && e.mount() && (TX(e), KX(e), e.reflow());
      }
    },
    !0
  );
}, zX = (e) => {
  const t = e.composition().visualGroup.matrix(), i = [
    t.column().getBottomAxes().map((s) => s.source()),
    t.column().getTopAxes().map((s) => s.source())
  ], n = [
    t.row().getLeftAxes().map((s) => s.source()),
    t.row().getRightAxes().map((s) => s.source())
  ];
  return { xAxes: i, yAxes: n };
}, $X = (e, { forceRender: t, scrollLeft: i, scrollTop: n }) => {
  const s = XX(e);
  if (s) {
    const A = zX(e);
    s.updateScrollableCompsContent(
      e,
      i,
      n,
      t,
      A
    );
  }
}, XX = (e) => e.composition().componentWrappers?.find((t) => t instanceof am), ZX = (e) => {
  e._store.registerChangeListener(
    [
      `${re}.scrollLeft`,
      `${re}.scrollTop`,
      `${Ya}.domain.x`,
      `${Ya}.domain.y`
    ],
    (...i) => {
      const n = i[0][1], s = i[1][1], A = i[2][1], o = i[3][1], a = e._prevDomainX === A && e._prevDomainY === o;
      e.render({
        gridRenderConfig: {
          scrollLeft: n,
          scrollTop: s,
          forceRender: !a
        }
      }), e._prevDomainX = i[2][1], e._prevDomainY = i[3][1];
    },
    !1
  );
}, tZ = (e) => e === null ? !0 : Array.isArray(e) ? !e.flat().length : !1, eZ = (e) => !!(Array.isArray(e) ? e.flat() : []).find((i) => i === ht), md = (e) => e.every((t) => t.isContinuous()), iZ = (e) => {
  const { rowProjections: t, colProjections: i } = e, n = i.flat(), s = t.flat();
  return !!(md(n) && md(s));
}, nZ = (e) => {
  let t = 0;
  const i = e.xAxes() || [];
  for (let n = 0; n < i.length; n++) {
    const s = i[n].renderConfig().labels.rotation;
    if (s && s !== 0) {
      t = s;
      break;
    }
  }
  t && i.forEach((n) => {
    n.renderConfig({ labels: { rotation: t } }), n.smartTicks(n.setTickConfig());
  });
}, sZ = (e) => {
  const [t, i] = Ad.getState(), n = e._store;
  n.append("app.group", t), n.append("local.group", i);
}, AZ = () => new p$({
  className: "muze-group-container"
}), Fu = (e) => e === li || e === _s ? ql : Do, oZ = (e) => e === Pe ? zB : e === Ee ? $B : e === li ? XB : ZB, aZ = (e) => {
  const { legend: t } = e.props;
  [ks, Ia, vs, go].forEach((i) => {
    (e.composition().legend[i] || []).forEach((s) => {
      const A = s.fieldName(), o = s.config().splitFieldInfo;
      let a;
      if (o.field ? a = Z(
        t[i],
        A,
        "splitLegends",
        o.value
      ) : a = t[i][A], a)
        for (let r in a.interaction)
          s.firebolt().dispatchBehaviour(r, a.interaction[r]);
    });
  });
}, rZ = (e) => {
  e.once("afterRendered", () => {
    aZ(e);
  });
};
class lZ {
  /**
   * Creates an instance of TableLayout.
   * @param {HTMLElement} mountPoint DOM element/d3 selection where the layout is to be mounted
   * @param {Object} measurement The dimensions of the layout
   * @param {Object} config configuration to be given for the layout
   * @param {Object} dependencies external dependencies.
   *
   * @memberof GenericLayout
   *
   */
  constructor(t, i, n, s) {
    this._config = {}, this._measurement = {}, this._matrices = [], this._dependencies = s, this.measurement(i), this.mountPoint(t), this.config(n);
  }
  /**
   * Returns an object which is used to recreate the layout.
   * @return {Object} the serialized components
   */
  serialize() {
    return {
      measurement: this.measurement(),
      config: this.config(),
      matrices: this.matrices()
    };
  }
  /**
  * Sets/Gets the config for the layout
  * @param {Object} config configuration for the layout
  * @return {Layout|Object} Gets the Config/ Returns this instance when set
  */
  config(t) {
    return t ? (this._config = et(this._config || {}, t), this._config.border.width = Math.max(0, this._config.border.width), this) : this._config;
  }
  /**
   * Sets/Gets the measurement for the layout
   * @param {Object} measurement measurement for the layout
   * @return {Layout|Object} Gets the measurement/ Returns this instance when set
   */
  measurement(t) {
    return t ? (this._measurement = et(this._measurement || {}, t), this) : this._measurement;
  }
  /**
   * Sets/Gets the matrices for the layout
   * @param {Object} matrices matrices for the layout
   * @return {Layout|Object} Gets the matrices/ Returns this instance when set
   */
  matrices(t) {
    return t ? (this._matrices = lx.typeObj([In, Ai, Cn], t), this) : this._matrices;
  }
  /**
   * Sets/Gets the matrix for row
   * @param {Object} matrix matrices for the layout
   * @return {Layout|Object} Gets the matrix/ Returns this instance when set
   */
  rowMatrix(t) {
    return t ? (this._rowMatrix = t, this) : this._rowMatrix;
  }
  /**
   * Sets/Gets the matrix for columns
   * @param {Object} matrix matrices for the layout
   * @return {Layout|Object} Gets the matrix/ Returns this instance when set
   */
  columnMatrix(t) {
    return t ? (this._columnMatrix = t, this) : this._columnMatrix;
  }
  /**
    * Sets/Gets the matrix for value
    * @param {Object} matrix matrices for the layout
    * @return {Layout|Object} Gets the matrix/ Returns this instance when set
    */
  centerMatrix(t) {
    return t ? (this._centerMatrix = t, this) : this._centerMatrix;
  }
  /**
   * Sets/Gets the mountPoint for the layout
   * @param {Object} mountPoint mountPoint for the layout
   * @return {Layout|Object} Gets the mountPoint/ Returns this instance when set
   */
  mountPoint(t) {
    return t ? (this._mountPoint = t, this) : this._mountPoint;
  }
}
const cZ = {
  [vz]: {
    [Pz]: "solid",
    [Yz]: "#d6d6d6",
    [DA]: 2,
    [Jz]: !0,
    [Kz]: 0
  },
  [Xz]: "scroll",
  [Zz]: 20,
  [Wz]: { rows: [], columns: [] },
  [Vz]: { rows: [], columns: [] },
  [qz]: { rows: [], columns: [] },
  [Lz]: !1,
  [Uz]: !1,
  [Gz]: 0,
  [Tz]: 0
}, gZ = {
  [Rz]: 100,
  [kz]: 100,
  [Hz]: 100,
  [Oz]: 100
}, hZ = 0.2, dZ = 0.8, uZ = fn.nest, fZ = (e) => e ? {
  firstMeasure: fd,
  secondMeasure: DA
} : {
  firstMeasure: DA,
  secondMeasure: fd
}, tw = (e, t) => {
  let i = 0;
  for (const n in t)
    if (e < t[n]) {
      i = n;
      break;
    }
  return i;
}, eF = (e, t) => {
  const { isTransposed: i } = t;
  let n = e[0].length > 0 ? e[0] : e[1];
  return i ? (n = e[0].length > 0 ? [...e[0]] : [], n = e[1].length > 0 ? [...n, ...e[1]] : n) : n = n.map((s, A) => {
    let o = [];
    return e[0].length > 0 && (o = [...e[0][A]]), e[1].length > 0 && (o = [...o, ...e[1][A]]), o;
  }), n;
}, IZ = (e) => {
  let t = {}, i = 0, n = Xs;
  const s = uZ(), A = [], o = e._layoutMatrix, a = e.primaryMatrix(), r = e.secondaryMatrix(), { isTransposed: l, breakPage: c } = e.config();
  if (l) {
    if (a.length === 0 ? n = Xs : r.length === 0 ? n = ta : n = a.length >= r.length ? Xs : ta, a.length > 0) {
      for (let h = 0; h < a.length - 1; h++)
        A.push(h);
      A.push(a.length - 1), n === ta && (i = a.length - 1);
    }
    if (r.length > 0) {
      const h = a.length;
      for (let d = r.length - 1; d > 0; d--)
        A.push(d + h);
      A.push(h), n === Xs && (i = h);
    }
    A.forEach((h) => {
      let d = -1;
      return s.key((u) => (d++, `${u[h].key()}-${tw(d, c)}`));
    });
    let g = [];
    g = o[0].map(
      (h, d) => o.map((u) => u[d])
    ), t = s.entries(g);
  } else {
    if (a.length === 0 ? n = Xs : r.length === 0 ? n = ta : n = a.length >= r.length ? Xs : ta, a.length > 0) {
      for (let g = 0; g < a[0].length - 1; g++)
        A.push(g);
      A.push(a[0].length - 1), (n === ta || r.length === 0) && (i = a[0].length - 1);
    }
    if (r.length > 0) {
      const g = a.length > 0 ? a[0].length : 0;
      for (let h = r[0].length - 1; h > 0; h--)
        A.push(h + g);
      A.push(g), n === Xs && (i = g);
    } else
      i = a.length > 0 ? a[0].length - 1 : 0;
    A.forEach((g) => {
      let h = -1;
      return s.key((d) => (h++, `${d[g].key()}-${tw(h, c)}`));
    }), t = s.entries(o);
  }
  return { tree: t, lastLevelKey: i };
}, CZ = (e, t) => e ? {
  height: 0,
  width: t.width
} : {
  height: t.height,
  width: 0
}, EZ = (e, t, i, n = [], s = {}) => {
  const { firstMeasure: A, secondMeasure: o } = t;
  let a = 0, r = 0;
  return e.values.forEach((l) => {
    let c = 0, g = 0;
    l.forEach((h, d) => {
      h.setAvailableSpace();
      let u = {
        ...h.getLogicalSpace({ useRawSpace: !0 }),
        ...s.calculateSecondMeasure === !1 ? { [o]: 0 } : {}
      };
      const f = s.calculateSecondMeasure === !1 ? 0 : h.getMinMeasures(i[o]);
      g = Math.max(g, +u[o], f), n[d] = Math.max(
        n[d] || 0,
        u[A]
      ), c += +n[d];
    }), r += g, a = Math.max(a, c), e.space = {
      [o]: Math.ceil(r),
      [A]: Math.ceil(a)
    };
  }), {
    [o]: r,
    [A]: a
  };
}, lm = (e = {}, t, i, n) => {
  const { isTransposed: s = !1, unitMeasures: A } = t, { firstMeasure: o, secondMeasure: a } = fZ(s), { values: r } = e, l = CZ(s, A), { extraCellLengths: c } = t;
  let g = r;
  if (g.length && g[0].key) {
    const h = { [o]: 0, [a]: 0 };
    return g.forEach((d, u) => {
      const f = lm(
        d,
        t,
        i,
        n !== void 0 ? n : u
      );
      h[o] = Math.max(
        h[o],
        f[o],
        l[o]
      ), h[a] += +f[a];
    }), e.space = h, h;
  }
  return EZ(
    e,
    { firstMeasure: o, secondMeasure: a },
    l,
    i,
    { calculateSecondMeasure: n >= c[0] }
  );
}, BZ = (e) => {
  let t = 0, i = 0;
  return e.forEach((n) => {
    const s = n.getLogicalSpace();
    t = Math.max(t, s.height), i += s.width;
  }), {
    width: i,
    height: t
  };
}, mZ = (e, t) => {
  let i = 0, n = 0;
  return e.forEach((s) => {
    const o = s[t].getLogicalSpace();
    n = Math.max(n, o.width), i += o.height;
  }), {
    width: n,
    height: i
  };
}, pd = (e, t) => {
  if (e.values[0].key) {
    const i = [];
    return e.values.forEach((n) => {
      t ? pd(n, t).forEach((A, o) => {
        i[o] = i[o] || [], i[o].push(...A);
      }) : i.push(...pd(n, t));
    }), e.matrix = i, i;
  }
  return t ? e.matrix = e.values[0].map(
    (i, n) => e.values.map((s) => s[n])
  ) : e.matrix = e.values, e.matrix;
}, pZ = (e, t, i) => {
  const n = [], s = [];
  return t ? e.forEach((A, o) => {
    o >= i ? s.push(A) : n.push(A);
  }) : e.forEach((A, o) => {
    A.forEach((a, r) => {
      r >= i ? (s[o] = s[o] || [], s[o].push(a)) : (n[o] = n[o] || [], n[o].push(a));
    });
  }), [n, s];
}, QZ = (e, t) => {
  const { availableWidth: i, width: n, row: s, innerMostColFacets: A, columnMaxWidth: o } = e, { isDistributionEqual: a, isTransposed: r, distribution: l, cellRenderer: c } = t;
  let g = 0;
  return l && l[0] && (g = l.reduce((d, u) => (d += u, d))), s.map((d, u) => {
    let f = d.getLogicalSpace().width;
    const C = d.overrideDimension != null && d.overrideDimension() != null ? d.overrideDimension().width : null, I = Math.max(
      A[u]?.getMinWidth() ?? 0,
      f
    );
    let E = c === "html" || d.config().touched ? f : I + (i - o) * (f / n);
    if (r) {
      if (l.length > 0)
        E = i * l[u] / g;
      else if ((a || n === 0) && C == null) {
        const B = s.length;
        E = i / B;
      }
    }
    return Math.floor(E);
  });
}, kf = (e) => K.isInvalid(e) ? null : e, iF = (e) => {
  const {
    unitMeasures: { border: t },
    priority: i,
    isTransposed: n
  } = e.config(), s = i === 2, A = un(e.tree(), (h) => h.values), o = (h) => n ? h.data.matrix[h.depth - 1][0] : h.data.matrix[0][h.depth - 1], a = (h, d) => {
    n ? h.width = d : h.height = d;
  }, r = (h, d) => {
    n ? h.height = d : h.width = d;
  }, l = (h) => n ? h.width - t : h.height, c = (h) => n ? h.height : h.width - t, g = [];
  return A.each((h) => {
    if (h.depth > 0 && h.height > 0 && h.data.touched && h.data.isPersistent) {
      const d = {}, u = h.ancestors().slice(0, -1).reverse().map((m) => {
        if (m.height <= (s ? 2 : 1)) {
          const p = h.height > 1 ? h.children[0].children[0].data[h.children[0].children[0].data.length - 2].source() : h.children[0].data[h.children[0].data.length - 1].source();
          if (typeof p == "object" && p !== null) {
            const w = {
              field: p.config().field,
              sourceType: p.config().metaInf.sourceType
            };
            return typeof h.data.touchedValue < "u" && (w.value = kf(h.data.touchedValue)), w;
          } else {
            const w = e.getNodeInfo(m, "muze-row-header");
            return {
              ...w,
              value: typeof w.value > "u" ? w.value : kf(o(m).rawSource())
            };
          }
        } else {
          const p = e.getNodeInfo(m, "muze-corner");
          return {
            ...p,
            value: typeof p.value > "u" ? p.value : kf(o(m).rawSource())
          };
        }
      }).filter((m) => m != null);
      d.target = u.length > 0 && Nl(u[u.length - 1]) ? u : u.filter((m) => !Nl(m));
      const C = o(h).source(), I = o(h)._overriddenDimension, E = l(I), B = c(I);
      if (E != null && n) {
        const m = d.target[d.target.length - 1].value;
        h.height === 1 && typeof C == "object" && C !== null && C.constructor.type() === "band" && typeof m < "u" ? yh(C.domain(), m) && a(d, E / C.domain().length) : a(d, E);
      }
      B != null && !n && r(d, B), g.push(d);
    }
  }), g;
}, nF = (e, t, { minWidth: i = 8, minHeight: n = 8 } = {}) => {
  const s = un(e.tree(), (f) => f.values), A = e.config().priority === 2, o = e.config().isTransposed, a = ll(e), r = (f, C) => {
    o ? f.nodeWidth = C : f.nodeHeight = C;
  }, l = (f, C) => {
    o ? f.nodeHeight = C : f.nodeWidth = C;
  }, c = (f) => o ? f.nodeWidth : f.nodeHeight, g = () => o ? i : n, h = () => o ? n : i, d = (f, C) => o ? C[f][0] : C[0][f], u = s.find((f) => {
    if (f.depth > 0 && f.height > 0) {
      const C = a(f);
      return ca(t, C);
    }
  });
  if (u == null)
    return { minHeight: null, minWidth: null };
  if (u.height <= (A ? 2 : 1)) {
    const f = d(
      u.depth - 1,
      u.data.matrix
    ), C = f.source();
    f.type === "axis" && C.constructor.type() === "band" ? t[t.length - 1].value == null ? r(u, C.domain().length * g()) : C.domain().find((E) => E === t[t.length - 1].value) ? r(u, g()) : r(u, null) : r(u, g());
  } else
    u.eachAfter((f) => {
      if (f.height > 0)
        if (f.height === 1) {
          const C = d(f.depth - 1, f.data.matrix), I = C.source();
          C.type === "axis" ? I.constructor.type() === "band" && t[t.length - 1].value == null ? r(f, g()) : r(f, I.domain().length * g()) : r(f, g());
        } else
          r(
            f,
            f.children.reduce((C, I) => C + c(I), 0)
          );
    });
  return l(u, h()), {
    minHeight: u.nodeHeight,
    minWidth: u.nodeWidth
  };
}, yZ = (e) => {
  let t = 0, i = 0, n = 0;
  const {
    isTransposed: s,
    distribution: A,
    availableHeight: o,
    height: a,
    isDistributionEqual: r,
    gutter: l,
    matrix: c,
    cIdx: g,
    cellRenderer: h
  } = e;
  A && A[0] !== void 0 && (t = A.reduce((u, f) => (u += f, u))), l && l[0] !== void 0 && (i = l.reduce((u, f) => (u += f, u))), n = o - Math.floor(o * i);
  const d = c.length;
  return c.map((u, f) => {
    const C = u[g], I = C.getLogicalSpace().height, E = C.overrideDimension != null && C.overrideDimension() != null ? C.overrideDimension().height : null;
    let B = h === "html" || C.config().touchedHeight ? I : I + (n - a) * (I / a);
    return s || (A.length > 0 && d === A.length ? B = n * A[f] / t : (r || e.height === 0) && E == null && (B = n / d)), Math.floor(B);
  });
}, lA = (e, t, i) => e.slice(t, -i), sF = (e = [], t, i, n) => {
  const s = n._breakPointer, A = n.config(), { isTransposed: o } = A, { tree: a, layoutMatrix: r } = i;
  if (t === 0) {
    const c = pZ(a.matrix, o, s);
    return e.push({
      matrix: a.matrix,
      primaryMatrix: c[0],
      secondaryMatrix: c[1],
      space: a.space
    }), e;
  }
  const l = t - 1;
  return a.values.forEach((c) => {
    sF(
      e,
      l,
      {
        tree: c,
        layoutMatrix: r
      },
      n
    );
  }), e;
}, wZ = (e, t) => {
  const { style: i, encoding: n } = e.config(), { smartLabel: s } = e.dependencies(), { geomMatrixSize: A, availableSpace: o } = t, { width: a, height: r } = e.calculateOptimumTextLabelDimensions(), { x: l, y: c } = e.axes(), g = [];
  let h = 0;
  e._normalizedData.forEach((S) => {
    S.forEach((b) => {
      const R = l.getIndex(b.x, null), G = c.getIndex(b.y, null);
      g[G] || (g[G] = []), g[G][R] || (g[G][R] = []), g[G][R].push(b), h = Math.max(h, g[G][R].length);
    });
  }), e.cellMaxCount(h);
  const d = l.domain(), u = c.domain(), f = a + 2 * xa, C = r + 2 * xa, I = Math.max(
    Math.floor(
      o.height / A.rows / u.length / C
    ),
    o$
  ), E = Math.max(
    Math.floor(
      o.width / A.columns / d.length / f
    ),
    a$
  );
  let B, m;
  h >= I * E ? (B = I, m = E) : (m = Math.min(E, Math.floor(Math.sqrt(h))), B = Math.floor(h / m), B > I && (B = I, m = Math.floor(h / B)));
  const p = m * B;
  let w, Q;
  p > 1 ? (w = m * f, Q = B * C) : (w = a, Q = r);
  const { charsAcross: y } = n.text, D = mh(y.min, "W");
  s.setStyle(i);
  const { width: _, height: x } = s.getOriSize(
    D
  );
  return w = Math.max(w, _), Q = Math.max(Q, x), h > 1 && (w += OA), w += vl * 2, Q += vl * 2, {
    width: w,
    height: Q
  };
}, DZ = {
  config: {
    sanitization: (e, t) => et(e._config || {}, t)
  },
  maxMeasures: {},
  availableSpace: {},
  logicalSpace: {}
};
class cm {
  /**
   *Creates an instance of VisualMatrix.
   * @param {any} matrix Two set of matrices
   * @param {any} [config={}] Configuration for VisualMatrix
   * @memberof VisualMatrix
   */
  constructor(t, i = {}) {
    this._lastLevelKey = 0, this._primaryMatrix = t[0] || [], this._secondaryMatrix = t[1] || [], this._maxMeasures = [], this._availableSpace = {}, this._overriddenDimension = {}, ve(this, DZ);
    const n = Object.assign({}, this.constructor.defaultConfig());
    this.config(et(n, i)), this._layoutMatrix = eF(
      [t[0] || [], t[1] || []],
      this.config()
    );
  }
  /**
   * Computes the logical space taken by the entire matrixTree
   *
   * @return {Object} Logical space taken
   * @memberof VisualMatrix
   */
  computeLogicalSpace() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  computeViewableSpaces() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   *
   *
   * @return
   * @memberof VisualMatrix
   */
  removeExtraCells() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  getPriorityDistribution() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Calculates the depth of the tree that can be viewed
   *
   * @param {Array} widthMeasures array of widths
   * @param {Array} heightMeasures array of heights
   * @return {number} depth of the tree
   * @memberof VisualMatrix
   */
  calculateDepth() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Redistributes the provied space to all cells
   *
   * @param {*} viewableMatrix current viewport matrix
   * @param {*} width provied width
   * @param {*} height provied height
   * @return {Object} current viewports matrixes with measures
   * @memberof VisualMatrix
   */
  redistributeSpaces() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Distibutes the given space row wisely
   *
   * @param {Object} measures Redistribution information
   * @memberof VisualMatrix
   */
  redistributeViewSpaces() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Dispatch the calculated cell dimensions to all the cells
   *
   * @param {Object} measures cell dimension information
   * @return {Object} row and column heights / widths
   * @memberof VisualMatrix
   */
  getCellDimensions() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   *
   *
   * @param {*} params
   * @returns
   * @memberof VisualMatrix
   */
  primaryMatrix(...t) {
    return t.length ? this : this._primaryMatrix;
  }
  secondaryMatrix(...t) {
    return t.length ? this : this._secondaryMatrix;
  }
  tree(...t) {
    return t.length ? this : this._tree;
  }
  static defaultConfig() {
    return Nu;
  }
  createTree() {
    const { tree: t, lastLevelKey: i } = IZ(this);
    return this._lastLevelKey = i, t;
  }
  overrideDimension(t) {
    return t == null ? this._overriddenDimension : (t.width != null && (this._overriddenDimension.width = t.width), t.height != null && (this._overriddenDimension.height = t.height), this);
  }
  /**
   * Returns the space taken by visual matrix
   *
   * @return {Object} space taken by the matrix
   * @memberof VisualMatrix
   */
  getLogicalSpace() {
    const t = {}, i = this.logicalSpace(), n = this.overrideDimension();
    return n.width ? t.width = n.width : t.width = i.width, n.height ? t.height = n.height : t.height = i.height, i.detail && (t.detail = i.detail), t;
  }
  /**
   * Sets the provied space to the visual matrix
   *
   * @param {number} width width provided
   * @param {number} height height provided
   * @memberof VisualMatrix
   */
  setAvailableSpace(t, i) {
    this.availableSpace({ width: t, height: i });
    const n = this.tree(), s = this.populateMaxMeasures(fd, n), A = this.populateMaxMeasures(DA, n), o = this.calculateDepth(A, s);
    return this.viewableMatrix = this.createViewPortMatrix(o), this.viewableMeasures = this.redistributeSpaces(t, i), this;
  }
  /**
   * Populate the max measures in the array
   *
   * @param {Array} measures array to be filled with max measures
   * @param {Object} matrixTree matrix tree of visual matrix
   * @param {number} measure width or height
   * @param {number} [depth=0] depth of the tree that to be calculated
   * @memberof VisualMatrix
   */
  populateMaxMeasures(t, i, n = 0, s = []) {
    if (s[n] = Math.max(s[n] || 0, i.space[t]), i.values) {
      const A = n + 1;
      i.values.forEach((o) => {
        o.space && (s = this.populateMaxMeasures(
          t,
          o,
          A,
          s
        ));
      });
    }
    return s;
  }
  /**
   * Gets the viewable measures for the current viewable matrix
   *
   * @return {Object} Set of viewable measures
   * @memberof VisualMatrix
   */
  getViewableSpaces() {
    return this.viewableMeasures;
  }
  /**
   * Returns the matrix that can be viewed in the current viewport
   *
   * @return {Array} Set of matrices that can be viewed
   * @memberof VisualMatrix
   */
  getViewableMatrices() {
    return this.viewableMatrix;
  }
  /**
   * Creates the viewport that can be viewed together
   *
   * @param {number} depth maxDepth that can be viewed in the viewport
   * @return {Array<Object>} Set of matrices that can be viewed
   * @memberof VisualMatrix
   */
  createViewPortMatrix(t) {
    const i = [];
    return sF(i, t, this.removeExtraCells(), this), i;
  }
}
class xZ extends cm {
  /**
   *Creates an instance of VisualMatrix.
   * @param {any} matrix Two set of matrices
   * @param {any} [config={}] Configuration for VisualMatrix
   * @memberof VisualMatrix
   */
  constructor(t, i = {}) {
    super(t, i);
    const n = this.config();
    this._breakPointer = t[0].length > 0 ? t[0][0].length : 0, this._layoutMatrix = eF(
      [t[0] || [], t[1] || []],
      n
    ), this._tree = {
      key: jz,
      values: this.createTree()
    }, this._hierarchy = un(this.tree(), (s) => s.values);
  }
  compute(t) {
    const i = this.config(), {
      cellRenderer: n,
      extraCellLengths: [s, A]
    } = i;
    t && n === "html" && this._layoutMatrix.slice(s, this._layoutMatrix.length - A).forEach((o, a) => {
      o[o.length - 1].overrideDimension({ height: t[a] });
    }), this._logicalSpace = this.computeLogicalSpace();
  }
  /**
   * Computes the logical space taken by the entire matrixTree
   *
   * @return {Object} Logical space taken
   * @memberof VisualMatrix
   */
  computeLogicalSpace() {
    const t = this.tree();
    return pd(t, !1), lm(
      t,
      { ...this.config() },
      this.maxMeasures()
    );
  }
  getMinTargetDimensions(...t) {
    return nF(this, ...t);
  }
  getNodeInfo(t, i) {
    const n = t.data.matrix[0][t.depth - 1], s = n.config().fieldName || i, A = n.rawSource && n.rawSource(), o = n.config().type === "headerTitle" || A === s;
    return {
      field: s,
      // header cells do not represent a value, just the field name - which is
      // already available in the field property of this returned object
      value: o ? void 0 : A,
      sourceType: Z(n.config(), "metaInf", "sourceType")
    };
  }
  computeViewableSpaces(t) {
    const { maxHeights: i, maxWidths: n, height: s } = t;
    return this.viewableMatrix.map((A, o) => {
      const a = {
        matrixInst: A,
        maxWidths: n,
        maxHeights: i,
        matrixIndex: o
      }, { widths: r, rowHeights: l, columnWidths: c } = this.getCellDimensions(a), g = [s, s], h = r;
      return {
        rowHeights: {
          primary: l[0],
          secondary: l[1]
        },
        columnWidths: {
          primary: c[0],
          secondary: c[1]
        },
        height: {
          primary: g[0],
          secondary: g[1]
        },
        width: {
          primary: h[0],
          secondary: h[1]
        }
      };
    });
  }
  /**
   *
   *
   * @return
   * @memberof VisualMatrix
   */
  removeExtraCells() {
    const { isTransposed: t, extraCellLengths: i } = this.config(), n = this._layoutMatrix, s = et({}, this.tree()), A = i[0], o = i[1] || Number.NEGATIVE_INFINITY, a = t ? n.slice(0).map((r) => lA(r, A, o)) : lA(n, A, o);
    return s.values = lA(s.values, A, o), s.matrix = lA(s.matrix, A, o), {
      tree: s,
      layoutMatrix: a
    };
  }
  getPriorityDistribution(t) {
    let i, n, s = [], A = [];
    const {
      matrix: o,
      width: a,
      maxMeasures: r,
      maxWidth: l,
      height: c
    } = t, g = this.primaryMatrix(), h = Ye(this._layoutMatrix), d = h.map(
      (v) => v.some((H) => H.config().touched)
    ), u = (v) => d[v], f = d[g[0].length - 1] === !0 ? -1 : g[0].length - 1, C = Ii(
      h.filter((v, H) => !u(H)).map((v) => xi(v.map((H) => H.getMinWidth())))
    ), { priority: I, priorityMinWidths: E, priorityMaxWidths: B } = this.config(), m = g.length ? g[0].length : 0, p = [];
    i = a, n = l;
    const { touchedColumnWidths: w, untouchedColumnWidths: Q } = r.map((v, H) => ({ width: v, originalIdx: H })).reduce(
      ({ touchedColumnWidths: v, untouchedColumnWidths: H }, N, M) => u(M) ? {
        touchedColumnWidths: v.concat(N),
        untouchedColumnWidths: H.slice()
      } : {
        touchedColumnWidths: v.slice(),
        untouchedColumnWidths: H.concat(N)
      },
      {
        touchedColumnWidths: [],
        untouchedColumnWidths: []
      }
    ), y = Ii(
      w,
      ({ width: v }) => v
    ), D = Ii(
      Q,
      ({ width: v }) => v
    ), _ = this._maxPossibleWidth - C;
    let x = [];
    if (y > _) {
      const H = (y - _) / y;
      x = w.map(
        ({ width: N, originalIdx: M }) => ({
          width: Math.round(N * (1 - H)),
          originalIdx: M
        })
      );
    } else
      x = w.slice();
    x.forEach(({ width: v, originalIdx: H }) => {
      s[H] = v;
    });
    const S = x.reduce(
      (v, { width: H, originalIdx: N }) => ({ ...v, [N]: H }),
      {}
    );
    i -= Ii(
      x,
      ({ width: v }) => v
    ), n = D, I === 2 ? A = [f, m] : A = I === 0 ? [f] : [m], A = A.filter(
      (v, H, N) => v != null && v >= 0 && N.indexOf(v) === H
    ), A.forEach((v) => {
      if (!u(v)) {
        p[v] = r[v];
        let H;
        E !== null && i < n ? p[v] === 0 ? H = 0 : H = Math.min(
          Math.max(
            r[v] / n,
            E / A.length
          ),
          B / A.length
        ) * i : H = r[v], p[v] = H, i -= H, n -= r[v];
      }
    }), o[0].forEach((v, H) => {
      u(H) || A.indexOf(H) === -1 && (p[H] = i * (r[H] / n));
    });
    const b = [];
    o.forEach(
      (v) => v.forEach((H, N) => {
        if (!u(N))
          if (A.indexOf(N) === -1) {
            H.setAvailableSpace(p[N], c);
            const M = H.getMinWidth();
            s[N] = S[N] == null ? Math.max(
              s[N] || 0,
              Math.floor(H.getLogicalSpace().width)
            ) : S[N], b[N] = Math.max(M, b[N] || 0);
          } else
            s[N] = p[N];
      })
    );
    let R = b.reduce((v, H) => v + (H || 0), 0);
    i -= R, s.forEach((v, H) => {
      if (!u(H) && A.indexOf(H) === -1 && r[H]) {
        const N = r[H] / n, M = Math.min(
          N * i,
          r[H]
        );
        s[H] = Math.max(M + b[H], 0), n -= r[H], i -= M;
      }
    });
    const G = Math.max(
      a - s.reduce((v, H) => v + H),
      0
    );
    A.forEach((v) => {
      u(v) || (s[v] = Math.floor(p[v] + G / A.length));
    });
    const T = this._maxPossibleWidth - Ii(s);
    return o.map((v) => {
      v.map((H) => {
        H._resizeDelta = T;
      });
    }), s;
  }
  /**
   * Calculates the depth of the tree that can be viewed
   *
   * @param {Array} widthMeasures array of widths
   * @param {Array} heightMeasures array of heights
   * @return {number} depth of the tree
   * @memberof VisualMatrix
   */
  // calculateDepth(widthMeasures, heightMeasures) {
  calculateDepth() {
    return 0;
  }
  /**
   * Redistributes the provied space to all cells
   *
   * @param {*} viewableMatrix current viewport matrix
   * @param {*} width provied width
   * @param {*} height provied height
   * @return {Object} current viewports matrixes with measures
   * @memberof VisualMatrix
   */
  redistributeSpaces(t, i) {
    let n = [], s = [];
    const A = this.maxMeasures(), o = A.reduce((r, l) => (r += l, r)), a = this.getPriorityDistribution({
      matrix: this._layoutMatrix,
      maxWidth: o,
      maxMeasures: A,
      width: t,
      height: i
    });
    return this.viewableMatrix.forEach((r) => {
      const h = {
        mWidth: 0,
        mHeight: 0,
        matrix: r.matrix,
        width: t,
        height: i,
        maxHeights: n,
        maxWidths: s,
        logicalWidths: a
      }, d = this.redistributeViewSpaces(h);
      s = d.maxWidths, n = d.maxHeights;
    }), this.computeViewableSpaces({ height: i, width: t, maxHeights: n, maxWidths: s });
  }
  blueprints() {
    return iF(this);
  }
  /**
   * Distibutes the given space row wisely
   *
   * @param {Object} measures Redistribution information
   * @memberof VisualMatrix
   */
  redistributeViewSpaces(t) {
    let i = [], n = [], s = 0;
    const A = this.maxMeasures(), {
      isDistributionEqual: o,
      distribution: a,
      isTransposed: r,
      gutter: l,
      cellRenderer: c
    } = this.config(), { matrix: g, height: h, maxHeights: d, maxWidths: u, logicalWidths: f } = t;
    s = mZ(g, this._lastLevelKey).height;
    const C = A.reduce((I, E) => (I += E, I));
    t.maxMeasures = A, t.maxWidth = C, C > 0 ? i = f : i = A.map(() => 0), n = yZ({
      matrix: g,
      cIdx: this._lastLevelKey,
      height: s,
      availableHeight: h,
      isDistributionEqual: o,
      distribution: a,
      isTransposed: r,
      gutter: l,
      cellRenderer: c
    }), u.length > 0 && (i = i.map((I, E) => Math.max(I, u[0][E] || 0))), u.push(i);
    for (let I = 0; I < u.length; I++)
      u[I] = i;
    return d.push(n), { maxWidths: u, maxHeights: d };
  }
  /**
   * Dispatch the calculated cell dimensions to all the cells
   *
   * @param {Object} measures cell dimension information
   * @return {Object} row and column heights / widths
   * @memberof VisualMatrix
   */
  getCellDimensions(t) {
    const { unitMeasures: i } = this.config(), n = i.border, { matrixInst: s, maxWidths: A, maxHeights: o, matrixIndex: a } = t, r = s.matrix, l = [[0], [0]], c = [[0], [0]], g = [0, 0], h = [0, 0], d = this._breakPointer;
    return r.forEach((u, f) => {
      u.forEach((C, I) => {
        const E = o[a][f] || 0, B = A[a][I];
        C.setAvailableSpace(B - n, E - n), f === 0 && I < d ? (c[0][I] = B, h[0] = (h[0] || 0) + B) : f === 0 && I >= d && (c[1][I - d] = B, h[1] = (h[1] || 0) + B), I === this._lastLevelKey && (l[0][f] = E, l[1][f] = E);
      });
    }), {
      heights: g,
      widths: h,
      rowHeights: l,
      columnWidths: c
    };
  }
}
class SZ extends cm {
  /**
   * Creates an instance of VisualMatrix.
   * @param {any} matrix Two set of matrices
   * @param {any} [config={}] Configuration for VisualMatrix
   * @memberof VisualMatrix
   */
  constructor(t, i = {}) {
    super(t, i);
    const n = this.config();
    this._breakPointer = t[0].length, this._cornerMatrices = {
      ...n.cornerMatrices
    }, this._tree = {
      key: zz,
      values: this.createTree()
    }, this._hierarchy = un(this.tree(), (s) => s.values);
  }
  compute(t) {
    const i = this.config(), {
      cellRenderer: n,
      extraCellLengths: [s, A]
    } = i;
    if (t && n === "html") {
      const o = this._layoutMatrix[this._layoutMatrix.length - 1];
      o.slice(s, o.length - A).forEach((a, r) => {
        a.overrideDimension({ width: t[r] });
      });
    }
    this._logicalSpace = this.computeLogicalSpace();
  }
  /**
   * Computes the logical space taken by the entire matrixTree
   *
   * @return {Object} Logical space taken
   * @memberof VisualMatrix
   */
  computeLogicalSpace() {
    const t = this.tree();
    return pd(t, !0), lm(
      t,
      { ...this.config() },
      this.maxMeasures()
    );
  }
  getMinTargetDimensions(...t) {
    return nF(this, ...t);
  }
  getNodeInfo(t, i) {
    return {
      field: typeof t.data.matrix[t.depth - 1][0].config().fieldName > "u" ? i : t.data.matrix[t.depth - 1][0].config().fieldName,
      value: t.data.matrix[t.depth - 1][0].rawSource && t.data.matrix[t.depth - 1][0].rawSource(),
      sourceType: Z(
        t.data.matrix[t.depth - 1][0].config(),
        "metaInf",
        "sourceType"
      )
    };
  }
  computeViewableSpaces(t) {
    const { maxHeights: i, maxWidths: n, height: s, width: A } = t, o = this.cornerMatrixSpaces();
    return this.viewableMatrix.map((a, r) => {
      const l = {
        matrixInst: a,
        maxWidths: n,
        maxHeights: i,
        matrixIndex: r,
        height: s
      }, { heights: c, rowHeights: g, columnWidths: h } = this.getCellDimensions(l), d = c, u = [A, A];
      return {
        rowHeights: {
          primary: g[0].map((f, C) => Math.max(
            f,
            o.topLeft.rowHeights[C],
            o.topRight.rowHeights[C]
          )),
          secondary: g[1].map((f, C) => Math.max(
            f,
            o.bottomLeft.rowHeights[C],
            o.bottomRight.rowHeights[C]
          ))
        },
        columnWidths: {
          primary: h[0],
          secondary: h[1]
        },
        height: {
          primary: Math.max(
            d[0],
            o.topLeft.height,
            o.topRight.height
          ),
          secondary: Math.max(
            d[1],
            o.bottomLeft.height,
            o.bottomRight.height
          )
        },
        width: {
          primary: u[0],
          secondary: u[1]
        }
      };
    });
  }
  cornerMatrices() {
    return this._cornerMatrices;
  }
  cornerMatrixSpaces() {
    const t = {};
    return Object.keys(this._cornerMatrices).map((i) => {
      const s = this._cornerMatrices[i].map((A) => A.map((o) => o.getLogicalSpace()).reduce((o, a) => Math.max(o, a.height), 0));
      t[i] = {
        rowHeights: s,
        height: s.reduce((A, o) => A + o, 0)
      };
    }), t;
  }
  /**
   *
   *
   * @return
   * @memberof VisualMatrix
   */
  removeExtraCells() {
    const { isTransposed: t, extraCellLengths: i } = this.config(), n = this._layoutMatrix, s = et({}, this.tree()), A = i[0], o = i[1] || Number.NEGATIVE_INFINITY, a = t ? n.slice(0).map((r) => lA(r, A, o)) : lA(n, A, o);
    return s.values = lA(s.values, A, o), s.matrix = s.matrix.map(
      (r) => lA(r, A, o)
    ), {
      tree: s,
      layoutMatrix: a
    };
  }
  getPriorityDistribution(t) {
    const { height: i, maxHeights: n } = t;
    let s = i, A = [], o = [], a = 2;
    const r = this.config().priority, l = this.primaryMatrix().length;
    return r === 2 ? (o = [l - 1, l], a = 2) : (o = r === 0 ? [l - 1] : [l], a = 1), n.forEach((c, g) => {
      o.indexOf(g) === -1 && (A[g] = c, s -= c);
    }), s < 0 ? A = A.map(() => 0) : o.forEach((c) => {
      A[c] = Math.min(
        n[c],
        s / a
      );
    }), A;
  }
  /**
   * Calculates the depth of the tree that can be viewed
   *
   * @param {Array} widthMeasures array of widths
   * @param {Array} heightMeasures array of heights
   * @return {number} depth of the tree
   * @memberof VisualMatrix
   */
  // calculateDepth(widthMeasures) {
  calculateDepth() {
    return 0;
  }
  blueprints() {
    return iF(this);
  }
  /**
   * Redistributes the provied space to all cells
   *
   * @param {*} viewableMatrix current viewport matrix
   * @param {*} width provied width
   * @param {*} height provied height
   * @return {Object} current viewports matrixes with measures
   * @memberof VisualMatrix
   */
  redistributeSpaces(t, i) {
    let n = [], s = [];
    return this.viewableMatrix.forEach((A) => {
      const l = {
        mWidth: 0,
        mHeight: 0,
        matrix: A.matrix,
        width: t,
        height: i,
        maxHeights: n,
        maxWidths: s
      }, c = this.redistributeViewSpaces(l);
      s = c.maxWidths, n = c.maxHeights;
    }), this.computeViewableSpaces({ height: i, width: t, maxHeights: n, maxWidths: s });
  }
  /**
   * Distibutes the given space column wisely
   *
   * @param {Object} measures Redistribution information
   * @memberof VisualMatrix
   */
  redistributeViewSpaces(t) {
    let i = [];
    const { matrix: n, width: s, maxHeights: A, maxWidths: o, height: a } = t, r = this.config().unitMeasures.border, l = BZ(n[this._lastLevelKey]).width, c = this._lastLevelKey > 0 ? n[this._lastLevelKey - 1] : [];
    let g = 0;
    c.forEach((d, u) => {
      const C = n[this._lastLevelKey][u].getLogicalSpace(), I = d.getMinWidth(), E = Math.max(C.width, I);
      g += E;
    });
    const h = QZ(
      {
        row: n[this._lastLevelKey],
        width: l,
        availableWidth: s,
        innerMostColFacets: c,
        columnMaxWidth: g || l
      },
      this.config()
    );
    n.forEach(
      (d, u) => d.forEach((f, C) => {
        const I = f.getLogicalSpace();
        f.setAvailableSpace(
          h[C] - r,
          I.height
        ), i[u] = Math.max(
          i[u] || 0,
          Math.floor(f.getLogicalSpace().height)
        );
      })
    ), A.length > 0 && (i = i.map((d, u) => Math.max(d, A[0][u]))), a > 0 && fx(i) === 0 && (i[i.length - 1] = a), A.push(i);
    for (let d = 0, u = A.length; d < u; d++)
      A[d] = i;
    return o.push(h), { maxHeights: A, maxWidths: o };
  }
  /**
   * Dispatch the calculated cell dimensions to all the cells
   *
   * @param {Object} measures cell dimension information
   * @return {Object} row and column heights / widths
   * @memberof VisualMatrix
   */
  getCellDimensions(t) {
    const { unitMeasures: i } = this.config(), n = i.border, { matrixInst: s, height: A, maxWidths: o, maxHeights: a, matrixIndex: r } = t, l = s.matrix, c = [[0], [0]], g = [[0], [0]], h = [0, 0], d = [0, 0], u = this._breakPointer, f = this.getPriorityDistribution({
      height: A,
      maxHeights: a[0] || []
    });
    return l.forEach((C, I) => {
      C.forEach((E, B) => {
        const m = f[I] || 0, p = o[r][B];
        E.setAvailableSpace(p - n, m), B === 0 && I < u ? (c[0][I] = m, h[0] = (h[0] || 0) + m) : B === 0 && I >= u && (c[1][I - u] = m, h[1] = (h[1] || 0) + m), I === this._lastLevelKey && (g[0][B] = p, g[1][B] = p);
      });
    }), {
      heights: h,
      widths: d,
      rowHeights: c,
      columnWidths: g
    };
  }
}
const ew = 12;
class _Z extends cm {
  constructor(t, i = {}) {
    super([t], i);
  }
  compute(t) {
    const i = this.config();
    this._logicalSpace = i.cellRenderer === "html" ? this.computeLogicalSpace(t) : { detail: {} };
  }
  computeLogicalSpace(t) {
    const i = this.primaryMatrix(), n = {
      rows: i.length,
      columns: i.length ? i[0].length : 0
    }, s = i.map((a) => a.map((r) => {
      const c = r.source().layers(), { width: g, height: h } = c.reduce(
        (d, u) => {
          const { width: f, height: C } = wZ(u, {
            ...t,
            geomMatrixSize: n
          }), { x: I, y: E } = u.axes();
          return {
            width: Math.max(
              d.width,
              (f + ew) * I.domain().length
            ),
            height: d.height + (C + ew) * E.domain().length
          };
        },
        { width: 0, height: 0 }
      );
      return {
        width: g,
        height: h
      };
    })), A = s.map((a) => {
      const r = a.map(({ height: l }) => l);
      return Math.max(...r);
    }), o = Ye(s).map(
      (a) => {
        const r = a.map(({ width: l }) => l);
        return Math.max(...r);
      }
    );
    return {
      width: Ii(o),
      height: Ii(A),
      detail: { rowHeights: A, columnWidths: o }
    };
  }
}
const bZ = (e, t) => {
  let i = [], n = [], s = [], A = [], o, a;
  const {
    isRowSizeEqual: r,
    isColumnSizeEqual: l,
    gutterSpace: c,
    distribution: g,
    border: h,
    breakPage: d,
    priority: u,
    cellRenderer: f,
    priorityMinWidths: C,
    priorityMaxWidths: I,
    rows: { totalMaxWidthRatio: E }
  } = e.config(), { minUnitHeight: B, minUnitWidth: m } = e.measurement(), { top: p, center: w, bottom: Q } = t, [y, D, _] = p, [x, S, b] = w, [R, G, T] = Q;
  x.length > 0 && (i = [...y, ...x, ...R]), b.length > 0 && (n = [..._, ...b, ...T]), D.length > 0 && D[0].length > 0 && (s = D.map((M, F) => [...y[F], ...M, ..._[F]])), G.length > 0 && G[0].length > 0 && (A = G.map((M, F) => [
    ...R[F],
    ...M,
    ...T[F]
  ]));
  const v = {
    topLeft: y,
    topRight: _,
    bottomLeft: R,
    bottomRight: T
  }, H = new _Z(S, { cellRenderer: f });
  e.centerMatrix(H);
  const N = Math.min(
    dZ,
    Math.max(hZ, E)
  );
  return e.rowMatrix(
    new xZ([i, n], {
      totalMaxWidthRatio: N,
      isDistributionEqual: r,
      distribution: g.rows,
      gutter: c.rows,
      unitMeasures: {
        width: m,
        height: B,
        border: h.width
      },
      priority: u.row,
      breakPage: d.rows.map(
        (M) => M + Math.max(y.length, _.length)
      ),
      extraCellLengths: [y.length, R.length],
      // centerMatrixDetails: rowHeights,
      cellRenderer: f,
      priorityMinWidths: C.row,
      priorityMaxWidths: I.row
    })
  ), y.length > 0 ? o = y[0].length : o = R.length > 0 ? R[0].length : 0, _.length > 0 ? a = _[0].length : a = T.length > 0 ? T[0].length : 0, e.columnMatrix(
    new SZ([s, A], {
      isDistributionEqual: l,
      distribution: g.columns,
      gutter: c.columns,
      isTransposed: !0,
      unitMeasures: {
        width: m,
        height: B,
        border: h.width
      },
      priority: u.col,
      breakPage: d.columns,
      extraCellLengths: [o, a],
      // centerMatrixDetails: columnWidths,
      cellRenderer: f,
      cornerMatrices: v
    })
  ), t;
};
function Qd(e, t) {
  return e ? e.getLogicalSpace()[t] : 0;
}
const pg = (e, t, i) => {
  e.forEach((n, s) => {
    n.forEach((A, o) => {
      A.setAvailableSpace(t[o], i[s]);
    });
  });
}, iw = (e, t, i) => {
  let n = e.config()[`${t}Pointer`];
  return i.length - 1 < n && (n = 0, e.config({ [`${t}Pointer`]: n })), n;
}, MZ = {
  column: {
    maxMeasure: i$,
    matrix: n$,
    measureType: DA,
    scrollType: wN
  },
  row: {
    maxMeasure: s$,
    matrix: A$,
    measureType: fd,
    scrollType: yN
  }
}, NZ = (e, t, i, n) => {
  const { pagination: s, cellRenderer: A } = e.config(), { matrix: o, measureType: a, scrollType: r } = t;
  switch (s) {
    case t$:
      return i;
    default: {
      const l = Qd(e[o](), a) + n;
      return A === "html" ? e.centerMatrix().getLogicalSpace()[a] + n > i && e.scrollInfo({ [r]: !0 }) : Math.ceil(l) > Math.ceil(i) && e.scrollInfo({ [r]: !0 }), Math.max(i, l);
    }
  }
}, AF = (e, t, i, n) => NZ(
  e,
  MZ[t],
  i,
  n
), FZ = (e) => {
  const t = e.rowMatrix(), i = t.config().totalMaxWidthRatio, n = e.columnMatrix(), { width: s } = e.measurement(), {
    border: A,
    buffer: o,
    axes: {
      x: { compact: a }
    }
  } = e.config(), r = a ? 0 : A.width, l = Qd(t, DA), c = Qd(n, DA), g = Math.max(
    1 - c / s,
    i
  ), h = Math.min(
    l + o,
    s * g
  ), d = s - h - r, u = AF(
    e,
    Jn,
    d,
    0
  );
  return {
    rowMatrixWidth: l,
    maxRowMatrixWidth: h,
    columnMatrixWidth: u,
    maxWidthAvailableForColumnMatrix: d
  };
}, RZ = (e, t) => {
  const { height: i } = e.measurement(), n = e.columnMatrix(), s = Math.min(
    n.getLogicalSpace().height,
    i / 2
  );
  n.setAvailableSpace(t, s);
  const o = n.getViewableSpaces()[e.config().columnPointer];
  return {
    columnMatrixHeight: o.height.primary + o.height.secondary,
    maxColumnMatrixHeight: s
  };
}, kZ = (e, t) => {
  const { height: i } = e.measurement(), { buffer: n } = e.config(), { columnMatrixHeight: s, maxColumnMatrixHeight: A } = RZ(e, t), o = i - Math.min(A, s), a = AF(
    e,
    Kn,
    o,
    n
  );
  return {
    columnMatrixHeight: s,
    maxColumnMatrixHeight: A,
    rowMatrixHeight: a,
    maxHeightAvailableForRowMatrix: o
  };
}, vZ = (e, t, i) => {
  const n = e.centerMatrix().primaryMatrix(), { border: s } = e.config(), A = e.matrices(), { top: o, bottom: a } = A, r = s.width, l = [].concat(
    ...t.map((f) => f.rowHeights.primary)
  ), c = [].concat(
    ...t.map((f) => f.columnWidths.primary)
  ), g = [].concat(
    ...t.map((f) => f.columnWidths.secondary)
  ), h = [].concat(
    ...i.map((f) => f.columnWidths.primary)
  ), d = i[0].rowHeights.primary, u = [].concat(
    ...i.map((f) => f.rowHeights.secondary)
  );
  n.forEach((f, C) => {
    f.forEach((I, E) => {
      I.setAvailableSpace(
        h[E] - r,
        l[C] - r
      );
    });
  }), pg(o[0], c, d), pg(o[2], g, d), pg(a[0], c, u), pg(a[2], g, u);
}, nw = {
  isScroll: !0,
  pagination: e$
}, TZ = (e, t) => {
  const i = e.scrollInfo(), { pagination: n } = e.config(), s = {
    pagination: n,
    isScroll: i[t]
  };
  return Object.keys(nw).every(
    (A) => nw[A] === s[A]
  );
}, GZ = (e) => {
  const { buffer: t } = e.config(), [i, n] = [wN, yN].map(
    (s) => TZ(e, s) ? t : 0
  );
  return {
    horizontalBuffer: i,
    verticalBuffer: n
  };
}, LZ = (e) => {
  const t = e.rowMatrix(), i = t.config().totalMaxWidthRatio, n = e.columnMatrix(), { width: s } = e.measurement(), {
    rowMatrixWidth: A,
    maxRowMatrixWidth: o,
    maxWidthAvailableForColumnMatrix: a,
    columnMatrixWidth: r
  } = FZ(e), {
    columnMatrixHeight: l,
    rowMatrixHeight: c,
    maxHeightAvailableForRowMatrix: g
  } = kZ(e, r), { horizontalBuffer: h, verticalBuffer: d } = GZ(e), u = Math.max(
    1 - Qd(n, DA) / s,
    i
  );
  t._maxPossibleWidth = s * u - d, t.setAvailableSpace(
    o - d,
    c - h
  );
  const f = t.getViewableSpaces(), C = n.getViewableSpaces();
  return iw(e, Kn, f), iw(e, Jn, C), vZ(e, f, C), {
    rowMatrixHeight: c - h,
    rowMatrixWidth: A - d,
    maxHeightAvailableForRowMatrix: g - h,
    columnMatrixHeight: l,
    columnMatrixWidth: r,
    maxWidthAvailableForColumnMatrix: a
  };
}, UZ = (e, t, i) => {
  const n = e.rowMatrix(), s = e.columnMatrix(), A = e.centerMatrix().primaryMatrix(), o = e.matrices(), a = n.getViewableMatrices(), r = s.getViewableMatrices(), l = {
    row: 0,
    column: 0
  };
  for (let h = t - 1; h >= 0; h--) {
    const d = Math.max(
      a[h].primaryMatrix.length,
      a[h].secondaryMatrix.length
    );
    l.row += d;
  }
  for (let h = i - 1; h >= 0; h--) {
    const d = r[h], { primaryMatrix: u, secondaryMatrix: f } = d, C = Math.max(
      u[0] ? u[0].length : 0,
      f[0] ? f[0].length : 0
    );
    l.column += C;
  }
  o.top[1] = r[i].primaryMatrix, o.bottom[1] = r[i].secondaryMatrix, o.center[0] = a[t].primaryMatrix, o.center[2] = a[t].secondaryMatrix;
  const c = Math.max(
    o.center[0].length,
    o.center[2].length
  ), g = Math.max(
    o.top[1][0] ? o.top[1][0].length : 0,
    o.bottom[1][0] ? o.bottom[1][0].length : 0
  );
  return o.center[1] = A.slice(l.row, l.row + c).map(
    (h) => h.slice(
      l.column,
      l.column + g
    )
  ), {
    matrices: o,
    rowPages: a.length,
    columnPages: r.length
  };
}, Qg = (e) => e.reduce((t, i) => t + i, 0), HZ = (e, t, i) => {
  const n = e.rowMatrix(), s = e.columnMatrix(), { columnPointer: A, rowPointer: o } = e.config(), a = n.getViewableSpaces()[o], r = s.getViewableSpaces()[A], { rowHeights: l, width: c } = a, { columnWidths: g, height: h } = r, { primary: d, secondary: u } = c, { primary: f, secondary: C } = h, I = Qg(l.primary), E = Qg(g.primary), B = [d, Math.min(E, i), u], m = [
    f,
    Math.min(I, t),
    C
  ];
  return {
    viewWidth: B,
    viewHeight: m,
    actualCenterMeasures: {
      height: I,
      width: E
    },
    totalMeasures: {
      width: Qg(B),
      height: Qg(m)
    },
    unitHeights: l,
    unitWidths: g
  };
};
class gm extends lZ {
  /**
   * Creates an instance of TableLayout.
   * @param {HTMLElement} matrices Set of upto 9 matrices containing the cells to be rendered
   * @param {HTMLElement} mountPoint DOM element/d3 selection where the layout is to be mounted
   * @param {Object} measurement The dimensions of the layout
   * @param {Object} config external configurations.
   * @memberof GenericLayout
   */
  constructor(t, i, n, s) {
    super(i, n, s), this.matrices(t), this.config(this.constructor.defaultConfig()), this._layoutId = Zt(), this._scrollInfo = { horizontal: !1, vertical: !1 };
  }
  static defaultViewInfo() {
    return Object.assign(
      {},
      {
        layoutDimensions: {
          border: this.defaultConfig().border,
          viewHeight: [0, 0, 0],
          viewWidth: [0, 0, 0]
        },
        viewMatricesInfo: {
          columnPages: 0,
          rowPages: 0,
          matrices: { top: [], center: [], bottom: [] }
        }
      }
    );
  }
  /**
   * Returns initial set of measurements for the grid layout
   *
   * @static
   * @return {Object} Returns initial set of measurements
   * @memberof GridLayout
   */
  static defaultMeasurement() {
    return gZ;
  }
  /**
   * Returns initialconfiguration for grid layout
   *
   * @static
   * @return {Object} Returns initial configuration for grid layout
   * @memberof GridLayout
   */
  static defaultConfig() {
    return cZ;
  }
  /**
   * This function is used to return an instance of GridLayout
   *
   * @return {GridLayout} Instance of grid layout.
   * @static
   * @memberof GridLayout
   */
  static create() {
    return new gm(
      null,
      null,
      this.defaultMeasurement(),
      this.defaultConfig()
    );
  }
  /**
   * Sets/Gets the matrices for the layout
   *
   * @param {Array} matrices Set of matrices
   * @return {Object} Getter/Setter
   * @memberof GridLayout
   */
  matrices(t) {
    return t ? (this._matrices = bZ(this, t), this) : super.matrices(t);
  }
  compute() {
    const { width: t, height: i } = this.measurement();
    this.centerMatrix().compute({
      availableSpace: { width: t, height: i }
    });
    const {
      detail: { rowHeights: n, columnWidths: s }
    } = this._centerMatrix.getLogicalSpace();
    this._rowMatrix.compute(n), this._columnMatrix.compute(s);
  }
  /**
   * Triggers the computations for the layout based on the matrices available
   * This causes a reflow in the entire layout system.
   *
   * @return {Object} Layout instance
   * @memberof GridLayout
   */
  triggerReflow() {
    this.scrollInfo({ horizontal: !1, vertical: !1 });
    const { maxHeightAvailableForRowMatrix: t, maxWidthAvailableForColumnMatrix: i } = LZ(this);
    return this.setViewInformation(
      t,
      i
    ), this;
  }
  gotoPage(t, i) {
    const n = t.toLowerCase(), { viewMatricesInfo: s } = this.viewInfo(), A = s[`${n}Pages`], o = Math.min(Math.max(1, i), A);
    return this.config({
      [`${n}Pointer`]: o - 1
    }), this.setViewInformation(), this.renderGrid(), this;
  }
  pages(t) {
    const { viewMatricesInfo: i } = this.viewInfo(), n = t.toLowerCase();
    return {
      totalPages: i[`${n}Pages`],
      currentPage: this.config()[`${n}Pointer`] + 1
    };
  }
  viewInfo(...t) {
    return t.length ? (this._viewInfo = t[0], this) : this._viewInfo;
  }
  scrollInfo(...t) {
    return t.length ? (this._scrollInfo = et(this._scrollInfo, t[0]), this) : this._scrollInfo;
  }
  /**
   *
   *
   * @returns
   * @memberof GridLayout
   */
  setViewInformation(t, i) {
    const { rowPointer: n, columnPointer: s, border: A } = this.config(), o = UZ(this, n, s), a = HZ(
      this,
      t,
      i
    );
    return a.border = A, this.viewInfo({
      viewMatricesInfo: o,
      layoutDimensions: a
    }), this;
  }
  remove() {
    Object.values(this.matrices()).forEach((t) => {
      t.forEach((i) => {
        i.forEach((n) => {
          n.forEach((s) => {
            s.remove();
          });
        });
      });
    });
  }
}
class OZ {
  /**
   * Property accessor for data member of the class. Data is passed to the system by calling this method.
   */
  data() {
    throw new Error(yt.INTERFACE_IMPl);
  }
  /**
   * Property accessor for width of the class. Width is passed as an integer.
   */
  width() {
    throw new Error(yt.INTERFACE_IMPl);
  }
  /**
   * Property accessor for height of the class. Height is passed as an integer.
   */
  height() {
    throw new Error(yt.INTERFACE_IMPl);
  }
  /**
   * Property accessor for config of the class. Config is passed as an object.
   */
  config() {
    throw new Error(yt.INTERFACE_IMPl);
  }
}
const PZ = (e) => {
  const t = e.config().legend, i = e.title()[1], n = e.subtitle()[1], s = {
    [`${Re}-${Re}`]: [Mi, $n, ug],
    [`${aA}-${aA}`]: [ug, $n, Mi],
    [`${Re}-${aA}`]: [Mi, ug, $n],
    [`${aA}-${Re}`]: [$n, ug, Mi]
  }, A = [
    [rC, Iy],
    [Iy, rC]
  ], o = i.position || Re, a = n.position || Re;
  return {
    headers: s[`${o}-${a}`],
    legends: t.position === li || t.position === Re ? A[0] : A[1]
  };
}, sw = (e) => typeof e == "function" && !e._sanitize ? e() : wx(e()), YZ = (e, t, i, n) => {
  let s = {};
  const {
    content: A,
    classPrefix: o,
    maxLines: a,
    separator: r,
    columnHeaderFields: l,
    align: c
  } = e, g = () => new My(
    {
      type: "header",
      className: `${o}-composite-${ds}-cell`,
      subType: ds,
      textAlign: c,
      separator: r
    },
    { labelManager: i }
  ).config({ maxLines: a }).minSpacing({ width: 0, height: 0 }), h = () => new _o(
    {
      type: t === Mi ? "header" : "text",
      className: `${o}-${t}-cell`,
      subType: t,
      textAlign: c
    },
    { labelManager: i }
  ).config({ maxLines: a }).minSpacing({ width: 0, height: 0 }), u = ((f, C) => {
    const I = f && C === ds && f instanceof My, E = f && C !== ds && f instanceof _o;
    if (I || E)
      return f;
    if (C === ds) {
      const m = g();
      return m.source({ texts: A, fields: l }), m;
    }
    const B = h();
    return B.source(A), B;
  })(n, t);
  return u._minTickDiff = { height: 0, width: 0 }, e.position === Re ? s = { top: 0, bottom: e.padding } : s = { top: e.padding, bottom: 0 }, u.config({ margin: s }), u;
}, JZ = (e, t, i, n) => e ? YZ(e, t, i, n) : "", KZ = (e) => {
  const t = {}, i = e.subtitle(), n = sw(i[0]);
  return (e.config().columns.headers.show ? [Mi, $n, ds] : [Mi, $n]).forEach((A) => {
    let o = {}, a = "", r = null;
    if (A === ds) {
      o = e.config().columns.headers;
      const l = e.composition().visualGroup.matrix().column();
      a = l.getColumnTexts(), r = l.getColumnTitleFields();
    } else
      o = e[A](), a = sw(o[0]);
    if (a) {
      const l = A === Mi || A === $n ? o[1] : o;
      l.classPrefix = e.config().classPrefix, l.content = a, l.columnHeaderFields = r, l.padding = A === Mi && n && !n.length ? i[1].padding : l.padding;
      const c = JZ(
        l,
        A,
        e.dependencies().smartlabel,
        e[`${A}Cell`]
      );
      t[`${A}Cell`] = c, e._composition[A] = c;
    }
  }), t;
}, VZ = (e, t) => {
  const { width: i, height: n } = t;
  let s = 0;
  if (n >= 200 && i >= 200) {
    for (let A in e) {
      const o = e[A], a = {};
      a.width = i, a.height = n, o.config(a);
      const r = o.getLogicalSpace().height;
      s += r;
    }
    return s;
  }
  return s;
}, WZ = (e) => {
  const t = [], i = e.getRetinalAxes();
  return Object.entries(i).forEach((n) => {
    const s = n[0];
    if (s !== "opacity") {
      const A = n[1], o = e.data();
      A.forEach((a) => {
        if (!a)
          return;
        const { field: r, type: l, step: c, splitFieldValue: g, splitBy: h } = a.config(), d = o.getFieldIndex(r), u = Number.isFinite(d) && d >= 0;
        if (r && u && a.domain()) {
          const C = ez[`${l}-${typeof c == "boolean" ? c : !1}-${s}`];
          t.push({
            scale: a,
            canvas: e,
            fieldName: r,
            splitFieldInfo: {
              field: h ? h.field : null,
              value: h ? g : null
            },
            title: g || dc(e.data(), r),
            LegendCls: C,
            scaleType: s
          });
        }
      });
    }
  }), t;
}, qZ = (e, t) => {
  const i = e.map((s) => s.config().mark);
  return tz[(t === ks || t === vs) && i.includes(az)];
}, jZ = ({ legend: e, scaleType: t }, i) => (n) => {
  const s = e.fieldName(), A = e.config().splitFieldInfo;
  A.field ? (i.props.legend[t][s] || (i.props.legend[t][s] = {
    splitLegends: {}
  }), i.props.legend[t][s].splitLegends[A.value] = {
    interaction: n
  }) : i.props.legend[t][s] = {
    interaction: n
  };
}, zZ = (e, t) => {
  const i = [], n = WZ(t), { invalidValues: s, useUTC: A } = t.config(), o = t.registry().interactions.legend, a = fE(s);
  return n.forEach((r) => {
    const {
      LegendCls: l,
      scale: c,
      fieldName: g,
      splitFieldInfo: h,
      title: d,
      scaleType: u
    } = r;
    e[u][dg] = e[u][dg] !== void 0 ? e[u][dg] : e[dg];
    const f = et(
      { ...Mx([ks, go, vs], e) },
      e[u] || {}
    ), C = Z(f, "fields", g) || {}, I = Z(C, c.config().as) || {}, E = Z(
      C,
      "splitBy",
      "values",
      h.value
    ) || {}, B = et(
      {},
      f,
      C,
      I,
      E
    );
    B.align = Fu(B.position), delete B.splitBy, delete B.ordering, B.useUTC = A;
    const m = B.title || {};
    if (m.text = m.text || d, B.show) {
      const p = l.create(
        {
          labelManager: t._dependencies.smartlabel,
          cells: {
            AxisCell: Mu,
            TextCell: _o
          },
          registry: {
            interactions: o
          }
        },
        u,
        t.createChildEventManager()
      );
      [hN, dN, uN].forEach((R) => {
        B[R];
      });
      const w = p.metaData();
      w instanceof K && w.dispose();
      const Q = t.composition().visualGroup.matrix().geom().getMatrix()[0][0].source().layers(), { colFacets: y, rowFacets: D, rowProjections: _, colProjections: x } = t.composition().visualGroup.resolver().projections();
      B.shape = qZ(Q, u), B.splitFieldInfo = h;
      const S = [
        ...y,
        ...D,
        ..._,
        ...x
      ].flat().find((R) => `${R}` === g), b = t.config().rows.totals.subTotals.enabled || t.config().rows.facets.interaction.collapse.enabled || t.config().columns.totals.subTotals.enabled || t.config().columns.facets.interaction.collapse.enabled;
      B.hiddenDomain = t.config().legend.includeTotalDomain === !1 && S && b ? [
        .../* @__PURE__ */ new Set([
          t.config().rows.totals.data.totalString,
          t.config().columns.totals.data.totalString
        ])
      ] : [], p.scale(c).valueParser(a).title(m).fieldName(g).config(B).metaData(
        t.composition().visualGroup.getGroupByData().project(
          [g, h.field].filter((R) => R)
        )
      ).canvasAlias(t.alias()).setParentInfo({ canvasRoot: t.mount() }), p._globalContext = t._globalContext, p.firebolt()._globalContext = t._globalContext, p.firebolt()._saveSerializedInteractionState = jZ(
        {
          scaleType: u,
          legend: p
        },
        t
      ), i.push({ canvas: t, legend: p, scaleType: u });
    }
  }), i;
}, $Z = (e, t, i) => {
  const { height: n, width: s, headerHeight: A } = t, { legend: o } = i;
  e.forEach((h) => {
    const d = h.config(), u = {}, { align: f } = d;
    u.maxHeight = f === ql ? n - A : n * 0.2, u.maxWidth = f === Do ? s : s * 0.2, u.width = Math.min(u.maxWidth, d.width), u.height = Math.min(u.maxHeight, d.height), [hN, dN, uN].forEach((E) => {
      u[E] = d[E];
    });
    const { legend: C } = i, { show: I } = C;
    C.show = I && (f === ql && s > 200 || f === Do && n > 200), h.config({
      show: C.show
    }).measurement(u).setLegendMeasures(u);
  });
  const a = [Re, aA, li, _s].reduce(
    (h, d) => (h[d] = {
      legends: [],
      config: et(
        { ...o },
        { position: d, align: Fu(d) }
      )
    }, h),
    {}
  ), r = e.reduce((h, d) => {
    const u = d.config().position;
    return h[u] && h[u].legends.push(d), h;
  }, a), l = Object.keys(r).reduce((h, d) => {
    const { legends: u, config: f } = r[d];
    let C = { width: 0, height: 0 };
    return u.length > 0 && (C = XZ(u, f, n, s)), h[d] = C, h;
  }, {}), c = l[li].width + l[_s].width, g = l[Re].height + l[aA].height;
  return {
    legendSpace: l,
    legendWidth: c,
    legendHeight: g
  };
}, XZ = (e, t, i, n) => {
  const s = e.map((a) => a.measurement()), A = { width: 0, height: 0 };
  let o = 0;
  return s.forEach((a) => {
    const r = Math.min(a.width, a.maxWidth), l = Math.min(a.height, a.maxHeight);
    t.align === Do ? (A.width = n, o < dX && (A.height += l), A.height = Math.min(
      A.height,
      i * yq
    ), o++) : (A.width = Math.min(
      Math.max(A.width, r),
      n * pq
    ), A.height = i);
  }), A;
}, ZZ = (e) => {
  const t = e.config(), { legend: i } = t, { position: n, align: s } = i;
  i.classPrefix = e.config().classPrefix;
  const A = Fu(n);
  return i.align = A, s && (i.xAlign = s), zZ(
    i,
    e,
    // measurement,
    e.composition().legend || {}
  );
};
class ttt extends So {
  constructor(t) {
    super(t.name, t.component.getLogicalSpace(), 0), this.setParams(t);
  }
  renderHeader(t) {
    const i = this.params.config;
    t = X(t);
    const { align: n } = i, s = t.selectAll(`.${i.classPrefix}-inner-container`).data([this.name]);
    s.exit().remove();
    const o = s.enter().append("div").merge(s);
    o.classed(`${i.classPrefix}-inner-container`, !0);
    const { height: a, width: r } = this.boundBox();
    this.component.setAvailableSpace(r, a), this.component && this.component.render(o.node()), o.selectAll("div").classed(`${i.classPrefix}-inner-content`, !0), o.style("width", "100%"), i && this.component && o.style("float", li).style("text-align", n);
  }
  draw(t) {
    this.renderHeader(t || document.getElementById(this.renderAt()));
  }
  updateWrapper(t) {
    return this.setParams(t), this.name(t.name), this.boundBox(t.component.getLogicalSpace()), this;
  }
  setParams(t) {
    this.component = t.component, this.params = t, this.target(t.config.target), this.position(t.config.position), this.className(t.config.className), this.alignWith(t.config.alignWith), this.alignment(t.config.alignment);
  }
  setSpatialConfig(t) {
    this.boundBox({
      top: t.y,
      left: t.x,
      width: t.width,
      height: t.height
    }), this.renderAt(t.renderAt);
  }
}
const ett = hr(), itt = {
  left: $i,
  right: $i,
  top: Xi,
  bottom: Xi
}, oF = (e, t, i) => {
  let n = 0;
  return (e.primary && e.primary.length ? e.primary : e.secondary).map((A) => {
    const o = n * 100 / (t - i);
    return n += A, o;
  });
}, yd = (e, t, i) => {
  const { classPrefix: n, thickness: s } = i, A = z(
    e,
    "div",
    [t],
    `${n}-scroll-arrow-${t}`
  );
  return A.classed(`${n}-scroll-arrow`, !0), A.style(itt[t], `${s}px`), z(
    A,
    "div",
    [1],
    `${n}-scroll-arrow-chevron`
  ).attr("id", `${n}-scroll-arrow-chevron-${t}`), A;
}, aF = (e, t) => {
  const { classPrefix: i } = t, n = z(e, "div", [1], `${i}-scroll-rect`), s = z(n, "div", [1], `${i}-scroll-mover`);
  return { rect: n, mover: s };
}, ntt = (e, t) => {
  const { rect: i } = t;
  i.on("click", () => {
    const n = bt();
    e.emptyScrollAreaClick(n);
  });
}, stt = (e, t) => {
  let i = {}, n = 0, s = 0, A = {};
  const { mover: o, rect: a } = t;
  o.call(
    ett().on("start", () => {
      const r = bt();
      n = o.node().getBoundingClientRect(), s = a.node().getBoundingClientRect(), i = {
        x: r.x,
        y: r.y
      };
    }).on("drag", () => {
      const r = bt(), l = dx();
      A = {
        x: r.x,
        y: r.y
      };
      const c = {
        x: A.x - i.x,
        y: A.y - i.y
      }, g = l.pageXOffset || document.documentElement.scrollLeft, h = l.pageYOffset || document.documentElement.scrollTop, d = {
        x: n.x + g + c.x - (s.x + g),
        y: n.y + h + c.y - (s.y + h)
      };
      e.changeMoverPosition(d);
    })
  ), e._onRemoveListeners.push(() => {
    o.on(".drag", null), X(window).on(".drag", null);
  });
}, Aw = (e, t, i) => {
  const { mover: n, rect: s } = e, { x: A, y: o } = n.node().getBoundingClientRect(), { x: a, y: r } = s.node().getBoundingClientRect();
  t.changeMoverPosition({
    x: A - a + i,
    y: o - r + i
  });
}, ow = (e, t, i, n) => {
  let s = "";
  const A = e._components[i];
  if (!A)
    return;
  const o = bE();
  A.on(o ? "touchstart" : "mousedown", () => {
    bt().preventDefault(), clearInterval(s), s = setInterval(() => {
      Aw(t, e, n);
    }, 100);
  }).on(o ? "touchend" : "mouseup", () => {
    bt().preventDefault(), clearInterval(s);
  }).on("click", () => {
    clearInterval(s), Aw(t, e, n);
  }).on("mouseout", () => {
    clearInterval(s);
  }), e._onRemoveListeners.push(() => {
    clearInterval(s);
  });
}, Att = (e) => {
  const { moverRect: t } = e._components, i = e.config().speed;
  e.clearOnRemoveListeners(), ow(e, t, "prevArrow", -i), stt(e, t), ntt(e, t), ow(e, t, "nextArrow", i);
}, ott = (e, t, i, n) => {
  const { classPrefix: s } = t, A = z(
    X(e),
    "div",
    [1],
    `#${s}-scroll-bar-${n}`
  );
  return A.classed(`${s}-scroll-bar`, !0), A.style($i, `${i.width}px`), A.style(Xi, `${i.height}px`), A;
}, att = {
  config: {
    sanitization: (e, t) => (t = et(e._config, t), t)
  },
  manager: {},
  unitPositions: {},
  logicalSpace: {}
};
class rF {
  constructor() {
    this._components = {}, this._logicalSpace = {}, this._attachedScrollAction = () => {
    }, this._config = {
      thickness: 10,
      speed: 2
    }, this._unitPositions = null, this._scrollPercent = 0, ve(this, att), this._props = {}, this._stateManager = null, this._scrollListeners = [], this._onRemoveListeners = [];
  }
  props(t) {
    return t && (this._props = t), this._props;
  }
  static type() {
    throw new yt("Method not implemented");
  }
  emptyScrollAreaClick() {
    throw new yt("Method not implemented");
  }
  changeMoverPosition() {
    throw new yt("Method not implemented");
  }
  scrollTo() {
    throw new yt("Method not implemented");
  }
  scrollDeltaTo() {
    throw new yt("Method not implemented");
  }
  createScroll(t) {
    const i = this.config();
    return {
      scrollBarContainer: ott(
        t,
        i,
        this.logicalSpace(),
        this.constructor.type()
      )
    };
  }
  attachScrollAction(t) {
    return this._attachedScrollAction = t, this;
  }
  detachScrollAction() {
    return this._attachedScrollAction = () => {
    }, this;
  }
  getLogicalSpace() {
    return this.logicalSpace();
  }
  registerListeners() {
    return Att(this), this;
  }
  remove() {
    const t = this._components.scrollBarContainer;
    return t && t.remove(), this.clearOnRemoveListeners(), this;
  }
  stateManager(t) {
    return t && (this._stateManager = t), this._stateManager;
  }
  onScroll(t) {
    this._scrollListeners.push(t);
  }
  clearOnRemoveListeners() {
    this._onRemoveListeners.forEach((t) => t()), this._onRemoveListeners.length = 0;
  }
}
class rtt extends rF {
  /**
   * Describes the type of the ScrollMaker
   *
   * @public
   *
   * @return {String} Returns the type of scroll maker: horizontal
   */
  static type() {
    return Do;
  }
  createScroll(t, i = this.logicalSpace()) {
    const n = this.config(), { scrollBarContainer: s } = super.createScroll(
      t,
      n,
      i
    ), A = n.buttons.show, o = A ? yd(s, "left", n) : void 0, a = aF(s, n), r = A ? yd(s, "right", n) : void 0, { mover: l, rect: c } = a, { height: g, width: h, totalLength: d, viewLength: u, unitWidths: f } = this.logicalSpace(), C = h - (A ? g * 2 : 0);
    c.style($i, `${C}px`), c.style(Xi, "100%"), l.style(
      $i,
      `${u * C / d}px`
    ), l.style(Xi, "100%");
    const I = this.getMoverPosFromScrollPercent(this.getScrollPercent());
    l.style(li, `${I}px`), this._components = {
      prevArrow: o,
      nextArrow: r,
      moverRect: a,
      scrollBarContainer: s
    }, this.unitPositions(oF(f, d, u)), this.registerListeners();
  }
  emptyScrollAreaClick(t) {
    const { mover: i, rect: n } = this._components.moverRect, s = this.config().speed, { x: A, y: o } = i.node().getBoundingClientRect(), { x: a, y: r } = n.node().getBoundingClientRect();
    let l = s * 10;
    t.x < A && (l = -s * 10), this.changeMoverPosition({
      x: A - a + l,
      y: o - r + l
    });
  }
  // This function is called on every scroll events.
  changeMoverPosition(t, i = !0) {
    let n;
    const { mover: s, rect: A } = this._components.moverRect, o = A.node().getBoundingClientRect(), a = s.node().getBoundingClientRect(), { totalLength: r } = this.logicalSpace();
    t.x < 0 ? n = 0 : t.x + a.width > o.width ? n = o.width - a.width : n = t.x, s.style(li, `${n}px`);
    const l = this.getScrollBarWithoutArrowLength(), c = n * r / l, g = n * 100 / (this.getScrollBarWithoutArrowLength() - a.width);
    this.setScrollPercent(
      Number.isNaN(g) ? 0 : g
    ), this.manager().performAttachedScrollFunction(
      this.constructor.type(),
      c
    ), i && this._scrollListeners.forEach((h) => h());
  }
  getScrollPercent() {
    return this.manager().getHorizontalScrollPercent();
  }
  setScrollPercent(t) {
    this.manager().updateHorizontalScrollPercent(t);
  }
  scrollDeltaTo(t) {
    const { mover: i, rect: n } = this._components.moverRect, s = i.node().getBoundingClientRect(), A = n.node().getBoundingClientRect(), { totalLength: o } = this.logicalSpace(), a = s.x - A.x, r = this.getScrollBarWithoutArrowLength(), l = a * o / r, g = Math.max(l + t, 0) * r / o;
    return this.changeMoverPosition({ y: 0, x: g }), this;
  }
  /**
   * Scrolls to the specific point in the page. The input is provided as a percentage (0 - 100)
   *
   * @public
   *
   * @param {number} scrollPercentage Its the percentage based on which the scroll action will occur
   * @return {HorizontalScrollMaker} Instance of the HorizontalScrollMaker
   */
  scrollTo(t, i) {
    const n = this.getMoverPosFromScrollPercent(t);
    return this.changeMoverPosition({ y: 0, x: n }, i), this;
  }
  getScrollPixelsFromScrollPercent(t) {
    const { totalLength: i } = this.logicalSpace(), n = this.getMoverPosFromScrollPercent(t), s = this.getScrollBarWithoutArrowLength();
    return n * i / s;
  }
  getMoverPosFromScrollPercent(t) {
    const i = this.getScrollBarWithoutArrowLength(), { width: n } = this.logicalSpace(), s = this.getMoverWidth(), A = t * (i - s) / 100;
    let o;
    return A < 0 ? o = 0 : A + s > n ? o = n - s : o = A, o;
  }
  getMoverWidth() {
    const { viewLength: t, totalLength: i } = this.logicalSpace(), n = this.getScrollBarWithoutArrowLength();
    return t * n / i;
  }
  getScrollBarWithoutArrowLength() {
    const { width: t, height: i } = this.logicalSpace(), n = this.config().buttons.show;
    return t - (n ? i * 2 : 0);
  }
}
class ltt extends rF {
  constructor(...t) {
    super(...t);
  }
  /**
   * Describes the type of the ScrollMaker
   *
   * @public
   *
   * @return {String} Returns the type of scroll maker: vertical
   */
  static type() {
    return ql;
  }
  createScroll(t, i = this.logicalSpace()) {
    const n = this.config(), { scrollBarContainer: s } = super.createScroll(t, i), A = n.buttons.show, o = A ? yd(s, "top", n) : void 0, a = aF(s, n), r = A ? yd(s, "bottom", n) : void 0, { mover: l, rect: c } = a, { height: g, width: h, totalLength: d, viewLength: u, unitHeights: f } = this.logicalSpace(), C = g - (A ? h * 2 : 0);
    c.style(Xi, `${C}px`), c.style($i, "100%"), l.style($i, "100%"), l.style(
      Xi,
      `${u * C / d}px`
    );
    const I = this.getMoverPosFromScrollPercent(this.getScrollPercent());
    l.style(Re, `${I}px`), this._components = {
      prevArrow: o,
      nextArrow: r,
      moverRect: a,
      scrollBarContainer: s
    }, this.unitPositions(oF(f, d, u)), this.registerListeners();
  }
  emptyScrollAreaClick(t) {
    const { mover: i, rect: n } = this._components.moverRect, s = this.config().speed, { x: A, y: o } = i.node().getBoundingClientRect(), { x: a, y: r } = n.node().getBoundingClientRect();
    let l = s * 10;
    t.y < o && (l = -s * 10), this.changeMoverPosition({
      x: A - a + l,
      y: o - r + l
    });
  }
  changeMoverPosition(t, i = !0) {
    let n;
    const { mover: s, rect: A } = this._components.moverRect, { totalLength: o } = this.logicalSpace(), a = A.node().getBoundingClientRect(), r = s.node().getBoundingClientRect();
    t.y < 0 ? n = 0 : t.y + r.height > a.height ? n = a.height - r.height : n = t.y, s.style(Re, `${n}px`);
    const l = this.getScrollBarWithoutArrowLength(), c = n * o / l, g = n * 100 / (this.getScrollBarWithoutArrowLength() - r.height);
    this.setScrollPercent(
      Number.isNaN(g) ? 0 : g
    ), this.manager().performAttachedScrollFunction(
      this.constructor.type(),
      c
    ), i && this._scrollListeners.forEach((h) => h());
  }
  getScrollPercent() {
    return this.manager().getVerticalScrollPercent();
  }
  setScrollPercent(t) {
    this.manager().updateVerticalScrollPercent(t);
  }
  /**
   * Scrolls based on the actual pixel value provided. Since it's a delta change, the input will be
   * a delta between (-Infinity, Infinity), based on which the scroll will occur. Only a delta movement in
   * scroll occurs
   *
   * @public
   *
   * @param {number} delta Based on which the scroll will have a delta change in position
   * @return {VerticalScrollMaker} Instance of the VerticalScrollMaker
   */
  scrollDeltaTo(t) {
    const { mover: i, rect: n } = this._components.moverRect, s = i.node().getBoundingClientRect(), A = n.node().getBoundingClientRect(), { totalLength: o } = this.logicalSpace(), a = s.y - A.y, r = this.getScrollBarWithoutArrowLength(), l = a * o / r, g = Math.max(l + t, 0) * r / o;
    return this.changeMoverPosition({ y: g, x: 0 }), this;
  }
  /**
   * Scrolls to the specific point in the page. The input is provided as a percentage (0 - 100)
   *
   * @public
   *
   * @param {number} scrollPercentage Its the percentage based on which the scroll action will occur
   * @return {VerticalScrollMaker} Instance of the VerticalScrollMaker
   */
  scrollTo(t, i) {
    const { mover: n } = this._components.moverRect, s = n.node().getBoundingClientRect(), A = t * (this.getScrollBarWithoutArrowLength() - s.height) / 100;
    return this.changeMoverPosition({ x: 0, y: A }, i), this;
  }
  getScrollPixelsFromScrollPercent(t) {
    const { totalLength: i } = this.logicalSpace(), n = this.getMoverPosFromScrollPercent(t), s = this.getScrollBarWithoutArrowLength();
    return n * i / s;
  }
  getMoverPosFromScrollPercent(t) {
    const i = this.getScrollBarWithoutArrowLength(), { height: n } = this.logicalSpace(), s = this.getMoverHeight(), A = t * (i - s) / 100;
    let o;
    return A < 0 ? o = 0 : A + s > n ? o = n - s : o = A, o;
  }
  getMoverHeight() {
    const { viewLength: t, totalLength: i } = this.logicalSpace(), n = this.getScrollBarWithoutArrowLength();
    return t * n / i;
  }
  getScrollBarWithoutArrowLength() {
    const { width: t, height: i } = this.logicalSpace(), n = this.config().buttons.show;
    return i - (n ? t * 2 : 0);
  }
}
const ctt = {
  horizontal: rtt,
  vertical: ltt
};
class gtt extends So {
  constructor(t) {
    const i = ctt[t.config.type];
    t.component = new i(), t.component.config(t.config.scrollBarComponentConfig), t.component.logicalSpace(t.dimensions), super(t.name, t.component.getLogicalSpace(), 0), this.setParams(t);
  }
  manager(...t) {
    return t.length ? (this.component.manager(t[0]), this) : this.component.manager();
  }
  /**
   * Scrolls based on the actual pixel value provided. Since it's a delta change, the input will be
   * a delta between (-Infinity, Infinity), based on which the scroll will occur. Only a delta movement in
   * scroll occurs
   *
   * @public
   *
   * @param {number} delta Based on which the scroll will have a delta change in position
   * @return {ScrollComponent} Instance of the ScrollComponent
   */
  scrollDeltaTo(t) {
    return this.component.scrollDeltaTo(t), this;
  }
  /**
   * Scrolls to the specific point in the page. The input is provided as a percentage (0 - 100)
   *
   * @public
   *
   * @param {number} scrollPercentage Its the percentage based on which the scroll action will occur
   * @return {ScrollComponent} Instance of the ScrollComponent
   */
  scrollTo(t, i) {
    return this.component.scrollTo(t, i), this;
  }
  /**
   * Scrolls to the specific point in the page based on the unit index.
   * The input is provided as a number represting the index for the unit.
   * For vertical scroll, it's the row index that will be required.
   * For horizontal scroll, it's the column index that will be required.
   *
   * @public
   *
   * @param {number} unitIndex Index of the unit appearing in the grid
   * @return {ScrollComponent} Instance of the ScrollComponent
   */
  scrollToUnitIndex(t) {
    const i = this.getUnitScrollPosition(t);
    return this.component.scrollTo(i), this;
  }
  getUnitScrollPosition(t) {
    const i = this.component.unitPositions(), n = Math.min(
      Math.max(0, t),
      i.length - 1
    );
    return i[n];
  }
  /**
   * Provides the positions of the units(either horizontal or vertical based on the type
   * of scroll bar it wraps) relative to it's container. The position of the first unit starts at 0
   *
   *
   * @public
   *
   * @return {Array} Positions of units either horizontal or vertical
   */
  getScrollPositionsForUnits() {
    return this.component.unitPositions();
  }
  draw(t) {
    return this.component.createScroll(
      t || document.getElementById(this.renderAt())
    ), this;
  }
  /**
   * Can be used to attach a scroll action whenever scrolling occurs in the canvas
   *
   * @public
   * @param {number} externalAction Action to be attached during scroll
   * @return {ScrollComponent} Instance of the ScrollComponent
   */
  attachScrollAction(t) {
    return this.component.attachScrollAction(t), this;
  }
  /**
   * Can be used to detach the scroll action already bound to the scroll bar
   *
   * @public
   * @return {ScrollComponent} Instance of the ScrollComponent
   */
  detachScrollAction() {
    return this.component.detachScrollAction(), this;
  }
  updateWrapper(t) {
    return this.name(t.name), this.component.config(t.config.scrollBarComponentConfig), this.component.logicalSpace(t.dimensions), this.boundBox(this.component.getLogicalSpace()), this.setParams(t), this;
  }
  getScrollPercent() {
    return this.component.getScrollPercent();
  }
  getScrollPixelsFromScrollPercent(t) {
    return this.component.getScrollPixelsFromScrollPercent(t);
  }
  setScrollPercent(t) {
    return this.component.setScrollPercent(t), this;
  }
  setParams(t) {
    this.component = t.component || this.component, this.params = t, this.target(t.config.target), this.position(t.config.position), this.className(t.config.className), this.alignWith(t.config.alignWith), this.alignment(t.config.alignment);
  }
  remove() {
    this.component.remove();
  }
}
const htt = `<svg width="215px" height="199px" viewBox="0 0 215 199" 
version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<!-- Generator: Sketch 60.1 (88133) - https://sketch.com -->

<title>Group 23</title>
    <desc>Created with Sketch.</desc>
    <defs>
        <polygon id="path-1" points="0.149161328 0.420711883 72.119 0.420711883 
        72.119 71.9995421 0.149161328 71.9995421"></polygon>
        <polygon id="path-3" points="0 0.08 186.190753 0.08 186.190753 88.592 0 88.592"></polygon>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Group-23" transform="translate(0.000000, -1.000000)">
            <g id="Group-3" transform="translate(142.000000, 127.920000)">
                <mask id="mask-2" fill="white">
                    <use xlink:href="#path-1"></use>
                </mask>
                <g id="Clip-2"></g>
                <path d="M0.163,36.1555 C0.163,28.8495 0.126,21.5445 0.173,14.2395 
                C0.226,6.1165 4.776,0.7895 12.76,0.6405 C28.362,0.3505 43.979,0.3335 
                59.58,0.6735 C67.574,0.8475 72.079,6.2375 72.096,14.3735 C72.125,28.9835 
                72.129,43.5935 72.094,58.2045 C72.074,66.4205 67.223,71.7225 58.955,71.8405 
                C43.682,72.0565 28.4,72.0515 13.128,71.8315 C4.928,71.7135 0.221,66.4315 
                0.172,58.0705 C0.129,50.7655 0.163,43.4605 0.163,36.1555" id="Fill-1" 
                fill="#8c8d8e" mask="url(#mask-2)"></path>
            </g>
            <g id="Group-6" transform="translate(0.000000, 0.920000)">
                <mask id="mask-4" fill="white">
                    <use xlink:href="#path-3"></use>
                </mask>
                <g id="Clip-5"></g>
                <path d="M183.4677,4.615 C174.5697,3.72 165.6917,2.607 156.8037,1.597 C152.7477,1.136 
                147.5417,-0.986 144.9347,0.755 C142.0737,2.664 143.7187,8.515 142.6187,12.488 C141.7057,
                15.785 143.1607,16.531 146.0297,16.716 C149.3127,16.928 152.5717,17.483 156.6277,17.987 
                C137.8927,32.589 119.9087,46.473 102.1267,60.61 C99.4257,62.757 98.2077,62.204 96.1947,
                60.05 C85.5357,48.644 74.6947,37.409 64.0607,25.979 C61.8547,23.608 60.5757,23.002 57.8627,
                25.586 C51.9777,31.188 45.6137,36.286 39.4547,41.6 C26.7597,52.553 14.0947,63.54 1.3487,
                74.433 C-0.2963,75.838 -0.4833,76.732 1.0457,78.354 C4.1127,81.609 6.9717,85.061 10.0567,
                88.592 C26.7507,74.17 43.3037,59.87 59.9757,45.469 C71.5287,57.708 82.9977,69.719 94.2677,
                81.914 C96.5347,84.368 98.0097,84.604 100.6707,82.492 C116.3907,70.016 132.2397,57.704 
                148.0587,45.353 C153.9727,40.736 159.9197,36.162 165.9517,31.491 C167.0647,36.458 163.2367,
                42.055 165.8357,44.513 C168.4597,46.994 174.2387,46.065 178.6037,46.814 C180.5447,47.148 
                181.1657,46.627 181.4047,44.671 C182.9067,32.336 184.5297,20.016 186.1377,7.696 C186.4127,
                5.593 185.6327,4.833 183.4677,4.615" id="Fill-4" fill="#8c8d8e" mask="url(#mask-4)"></path>
            </g>
            <path d="M68.7436,89.5418 C63.2716,89.6988 57.7836,89.7768 52.3196,89.5178 C49.1866,89.3688 
            48.3926,90.4028 48.4386,93.4328 C48.6076,104.5468 48.5056,115.6668 48.5056,126.7838 C48.5056,
            138.0668 48.5916,149.3518 48.4436,160.6328 C48.4076,163.4118 49.1436,164.3578 52.0056,164.2518 
            C57.8066,164.0398 63.6226,164.0938 69.4276,164.2338 C71.7586,164.2898 72.5516,163.6408 72.5416,
            161.1938 C72.4536,138.4608 72.4326,115.7288 72.556775,92.9968 C72.5736,89.9318 71.3526,89.4668 
            68.7436,89.5418" id="Fill-7" fill="#8c8d8e"></path>
            <path d="M144.3769,91.2962 C138.9019,91.4772 133.4019,91.5912 127.9409,91.2652 C124.4229,91.0562 
            123.8999,92.4662 123.9449,95.5182 C124.1039,106.3102 124.0069,117.1072 124.0069,127.9012 C124.0079,
            137.3672 124.0079,146.8332 124.0079,156.3002 C124.0079,164.4422 124.0079,164.3082 132.1549,
            164.2632 C134.9749,164.2472 135.8559,163.4702 135.7569,160.6292 C135.5449,154.6582 135.6479,
            148.6742 135.6999,142.6952 C135.7679,135.0662 138.3559,128.6922 145.3599,124.8822 C147.2959,
            123.8292 147.7519,122.5322 147.7349,120.5452 C147.6649,111.9092 147.6109,103.2722 147.7569,
            94.6382 C147.8009,92.0132 146.9799,91.2102 144.3769,91.2962" id="Fill-9" fill="#8c8d8e"></path>
            <path d="M110.3095,117.074 C110.3265,114.616 109.4485,113.950948 107.1345,113.998 C101.3365,
            114.117 95.5265,114.204 89.7365,113.96 C86.7245,113.833 86.2185,115.041 86.2735,117.672 C86.4225,
            124.795 86.3255,131.923 86.3245,139.049 C86.3245,146.34 86.4355,153.634 86.2645,160.922 C86.2035,
            163.546 86.9745,164.336 89.6015,164.249 C95.3955,164.057 101.2015,164.133 107.0005,164.217 C109.1175,
            164.247 110.3385,163.986 110.3185,161.321 C110.2015,146.573 110.2115,131.823 110.3095,117.074" 
            id="Fill-11" fill="#8c8d8e"></path>
            <path d="M31.1347,116.1951 C25.3367,116.4001 19.5237,116.3591 13.7217,116.2131 C11.2637,116.1521 
            10.6717,117.0871 10.6857,119.3921 C10.7747,133.3221 10.7877,147.2541 10.6847,161.1851 C10.6667,163.6601 
            11.5637,164.2771 13.8597,164.2291 C19.6617,164.1061 25.4757,164.0161 31.2717,164.2601 C34.2827,164.3871 
            34.7937,163.2071 34.7267,160.5531 C34.5597,153.9241 34.6717,147.2871 34.6717,140.6531 C34.6717,133.6881 
            34.5377,126.7181 34.7367,119.7581 C34.8177,116.9131 33.9317,116.0961 31.1347,116.1951" id="Fill-13" 
            fill="#8c8d8e"></path>
            <path d="M182.5937,62.2083 C175.8157,62.4493 169.0307,62.4883 162.2477,62.6073 L162.2467,62.6073 
            C161.0087,63.1583 161.4327,64.2813 161.4317,65.1903 C161.4087,83.2963 161.4087,101.4033 161.4347,
            119.5103 C161.4357,120.4033 160.9787,121.5473 162.2837,122.0423 C169.0747,122.1203 175.8697,122.1063 
            182.6567,122.3223 C185.0277,122.3973 185.2947,121.3543 185.2887,119.3853 C185.2347,101.3103 
            185.2377,83.2343 185.290773,65.1593 C185.2967,63.1633 184.9367,62.1253 182.5937,62.2083" 
            id="Fill-15" fill="#8c8d8e"></path>
            <path d="M178.6747,133.095 C186.1527,133.096 193.6297,133.02 201.1057,133.12 C206.6837,133.197 
            209.9207,136.107 209.9837,141.656 C210.1537,156.606 210.1427,171.56 209.9877,186.51 C209.9317,
            192.015 206.6527,195.159 201.1977,195.197 C185.9127,195.303 170.6257,195.306 155.3397,195.216 
            C149.4057,195.182 146.3497,192.185 146.3107,186.367 C146.2127,171.582 146.2197,156.795 146.3047,
            142.01 C146.3387,136.149 149.3577,133.194 155.2477,133.118 C163.0557,133.019 170.8657,133.094 
            178.6747,133.095" id="Fill-17" fill="#fbc0af"></path>
            <path d="M186.1288,150.0833 C184.6798,156.9563 182.9098,165.3223 181.1508,173.6913 C180.7868,
            175.4293 179.7388,176.1553 177.9798,176.1143 C176.1458,176.0713 175.3328,175.0033 174.9608,
            173.4093 C173.0558,165.2363 171.0608,157.0593 170.2818,148.6993 C169.8138,143.6663 173.1078,
            140.3553 177.7748,140.2323 C182.7748,140.1013 186.1058,143.4083 186.1288,150.0833" 
            id="Fill-19" fill="#FDFDFC"></path>
            <path d="M177.7314,188.0823 C175.7614,187.9153 174.3044,186.6683 174.3184,184.3533 C174.3334,
            182.0403 175.8334,180.6253 178.1304,180.6793 C180.3624,180.7313 182.0564,182.0443 181.9314,
            184.4023 C181.8194,186.5383 180.5864,188.1203 177.7314,188.0823" id="Fill-21" fill="#FCF6F3"></path>
        </g>
    </g>
    </svg>`, dtt = (e, t) => {
  const { baseFontLimit: i, upperFontLimit: n, baseSizeLimit: s, upperSizeLimit: A } = Cl, o = (A - s) / (n - i);
  let a = n;
  const r = e < t && e !== 0 ? e : t;
  return r === 0 ? a = 0 : r <= s ? a = i : r > s && r < A && (a = i + (A - r) / o), a;
};
class utt extends So {
  constructor(t) {
    super(t.name, t.config.dimensions, 0), this.setParams(t);
  }
  render(t) {
    const i = X(t), { config: n } = this.params, { className: s } = n.classPrefix, A = z(i, "div", [1], s), { height: o, width: a } = n.dimensions, r = o > Cl.baseSizeLimit ? Cl.fractionChild * o : 0, { message: l } = n;
    Ji(A, { width: `${a}px`, height: `${o}px` });
    const c = z(A, "div", [1], `${s}-child`), g = z(c, "div", [1], `${s}-child-img`), h = z(c, "div", [1], `${s}-child-message`);
    Ji(c, { width: a, height: `${r}px` }), Ji(g, { width: a, height: `${r * Cl.fractionImage}px` }), g.html(htt);
    const d = z(h, "text", [1]);
    Ji(h, { "font-size": `${dtt(a, o)}px` }), d.html(l);
  }
  draw(t) {
    this.render(t || document.getElementById(this.renderAt()));
  }
  updateWrapper(t) {
    return this.name(t.name), this.boundBox(t.config.dimensions), this.setParams(t), this;
  }
  setParams(t) {
    const { target: i, className: n } = t.config;
    return this.component = t.component, this.params = t, this.target(i), this.className(n), this.position(t.config.position), this;
  }
}
class ftt extends rm {
  renderLegend(t) {
    const i = X(t);
    if (!this.components.length)
      return;
    const n = [], s = [], A = [];
    this.components.forEach((u) => {
      const { width: f, height: C } = u.legend.measurement();
      u.legend.scaleType === "shape" ? n.push({
        ...u,
        width: f,
        height: C
      }) : u.legend.scaleType === "size" ? s.push({
        ...u,
        width: f,
        height: C
      }) : A.push({
        ...u,
        width: f,
        height: C
      });
    }), A.push(...n), A.push(...s);
    const { height: o } = this.newDimensions;
    let a = o, r = A.length;
    const l = A.map((u) => {
      let f = 0;
      if (u.legend instanceof Li) {
        const { height: C } = u, I = Math.min(
          C,
          sN
        );
        if (a > 0) {
          const E = a / r;
          f = Math.max(
            Math.min(C, E),
            I
          );
        } else
          f = I;
      } else u.legend instanceof Vl, f = oC;
      return a -= f, r--, {
        legend: u.legend,
        scaleType: u.scaleType,
        width: u.width,
        height: f
      };
    }), { classPrefix: c, position: g } = this.params.config;
    i.style("overflow-x", "hidden"), i.style("overflow-y", "auto"), g === _s ? i.style("padding-left", `${Vg}px`) : i.style(
      "padding-right",
      `${Vg}px`
    );
    const h = z(
      i,
      "div",
      l,
      `${c}-legend-container`,
      {},
      (u) => u.legend.id()
    );
    h.style("width", "100%").style("height", (u) => `${u.height}px`).style("overflow", "hidden").style("position", "relative"), h.each(function(u) {
      X(this).classed(
        `${c}-${u.legend.config().position}-legend-container`,
        !0
      );
    });
    const d = i.node().clientWidth - Vg;
    h.each(function(u) {
      X(this).style("width", `${d}px`), u.legend.title().max_width = d, u.legend.mount(this);
    });
  }
}
class Itt extends rm {
  renderLegend(t) {
    const i = X(t);
    if (!this.components.length)
      return;
    const s = this.components.map((l) => {
      const { width: c, height: g } = l.legend.measurement();
      return {
        ...l,
        width: c,
        height: g
      };
    }).map((l) => {
      const { height: c, width: g } = l;
      return {
        legend: l.legend,
        scaleType: l.scaleType,
        width: g,
        height: c
      };
    }), { classPrefix: A } = this.params.config;
    i.style("overflow-x", "hidden"), i.style("overflow-y", "auto");
    const o = z(
      i,
      "div",
      s,
      `${A}-legend-container`,
      {},
      (l) => l.legend.id()
    );
    o.style("width", "100%").style("height", (l) => `${l.height}px`).style("overflow", "hidden").style("position", "relative"), o.each(function(l) {
      X(this).classed(
        `${A}-${l.legend.config().position}-legend-container`,
        !0
      );
    });
    const a = i.node().clientWidth, r = XN(o);
    o.each(function(l) {
      X(this).style("width", `${a}px`), l.legend.title().max_width = r, l.legend.mount(this);
    }), DX(o), SX(o);
  }
}
const Ctt = {
  title: {
    headerCell: "titleCell",
    configType: zN
  },
  subtitle: {
    headerCell: "subtitleCell",
    configType: $N
  },
  columnHeader: {
    headerCell: "columnHeaderCell",
    configType: {}
  }
}, lF = {
  [li]: li,
  [_s]: _s,
  [Ai]: sz
}, Ett = (e) => Object.keys(e).every((t) => e[t]), Btt = (e) => {
  const { rows: t, columns: i, values: n } = e.components;
  return Ett({ rows: t, columns: i, values: n });
}, vf = (e, t, i) => {
  let n = null;
  const { components: s, layoutConfig: A } = i, { headerCell: o, configType: a } = Ctt[e], r = { target: Mc };
  if (s.headers && s.headers[o] && i.measurement.headerHeight > 0) {
    let l = e === Mi || e === $n ? A[e] : A.axesHeaders.column;
    const c = s.headers[o];
    l = Object.assign({}, l, {
      classPrefix: A.classPrefix,
      ...r,
      alignWith: `${uA[0]}-${Cr[1]}`,
      alignment: lF[l.align],
      className: a.className || l.className
    });
    const g = {
      name: e,
      component: c,
      config: l
    }, h = t.getComponent(e);
    h ? n = h.updateWrapper(g) : n = new ttt(g);
  }
  return n;
}, mtt = (e, t, i) => {
  const { components: n, measurement: s } = t, A = Object.values(n.headers || {});
  let o = 0, a = null;
  for (const r of A) {
    const l = r.logicalSpace();
    o += l ? l.height : 0;
  }
  if (!i) {
    const r = {
      height: s.canvasHeight - o,
      width: s.canvasWidth
    }, l = e.getComponent(sr), { height: c, width: g } = l && l.getBoundBox() || r, d = {
      ...{ target: Mc },
      dimensions: { height: c, width: g },
      message: rz,
      classPrefix: Cl,
      position: Re
    }, u = {
      name: ud,
      component: null,
      config: d
    }, f = e.getComponent(ud);
    return f ? a = f.updateWrapper(u) : a = new utt(u), a;
  }
  return null;
}, ptt = (e) => ({
  vertical: {
    componentName: "verticalScrollBar",
    width: "thickness",
    height: "layoutBasedMeasure",
    layoutBasedMeasure: Xi,
    viewMeasure: "viewHeight",
    rowAlign: 1,
    colAlign: e.align === "right" ? 2 : 0,
    position: e.align,
    alignment: Re
  },
  horizontal: {
    componentName: "horizontalScrollBar",
    width: "layoutBasedMeasure",
    layoutBasedMeasure: $i,
    viewMeasure: "viewWidth",
    height: "thickness",
    rowAlign: e.align === "top" ? 0 : 2,
    colAlign: 1,
    position: e.align,
    alignment: li
  }
}), aw = (e, t, i, n, s, A) => {
  if (s) {
    let o = null;
    const { layoutConfig: a } = i, r = { target: Mc }, { scrollBar: l } = a, { layoutDimensions: c } = n.viewInfo(), { actualCenterMeasures: g, unitHeights: h, unitWidths: d } = c, {
      componentName: u,
      layoutBasedMeasure: f,
      width: C,
      height: I,
      rowAlign: E,
      colAlign: B,
      viewMeasure: m,
      position: p,
      alignment: w
    } = ptt(l[e])[e], Q = {
      thickness: l.thickness,
      layoutBasedMeasure: c[m][1]
    }, y = n.scrollInfo()[e], D = g[f], _ = c[m][1], x = Object.assign(
      {},
      {
        classPrefix: a.classPrefix,
        ...r,
        scrollBarComponentConfig: {
          ...l,
          classPrefix: a.classPrefix
        },
        type: e,
        alignWith: `${uA[E]}-${Cr[B]}`,
        alignment: w,
        position: p
      }
    ), S = {
      name: u,
      config: x,
      dimensions: {
        width: Q[C],
        height: Q[I],
        totalLength: D,
        viewLength: _,
        unitHeights: h,
        unitWidths: d
      }
    }, b = t.getComponent(u);
    return y ? (b ? o = b.updateWrapper(S) : o = new gtt(S), o.component.stateManager(i.scrollStateManager), o) : (b && b.remove(), e === "vertical" ? EX(A._store) : BX(A._store), null);
  }
  return null;
}, yg = (e, t, i, n) => {
  if (i) {
    let s = null;
    const { components: A, measurement: o } = t, a = { target: Mc }, { legends: r, config: l } = A.mappedLegends[n];
    if (r && r.length) {
      let c = { ...l, ...a, measurement: o };
      (n === Re || n === Ee) && l.xAlign && (c = {
        ...c,
        alignment: lF[l.xAlign]
      });
      const g = oZ(n), h = {
        name: g,
        component: r,
        config: c
      }, d = e.getComponent(g);
      d ? s = d.updateWrapper(h) : s = n === li || n === _s ? new ftt(h) : new Itt(h);
    }
    return s;
  }
  return null;
}, Qtt = (e, t, i, n, s) => {
  if (n) {
    let A = null;
    const o = { target: Mc }, { layoutConfig: a } = t, r = {
      ...o,
      pagination: "scroll",
      classPrefix: a.classPrefix,
      dimensions: { height: 0, width: 0 }
    }, l = {
      name: sr,
      component: i,
      config: r,
      store: s,
      layout: i
    }, c = e.getComponent(sr);
    return c ? A = c.updateWrapper(l) : A = new am(l), A;
  }
  return null;
}, ytt = (e, t, i) => {
  const n = e._layoutManager, s = Btt(i);
  return {
    [Mi]: vf(Mi, n, i),
    [sm]: vf($n, n, i),
    [ds]: vf(
      ds,
      n,
      i
    ),
    [ud]: mtt(n, i, s),
    [zB]: yg(
      n,
      i,
      s,
      Re
    ),
    [$B]: yg(
      n,
      i,
      s,
      Ee
    ),
    [XB]: yg(
      n,
      i,
      s,
      li
    ),
    [ZB]: yg(
      n,
      i,
      s,
      _s
    ),
    [sr]: Qtt(
      n,
      i,
      t,
      s,
      e._store
    ),
    [fN]: aw(
      ql,
      n,
      i,
      t,
      s,
      e
    ),
    [IN]: aw(
      Do,
      n,
      i,
      t,
      s,
      e
    )
  };
};
class wtt {
  constructor(t) {
    this._scrollBarComponents = {}, this._attachedComponents = {}, this._dependencies = t, this.updateStoreHorizontalScroll = Gf(
      this.updateStoreHorizontalScroll.bind(this),
      Ny,
      Fy
    ), this.updateStoreVerticalScroll = Gf(
      this.updateStoreVerticalScroll.bind(this),
      Ny,
      Fy
    );
  }
  dependencies(...t) {
    return t.length ? (this._dependencies = t[0], this) : this._dependencies;
  }
  scrollBarComponents(...t) {
    return t.length ? (this._scrollBarComponents = t[0], this) : this._scrollBarComponents;
  }
  attachedComponents(...t) {
    return t.length ? (this._attachedComponents = t[0], this) : this._attachedComponents;
  }
  preventBrowserScroll(t, i) {
    return this.scrollBarComponents()[t] && i.preventDefault(), this;
  }
  updateStoreHorizontalScroll(t) {
    const { store: i } = this._dependencies;
    i.commit(
      `${re}.scrollLeft`,
      t
    );
  }
  updateStoreVerticalScroll(t) {
    const { store: i } = this._dependencies;
    i.commit(
      `${re}.scrollTop`,
      t
    );
  }
  performAttachedScrollFunction(t, i) {
    return t === "horizontal" ? this.updateStoreHorizontalScroll(i) : this.updateStoreVerticalScroll(i), Object.values(this.attachedComponents()).forEach((n) => {
      n.performScrollAction(t, i);
    }), this;
  }
  triggerScrollBarAction(t, i) {
    return this.scrollBarComponents()[t] && this.scrollBarComponents()[t].scrollDeltaTo(i), this;
  }
  updateVerticalScrollPercent(t) {
    const { store: i } = this._dependencies;
    i.lockModel(), i.commit(
      `${rA}.${Cd}`,
      t
    ), i.unlockModel();
  }
  updateHorizontalScrollPercent(t) {
    const { store: i } = this._dependencies;
    i.lockModel(), i.commit(
      `${rA}.${Ed}`,
      t
    ), i.unlockModel();
  }
  getVerticalScrollPercent() {
    return this._dependencies.store.get(
      `${rA}.${Cd}`
    );
  }
  getHorizontalScrollPercent() {
    return this._dependencies.store.get(
      `${rA}.${Ed}`
    );
  }
  resetVerticalScrollPercent() {
    this.updateVerticalScrollPercent(0);
  }
  resetHorizontalScrollPercent() {
    this.updateHorizontalScrollPercent(0);
  }
}
const Dtt = (e, t) => {
  const { components: i, layoutConfig: n, measurement: s } = t, { rows: A, columns: o, values: a, cornerMatrices: r } = i, { topLeft: l, topRight: c, bottomLeft: g, bottomRight: h } = r;
  if (A && o) {
    const [d, u] = A, [f, C] = o;
    e.measurement(s).config(n).matrices({
      top: [l, f, c],
      center: [d, a, u],
      bottom: [g, C, h]
    });
  }
}, xtt = (e) => {
  e.triggerReflow();
}, Stt = (e, t) => {
  let i = et({}, e.config());
  const n = e.composition().visualGroup, {
    isColumnSizeEqual: s,
    isRowSizeEqual: A,
    priority: o,
    rows: a,
    columns: r,
    values: l,
    cellRenderer: c,
    priorityMaxWidths: g,
    priorityMinWidths: h
  } = n.placeholderInfo(), {
    // minWidth,
    // minHeight,
    classPrefix: d,
    showHeaders: u,
    legend: f,
    scrollBar: C,
    // axesHeaders,
    rows: { headers: I },
    columns: { headers: E }
  } = e.config(), B = e.title()[1], m = e.subtitle()[1], p = PZ(e), w = KZ(e), Q = ZZ(e), y = [Re, aA, li, _s].reduce(
    (x, S) => (x[S] = {
      legends: [],
      config: et(
        { ...f },
        { position: S, align: Fu(S) }
      )
    }, x),
    {}
  ), D = Q.reduce((x, S) => {
    const b = S.legend.config().position;
    return x[b] && x[b].legends.push(S), x;
  }, y);
  e._composition.legend = {}, Q.forEach((x) => {
    const S = e._composition.legend[x.scaleType] || [];
    S.push(x.legend), e._composition.legend[x.scaleType] = S;
  });
  const _ = {
    headers: w,
    mappedLegends: D,
    canvases: [e],
    rows: a,
    columns: r,
    values: l,
    cornerMatrices: n.cornerMatrices()
  };
  return i = et(i, {
    classPrefix: d,
    showHeaders: u,
    border: et(n.metaData().border, e.config().border),
    layoutArrangement: p,
    legend: f,
    buffer: C.thickness,
    title: B,
    subtitle: m,
    axesHeaders: {
      row: I,
      column: E
    },
    // axesHeaders,
    isColumnSizeEqual: s,
    isRowSizeEqual: A,
    mount: t,
    priority: o,
    cellRenderer: c,
    priorityMaxWidths: g,
    priorityMinWidths: h,
    pagination: "scroll"
  }), {
    layoutConfig: i,
    components: _
  };
}, _tt = (e) => {
  const t = e.mount(), { minWidth: i, minHeight: n } = e.config();
  let { height: s, width: A } = t.getBoundingClientRect();
  const o = e.height(), a = e.width();
  s = Math.floor(s), A = Math.floor(A);
  const r = Math.max(
    o > 0 ? o : s,
    n
  ), l = Math.max(
    a > 0 ? a : A,
    i
  ), c = VZ(
    e._renderDetails.components.headers,
    {
      height: r,
      width: l
    }
  ), g = e.composition().legend, h = Object.keys(e.composition().legend).map((I) => g[I]).flat(), { legendSpace: d, legendWidth: u, legendHeight: f } = $Z(
    h,
    {
      headerHeight: c,
      height: r,
      width: l
    },
    e.config()
  );
  return {
    mountSpace: {
      height: s,
      width: A
    },
    headerHeight: c,
    legendSpace: d,
    canvasWidth: l,
    canvasHeight: r,
    width: l - u,
    height: r - c - f,
    minUnitHeight: e.minUnitHeight(),
    minUnitWidth: e.minUnitWidth()
  };
}, cF = [
  Mi,
  $n,
  zB,
  $B,
  ds,
  XB,
  ZB,
  fN,
  IN,
  sr,
  ud
], mC = cF.reduce((e, t, i) => (e[t] = i, e), {}), btt = cF.reduce((e, t, i) => (e[i] = t, e), {}), Mtt = (e, t) => {
  const i = {
    layoutRootNodeId: t.getLayoutRootNodeId(),
    scrollableBoundBox: t.getScrollableBoundBox(e)
  };
  e.forEach((n) => {
    n && n.attachListener(i);
  });
}, Ntt = (e, t) => {
  const { horizontalScrollBar: i, verticalScrollBar: n, grid: s } = mC, A = e[i], o = e[n], a = e[s], r = new wtt({
    store: t._store
  }), l = {};
  o && (l.vertical = o), A && (l.horizontal = A), r.scrollBarComponents(l).attachedComponents({
    grid: a
  }), t.composition().hScrollBar = A, t.composition().vScrollBar = o, t.composition().scrollBarManager = r, [A, o].forEach((c) => {
    c && c.manager(r);
  }), a.scrollBarManager(r);
}, Ftt = (e, t) => {
  const i = e.layout(), { grid: n } = mC, s = ytt(e, i, t), A = Object.keys(mC).map(
    (a) => s[a]
  );
  return A[n] && Ntt(A, e), A;
}, Rtt = (e, t) => {
  t.forEach((i, n) => {
    if (!i) {
      const s = btt[n];
      e.removeComponent(s);
    }
  }), e.registerComponents(t).compute();
}, Qe = 25, rw = 10, lw = ({ value: e }) => e, cw = (e) => e != null, wg = (e) => {
  const t = e._overriddenDimension != null && e._overriddenDimension.width, i = e._implicitSpace.width;
  let n = 0;
  if (t != null ? n = t : i != null && (n = i), e instanceof Mu) {
    const s = e.availWidth();
    s && (n = Math.min(n, s));
  }
  return n;
}, Dg = (e) => {
  const t = e._overriddenDimension != null && e._overriddenDimension.height, i = e._implicitSpace.height;
  let n = 0;
  return t != null ? n = t : i != null && (n = i), n;
}, gw = (e) => e.ancestors().slice(0, -1).filter(
  (t) => t.height === 0 ? !0 : t.leaves()[0].data[t.depth - 1].source() !== " "
).length, ea = (e) => e.data.space.width, ia = (e) => e.data.space.height, ktt = (e, t, { canvas: i }) => {
  let {
    columns: { layout: n },
    rows: { layout: s }
  } = t;
  const {
    border: { width: A },
    axes: {
      x: { compact: o },
      y: { compact: a }
    },
    rows: {
      totals: {
        grandTotals: { enabled: r }
      }
    },
    columns: {
      totals: {
        grandTotals: { enabled: l }
      }
    }
  } = e.config(), {
    legendSpace: {
      left: { width: c },
      right: { width: g },
      top: { height: h },
      bottom: { height: d }
    }
  } = e.measurement();
  if (o) {
    if (!e.columnMatrix().config().isCompacted) {
      e.columnMatrix().config().isCompacted = !0;
      const u = un(
        e.columnMatrix().tree(),
        (y) => y.values
      ), [f, C] = e.columnMatrix().config().extraCellLengths, I = e.measurement().canvasWidth, E = u.leaves(), B = Math.max(
        I - e.rowMatrix().logicalSpace().width - c - g,
        I / 2
      ) - A * (E.length + 2) - rw - (r ? Qe : 0);
      if (n.length) {
        const y = ll(
          e.columnMatrix()
        ), D = pa(
          n,
          (_) => _.target.length
        );
        u.eachBefore((_) => {
          if (_.depth > 0 && _.height > 0)
            if (_.parent.data.preventCompaction)
              _.data.preventCompaction = !0;
            else {
              const x = y(_), S = (R) => R.filter(
                (G) => ca(G.target, x)
              ).reverse().find(
                (G) => G.width != null || G.collapsedWidth != null || G.height != null
              ), b = D.get(x.length);
              if (b != null)
                if (_.height === 1) {
                  const G = Gi(_).source();
                  typeof G == "object" && G !== null && S(
                    b
                  ) != null && (_.data.preventCompaction = !0);
                } else
                  S(
                    b
                  ) != null && (_.data.preventCompaction = !0);
            }
        });
      }
      const m = E.slice(f, E.length - C).map((y) => y.parent), p = Gi(m[0]).source().constructor.type() === "band";
      let w = 0;
      p ? w = m.reduce((y, D) => {
        const _ = Gi(D).source();
        return typeof _ == "object" && _ !== null ? y + _.domain().length : y;
      }, 0) : w = m.length;
      const { blueprints: Q } = m.filter((y) => !y.data.preventCompaction).reduce(
        ({ blueprints: y, remainingWidth: D, remainingDiscreteUnitCount: _ }, x) => {
          const S = D / _, b = Gi(x), R = b.source(), G = b.getDataPath().map(({ field: H, value: N, sourceType: M }) => ({
            field: H.getMembers()[0],
            value: N,
            sourceType: M
          }));
          let T = 0, v = 0;
          if (p && typeof R == "object" && R !== null) {
            const H = R.domain().length;
            T = Math.max(
              Qe,
              H * (e.config().cellRenderer === "html" ? Math.max(S, Qe) : S)
            ), v = _ - H;
          } else
            T = Math.max(S, Qe), v = _ - 1;
          return {
            blueprints: y.concat({
              target: G,
              width: T,
              isTransient: !0
            }),
            remainingWidth: D - T,
            remainingDiscreteUnitCount: v
          };
        },
        {
          blueprints: [],
          remainingWidth: B,
          remainingDiscreteUnitCount: w
        }
      );
      n = n.concat(Q);
    }
  } else
    e.columnMatrix().config().isCompacted = !1;
  if (a) {
    if (e.config().cellRenderer === "svg" && !e.rowMatrix().config().isCompacted) {
      e.rowMatrix().config().isCompacted = !0;
      const u = un(
        e.rowMatrix().tree(),
        (y) => y.values
      ), [f, C] = e.rowMatrix().config().extraCellLengths, I = e.measurement().canvasHeight, E = u.leaves(), B = Math.max(
        I - e.columnMatrix().logicalSpace().height - h - d,
        I / 2
      ) - A * (E.length + 2) - rw - (l ? Qe : 0), m = E.slice(f, E.length - C).map((y) => y.parent), p = Gi(m[0]).source().constructor.type() === "band";
      let w = 0;
      p ? w = m.reduce((y, D) => {
        const _ = Gi(D).source();
        return typeof _ == "object" && _ !== null ? y + _.domain().length : y;
      }, 0) : w = m.length;
      const { blueprints: Q } = m.reduce(
        ({ blueprints: y, remainingHeight: D, remainingDiscreteUnitCount: _ }, x) => {
          const S = D / _, b = Gi(x), R = b.source(), G = b.getDataPath().map(({ field: H, value: N, sourceType: M }) => ({
            field: H.getMembers()[0],
            value: N,
            sourceType: M
          }));
          let T = 0, v = 0;
          if (p && typeof R == "object" && R !== null) {
            const H = R.domain().length;
            T = Math.max(
              Qe,
              H * (e.config().cellRenderer === "html" ? Math.max(S, Qe) : S)
            ), v = _ - H;
          } else
            T = Math.max(S, Qe), v = _ - 1;
          return {
            blueprints: y.concat({
              target: G,
              height: T,
              isTransient: !0
            }),
            remainingHeight: D - T,
            remainingDiscreteUnitCount: v
          };
        },
        {
          blueprints: [],
          remainingHeight: B,
          remainingDiscreteUnitCount: w
        }
      );
      s = s.concat(Q);
    }
  } else
    e.rowMatrix().config().isCompacted = !1;
  if (n.length) {
    const u = e.columnMatrix(), f = e.centerMatrix(), C = ll(u), I = pa(
      n,
      (Q) => Q.target.length
    ), E = un(u.tree(), (Q) => Q.values);
    E.each((Q) => {
      const y = gw(Q);
      if (Q.depth > 0 && Q.height > 0) {
        const D = C(Q), _ = (S) => S.filter(
          (b) => ca(b.target, D, {
            isCornerMatrix: b.target.value == null && b.width == null
          })
        ).reverse().find(
          (b) => b.width != null || b.collapsedWidth != null || b.height != null
        ), x = I.get(D.length);
        if (x != null)
          if (Q.height === 1) {
            const S = Gi(Q), b = S.source();
            if (typeof b == "object" && b !== null) {
              const R = _(
                x
              );
              if (R != null) {
                const G = R.isTransient !== !0, T = R.target.map(lw).filter(cw), H = BC(i, T) ? "collapsedWidth" : "width", N = R.target[y - 1] != null && R.target[y - 1].value;
                if (b.constructor.type() === "band" && typeof N < "u") {
                  if (yh(
                    b.domain(),
                    N
                  )) {
                    const M = b.domain().length;
                    R[H] != null && (Q.data.specifiedWidth = R[H] * M, Q.data.touchedValue = N), R.height != null && (Q.data.specifiedHeight = R.height * M, Q.data.touchedValue = N), S.config().touched = !0, Q.data.isPersistent = G, Q.data.touched = !0;
                  }
                } else
                  R[H] != null && S.config().type !== "headerTitle" && (Q.data.specifiedWidth = R[H]), R.height != null && (Q.data.specifiedHeight = R.height), S.config().touched = !0, Q.data.isPersistent = G, Q.data.touched = !0;
              }
            }
          } else {
            const S = _(
              x
            );
            if (S != null) {
              const b = S.isTransient !== !0, R = S.target.map(lw).filter(cw), T = BC(i, R) ? "collapsedWidth" : "width";
              S[T] != null && (Q.data.specifiedWidth = S[T]), S.height != null && (Q.data.specifiedHeight = S.height), Q.leaves().forEach((v) => {
                v.data[v.data.length - 1].config().touched = !0;
              }), Q.data.isPersistent = b, Q.data.touched = !0;
            }
          }
      }
    }), E.each((Q) => {
      Q.find((D) => D !== Q && D.data.specifiedWidth != null) != null && (Q.data.specifiedWidth = null);
    }), E.each((Q) => {
      Q.depth > 0 && Q.height > 0 && (Q.parent.data.specifiedWidth != null && (Q.data.specifiedWidth = Q.parent.data.specifiedWidth / Q.parent.children.length), Q.data.specifiedHeight == null && (Q.data.specifiedHeight = xi(
        Q.data.matrix[Q.depth - 1].map(Dg)
      )));
    }), E.eachAfter((Q) => {
      if (Q.height > 0) {
        if (Q.height === 1) {
          if (Q.data.specifiedWidth == null) {
            const y = Gi(Q), D = y.source();
            typeof D == "object" && D !== null && (Q.data.space.width = wg(y));
          } else
            Q.data.space.width = Q.data.specifiedWidth > Qe ? Q.data.specifiedWidth : Qe;
          Q.data.space.height = Ii(
            Q.ancestors().slice(0, -1),
            (y) => y.data.specifiedHeight > Qe ? y.data.specifiedHeight : Qe
          );
        } else if (Q.data.space)
          if (Q.depth === 0)
            Q.data.space.width = Ii(Q.children, ea), Q.data.space.height = xi(Q.children.map(ia));
          else {
            const y = Q.data.matrix[Q.depth - 1][0], D = Ii(Q.children, ea);
            Q.data.specifiedWidth == null ? Q.data.space.width = o ? D : xi([wg(y), D]) : Q.data.space.width = xi([
              Q.data.specifiedWidth > Qe ? Q.data.specifiedWidth : Qe,
              D
            ]), Q.data.space.height = xi([
              Dg(y),
              ...Q.children.map(ia)
            ]);
          }
      }
    });
    const [B, m] = u.config().extraCellLengths, p = Ii(
      E.children.slice(
        B,
        E.children.length - m
      ),
      ea
    );
    u.overrideDimension({
      width: p,
      height: E.data.space.height
    }), f.overrideDimension({ width: p });
    const w = E.leaves();
    w.slice(B, w.length - m).forEach((Q) => {
      const y = Q.ancestors().slice(1, -1).reverse(), D = y.map(ea), _ = y.map((S) => S.data.specifiedHeight);
      Q.data.forEach((S, b) => {
        S.type !== "blank" && (S.logicalSpace() == null && S.logicalSpace({}), S.overrideDimension() != null && S.overrideDimension({
          width: D[b] + A,
          height: _[b]
        }), S.logicalSpace({
          width: D[b] + A,
          height: _[b]
        }), S.type === "axis" && (S.source().logicalSpace() == null && S.source().logicalSpace({}), S.source().overrideDimension && S.source().overrideDimension() != null && S.source().overrideDimension({
          width: D[b] + A,
          height: _[b]
        }), S.source().logicalSpace({
          width: D[b] + A,
          height: _[b]
        })));
      }), y.forEach((S) => {
        S.data.specifiedWidth = null, S.data.specifiedHeight = null;
      });
    });
  }
  if (s.length) {
    const u = e.rowMatrix(), f = e.rowMatrix().config().isCompacted, C = u.config().cellRenderer === "html" || f ? Qe : u.config().unitMeasures.height, I = e.centerMatrix(), E = ll(u), B = un(u.tree(), (x) => x.values), m = u.config().priority === 2, p = pa(
      s,
      (x) => x.target.length
    ), w = /* @__PURE__ */ new Map();
    B.each((x) => {
      const S = gw(x);
      if (x.depth > 0 && x.height > 0) {
        const b = E(x), R = (v) => v.filter(
          (H) => ca(H.target, b, {
            isCornerMatrix: H.target.value == null && H.height == null
          })
        ).reverse().find((H) => H.width != null || H.height != null), G = (v) => v.filter(
          (H) => ca(H.target, b, { strict: !0 })
        ).reverse().find((H) => H.width != null || H.height != null), T = p.get(b.length);
        if (T != null)
          if (x.height <= (m ? 2 : 1)) {
            const v = Gi(x, x.height > 1), H = v.source(), N = R(
              T
            ), M = G(
              T
            ) != null;
            if (N != null) {
              const F = N.isTransient !== !0;
              if (typeof H == "object" && H !== null && H.constructor.type() === "band" && N.target[S - 1] != null && typeof N.target[S - 1].value < "u") {
                const k = N.target[S - 1].value;
                if (yh(
                  H.domain(),
                  k
                )) {
                  const O = H.domain().length;
                  N.width != null && (x.data.specifiedWidth = N.width * O, M && (x.data.touchedValue = k, w.set(b.length - 1, !0))), N.height != null && (x.data.specifiedHeight = N.height * O, M && (x.data.touchedValue = k, w.set(b.length - 1, !0))), M && (v.config().touched = !0, x.data.isPersistent = F, x.data.touched = !0, w.set(b.length - 1, !0));
                }
              } else
                typeof H == "object" && H != null && (H.config().belongsToTouchedColumn = !0), N.width != null && (x.data.specifiedWidth = N.width), N.height != null && H != null && v.config().type !== "headerTitle" && (x.data.specifiedHeight = N.height, M && (v.config().touchedHeight = !0)), M && (v.config().touched = !0, x.data.isPersistent = F, x.data.touched = !0, w.set(b.length - 1, !0));
            }
          } else {
            const v = R(
              T
            ), H = G(
              T
            ) != null;
            if (v != null) {
              const N = v.isTransient !== !0;
              v.width != null && (x.data.specifiedWidth = v.width), v.height != null && (x.data.specifiedHeight = v.height, H && x.leaves().forEach((M) => {
                M.data[S - 1].config().touchedHeight = !0;
              })), H && (x.leaves().forEach((M) => {
                M.data[S - 1].config().touched = !0;
              }), x.data.isPersistent = N, x.data.touched = !0, w.set(b.length - 1, !0));
            }
          }
      }
    }), B.each((x) => {
      x.find((b) => b !== x && b.data.specifiedHeight != null) != null && (x.data.specifiedHeight = null);
    }), B.each((x) => {
      x.depth > 0 && x.height > 0 && (x.parent.data.specifiedHeight != null && (x.data.specifiedHeight = x.parent.data.specifiedHeight / x.parent.children.length), x.data.specifiedWidth == null && (x.data.specifiedWidth = xi(
        x.data.matrix.flatMap((S) => S[x.depth - 1]).map(wg)
      )));
    }), B.eachAfter((x) => {
      if (x.height > 0) {
        if (x.height === 1) {
          if (x.data.specifiedHeight == null) {
            const S = Gi(x, x.height > 1), b = S.source();
            if (typeof b == "object" && b !== null) {
              const R = Dg(S);
              x.data.space.height = R > C ? R : C;
            }
          } else
            x.data.space.height = x.data.specifiedHeight > Qe ? x.data.specifiedHeight : Qe;
          x.data.space.width = Ii(
            x.ancestors().slice(0, -1),
            (S) => S.data.specifiedWidth > Qe ? S.data.specifiedWidth : Qe
          );
        } else if (x.data.space)
          if (x.depth === 0)
            x.data.space.height = Ii(x.children, ia), x.data.space.width = xi(x.children.map(ea));
          else {
            const S = x.data.matrix[0][x.depth - 1], b = Ii(x.children, ia);
            x.data.specifiedHeight == null ? x.data.space.height = a ? b : xi([Dg(S), b]) : x.data.space.height = xi([
              x.data.specifiedHeight > Qe ? x.data.specifiedHeight : Qe,
              b
            ]), x.data.space.width = xi([
              wg(S),
              ...x.children.map(ea)
            ]);
          }
      }
    });
    const [Q, y] = u.config().extraCellLengths, D = Ii(
      B.children.slice(
        Q,
        B.children.length - y
      ),
      ia
    );
    u.overrideDimension({
      width: B.data.space.width,
      height: D
    }), I.overrideDimension({ height: D }), B.leaves().forEach((x) => {
      const S = x.ancestors().slice(1, -1).reverse(), b = S.map(ia), R = S.map((T) => T.data.specifiedWidth);
      x.data.forEach((T, v) => {
        (T.type !== "blank" || T.type === "blank" && T.config().type === "headerTitle") && (T.logicalSpace() == null && T.logicalSpace({}), T.overrideDimension() != null && T.overrideDimension({
          height: b[v],
          width: R[v]
        }), T.logicalSpace({
          height: b[v],
          width: R[v]
        }), T.type === "axis" && (T.source().logicalSpace() == null && T.source().logicalSpace({}), T.source().overrideDimension && T.source().overrideDimension() != null && T.source().overrideDimension({
          height: b[v],
          width: R[v]
        }), T.source().logicalSpace({
          height: b[v],
          width: R[v]
        })));
      }), S.forEach((T) => {
        T.data.specifiedWidth = null, T.data.specifiedHeight = null;
      });
    });
    const _ = e.rowMatrix().maxMeasures();
    e.rowMatrix().maxMeasures(
      Ye(B.leaves().map((x) => x.data)).map(
        (x, S) => xi(
          x.map(
            (b) => b.logicalSpace() != null && w.get(S) ? b.logicalSpace().width : _[S]
          )
        )
      )
    );
  }
}, hw = (e, t) => t.canvasId ? e.canvasId === t.canvasId : !0, Or = (e, t, i) => {
  const n = i.fields || [], s = t.fields;
  return e.canvasId === t.canvasId ? !0 : n.length ? Wd(n, s).length : !0;
}, vtt = {
  behaviours: {
    "*": hw,
    // brush: (source, target, payload) => {
    //   if (isSameCanvas(source, target, payload) && source.type === "canvas") {
    //     if (source.layerId) {
    //       return source.layerId === target.layerId;
    //     }
    //     if (source.unitId) {
    //       return source.unitId === target.unitId;
    //     }
    //     return true;
    //   }
    //   return true;
    // },
    // highlight: (source, target, payload) => {
    //   if (isSameCanvas(source, target, payload) && source.type === "canvas") {
    //     if (source.layerId) {
    //       return source.layerId === target.layerId;
    //     }
    //     if (source.unitId) {
    //       return source.unitId === target.unitId;
    //     }
    //     return true;
    //   }
    //   return true;
    // },
    filter: (e, t) => e.type === "canvas" ? e.canvasId !== t.canvasId : !0
  },
  sideEffects: {
    "*": hw,
    selectionBox: (e, t) => e.unitId === t.unitId,
    tooltip: Or,
    highlighter: Or,
    [wB]: Or,
    anchors: Or,
    crossline: Or
  }
};
class Ttt extends Yo {
  constructor(...t) {
    super(...t), this._entryExitSet = /* @__PURE__ */ new Map(), this._payloads = {}, this.interactionPolicy(this.constructor.defaultInteractionPolicy());
    const i = this.context._throwback;
    this._crossInteractionConfig = {}, this._propagationDms = {}, this._interactionStates = /* @__PURE__ */ new Map();
    let n, s = !1, A = !1;
    this.context.on("afterLayout", () => {
      const o = () => {
        s || (s = !0, this._actionBehaviourMap.hover.behaviours.includes("highlight") && (A = !0, this.dispatchBehaviour("highlight", {
          criteria: null
        }), this.dissociateBehaviour(["highlight", "hover"])), clearTimeout(n), n = setTimeout(() => {
          A && this.registerPhysicalBehaviouralMap({
            hover: {
              behaviours: ["highlight"]
            }
          }), s = !1;
        }, 250));
      }, { vScrollBar: a, hScrollBar: r } = this.context.composition();
      a && a.component.onScroll(o), r && r.component.onScroll(o);
    }), this.context.on("afterRendered", () => {
      this.applyExistingInteractions();
    }), i.registerImmediateListener([ka.MATRIX_CREATED], () => {
      const o = this.context.composition().visualGroup;
      if (o) {
        NX(this), this._propagationCount = /* @__PURE__ */ new Map();
        const a = [];
        o.matrix().geom().forEach((l) => {
          const c = l.source();
          a.push(c.firebolt());
        }), this.childFirebolts(a), Jy(this), a.forEach((l) => {
          l.onPropagationDone(
            (c, g, h) => {
              let d = a.length;
              const u = c.sourceId, f = u ? `${u}-${c.action}` : c.action;
              let C = this._propagationCount.get(f) || 0;
              const I = ++C;
              this._propagationCount.set(f, I), I === d && (this._targetUnit = Rf(c, this), this.onUnitPropagationComplete({
                payload: c,
                propagationData: g,
                propagationInf: h
              }), this._propagationCount.set(f, 0));
            }
          );
        });
      }
    });
  }
  applyExistingInteractions() {
    this._interactionStates.forEach(({ action: i, payload: n, propagationInf: s }) => {
      const A = n.sideEffects.filter((o) => this.sideEffects()[o.name] && this.sideEffects()[o.name].shouldApplyOnRenderAfterScrolling());
      this.dispatchSideEffects(
        i,
        { ...n, sideEffects: A },
        s
      );
    }), this.childFirebolts().forEach((i) => {
      i.applyExistingInteractions();
    });
  }
  childFirebolts(t) {
    return t ? (this._childFirebolts.length = 0, this._childFirebolts = t, this) : this._childFirebolts;
  }
  createEntryExitSet(t) {
    const i = this.childFirebolts(), n = t.action, s = i.map((A) => A.getEntryExitSet(n)).filter((A) => A);
    return this._entryExitSet[n] && this._entryExitSet[n].dispose(!1), s.length ? this._entryExitSet[n] = new gb(s, {
      extraData: {},
      name: `visual-group-${t.action}`
    }) : this._entryExitSet[n] = null, this._entryExitSet[n];
  }
  getSideEffectsForSourceAction({ action: t }) {
    const i = this.config()[t] || {};
    return Object.keys(i.sideEffects || {}).map((s) => ({
      name: s,
      ...i.sideEffects[s]
    })).filter((s) => s.enabled !== !1);
  }
  onUnitPropagationComplete({ payload: t, propagationInf: i }) {
    const n = Rf(t, this);
    if (n) {
      this._targetUnit = n;
      const s = n.getLayerById(t.sourceInfo.layerId);
      this._targetLayer = s || n.layers()[0];
      let A = [];
      t.resetAllInteractions ? (A = Z(
        this._lastInteraction.get(t.action),
        "sideEffects"
      ) || [], this._lastInteraction.delete(t.action)) : (A = mB(
        {
          action: t.action.split(":")[1],
          targetActions: t.targetActions,
          sourceCanvas: t.sourceInfo.canvasId
        },
        this
      ), this._lastInteraction.set(t.action, {
        behaviour: t.action,
        sideEffects: A
      })), this.createEntryExitSet(t), this.dispatchSideEffects(
        t.action,
        { ...t, sideEffects: A },
        i,
        t.forceDispatch
      ), this.saveInteractionState({
        action: t.action,
        payload: { ...t, sideEffects: A },
        propagationInf: i,
        forceDispatch: t.forceDispatch
      });
    }
  }
  static defaultInteractionPolicy() {
    return vtt;
  }
  interactionPolicy(...t) {
    return t.length ? (this._interactionPolicy = et(
      et({}, this.constructor.defaultInteractionPolicy()),
      t[0] || {}
    ), Jy(this), this) : this._interactionPolicy;
  }
  registerSideEffects(t) {
    for (const i in t)
      this._sideEffectDefinitions[t[i].formalName()] = t[i];
    return this.initializeSideEffects(), this;
  }
  target() {
    return "visual-group";
  }
  id() {
    return this.context.alias();
  }
  data(t, i = {}, n = {}) {
    const s = this.context.composition().visualGroup;
    if (t) {
      const { unitDataModels: A, layerDataModels: o } = i, a = this.context.store();
      a.lockModel();
      const r = t;
      return s.groupedData(r), s.matrix().geom().forEach((c, g, h) => {
        c.source().firebolt().data(
          A[g][h],
          o[g][h]
        );
      }), a.unlockModel(), s._triggerDomainChangeListener = !1, s._lockAxisDomain = n.lockDomain, sd(s, {
        recalculateDomains: !0,
        unionAxisDomainPerPage: !0
      }), this.context.render({
        gridRenderConfig: {
          forceRender: !0,
          scrollLeft: a.get(
            `${re}.scrollLeft`
          ),
          scrollTop: a.get(
            `${re}.scrollTop`
          )
        }
      }), this;
    }
    return s.getGroupByData();
  }
  resetData() {
    const t = this.context.composition().visualGroup, i = this.context.store();
    return i.lockModel(), t.resetData(), t.matrix().geom().forEach((s) => {
      s.source().firebolt().resetData();
    }), i.unlockModel(), t._triggerDomainChangeListener = !1, t._lockAxisDomain = !1, sd(this.context.composition().visualGroup, {
      recalculateDomains: !0
    }), this.context.render({
      gridRenderConfig: {
        forceRender: !0,
        scrollLeft: i.get(
          `${re}.scrollLeft`
        ),
        scrollTop: i.get(
          `${re}.scrollTop`
        )
      }
    }), this;
  }
  getPropagationDetails(t, i, n) {
    const s = this._globalContext, A = Z(this.crossInteractionConfig()[t], "target") || {}, { propIdentifiers: o, interpolated: a } = bX({
      action: t,
      firebolts: this._childFirebolts
    }), r = this.getPropagationSource(), l = r ? r.getPropagationQuery(o, {
      fields: i.fields,
      interpolated: a,
      isQuery: !0
    }) : null, c = Object.keys(A).some(
      (C) => A[C].filter
    ), g = s.interactionFilters.get(
      this.sourceCanvas()
    ), h = {
      ...g,
      layer: {
        identifiers: l,
        fields: i.fields || []
      }
    };
    let d = !1;
    c && (!g && s.interactionFilters.get().size && (d = !0), !i.criteria && d && s.interactionFilters.clear(), s.interactionFilters.save(this.sourceCanvas(), h));
    const u = Object.values(h).map(({ identifiers: C, fields: I }) => ({
      criteria: C,
      fields: I
    })), f = {
      sourceAction: t,
      propagationSourceId: this.id(),
      interpolated: a,
      targetActions: {
        ...n.targetActions,
        interCanvas: A
      },
      resetAllInteractions: n.resetAllInteractions,
      resetFilterAction: d
    };
    return {
      queries: u,
      payload: { ...i, ...f },
      sourcePropQuery: l
    };
  }
  propagate(t, i, n) {
    const {
      queries: s,
      payload: A,
      sourcePropQuery: o
    } = this.getPropagationDetails(t, i, n), a = this.getPropagationSource();
    a && a.propagate(s, {
      ...A,
      sourcePropQuery: o,
      propagateDm: n.propagateDm,
      applyOnVisibleUnits: n.applyOnVisibleUnits,
      targetFacets: this._targetUnit ? this._targetUnit.facetFieldsMap() : {}
    });
  }
  onPhysicalActionTrigger(t) {
    const i = (s) => {
      if (s !== "highlight") {
        const A = this.getEntryExitSet(s);
        Z(A, "entrySet", "length") || this.propagate(
          s,
          {
            criteria: null
          },
          {
            sourceId: this.id(),
            resetAllInteractions: !0
          }
        );
      }
    }, { behaviours: n } = t;
    n.forEach((s) => {
      i(s);
      const { payload: A } = t;
      A.sourceInfo = {
        layerId: A.layerId,
        canvasId: this.sourceCanvas(),
        unitId: t.sourceUnit,
        type: "layer",
        unitRowIndex: t.unitMetaInf.rowIndex,
        unitColIndex: t.unitMetaInf.colIndex
      }, this._payloads[s] = { ...A, action: s }, this.dispatchBehaviour(s, {
        ...A,
        action: s,
        isExplicitAction: !0
      });
    });
  }
  getPropagationBehaviour(t) {
    return this._propagationBehaviourMap[t] || t;
  }
  getPropagationSource() {
    return this.context.composition().visualGroup.resolver()._groupedData;
  }
  sourceCanvas() {
    return this.context.alias();
  }
  getEntryExitSet(t) {
    return this._entryExitSet[t];
  }
  getPlotPointsFromIdentifiers(...t) {
    return this._targetUnit.getPlotPointsFromIdentifiers(
      ...t,
      this._targetLayer.id()
    );
  }
  getDrawingContext() {
    return this._targetUnit.getDrawingContext();
  }
  getSourceInfo() {
    return Object.assign({}, this._targetUnit.getSourceInfo(), {
      targetLayer: this._targetLayer
    });
  }
  layers() {
    return this._targetUnit.layers();
  }
  getPayload(t) {
    return this._payloads[t];
  }
  dispatchBehaviour(t, i) {
    const n = Rf(i, this);
    if (!n)
      return;
    if (i.sourceInfo || (i.sourceInfo = {
      unitId: n.id(),
      canvasId: this.sourceCanvas()
    }), i.action = t, !i.fields)
      if (i.criteria) {
        i.fields = Z(i.criteria, "dimensions", 0) || [];
        const d = Object.keys(
          Z(i.criteria, "range") || {}
        );
        i.fields.push(...d);
      } else
        i.fields = [];
    const s = i.sourceInfo.unitId, A = this._childFirebolts, o = this.config()[i.action] || {};
    [
      n.firebolt(),
      ...A.filter(
        (d) => d !== n.firebolt()
      )
    ].forEach((d) => {
      (o.applyOnVisibleUnits ? d.isVisible() : !0) && (d.dispatchBehaviour(t, {
        ...i,
        isExplicitAction: i.isExplicitAction
      }), this.metaData(d.metaData()));
    });
    const r = A.find(
      (d) => d.id() === s
    ), l = r._childFirebolts.find(
      (d) => d.id() === i.sourceInfo.layerId
    );
    let c;
    l ? c = l.getTargetActions(t) : c = r._childFirebolts[0].getTargetActions(t), i.metaData = et(this.metaData(), i.metaData), this.createEntryExitSet(i);
    const g = this.getSideEffectsForSourceAction({
      action: i.action
    }), h = n.getLayerById(i.sourceInfo.layerId);
    this._targetUnit = n, this._targetLayer = h || n.layers()[0], this.dispatchSideEffects(
      t,
      { ...i, sideEffects: g },
      {},
      i.forceDispatch
    ), this.saveInteractionState({
      action: t,
      payload: Object.assign({}, i, { sideEffects: g }),
      propagationInf: {},
      forceDispatch: !1
    }), this._lastInteraction.set(t, {
      behaviour: t,
      sideEffects: g
    }), this.propagate(
      t,
      { ...i },
      {
        targetActions: c,
        sourceId: s,
        propagateDm: o.propagateDm,
        applyOnVisibleUnits: o.applyOnVisibleUnits
      }
    ), i.criteria === null && (this._entryExitSet[i.action] = null);
  }
  getInteractions() {
    return {
      physicalActions: this._actions.physicalActionDefs,
      behaviours: this._actions.behaviourDefs,
      sideEffects: this._sideEffectDefinitions,
      behaviourEffectMap: this._behaviourEffectMap,
      physicalBehaviouralMap: this._actionBehaviourMap
    };
  }
  getUnitDataModels(t) {
    const n = this.context.composition().visualGroup.matrix().geom(), s = [];
    return n.forEach((A, o, a) => {
      s[o] || (s[o] = []), s[o][a] = A.source().firebolt().getEntryExitSet(t)?.entrySet?.model;
    }), s;
  }
  getLayerDataModels(t) {
    const n = this.context.composition().visualGroup.matrix().geom(), s = [];
    return n.forEach((A, o, a) => {
      s[o] || (s[o] = []), s[o][a] || (s[o][a] = {}), A.source().layers().forEach((l) => {
        const c = l.firebolt().getEntryExitSet(t).entrySet.model;
        s[o][a][l.id()] = c;
      });
    }), s;
  }
  crossInteractionConfig(...t) {
    return t.length ? (this._crossInteractionConfig = t[0] || {}, this) : this._crossInteractionConfig;
  }
  removeDisposedSelectionSetsFromUnitFirebolts() {
    const t = this._entryExitSet;
    for (const [i, n] of Object.entries(t)) {
      if (!n) {
        delete t[i];
        continue;
      }
      const s = n._entryExitSets;
      Array.isArray(s) && s.forEach((A) => {
        const o = A._entryExitSets;
        Array.isArray(o) && (A._entryExitSets = o.filter(
          (a) => !a._disposed
        ));
      }), n._entryExitSets?.length || delete t[i];
    }
  }
}
const Gtt = {
  app: {
    group: {},
    units: {},
    layers: {},
    canvas: {}
  },
  local: {
    canvas: {},
    group: {},
    units: {},
    layers: {}
  },
  interactions: {
    select: {
      entrySet: null,
      exitSet: null
    }
  },
  virtualScrolling: {
    scrollLeft: 0,
    scrollTop: 0,
    vScrollPercent: 0,
    hScrollPercent: 0,
    viewport: {
      rowStart: 0,
      rowEnd: 0,
      colStart: 0,
      colEnd: 0
    }
  }
}, Ltt = {
  columns: {
    expandCollapseState: null,
    layout: []
  },
  rows: {
    expandCollapseState: null,
    layout: []
  }
}, Utt = (e) => !Xe(e) && typeof e == "object" && e.constructor.type() === "band", Htt = (e, t) => {
  t.leaves().map((n) => n.ancestors()).forEach((n) => {
    const s = [];
    n.every((A) => {
      if (s.push(A), A.height > 0 && A.depth > 0 && A.height <= (e ? 2 : 1)) {
        const a = Gi(A, A.height > 1).source();
        return Utt(a) ? a.domain().length <= 1 : A.parent.children.length <= 1;
      } else
        return (A.parent?.children.length ?? 0) <= 1;
    }), s.filter((A) => A.height > 0 && A.depth > 0).forEach((A, o) => {
      A.leaves()[0].data.toReversed && A.leaves()[0].data.toReversed()[o].hideCollapseIcon?.();
    });
  });
}, Ott = () => Zt();
class Nc extends ci(OZ).with(
  LS("canvas")
) {
  /**
   * Creates reactive property accessors.
   * - data
   * - height
   * - width
   * - config
   * This configs are retrieved from options
   */
  constructor(t, i, n) {
    super(), this.eventManager(i);
    const s = !!n;
    this.renderSkipped = !1, this._allOptions = Object.assign({}, pC, Py), this._registry = {}, this._composition = {}, this._cachedProps = {}, this._prevProps = {}, this._alias = null, this._globalContext = null, this._composition.layout = new gm(), this._store = new Rl(Gtt, {
      isPrintMode: s
    }), this._throwback = new Rl(
      {
        [ka.MATRIX_CREATED]: !1
      },
      { isPrintMode: s }
    ), this._disposed = null;
    const A = iE, o = Object.assign({}, pC, Py, CC);
    dS(
      this,
      o,
      this._store,
      {
        namespace: A
      },
      s
    ), this.dependencies(
      Object.assign({}, t, this._dependencies)
    ), this.props = Ltt, this.alias(`canvas-${Ott()}`), this.title("", {}), this.subtitle("", {}), this.legend({}), this.color({}), this.opacity({}), this.backgroundColor({}), this.shape({}), this.size({}), jX(this), this._layoutManager = AZ(), this._deregisterDMPreDisposeTask = void 0, this._scrollState = null;
  }
  associatedHookComponentPaths() {
    return [[Ht.CANVAS]];
  }
  store() {
    return this._store;
  }
  /**
   * Retrieves an instance of layout which is responsible for layouting. Layout is responsible for creating faceted
   * presentation using table layout.
   *
   * @public
   *
   * @return {GridLayout} Instance of layout attached to canvas.
   */
  layout(...t) {
    return t.length ? this : this.composition().layout;
  }
  /**
   * Retrieves the composition for a canvas
   *
   * @public
   *
   * @return {object} Instances of the components which canvas requires to draw the full visualization.
   *      ```
   *          {
   *              layout: // Instance of {@link GridLayout}
   *              legend: // Instance of {@link Legend}
   *              subtitle: // Instance of {@link TextCell} using which the title is rendered
   *              title: // Instance of {@link TextCell} using which the title is rendered
   *              visualGroup: // Instance of {@link visualGroup}
   *          }
   *      ```
   */
  composition(...t) {
    return t.length ? this : this._composition;
  }
  /**
   * Sets or gets the alias of the canvas. Alias is a name by which the canvas can be referred.
   *
   * When setter
   * @param {string} alias Name of the alias.
   *
   * @return {Canvas} Instance of the canvas.
   *
   * When getter
   *
   * @return {string} Alias of canvas.
   *
   * @public
   */
  alias(...t) {
    if (t.length) {
      const i = this.composition().visualGroup;
      return this._alias = t[0], i && i.alias(this.alias()), this;
    }
    return this._alias;
  }
  /**
   * Creates an instance initiated with given settings.
   *
   * @param {Object} initialSettings Initial settings to be populated in the model
   * @param {Object} regEntry newly created instance with the initial settings
   * @param {Object} globalDependencies dependencies which will be created only once in the page
   *
   * @return {Object} newly created instance with the initial settings
   */
  static withSettings(t, i, n, s, A, o) {
    const a = new Nc(n, A, o);
    for (const l in t)
      a[l](t[l]);
    a.registry(i);
    const r = i.interactions.visualGroup;
    return a.firebolt(
      new Ttt(
        a,
        {
          behavioural: Object.assign({}, r.behaviours.get(), {
            [Bo]: SB
          }),
          physical: Object.assign(
            {},
            r.physicalActions.get()
          ),
          physicalBehaviouralMap: Object.assign(
            {},
            r.physicalBehaviouralMap.get()
          )
        },
        Object.assign({}, r.sideEffects.get()),
        Object.assign({}, r.behaviourEffectMap.get())
      )
    ), a._globalContext = s, a.firebolt()._globalContext = s, ZX(a), a;
  }
  /**
   *
   *
   * @static
   *
   * @memberof Canvas
   */
  static formalName() {
    return "canvas";
  }
  /**
   * Returns the instance of firebolt associated with this canvas. The firebolt instance can be used to dispatch a
   * behaviour dynamically on the canvas. This firebolt does not handle any physical actions. It is just used to
   * propagate the action to all the visual units in it's composition.
   *
   * @public
   *
   * @return {GroupFireBolt} Instance of firebolt associated with canvas.
   */
  firebolt(...t) {
    return t.length ? (this._firebolt = t[0], this) : this._firebolt;
  }
  /**
   * Registry peoperty accessor
   *
   * @param {Object} reg plain old javascript object keyvalue pairs. Key containing module name and value contains
   * module definition class. The reg object has to be flat object of level 1.
   */
  registry(...t) {
    if (t.length) {
      const i = t[0], n = Object.assign({}, i.components), s = Object.assign(
        {},
        i.componentSubRegistry
      ), A = Object.assign({}, i.interactions);
      this._registry = {
        components: n,
        componentSubRegistry: s,
        interactions: A
      }, sZ(this);
      const o = GX(this);
      return this._composition.visualGroup = o[0], this.composition().visualGroup.alias(this.alias()), this;
    }
    return this._registry;
  }
  /*
   * Prepare dependencies for top level elements
   */
  dependencies(...t) {
    return t.length ? (this._dependencies = t[0], this) : this._dependencies;
  }
  legend(...t) {
    return t.length ? this : this.composition().legend;
  }
  /**
   * Internal function to trigger reflow, this method is cognizant of all the properties of the core modules and
   * establish a passive reactivity. Passive reactivity is not always a bad thing :)
   * @internal
   */
  reflow() {
    this.composition() != null && (this.prepareRenderDetails(), this.registerLegendHookAggEvents(), this.computeLayout({
      hScrollPercent: 0
    }), this.composition() != null && ([this.layout().rowMatrix(), this.layout().columnMatrix()].forEach(
      (t) => Htt(t.config().priority, t._hierarchy)
    ), this.registerAnimationEndEvent(), rZ(this)));
  }
  updateSize() {
    if (this.composition() == null) return;
    const t = this.composition().visualGroup;
    sd(t, {
      recalculateDomains: !0,
      unionAxisDomainPerPage: t._unionAxisDomainPerPage
    }), this.computeLayout({
      hScrollPercent: 0,
      extendDomain: !this.composition().visualGroup._lockAxisDomain
    });
  }
  computeLayout(t = {}) {
    if (this.emitSelfHooks(mt.BEFORE_LAYOUT), HK(this.config().theme), this.composition() == null) return;
    const i = this._renderDetails, n = this.layout(), s = {
      rows: this.props.rows,
      columns: this.props.columns
    };
    if (!t.skipPeripheralComponentsLayout) {
      const o = _tt(this);
      i.measurement = o;
    }
    i.components.rows && i.components.columns && (t.recomputeGridSpace !== !1 && (Dtt(this.layout(), i), n.compute()), ktt(n, s, { canvas: this }), xtt(n)), this._layoutManager.dimension({
      height: i.measurement.canvasHeight,
      width: i.measurement.canvasWidth
    }), this._layoutManager.renderAt(this.mount());
    const A = Ftt(this, {
      ...i
    });
    this._composition.componentWrappers = A, A.forEach((o) => {
      o && o.shouldRender(!0);
    }), Rtt(this._layoutManager, A), this.emitSelfHooks(mt.AFTER_LAYOUT), this.composition() != null && this.postLayout(t);
  }
  prepareRenderDetails() {
    const t = this.mount(), i = Stt(this, t);
    this._renderDetails = i;
  }
  postLayout(t = {}) {
    const { vScrollBar: i, hScrollBar: n } = this.composition(), s = qN(this._store), A = jN(this._store), o = i ? i.component.getScrollPixelsFromScrollPercent(s) : 0, a = n ? n.component.getScrollPixelsFromScrollPercent(A) : 0;
    this._scrollState ? (this._scrollState = {
      ...this._scrollState,
      scrollTop: o,
      scrollLeft: a,
      viewPortInfo: mX(this._store)
    }, n || JN(this._store, {
      scrollLeft: a
    }), i || KN(this._store, {
      scrollTop: o
    })) : vy(this._store, {
      scrollTop: o,
      scrollLeft: a
    });
    const r = this.composition().visualGroup;
    r.matrix().geom().forEach((l) => {
      l.source().layers().forEach((g) => {
        g.postLayout();
      });
    }), t.extendDomain !== !1 && (r.matrix().clearExtendedAxisDomainCache(), r.matrix().extendAxisDomainsIfNeeded()), nZ(this);
  }
  render({ gridRenderConfig: t = {} }) {
    if (!this.isRenderableInMountPoint() || (this.emitSelfHooks(mt.BEFORE_RENDERED), this.composition() == null)) return;
    if (this.composition().componentWrappers !== this._prevComponentWrappers) {
      if (this._layoutManager.render(), OK(
        this.config().theme,
        document.getElementById(this.getLayoutRootNodeId())
      ), this.composition() == null) return;
      Mtt(this.composition().componentWrappers, this);
    }
    if (this.renderGridComponent(t), this.composition() == null) return;
    this._prevComponentWrappers = this.composition().componentWrappers, PX(this), this._scrollState && this.handleVirtualScrollAfterCollapse(), this._scrollState = null;
    const i = this._store, { rowStart: n, rowEnd: s, colStart: A, colEnd: o } = i.get(
      `${re}.viewport`
    );
    if (this.emitSelfHooks(mt.AFTER_RENDERED, {
      virtualScrolling: {
        viewportRange: {
          rowRange: [n, s],
          colRange: [A, o]
        }
      }
    }), this.composition() == null) return;
    this.composition().visualGroup.matrix().column().mapActionsAndBehaviour(), this.composition().visualGroup.matrix().row().mapActionsAndBehaviour();
  }
  handleVirtualScrollAfterCollapse() {
    const t = this.composition() ?? {}, { vScrollBar: i, hScrollBar: n } = t;
    let s = i?.getScrollPercent(), A = n?.getScrollPercent();
    if (this._scrollState.rowIndex >= 0 && i) {
      const o = i.getUnitScrollPosition(
        this._scrollState.rowIndex
      ), a = (o - this._scrollState.vScrollUnit) / this._scrollState.vScrollUnit;
      s = this._scrollState.currentPageChanged || this._scrollState.vScroll > this._scrollState.vScrollUnit || isNaN(a) ? o : s + s * a;
    }
    if (this._scrollState.columnIndex >= 0 && n) {
      const o = n.getUnitScrollPosition(
        this._scrollState.columnIndex
      ), a = (o - this._scrollState.hScrollUnit) / this._scrollState.hScrollUnit;
      A = this._scrollState.hScroll > this._scrollState.hScrollUnit || isNaN(a) ? o : A + A * a;
    }
    this._scrollState?.vScroll >= 0 || this._scrollState?.hScroll >= 0 ? (i?.scrollTo(s, !1), n?.scrollTo(A, !1)) : vy(this._store, {
      scrollTop: this._scrollState.scrollTop,
      scrollLeft: this._scrollState.scrollLeft,
      viewPortInfo: this._scrollState.viewPortInfo
    });
  }
  renderGridComponent(t) {
    $X(this, t);
  }
  registerAnimationEndEvent() {
    if (this.composition().componentWrappers[10]) {
      this.eventManager().once(
        new $e({
          componentPath: [Ht.CANVAS],
          modifier: ze.EACH,
          hookName: mt.AFTER_RENDERED
        }),
        () => {
          this.emitSelfHooks(mt.ANIMATION_END);
        }
      );
      return;
    }
    let t = {}, i = !1;
    const n = !!Object.values(this.legend()).flat().length, s = [
      { label: "xAxes", componentPath: [Ht.AXIS, "x"] },
      { label: "yAxes", componentPath: [Ht.AXIS, "y"] },
      { label: "units", componentPath: [Ht.UNIT] }
    ];
    n && s.push({
      label: "legends",
      componentPath: [Ht.LEGEND]
    }), s.forEach(({ label: A, componentPath: o }) => {
      const a = new $e({
        componentPath: o,
        modifier: ze.ALL,
        hookName: mt.ANIMATION_END
      }), r = this.eventManager().listeners(a).find(
        (l) => Z(l, "meta", "tag") === Xc
      );
      r && this.eventManager().off(a, r.listener), this.eventManager().on(
        a,
        () => {
          t[A] = !0;
          let l = !1;
          if (i ? l = t.xAxes && t.units || t.yAxes && t.units : (l = t.xAxes && t.yAxes && t.units, n && (l = l && t.legends)), l) {
            const { rowStart: c, rowEnd: g, colStart: h, colEnd: d } = this.store().get(
              `${re}.viewport`
            );
            this.emitSelfHooks(mt.ANIMATION_END, {
              virtualScrolling: {
                viewportRange: {
                  rowRange: [c, g],
                  colRange: [h, d]
                }
              }
            }), i = !0, t = {};
          }
        },
        { tag: Xc }
      );
    });
  }
  registerLegendHookAggEvents() {
    const t = this.composition().legend, i = [
      {
        componentPath: [Ht.LEGEND],
        targets: Object.values(t).flat(1)
      },
      ...Object.keys(t).map((n) => ({
        componentPath: [Ht.LEGEND, n],
        targets: t[n]
      }))
    ];
    [
      mt.BEFORE_RENDERED,
      mt.AFTER_RENDERED,
      mt.ANIMATION_END
    ].forEach((n) => {
      i.forEach(({ componentPath: s, targets: A }) => {
        let o = [];
        const a = A.filter((r) => !!r);
        a.forEach((r) => {
          const l = new $e({
            componentPath: s,
            modifier: ze.EACH,
            hookName: n
          }), c = r.eventManager().listeners(l).find(
            (g) => Z(g, "meta", "tag") === Xc
          );
          c && this.eventManager().off(l, c.listener), r.eventManager().on(
            l,
            (g) => {
              o.push(g), o.length >= a.length && (this.emitEvent({
                name: new $e({
                  componentPath: s,
                  modifier: ze.ALL,
                  hookName: n
                }),
                target: a,
                data: { aggEventObjects: o }
              }), o = []);
            },
            { tag: Xc },
            {
              executePostPropagation: !0
            }
          );
        });
      });
    });
  }
  /**
   * Returns the instances of x axis of the canvas. It returns the instances in a two dimensional array form.
   *
   * ```
   *   // The first element in the sub array represents the top axis and the second element represents the bottom
   *   // axis.
   *   [
   *      [X1, X2],
   *      [X3, X4]
   *   ]
   * ```
   * @public
   *
   * @return {Array.<Array>} Instances of x axis.
   */
  xAxes() {
    return this.composition().visualGroup.getAxes("x");
  }
  /**
   * Returns the instances of y axis of the canvas. It returns the instances in a two dimensional array form.
   *
   * ```
   *   // The first element in the sub array represents the left axis and the second element represents the right
   *   // axis.
   *   [
   *      [Y1, Y2],
   *      [Y3, Y4]
   *   ]
   * ```
   * @public
   * @return {Array.<Array>} Instances of y axis.
   */
  yAxes() {
    return this.composition().visualGroup.getAxes("y");
  }
  /**
   * Returns all the retinal axis of the canvas. Color, shape and size axis are combinedly called retinal axis.
   *
   * @public
   * @return {Object} Instances of retinal axis.
   *          ```
   *              {
   *                  color: [ColorAxis], // Array of color axis.
   *                  shape: [ShapeAxis], // Array of shape axis.
   *                  size: [SizeAxis] // Array of size axis.
   *              }
   *          ```
   */
  getRetinalAxes() {
    return this.composition().visualGroup.getAxes(nz);
  }
  mount(...t) {
    if (t.length) {
      let i = t[0];
      return typeof t[0] == "string" && (i = X(t[0]).node()), this._mount = i, this;
    }
    return this._mount;
  }
  isRenderableInMountPoint() {
    const t = this.mount();
    return t && t instanceof Element && window.document.contains(t);
  }
  getLayoutRootNodeId() {
    return this._layoutManager.getRootNodeId();
  }
  getScrollableBoundBox(t) {
    const i = (t || this.composition().componentWrappers).find((a) => a instanceof am);
    if (!i)
      return null;
    const { left: n, top: s } = i.getBoundBox(), { width: A, height: o } = this.composition().layout.measurement();
    return {
      left: n,
      top: s,
      width: A,
      height: o
    };
  }
  dispose() {
    if (this.emitSelfHooks(mt.BEFORE_DISPOSED), this.composition() == null) return;
    const { columnHeader: t, layout: i, legend: n, visualGroup: s } = this.composition();
    this._composition = null, this._store.unsubscribeAll(), this._throwback.unsubscribeAll(), this.firebolt().dispose(), s.remove(), t && t.remove(), i.remove(), this._layoutManager.removeAllComponents(), n != null && Object.values(n).forEach(
      (A) => A.forEach((o) => o.dispose())
    ), this.emitSelfHooks(mt.AFTER_DISPOSED), this._disposed = !0;
  }
  goToNextPage() {
    this.composition().visualGroup.goToNextPage(), this.reflow();
  }
  goToPreviousPage() {
    this.composition().visualGroup.goToPreviousPage(), this.reflow();
  }
  goToPage(t) {
    this.composition().visualGroup.goToPage(t), this.reflow();
  }
  goToLastPage() {
    this.composition().visualGroup.goToLastPage(), this.reflow();
  }
  getPaginationMetaInfo() {
    const i = this.composition().visualGroup.getPaginationInstance();
    return i ? {
      pageCount: i.getTotalPageCount(),
      totalFacetCount: i.getTotalFacetCount(),
      facetCountForCurrentPage: i.getFacetCountForCurrentPage(),
      currentPageNumber: i.getCurrentPageNumber(),
      rowsCountForCurrentPage: i.getRowsCount()
    } : null;
  }
  setRowCollapseState(t) {
    zy(this.props.rows.expandCollapseState, t);
    const { visualGroup: i, vScrollBar: n } = this.composition(), s = i.updateMatrices(t, "row");
    this._scrollState = {
      vScrollUnit: n?.getUnitScrollPosition(s.rowIndex),
      rowIndex: s.rowIndex,
      vScroll: n?.getScrollPercent(),
      columnIndex: -1,
      currentPageChanged: s.currentPageChanged
    }, this.reflow(), this.firebolt().removeDisposedSelectionSetsFromUnitFirebolts();
  }
  setColumnsCollapseState(t) {
    zy(this.props.columns.expandCollapseState, t);
    const { visualGroup: i, hScrollBar: n } = this.composition(), s = i.updateMatrices(t, "column");
    this._scrollState = {
      columnIndex: s.columnIndex,
      hScrollUnit: n?.getUnitScrollPosition(s.columnIndex),
      hScroll: n?.getScrollPercent(),
      rowIndex: -1,
      currentPageChanged: !1
    }, this.reflow(), this.firebolt().removeDisposedSelectionSetsFromUnitFirebolts();
  }
}
const pC = {
  data: {
    value: null,
    meta: {
      typeCheck: (e) => e && (e instanceof K.DataModel() || e instanceof K),
      sanitization: (e, t, i) => e && (e = e instanceof K ? e : new K(e, e._config), i instanceof Nc && (e.setCreatorIdentifier(i.alias()), e.openBroadcastChannel(), i._deregisterDMPreDisposeTask && i._deregisterDMPreDisposeTask(), e._model && (i._deregisterDMPreDisposeTask = e._model.registerPreDisposeTask(() => {
        i.dispose();
      }))), e)
    }
  },
  width: {
    value: 0,
    meta: {
      sanitization: zr,
      typeCheck: Number.isInteger
    }
  },
  height: {
    value: 0,
    meta: {
      sanitization: zr,
      typeCheck: Number.isInteger
    }
  },
  minUnitWidth: {
    value: 50,
    meta: {
      sanitization: zr,
      typeCheck: Number.isInteger
    }
  },
  minUnitHeight: {
    value: 60,
    meta: {
      sanitization: zr,
      typeCheck: Number.isInteger
    }
  },
  config: {
    value: [null, null],
    meta: {
      typeCheck: "constructor",
      typeExpected: "Object",
      takesMultipleParams: !0,
      sanitization: ([e, t = {}], i, n) => {
        const s = (h) => ["rows", "columns"].reduce((d, u) => (d[u] = {
          facets: {
            labels: {
              style: et(
                {},
                oA(Z(h, "theme", "font")),
                oA(
                  Z(
                    h,
                    "theme",
                    "font",
                    "components",
                    "facets"
                  )
                )
              )
            }
          }
        }, d), {});
        n.layers()[0]?.mark === "text" && e && (e.axes?.x?.showAxisName && (e.axes.x.showAxisName = !1), e.axes?.y?.showAxisName && (e.axes.y.showAxisName = !1)), e = et({}, e, s(e)), i = et({}, i, s(i));
        const { reset: A = !1 } = t;
        let o = {};
        e && e.scrollBar && (e.scrollBar.horizontal && !Number.isNaN(e.scrollBar.horizontal.initialScrollPercent) && e.scrollBar.horizontal.initialScrollPercent !== jN(n._store) && WN(
          n._store,
          e.scrollBar.horizontal.initialScrollPercent || 0
        ), e.scrollBar.vertical && !Number.isNaN(e.scrollBar.vertical.initialScrollPercent) && e.scrollBar.vertical.initialScrollPercent !== qN(n._store) && VN(
          n._store,
          e.scrollBar.vertical.initialScrollPercent || 0
        ));
        const a = LX(e);
        e = et(e, a), A || (o = et({}, e === null ? {} : i), o = Object.assign(
          o,
          OX(e, Bz)
        ), HX(o));
        const r = et({}, tm, o), l = Z(
          e,
          "axesHeaders",
          "column",
          "className"
        );
        l && (e.axesHeaders.column.className = `${r.axesHeaders.column.className} ${l}`);
        const c = et(r, e), g = c.axes;
        return g.x.alignZeroLine && (g.x.nice = !1), g.y.alignZeroLine && (g.y.nice = !1), UX(c);
      }
    }
  }
}, gF = {
  [Ad.formalName()]: Ad,
  [zh.formalName()]: zh
}, Ptt = {
  cells: om,
  layers: lM
}, hF = (e = gF) => {
  const t = Object.assign({}, e);
  return {
    register: (i) => {
      const n = i.formalName();
      return t[n] = i, hF;
    },
    get: () => t
  };
}, wd = {
  components: hF(gF),
  cells: om(),
  layers: lM(),
  interactions: wJ
};
class Ytt extends ci().with(LS("env")) {
  constructor(t) {
    super(), this.eventManager(t), this._eventAggMap = /* @__PURE__ */ new Map();
  }
  /**
   * Sets the data configuration property.
   * This is a getter-setter function.
   *
   * @param {DataModel} data Instance of datamodel to be visualized
   * @return {Env} Instance of the environment
   */
  data() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Sets the width configuration property. Width in px is total horizontal space each canvas should take.
   * This is a getter-setter function.
   *
   * @param {Number} width Width of the visualization area
   * @return {Env} Instance of the environment
   */
  width() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Sets the height configuration property. Height in px is total horizontal space each canvas should take.
   * This is a getter-setter function.
   *
   * @param {Number} width Height of the visualization area
   * @return {Env} Instance of the environment
   */
  height() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Sets the configuration property for setting minimum unit width. *Unit* here is {@link VisualUnit} component of
   * Muze.
   *
   * This is a getter-setter function.
   *
   * @param {Number} [minWidth = 150] Min width of a {@link VisualUnit}
   * @return {Env} Instance of the environment
   */
  minUnitWidth() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Sets the configuration property for setting minimum unit height. *Unit* here is {@link VisualUnit} component of
   * Muze.
   *
   * This is a getter-setter function.
   *
   * @param {Number} [minWidth = 150] Min height of a {@link VisualUnit}
   * @return {Env} Instance of the environment
   */
  minUnitHeight() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Sets the configuration for canvases. User passed configuration is merged with default configuration and then
   * set to canvas
   *
   * This is a getter-setter function.
   *
   * @param {Object} config Partial or full configuration of canvas.
   * @param {AxisConfig} config.axes.x X Axis configuration {@link AxisConfig}.
   * @param {AxisConfig} config.axes.y Y Axis configuration {@link AxisConfig}.
   * @param {GridLineConfig} config.gridLines Grid line configuration {@link GridLineConfig}.
   * @param {GridBandConfig} config.gridBands Grid band configuration {@link GridBandConfig}.
   * @param {GlobalLegendConfig} config.legend Legend configuration {@link GlobalLegendConfig}.
   * @param {InteractionConfig} config.interaction Interaction configuration {@link InteractionConfig}
   * @param {Object} config.autoGroupBy Group by configuration.
   * @param {boolean} config.autoGroupBy.disabled If true, then disables automatic group by of datamodel in the
   * chart. By default, set to false.
   * @return {Env} Instance of the environment
   */
  config() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   *  Creates an instance of {@link Canvas}
   *
   * @return {Canvas} Instance of canvas
   */
  canvas() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Components of Muze are loaded from registry. User can override the default component by overriding the registry
   * with new component definition.
   *
   * Muze creates multiple cells to house the visualization components. Those are called {@link Cells}.
   * `cellRegistry` is the registry for those cells.
   * - {@link SimpleCell}
   * - {@link TextCell}
   * - {@link AxisCell}
   * - {@link GeomCell}
   * - {@link BlankCell}
   *
   * This funciton acts as getter and setter.
   * When acts as a getter this returns the list of registries you can extend.
   * When acts as a setter this allows user to register a component for a existing key. During the process of setting
   * a new component in registry, it is not allowed to create a new key.
   *
   * ```
   *  const GeomCell = env.cellRegistry().GeomCell;
   *  env.cellRegistry({
   *      GeomCell: class NewGeomCell extends GeomCell {
   *          render () {
   *              // override the render
   *          }
   *      }
   * });
   * ```
   *
   * When called as a setter
   * @param {Object} override Key value pair where keys are the name of the cells user with to override. Allowed keys
   *      are
   *      - `SimpleCell`
   *      - `TextCell`
   *      - `AxisCell`
   *      - `GeomCell`
   *      - `BlankCell`
   *      And value being the overridden class definition.
   *
   * @return {Env} Instance of current environment
   *
   * When called as a getter
   * @return {object} Object containing the registration key and class definition
   *      ```
   *          {
   *              SimpleCell: SimpleCell,
   *              TextCell: TextCell,
   *              AxisCell: AxisCell,
   *              GeomCell: GeomCell,
   *              BlankCell: BlankCell
   *          }
   *      ```
   */
  cellRegistry() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  /**
   * Components of Muze are loaded from registry. User can override the default component by overriding the registry
   * with new component definition.
   *
   * Muze composes layers to create a visualization. Each layer contain one mark (plot) type. Superposition of
   * one or multiple such layers create one visulization. Muze provides definition of atomic layers. A new layer can
   * be created and used as a mark type. `layerRegistry` handles the registrtion process. Atomic layers are
   *      - {@link AreaLayer}
   *      - {@link ArcLayer}
   *      - {@link LineLayer}
   *      - {@link TextLayer}
   *      - {@link PointLayer}
   *      - {@link TickLayer}
   *      - {@link BarLayer}
   *      - {@link BaseLayer}
   *
   * For `layerRegistry` a new layer can be registered by using a new key.
   *
   * ```
   *  const PointLayer = env.layerRegistry().point;
   *  env.layerRegistry({
   *      grass: class GrassLayer extends PointLayer {
   *          render () {
   *              // renders layer here
   *          }
   *      }
   *  });
   * ```
   * Access the new layer type by mentioning it as a mark type
   * ```
   *  .layers([{
   *      mark: 'bar',
   *      encoding: {
   *          y: 'Acceleration'
   *      }
   *  }, {
   *      mark: 'grass', // new mark type
   *      encoding: {
   *          y: 'Displacement'
   *      }
   *  }])
   * ```
   *
   * When called as a setter
   * @param {Object} override Key value pair where keys are the name of the cells user with to override. Allowed keys
   *      are
   *      - `Area`
   *      - `Arc`
   *      - `Line`
   *      - `Text`
   *      - `Point`
   *      - `Tick`
   *      - `Bar`
   *      And value being the overridden class definition.
   *
   * @return {Env} Instance of current environment
   *
   * When called as a getter
   * @return {object} Object containing the registration key and class definition
   *      ```
   *          {
   *              Area: AreaLayer,
   *              Text: TextLayer,
   *              Arc: ArcLayer,
   *              Line: LineLayer,
   *              Bar: BarLayer,
   *              Line: LineLayer,
   *              Point: PointLayer,
   *              Tick: TickLayer
   *          }
   *      ```
   */
  layerRegistry() {
    throw new Error(yt.INTERFACE_IMPL);
  }
  registerAggHooks(t) {
    [
      mt.BEFORE_RENDERED,
      mt.AFTER_RENDERED,
      mt.BEFORE_LAYOUT,
      mt.AFTER_LAYOUT,
      mt.BEFORE_DISPOSED,
      mt.AFTER_DISPOSED,
      mt.ANIMATION_END
    ].forEach((n) => {
      t.eventManager().once(
        new $e({
          componentPath: [Ht.CANVAS],
          modifier: ze.EACH,
          hookName: n
        }),
        (s) => {
          const A = this._eventAggMap.get(n);
          A.eventObjects.push(s), A.eventObjects.length === A.canvases.length && (this.emitEvent({
            name: new $e({
              componentPath: [Ht.CANVAS],
              modifier: ze.ALL,
              hookName: n
            }),
            target: A.canvases,
            data: { aggEventObjects: A.eventObjects }
          }), A.eventObjects = [], A.canvases = []);
        }
      ), this._eventAggMap.has(n) ? this._eventAggMap.get(n).canvases.push(t) : this._eventAggMap.set(n, {
        canvases: [t],
        eventObjects: []
      });
    });
  }
  dispose() {
    this._eventAggMap.clear();
  }
}
const { transactor: Jtt, LabelManager: Ktt, getDataStore: Vtt } = CS, Tf = {}, Wtt = wd.components, dw = (e, t) => {
  e.forEach((i) => {
    t.register(i);
  });
}, uw = (e) => {
  const t = {};
  for (let i in e)
    t[i] = rl(e[i]);
  return t;
}, qtt = (e) => ({
  ...e
}), Pn = () => {
  const e = Vtt(), t = new Ytt(new OE(null)), i = Jtt(t, pC)[1], n = Object.assign({}, wd.components.get()), s = Object.assign({}, Ptt), A = {};
  for (const a in s)
    A[a] = s[a](
      wd[a].get()
    );
  const o = qtt({
    interactionFilters: K7()
  });
  return t.canvas = (a) => {
    a = et({}, { isPrintMode: !1 }, a);
    const r = i.serialize(), { visualGroup: l, legend: c } = mN.registry(), g = Nc.withSettings(
      r,
      {
        /* registry */
        components: n,
        componentSubRegistry: A,
        interactions: {
          visualGroup: uw(l),
          legend: uw(c)
        }
      },
      t.globalDependencies(),
      o,
      t.createChildEventManager(),
      a.isPrintMode
    );
    return t.registerAggHooks(g), g;
  }, t.globalDependencies = () => (Tf.smartlabel || (Tf.smartlabel = new Ktt(1, "body")), {
    smartlabel: Tf.smartlabel,
    DataStore: e
  }), t.settings = () => i.serialize(), t.registry = (...a) => a.length ? (a.forEach((r) => {
    const l = r.formalName();
    l in Wtt && (n[l] = r);
  }), t) : n, t.cellRegistry = (...a) => {
    const r = A.cellRegistry;
    return a.length ? (dw(a, r), t) : r.get();
  }, t.layerRegistry = (...a) => {
    const r = A.layerRegistry;
    return a.length ? (dw(a, r), t) : r.get();
  }, t;
};
Pn.registry = wd;
Pn.Components = {
  VisualLayer: {
    layers: {
      BaseLayer: Ws,
      LineLayer: Pb,
      TextLayer: Kb,
      TickLayer: Zb,
      PointLayer: zb,
      SimpleLayer: US,
      AreaLayer: Ub,
      ArcLayer: Ob
    },
    helpers: IV,
    enums: fV,
    layerMixins: CV
  },
  VisualUnit: {
    constructor: zh,
    helpers: DV,
    enums: JV,
    UnitFireBolt: TM
  },
  VisualGroup: {
    constructor: Ad,
    Encoders: $1,
    encoderHelpers: T7,
    groupUtils: n1,
    enums: x9
  },
  Canvas: {
    constructor: Nc
  },
  Firebolt: {
    constructor: Yo
  }
};
const jtt = {
  sideEffects: xB,
  standards: {
    SurrogateSideEffect: pe,
    SpawnableSideEffect: Ir,
    GenericSideEffect: yu
  }
}, ztt = {
  behaviouralActions: yB,
  standards: {
    GenericBehaviour: sn,
    PersistentBehaviour: xc,
    VolatileBehaviour: Dc
  }
}, $tt = {
  MuzeLight: Yb,
  ModeLight: LK,
  DummyLight: UK
};
Pn.DataStore = K;
Pn.DataModel = Ae;
Pn.version = W7.version;
Pn.SideEffects = jtt;
Pn.ActionModel = mN;
Pn.layerFactory = en;
Pn.Operators = gz;
Pn.Behaviours = ztt;
Pn.utils = CS;
Pn.Themes = $tt;
export {
  Pn as default
};
